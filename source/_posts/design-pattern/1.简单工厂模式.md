---
title: 设计模式1-简单工厂模式
categories:
	- Design Pattern
---

# 业务的封装

让业务逻辑与界面逻辑分开，让它们之间的耦合度下降。只有分离开，才可以达到容易维护或扩展，且可复用。

封装业务逻辑，开放特定外部接口，让界面逻辑使用。

封装业务逻辑前，与界面逻辑糅合在一起，不易维护：

```java
try {
    Scanner sc = new Scanner(System.in);
    System.out.println("请输入数字A:");
    double numberA = Double.parseDouble(sc.nextLine());
    System.out.println("请选择运算符号:");
    String strOperate = sc.nextLine();
    System.out.println("请输入数字B:");
    double numberB = Double.parseDouble(sc.nextLine());
    double result = 0d;
    
    switch (strOperate) {
        case "+":
            result = numberA + numberB;
            break;
        case "-":
            result = numberA - numberB;
            break;
        case "*":
            result = numberA * numberB;
            break;
        case "/":
            result = numberA / numberB;
            break;
    }
    
    System.out.println("result: " + result);
} catch (Exception e) {
    System.out.println("wrong input: " + e.toString());
}
```

将业务逻辑（计算）封装在Operation类中，与界面逻辑（输出）分离：

```java
// Operation类
public class Operation {
    public static double getResult(double numberA, double numberB, String operate) {
        double result = 0d;
        switch (operate) {
            case "+":
                result = numberA + numberB;
                break;
            case "-":
                result = numberA - numberB;
                break;
            case "*":
                result = numberA * numberB;
                break;
            case "/":
                result = numberA / numberB;
                break;
        }
        return result;
    }
}

// 客户端代码
try {
    Scanner sc = new Scanner(System.in);
    System.out.println("请输入数字A:");
    double numberA = Double.parseDouble(sc.nextLine());
    System.out.println("请选择运算符号:");
    String strOperate = sc.nextLine();
    System.out.println("请输入数字B:");
    double numberB = Double.parseDouble(sc.nextLine());
    
    double result = Operation.getResult(numberA, numberB, strOperate);
    
    System.out.println("result: " + result);
} catch (Exception e) {
    System.out.println("wrong input: " + e.toString());
}
```

# 紧耦合vs松耦合

按照上一节的写法，如果需要增加一个新的运算方式，加减乘除运算都会暴露。

可以将Operation类变为抽象类，各个运算方式继承这个类。这样新增运算方式只需要创建新类继承Operation不影响其他几个运算。

Operation类：

```java
public abstract class Operation {
    public double getResult(double numberA, double numberB) {
        return 0d;
    }
}
```

加减乘除类：

```java
public class Add extends Operation {
    public double getResult(double numberA, double numberB) {
        return numberA + numberB;
    }
}

public class Sub extends Operation {
    public double getResult(double numberA, double numberB) {
        return numberA - numberB;
    }
}

public class Mul extends Operation {
    public double getResult(double numberA, double numberB) {
        return numberA * numberB;
    }
}

public class Div extends Operation {
    public double getResult(double numberA, double numberB) {
        if (numberB == 0) {
            System.out.println("除数不能为0");
            throw new ArithmeticException();
        }
        return numberA / numberB;
    }
}
```

# 简单工厂模式

解决`实例化哪个类的对象`的问题。

简单运算工厂类：根据用户输入的运算符号，决定返回哪一个运算子类。

```java
public class OperationFactory {
    public static Operation createOperate(String operate) {
        Operation oper = null;
        switch (operate) {
            case "+":
                oper = new Add();
                break;
            case "-":
                oper = new Sub();
                break;
            case "*":
                oper = new Mul();
                break;
            case "/":
                oper = new Div();
                break;
        }
        return oper;
    }
}
```

客户端代码：

```java
Operation oper = OperationFactory.createOperate(strOperate);
double result = oper.getResult(numberA, numberB);
```

![简单工厂类图.jpg](https://s2.loli.net/2023/09/14/uDzxwSonvHCfRrj.jpg)
