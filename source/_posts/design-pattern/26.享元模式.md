---
title: 设计模式26-享元模式
categories:
	- Design Pattern
---

# 享元模式

## 定义

享元模式（Flyweight），运用共享技术有效地支持大量细粒度的对象。

## 结构图

![享元模式结构图.jpg](https://s2.loli.net/2023/11/03/bMCrOhWLicHdA4y.jpg)

## 基本代码

`Flyweight`类：所有具体享元类的超类/接口

```java
abstract class Flyweight {
  public abstract void operation(int extrinsicstate);
}
```

`ConcreteFlyweight`：继承`Flyweight`超类或实现`Flyweight`接口，并为内部状态增加存储空间

```java
// 需要共享的具体Flyweight子类
class ConcreteFlyweight extends Flyweight {
  pubilc void operation(int extrinsicstate) {
    System.out.println("具体Flyweight：" + extrinsicstate);
  }
}
```

`UnsharedConcreteFlyweight`：不需要共享的`Flyweight`子类

```java
// 不需要共享的Flyweight子类
class UnsharedConcerteFlyweight extends Flyweight {
  public void operation(int extrinsicstate) {
    System.out.println("不共享的具体Flyweight：" + extrinsicstate);
  }
}
```

`FlyweightFactory`：享元工厂，用来创建并管理`Flyweight`对象

```java
class FlyweightFactory {
  private Hashtable<String, Flyweight> flyweights = new Hashtable<>();
  
  // 初始化工厂时，先生成三个实例
  public FlyweightFactory() {
    flyweights.put("X", new ConcreteFlyweight));
    flyweights.put("Y", new ConcreteFlyweight));
    flyweights.put("Z", new ConcreteFlyweight));
  }
  
  // 根据客户端请求，获得已生成的实例
  public Flyweight getFlyweight(String key) {
    if (!flyweights.contains(key)) {
      flyweights.put(key, new ConcreteFlyweight(key));
    }
    return (Flyweight)flyweights.get(key);
  }
}
```

客户端代码：

```java
int extrinsicstate = 22;

FlyweightFactory f = new FlyweightFactory();

Flyweight fx = f.getFlyweight("X");
fx.operation(--extrinsicstate);

Flyweight fy = f.getFlyweight("Y");
fy.operation(--extrinsicstate);

Flyweight fz = f.getFlyweight("Z");
fz.operation(--extrinsicstate);

Flyweight uf = new UnsharedConcreteFlyweight();
uf.operation(--extrinsicstate);
```

注：

- `FlyweightFactory`初始化时不一定需要生成对象实例。也可以到需要时，再去根据对象是否为null来决定是否实例化。
- `UnsharedConcreteFlyweight`存在的原因：尽管我们大部分时间都需要共享对象来降低内存的损耗，但个
  别时候也有可能不需要共享，那么此时的`UnsharedConcreteFlyweight`子类就有存在的必要了，它可以解决那些不需要共享对象的问题。

## 内部状态与外部状态

- 内部状态：在享元对象内部并且不会随环境改变而改变的共享部分
- 外部状态：随环境改变而改变的、不可以共享的状态

>享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了**几个参数**外基本上都是相同的，有时就能够大幅度地减少需要实例化的类的数量。如果能把那些参数**移到类实例的外面**，**在方法调用时将它们传递进来**，就可以通过共享大幅度地减少单个实例的数目。

## 使用场景

- 一个应用程序使用了**大量的对象**，而大量的这些对象造成了很大的存储开销
- 对象的**大多数状态可以是外部状态**，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象

### 好处

非常好地解决了**对象的开销问题**。

因为用了享元模式，所以有了共享对象，实例总数就大大减少了，如果共享的对象越多，存储节约也就越多，节约量随着共享状态的增多而增大。

> 例：Java中的String就运用了Flyweight模式。
>
> '=='可以用来确定titleA与titleB是否是相同的实例，返回值为boolean值。当用new String()方法时，两个对象titleA和titleB的引用地址是不相同的，但当titleC和titleD都使用赋值的方式时，两个字符串的引用地址竟然是相同的。
>
> ```java
> String titleA = new String("test1");
> String titleB = new String("test1");
> 
> String titleC = "test2";
> String titleD = "test2";
> 
> /*
> ==: 比较内存引用地址
> equals(): 比较字符串的值
> 
> titleA == titleB: false
> titleA.equals(titleB): true
> titleC == titleD: true
> titleC.equals(titleD): true
> */
> ```
>
> 

### 不足

- 使用享元模式需要维护一个**记录了系统已有的所有享元的列表**，而这本身需要耗费资源，另外享元模式使得系统更加复杂。

- 为了使对象可以共享，需要将一些**状态外部化**，这使得程序的逻辑复杂化。

因此，应当在有**足够多的对象实例**可供共享时才值得使用享元模式。