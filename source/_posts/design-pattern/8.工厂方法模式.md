---
title: 设计模式8-工厂方法模式
categories:
	- Design Pattern
---

# 工厂方法模式

## 定义

工厂方法模式（Factory Method），定义一个用于创建对象的接口，让子类决定实例化哪一个类。

工厂方法使一个类的实例化**延迟到其子类**。

工厂方法处理对象的创建，并将对象创建封装在子类中，使得超类中的客户代码从子类的对象创建代码中解耦。

## 工厂方法模式结构图

![工厂方法模式结构图.jpg](https://s2.loli.net/2023/09/25/ECs5PaBurW7kmyZ.jpg)

相比于简单工厂（工厂类只有一个），工厂方法模式中有**多个工厂类**继承于工厂抽象类/实现工厂接口，增加新工厂不会影响原有工厂。此外，产品的实例化延迟到工厂子类中，而不是最外层的工厂类（如计算器中的 `OperationFactory`）。

# 例1：计算器

## 计算器V1

### 结构图

![工厂方法结构图.jpg](https://s2.loli.net/2023/09/25/5gty3FUwSMIWdv9.jpg)

### 代码实现

工厂接口 `IFactory` ：

```java
public interface IFactory {
    
    public Operation createOperation();
}
```

每种运算各建立一个具体工厂实现 `IFactory` 接口：

```java
// 加法工厂
public class AddFactory implements IFactory {
    
    public Operation createOperation() {
        return new Add();
    }
}

// 其余运算类似
```

运算工厂类 `OperationFactory` ：根据用户输入的运算符号，决定返回哪一个运算子类。

```java
public class OperationFactory {
    public static Operation createOperate(String operate) {
        Operation oper = null;
        IFactory factory = null;
        switch (operate) {
            case "+":
                factory = new AddFactory();
                break;
            case "-":
                factory = new SubFactory();
                break;
            case "*":
                factory = new MulFactory();
                break;
            case "/":
                factory = new DivFactory();
                break;
        }
        oper = factory.createOperation();
        return oper;
    }
}
```

客户端代码：

```java
Operation oper = OperationFactory.createOperate(strOperate);
double result = oper.getResult(numberA, numberB);
```

### 简单工厂vs工厂方法

#### 假如要增加一个指数运算？

##### 简单工厂

先增加指数运算的运算类，再更改 `OperationFactory` 类的 `switch` 语句。

##### 工厂方法

先增加指数运算的运算类，再更改 `OperationFactory` 类的 `switch` 语句，还要额外增加一个指数运算工厂类实现 `IFacotry` 接口。增加了复杂性。

##### 分析

- **简单工厂模式**：最大优点在于工厂类中包含必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。
  - 例如计算器，客户端不用管该用哪个类的实例，只需要把'+'给工厂，工厂自动就给出了相应的实例，客户端只要去做运算就可以了，不同的实例会实现不同的运算。但问题也就在这里，如你所说，如果要加一个'求x的n次方（x^n）'的功能，我们需要给OperationFactory类的方法里加'Case'的分支条件。目前来看，这个OperationFactory类，承载了太多功能，这可不是好办法。这就等于说，我们不但对扩展开放了，对修改也开放了，违背了开放-封闭原则。

- **工厂方法模式**：将长的代码切割成小段，再将每一小段'封装'起来，减少每段代码之间的耦合，这样风险就分散了，需要修改或扩展的难度就降低了。
  - 比如计算器：加减乘除运算统一设计成 `基础运算工厂` 的产品。增加指数、对数运算类，新开一个工厂 `高级运算工厂` 类，不需要对 `基础运算工厂` 做改动。

## 计算器V2

### 结构图

![工厂方法结构图2.jpg](https://s2.loli.net/2023/09/25/pij2CroZTRvWfIQ.jpg)

### 代码实现

增加指数运算类，继承 `Operation`：

```java
public class Pow extends Operation {
    
    public double getResult(double numberA, double numberB) {
        return Math.pow(numberA, numberB);
    }
}
```

将加减乘除运算封装到基础运算工厂类 `FactoryBasic`：

```java
public class FactoryBasic implements IFactory {
    
    public Operation createOperation(String operateType) {
        Operation oper = null;
        switch (operateType) {
            case "+":
                oper = new Add();
                break;
            case "-":
                oper = new Sub();
                break;
            case "*":
                oper = new Mul();
                break;
            case "/":
                oper = new Div();
                break;
        }
        return oper;
    }
}
```

将新运算封装到高级运算工厂类 `FactoryAdvanced`：

```java
public class FactoryAdvanced implements IFactory {
    
    public Operation createOperation(String operateType) {
        Operation oper = null;
        switch (operateType) {
            case "pow":
                oper = new Pow();
                break;
            case "log":
                oper = new Log();
                break;
            // 还可扩展其他高级运算类的实例化，但修改当前工厂类不会影响到基础运算工厂类
        }
        return oper;
    }
}
```

新的 `OperationFactory` 类：

```java
public class OperationFactory {
    public static Operation createOperate(String operate) {
        Operation oper = null;
        IFactory factory = null;
        switch (operate) {
            case "+":
            case "-":
            case "*":
            case "/":
                // 基础运算工厂实例
                factory = new FactoryBasic();
                break;
            case "pow":
            case "log":
                // 高级运算工厂实例
                factory = new FactoryAdvanced();
                break;
        }
        // 利用多态返回实际的运算类实例
        oper = factory.createOperation(operate);
        return oper;
    }
}
```

对比简单工厂模式中的 `OperationFactory` ：

```java
public class OperationFactory {
    public static Operation createOperate(String operate) {
        Operation oper = null;
        switch (operate) {
            case "+":
                oper = new Add();
                break;
            case "-":
                oper = new Sub();
                break;
            case "*":
                oper = new Mul();
                break;
            case "/":
                oper = new Div();
                break;
        }
        return oper;
    }
}
```

可以发现，新的 `OperationFactory` 类已经不存在运算子类实例化的代码了。也就是说，在这个代码里，全部是接口与具体工厂类，并不存在具体的实现，与原来的 `OperationFactory` 类对比，实例化的过程延迟到了工厂子类中。

遵循`依赖倒置原则`：针对接口（`IFactory`）编程，而不是针对实现（`Operation`）编程。

# 例2：再升级商场收银程序

> 简单工厂+策略+装饰+工厂方法

之前的`简单工厂+策略+装饰` 版本中：

```java
public class CashContext {
    
    private ISale cs;
    
    // 在构造函数中传入type，根据type来实例化具体的收费策略
    public CashContext(int cashType) {
        switch (cashType) {
            case 1:
                this.cs = new CashNormal();
                break;
            ...
            case 5:
                // 先打8折，再满300返100
                CashNormal cn = new CashNormal();
                CashReturn crt = new CashReturn(300d, 100d);
                CashRebate crb = new CashRebate(0.8d);
                
                crt.decorate(cn); // 用 满300返100算法 包装原价算法
                crb.decorate(crt); // 用 打8折算法 装饰 满300返100算法
                this.cs = crb;
                break;
        }
    }
    
    public double getResult(double price, int num) {
        // 根据收费策略的不同，获得计算结果
        return this.cs.acceptCash(price, num);
    }
}
```

`case 5`中new的对象太多，应该将其封装成一个工厂。

所有的case可以抽象成两个工厂类：`先打折后满减`和`先满减后打折`。有`先打折后满减`类存在，那它应该有三个初始化参数：*折扣值、满减条件、满减返利值*，那么：

- 打折类：其实就是满减返利值条件为0的情况
- 满减类：就相当于折扣参数为1的情况

## 结构图

![工厂方法结构图3.jpg](https://s2.loli.net/2023/09/25/uPfSU2R5J7bxM39.jpg)

## 代码实现

增加 `IFactory` 接口：

```java
public interface IFactory {
    
    public ISale createSalesModel(); // 创建销售模式
}
```

增加实现 `IFactory` 接口的两个类：`先打折后满减`和`先满减后打折`。

```java
// 先打折后满减类
public class CashRebateReturnFactory implements IFactory {
    
    private double moneyRebate = 1d;
    private double moneyCondition = 0d;
    private double moneyReturn = 0d;
    
    public CashRebateReturnFactory(double moneyRebate, double moneyCondition, double moneyReturn) {
        this.moneyRebate = moneyRebate;
        this.moneyCondition = moneyCondition;
        this.moneyReturn = moneyReturn;
    }
    
    // 重写接口方法，先打折后满减
    public ISale createSalesModel() {
        CashNormal cn = new CashNormal();
        CashReturn cr1 = new CashReturn(this.moneyCondition, this.moneyReturn);
        CashRebate cr2 = new CashRebate(this.moneyRebate);
        
        cr1.decorate(cn);
        cr2.decorate(cr1);
        return cr2;
    }
}

// 先满减后打折类类似。。
```

`CashContext` 类：针对 `ISale` 和 `IFactory` 接口和两个工厂类编程， 对于各个打折满减算法CashSuper、CashNormal、CashReturn、CashRebate等具体类一无所知。实现了松耦合的目的。

```java
public class CashContext {
    private ISale cs;
    
    // 构造函数传入收费策略
    public CashContext(int cashType) {
        IFactory fs = null;
        switch (cashType) {
            case 1: // 原价
                fs = new CashRebateReturnFactory(1d, 0d, 0d); // 不打折，不满减
                break;
            case 2: // 打8折
                fs = new CashRebateReturnFactory(0.8d, 0d, 0d);
                break;
            case 3: // 满300返100
                fs = new CashRebateReturnFactory(1d, 300d, 100d);
                break;
            case 4: // 先打8折，再满300返100
                fs = new CashRebateReturnFactory(0.8d, 300d, 100d);
                break;
            case 5: // 先满200返50，再打7折
                fs = new CashReturnRebateFactory(0.7d, 200d, 50d);
                break;
        }
        this.cs = fs.createSalesModel();
    }
    
    public double getResult(double price, int num) {
        return this.cs.acceptCash(price, num);
    }
}
```



# 总结

工厂方法模式是简单工厂模式的进一步抽象和推广：当只有一个工厂时，就是简单工厂模式；当有多个工厂时，就是工厂方法模式（当然外层还有一个总的工厂来决定具体选择哪一个工厂）。类似由一维进化成了二维。

工厂方法本质就是对获取对象过程的抽象，它克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。

## 工厂方法模式的好处

- **对于复杂的参数的构造对象，可以很好地对外层屏蔽代码的复杂性**，注意是指创建新实例的构造对象。比如说我们用了'先打折再满减'类工厂，其实就屏蔽了装饰模式的一部分代码，让CashContext不再需要了解装饰的过程。
- **有很好的解耦能力。**也就是针对接口在编程。当我们要修改具体实现层的代码时，上层代码完全不了解实现层的情况，因此并不会影响到上层代码的调用，这就达到了解耦的目的。