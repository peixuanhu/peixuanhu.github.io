---
title: 设计模式18-备忘录模式
categories:
	- Design Pattern
---

# 备忘录模式

## 定义

备忘录（Memento）：在**不破坏封装性**的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

> 如：游戏中的存档。不破坏封装性即不把过多的细节暴露给客户端

## 结构图

![备忘录模式结构图.jpg](https://s2.loli.net/2023/10/17/Af2uqHx4KsjVtWz.jpg)

`Originator`（发起人）：负责创建一个备忘录 `Memento`，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。`Originator` 可根据需要决定 `Memento` 存储 `Originator` 的哪些内部状态。

 `Memento` （备忘录）：负责存储 `Originator` 对象的内部状态，并可防止 `Originator` 以外的其他对象访问备忘录 `Memento` 。备忘录有两个接口：`Caretaker` 只能看到备忘录的窄接口，它只能将备忘录传递给其他对象；`Originator` 能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。

`CareTaker` （管理者）：负责保存好备忘录`Memento`，不能对备忘录的内容进行操作或检查。

## 基本代码

发起人 `Originator` 类：

```java
class Originator {
  
  // 需要保存的状态，可能有多个
  private String state;
  public String getState() {
    return this.state;
  }
  public void setState(String value) {
    this.state = value;
  }
  
  // 显示数据
  public void show() {
    System.out.println("State: " + this.state);
  }
  
  // 创建备忘录，将当前需要保存的信息（也许不是全部状态）导入，并实例化出一个Memento对象
  public Memento createMemento() {
    return new Memento(this.state);
  }
  
  // 恢复备忘录，将Memento导入并将相关数据恢复
  public void recoveryMemento(Memento memento) {
    this.setState(memento.getState());
  }
}
```

备忘录 `Memento` 类：

```java
class Memento {
  
  private String state;
  
  public Memento(String state) {
    this.state = state;
  }
  
  public String getState() {
    return this.state;
  }
  
  public void setState(String value) {
    this.state = value;
  }
}
```

管理者 `Caretaker` 类：

```java
class Caretaker {
  
  private Memento memento;
  
  public Memento getMemento() {
    return this.memento;
  }
  
  public void setMemento(Memento value) {
    this.memento = value;
  }
}
```

客户端代码：

```java
// Originator初始状态：例如状态属性为"On"
Originator o = new Originator();
o.setState("On");
o.show();

Caretaker c = new Caretaker();
// 保存状态时，由于有了很好的封装，可以隐藏Originator的实现细节
c.setMemento(o.createMMento());

// Originator改变了状态属性，变为"Off"
o.setState("Off");
o.show();

// 恢复原来的初始状态
o.recoveryMemento(c.getMemento());
o.show();
```

## 总结

### 优点

要保存的细节给封装在了Memento中了，要更改保存的细节也不用影响客户端了。

### 缺点

状态需要完整存储到备忘录对象中，如果状态数据很大很多，那么在资源消耗上，备忘录对象会非常耗内存。

### 适用场景

Memento模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，Originator可以根据保存的Memento信息还原到前一状态。

有时一些对象的内部信息必须保存在对象以外的地方，但是必须要由对象自己读取，这时，使用备忘录可以把复杂的对象内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。

> 管理类是有必要的。其实管理类主要得做两件事，一个是保存快照信息，这个快照信息可以保存多份的（用啥容器都行，栈、列表啥的），游戏状态这个例子里只保存了一份，所以会觉得没有必要；第二个是undo操作（即取出某个快照并恢复原发器状态的操作），该操作最好也要由管理者来提供，这样原发器的职责会更单一。
>
> 还有一个很致命的缺陷，快照Memento的getState是public的，不够安全。应该由Memento持有原发器的引用，且由Memento对象提供方法进行原发器对象的状态恢复，这样就不会有Memento.state的信息泄漏的危险了；当然，还有另一种做法，将Memento设计为原发器的私有内部类。

> 拓展：命令模式也有实现类似撤销的作用，如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态

