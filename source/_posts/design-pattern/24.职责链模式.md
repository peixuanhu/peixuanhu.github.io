---
title: 设计模式24-职责链模式
categories:
	- Design Pattern
---

# 职责链模式

## 定义

职责链模式（Chain of Responsibility）：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

## 结构图

![职责链模式结构图.jpg](https://s2.loli.net/2023/10/30/365cXGqiPFpfLoW.jpg)

## 基本代码

`Handler` 类：定义一个处理请求的接口。

```java
abstract class Handler {
  protected Handler successor;
  
  // 设置后继者
  public void setSuccessor(Handler successor) {
    this.successor = successor;
  }
  
  public abstract void handleRequest(int request);
}
```

`ConcreteHandler` 类：具体处理者类，处理它负责的请求，可访问它的后继者，如果可处理该请求，就处理之，否则就将该请求转发给它的后继者。

```java
// ConcreteHandler1: 当请求数为0~10时有权处理，否则转发给后继
class ConcreteHandler1 extends Handler {
  
  public void handleRequest(int request) {
    if (request >= 0 && request < 10) {
      System.out.println(this.getClass().getSimpleName() + "处理请求" + request);
    } else if (successor != null) {
      successor.handleRequest(request);
    }
  }
}

// ConcreteHandler2: 当请求数为10~20时有权处理，否则转发给后继
class ConcreteHandler2 extends Handler {
  
  public void handleRequest(int request) {
    if (request >= 10 && request < 20) {
      System.out.println(this.getClass().getSimpleName() + "处理请求" + request);
    } else if (successor != null) {
      successor.handleRequest(request);
    }
  }
}
```

客户端代码：

```java
Handler h1 = new ConcreteHandler1();
Handler h2 = new ConcreteHandler2();

h1.setSuccessor(h2);

int[] requests = { 2, 5, 14 };

for (int request : requests) {
	h1.handleRequest(request);
}
```

## 总结

当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。

### 好处

接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用，大大降低了耦合度。

### 注意

一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理。需要事先考虑全面。