---
title: 设计模式0-OOP Basic
categories:
	- Design Pattern
---



# 面向对象编程基础

## 三大特性

#### 1. 封装

每个对象都包含**它能进行操作所需要的所有信息**，这个特性称为封装，因此对象不必依赖其他对象来完成自己的操作。

##### 好处

- 良好的封装能够减少耦合（让某类和调用该类方法的其他类分离）
- 类内部的实现可以自由地修改（不影响其他的类）
- 类具有清晰的对外接口（其他类只需要关心这些接口，不用管内部实现）

#### 2. 继承

继承定义了类如何**相互关联，共享特性**（is-a, not has-a）。继承的工作方式是，定义父类和子类，或叫作基类和派生类，其中子类继承父类的所有特性。子类不但继承了父类的所有特性，还可以定义新的特性。

##### 特点

- 子类拥有父类非private的属性和功能
- 子类具有自己的属性和功能，即子类可以扩展父类没有的属性和功能
- 子类还可以以自己的方式实现父类的功能（方法重写）

protected表示继承时子类可以对基类有完全访问权。

不用继承的话，如果要修改功能，就必须在**所有重复的方法中修改**（枚举类同理），代码越多，出错的可能就越大，而继承的优点是，继承使得所有子类公共的部分都放在了父类，使得代码得到了共享，这就避免了重复，另外，继承可使得修改或扩展继承而来的实现都较为容易。

##### 缺点

- 父类变，则子类不得不变
- 继承会破坏包装，父类实现细节暴露给子类，这其实是增大了两个类之间的耦合性（继承是一种类与类之间**强耦合**的关系）

#### 3. 多态

多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行。

##### 特点

- 子类以父类的身份出现
- 子类在工作时以**自己的方式**来实现（子类可以选择使用override关键字，将父类实现替换为它自己的实现，这就是方法重写Override）
- 子类以父类的身份出现时，子类**特有的属性和方法不可以使用**

## 抽象类和接口

#### 抽象类/方法

考虑把实例化没有任何意义的父类改成抽象类；把方法体没有意义的方法改成抽象方法。

##### 特点

- 抽象类不能被实例化（没有意义）
- 抽象方法是必须被子类重写的方法（重写之前肯定没有意义）
- 如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法

##### 原则

- 应该考虑让抽象类拥有**尽可能多的共同代码**，拥有**尽可能少的数据**

##### 什么时候应该用抽象类？

抽象类通常代表一个抽象概念，它提供一个**继承的出发点**，当设计一个新的抽象类时，一定是用来继承的。所以，在一个以继承关系形成的等级结构里面，**树叶节点**应当是**具体类**，而**树枝节点**均应当是**抽象类**

<img src="https://s2.loli.net/2023/09/13/VhwuR9FrsnI1SdE.jpg" alt="抽象类和具体类.jpg" style="zoom:40%;" />

#### 接口

接口是把隐式公共方法和属性组合起来，以封装特定功能的一个集合。一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。

声明接口在语法上与声明抽象类完全相同，但不允许提供接口中任何成员的执行方式。

实现接口的类就必须要实现接口中的所有方法和属性。

一个类可以支持多个接口，多个类也可以支持相同的接口。

接口中的方法或属性前面不能有修饰符、方法没有方法体。

#### 抽象类vs接口

1. 抽象类可以给出一些成员的实现，接口却不包含成员的实现
2. 抽象类的抽象成员可被子类**部分实现**，接口的成员需要实现类**完全实现**
3. 一个类只能继承**一个抽象类**，但可以实现**多个接口**
4. 类是对对象的抽象，**抽象类**是对**类**的抽象，接口是对**行为**的抽象
5. 如果行为跨越**不同类的对象**，可使用接口；对于一些**相似的类对象**，用继承抽象类
   - 接口类似一个功能（如：飞行），实现某接口的不同类之间也许并没有什么关系；而继承抽象类的不同类之间一般关系紧密
6. 从设计角度讲，抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类；而接口是根本不知子类的存在，方法如何实现还不确认，预先定义

## SOLID原则

SOLID 原则是面向对象 class 设计的五条原则。它们是设计 class 结构时应该遵守的准则和最佳实践。

#### 1. **S**ingle Responsibility Principle，单一职责原则

一个 class 应该只做一件事，一个 class 应该只有一个变化的原因。

应该只有一个软件定义的潜在改变（数据库逻辑、日志逻辑等）能够影响 class 的定义。

单一职责适用于**接口、类**，同时也适用于**方法**。例如我们需要修改用户密码，有两种方式可以实现，一种是用「修改用户信息接口」实现修改密码，一种是新起一个接口来实现修改密码功能。在单一职责原则的指导下，一个方法只承担一个职能，所以我们应该新起一个接口来实现修改密码的功能。

在设计一个类的时候，可以先从粗粒度的类开始设计，等到业务发展到一定规模，我们发现这个粗粒度的类方法和属性太多，且经常修改的时候，我们就可以对这个类进行重构了，将这个类拆分成粒度更细的类，这就是所谓的持续重构。

#### 2. **O**pen Close Principle，开闭原则

一个软件实体，如类、模块和函数应该**对扩展开放**，**对修改关闭**。

当别人要修改软件功能的时候，使他不能修改我们原有代码，只能新增代码实现软件功能修改的目的。

```JAVA
/*反例*/
if(type == apple){
    //deal with apple 
} else if (type == banana){
    //deal with banana
} else if (type == ......){
    //......
}
```

```java
/*正例*/
public interface PeelOff {
    void peelOff();
}

public class ApplePeelOff implement PeelOff{
    void peelOff(){
  //deal with apple
    }
}

public class BananaPeelOff implement PeelOff{
    void peelOff(){
  //deal with banan
    }
}

public class PeelOffFactory{
    private Map<String, PeelOff> map = new HashMap();

    private init(){
        //init all the Class that implements PeelOff interface 
   }
}

.....

public static void main(){
    String type = "apple";
    PeelOff peelOff = PeelOffFactory.getPeelOff(type);  //get ApplePeelOff Class Instance.
    peelOff.pealOff();
}
```



#### 3. **L**iskov Substitution Principle，里氏替换原则

所有引用基类的地方必须能透明地使用其子类的对象。

所有父类能出现的地方，子类就可以出现，并且替换了也不会出现任何错误。对使用者来说，能够使用父类的地方，一定可以使用其子类，并且预期结果是一致的。

```java
Parent obj = new Son();
// 等价于
Son son  = new Son();
```

父类的约定，不仅仅指的是语法层面上的约定，还包括实现上的约定。有时候父类会在类注释、方法注释里做了相关约定的说明，当你要覆写父类的方法时，需要弄懂这些约定，否则可能会出现问题。例如子类违背父类声明要实现的功能。比如父类某个排序方法是从小到大来排序，你子类的方法竟然写成了从大到小来排序。

#### 4. **I**nterface Segregation Principle，接口隔离原则

类间的依赖关系应该建立在最小的接口上。简单地说：**接口的内容一定要尽可能地小，能有多小就多小。**

很多客户端特定的接口优于一个多用途接口。客户端不应该强制实现他们不需要的函数。

##### 优点

- 减少改动导致的变化风险
- 减少无用功能的理解成本

#### 5. **D**ependency Inversion Principle，依赖倒置原则

高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节，即接口或抽象类不依赖于实现类。细节应该依赖抽象，即实现类不应该依赖于接口或抽象类。**简单地说，我们应该面向接口编程。通过抽象成接口，使各个类的实现彼此独立，实现类之间的松耦合。**

#### 各原则间的联系

- 单一职责是所有设计原则的基础，开闭原则是设计的终极目标。
- 里氏替换原则强调的是子类替换父类后程序运行时的正确性，它用来帮助实现开闭原则。
- 而接口隔离原则用来帮助实现里氏替换原则，同时它也体现了单一职责。
- 依赖倒置原则是过程式编程与面向对象编程的分水岭，同时它也被用来指导接口隔离原则。

依赖倒置原则告诉我们要面向接口编程。当我们面向接口编程之后，接口隔离原则和单一职责原则又告诉我们要注意职责的划分，不要什么东西都塞在一起。当我们职责捋得差不多的时候，里氏替换原则告诉我们在使用继承的时候，要注意遵守父类的约定。而上面说的这四个原则，它们的最终目标都是为了实现开闭原则。

#### 参考

1. [https://www.freecodecamp.org/chinese/news/solid-principles/](https://www.freecodecamp.org/chinese/news/solid-principles/)
2. [https://zhuanlan.zhihu.com/p/350291336](https://zhuanlan.zhihu.com/p/350291336)
3. [https://insights.thoughtworks.cn/understand-solid-principles/](https://insights.thoughtworks.cn/understand-solid-principles/)

## 设计原则

### 1. 识别应用中变化的方面，把它们和不变的方面分开。

如果每次有新需求，某方面的代码就要变，那么这个行为需要抽出来，与其他不变的代码分离。

把会变化的部分取出并封装，这样以后就可以修改或扩展这个部分，而不会影响其他不需要变化的部分。

### 2. 针对接口编程，而不是针对实现编程。

这里的接口指的是广义的超类型，包括接口和抽象类。

```java
Animal a = getAnimal(); // 抽象类
a.makeSound(); // 抽象方法
```



### 3. 优先使用组合而非继承。

例：策略模式中的算法族引用就是使用了组合。



### 4. 尽量做到交互的对象之间的松耦合设计。

当两个对象之间松耦合时，它们可以交互，但是通常对彼此所知甚少。松耦合设计经常给我们带来很多弹性。

例：观察者模式

### 5. 类应该对扩展开发，但对修改关闭。

即开放-封闭原则。

例：装饰者模式

### 6. 依赖抽象，不依赖具体类。

高层组件（如PizzaStore）不应该依赖于低层组件（如具体Pizza），而应该依赖于抽象（如抽象Pizza）。

例：工厂方法模式。

## UML类图

![UML类图图示样例.jpg](https://s2.loli.net/2023/09/14/lLdVpOa35Z1YWDm.jpg)

### Class

#### 矩形框表示

- 第一层：类的名称
  - 抽象类用斜体显示
- 第二层：类的特性（字段和属性）
- 第三层：类的操作（方法和行为）
  - +表示public
  - -表示private
  - #表示protected

### Interface

#### 矩形框表示

顶端有<\<interface>>显示

- 第一层：接口名称
- 第二层：接口方法

#### 棒棒糖表示

如图中唐老鸭类实现“讲人话”接口

### 类与类、类与接口的关系

#### 继承关系

- 用**空心三角形+实线**表示

#### 实现接口

- 用**空心三角形+虚线**表示

#### 关联关系

- 用**实线箭头**表示
- 表示一个类*知道*另一个类（如企鹅需要知道气候的变化）
- 可以有基数

#### 聚合关系

- 用**空心菱形+实线箭头**表示
- 表示一种弱的*拥有*关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分（如雁群拥有大雁）
- 可以有基数

#### 合成关系

- 用**实心菱形+实线箭头**表示

- 表示一种强的*拥有*关系，体现了严格的部分和整体的关系（如鸟拥有翅膀）
- 部分和整体的生命周期一样
- 合成关系的连线两端还有一个数字'1'和数字'2'，这被称为基数

#### 依赖关系

- 用**虚线箭头**表示
- 比如动物依赖氧气和水
