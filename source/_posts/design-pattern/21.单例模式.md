---
title: 设计模式21-单例模式
categories:
	- Design Pattern
---

# 单例模式

## 定义

单例模式（Singleton），保证一个类仅有一个实例，并提供一个访问它的全局访问点。

## 结构图

![单例模式结构图.png](https://s2.loli.net/2023/10/23/7qNvY9VbhWHPit2.png)

## 基本代码

Singleton类，定义一个GetInstance操作，允许客户访问它的唯一实例。GetInstance是一个静态方法，主要负责创建自己的唯一实例。

### 懒汉式

调用getInstance的时候再来创建instance。

#### V1 线程不安全

在多线程的情况下有可能创建多个实例

```java
class Singleton {
  
  private static Singleton instance;
  
  // 构造方法private化，堵死了外部代码利用new创建此类实例的可能
  private Singleton() {}
  
  // 得到Singleton的实例（唯一途径）
  public static Singleton getInstance() {
    
    if (instance == null) {
      instance = new Singleton();
    }
    
    return instance; // 当instance为null时创建一个返回，否则直接返回原有实例
  }
}
```

#### V2 synchronized锁方法

每次调用 `getInstance` 时都需要锁。写起来简单，但比较影响性能。

```java
class Singleton {
  
  private static Singleton instance;
  
  // 构造方法private化
  private Singleton() {}
  
  // 得到Singleton的实例（唯一途径）
  public static synchronized Singleton getInstance() {
    
    if (instance == null) {
      instance = new Singleton();
    }
    
    return instance;
  }
}
```

#### V3 Double-Check Locking

不用让线程每次都加锁，而只是在实例未被创建的时候再加锁处理。同时也能保证多线程的安全。

```java
class Singleton {
  
  private volatile static Singleton instance; // volatile作用是使得所有线程能够及时得知instance是否被实例化的状态
  
  private Singleton() {}
  
  public static Singleton getInstance() {
    
    if (instance == null) {
      synchronized(Singleton.class) { // 保证所有线程用的是同一把锁
        if (instance == null) {
          instance = new Singleton();
        }
      }
    }

    return instance;
  }
}
```

为什么要两次判断instance是否为null？

对于instance存在的情况，就直接返回，这没有问题。当instance为null并且同时有两个线程调用getInstance（）方法时，它们将都可以通过第一重instance==null的判断。然后由于'锁'机制，这两个线程则只有一个进入，另一个在外排队等候，必须要其中的一个进入并出来后，另一个才能进入。而此时如果没有了第二重的instance是否为null的判断，则第一个线程创建了实例，而第二个线程还是可以继续再创建新的实例，这就没有达到单例的目的。

### 饿汉式（静态初始化）

不管有没有调用getInstance，先在自己被加载时就把instance创建出来。

```java
class Singleton {
  
  private static Singleton instance = new Singleton();
  
  private Singleton() {}
  
  public static Singleton getInstance() {
    return instance;
  }
}
```

### 客户端代码：

```java
// Singleton s0 = new Singleton();
Singleton s1 = Singleton.getInstance();
Singleton s2 = Singleton.getInstance();

if (s1 == s2) {
  System.out.println("两个对象是相同的实例");
}
```



## 单例模式好处

1. 可以保证唯一的实例。
2. 因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。

## 饿汉式和懒汉式对比

饿汉式，即静态初始化的方式，它是类一加载就实例化的对象，所以要提前占用系统资源。

然而懒汉式，又会面临着多线程访问的安全性问题，需要做双重锁定这样的处理才可以保证安全。

到底使用哪一种方式，取决于实际的需求。从Java语言角度来讲，饿汉式的单例类已经足够满足我们的需求了。

## 单例模式 vs 实用类静态方法

和单例模式类似，实用类通常也会采用私有化的构造方法来避免其有实例。

### 区别

1. 实用类不保存状态，只提供静态方法或静态属性使用；而单例类有状态。
2. 实用类不能用于继承多态；而单例类虽然实例唯一，但可以有子类来继承。
3. 实用类是一些方法属性的集合；单例类有唯一的对象实例。