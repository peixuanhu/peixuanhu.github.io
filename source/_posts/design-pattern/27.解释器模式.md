---
title: 设计模式27-解释器模式
categories:
	- Design Pattern
---

# 解释器模式

## 定义

解释器模式（interpreter），给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

## 结构图

![解释器模式结构图.jpg](https://s2.loli.net/2023/11/04/aJBM9Oxve8oF2tH.jpg)

## 基本代码

`AbstractExpression`类：声明一个抽象的解释操作，为抽象语法树中的所有节点所共享

```java
abstract class AbstractExpression {
  
  // 解释操作
  public abstract void interpret(Context context);
}
```

`TerminalExpression`（终结符表达式）：实现与文法中的终结符相关联的解释操作

```java
class TerminalExpression extends AbstractExpression {
  
  public void interpret(Context context) {
    System.out.println("终端解释器");
  }
}
```

`NonterminalExpression`（非终结符表达式）：为文法中的非终结符实现解释操作

```java
class NonterminalExpression extends AbstractExpression {
  
  public void interpret(Context context) {
    System.out.println("非终端解释器");
  }
}
```

`Context`类：包含解释器之外的一些全局信息

```java
class Context {
  
  private String input;
  private String output;
  
  public String getInput() {
    return this.input;
  }
  
  public void setInput(String value) {
    this.input = value;
  }
  
  public String getOutput() {
    return this.output;
  }
  
  public void setOutput(String value) {
    this.output = value;
  }
}
```

客户端代码：构建表示该文法定义的语言中一个特定的句子的抽象语法树。调用解释操作。

```java
Context context = new Context();
ArrayList<AbstractExpression> list = new ArrayList<>();
list.add(new TerminalExpression());
list.add(new NonterminalExpression());
list.add(new TerminalExpression());
list.add(new TerminalExpression());

for (AbstractExpression exp : list) {
  exp.interpret(context);
}
```

## 使用场景

通常当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。

### 好处

- 容易改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。
- 也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写。

### 不足

解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。

> 高级语言（如Java）的开发：当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理。

### 应用

- 正则表达式
- 浏览器（解释HTML，渲染页面）
- 机器人指令