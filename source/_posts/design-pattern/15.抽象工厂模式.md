---
title: 设计模式15-抽象工厂模式
categories:
	- Design Pattern
---

# 抽象工厂模式

## 定义

抽象工厂模式（Abstract Factory），提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

> 与工厂方法模式的区别：
>
> 以操作不同数据库为例：只有一个User类和User操作类的时候，是只需要工厂方法模式的，但现在显然你数据库中有很多的表，而SQL Server与Access又是两大不同的分类，所以解决这种涉及**多个产品系列**的问题，有一个专门的工厂模式叫抽象工厂模式。

## 结构图

![抽象工厂模式结构图.png](https://s2.loli.net/2023/10/11/RILujqhdlvWVsQF.png)

AbstractProductA和AbstractProductB是两个抽象产品，之所以为抽象，是因为它们都有可能有两种不同的实现，比如对两种数据库中某一张表的操作。

ProductA1、ProductA2和ProductB1、ProductB2就是对两个抽象产品的具体分类的实现。

IFactory是一个抽象工厂接口，它里面应该包含所有的产品创建的抽象方法。

而ConcreteFactory1和ConcreteFactory2就是具体的工厂了，就像SqlserverFactory和AccessFactory一样。

>通常是在**运行时刻**再创建一个ConcreteFactory类的实例，这个具体的工厂再创建具有特定实现的产品对象，也就是说，为创建不同的产品对象，客户端应使用不同的具体工厂。



## 优缺点

### 优点

- **易于交换产品系列**。由于具体工厂类，例如 `IFactory factory = new AccessFactory()`，在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易（只在初始化的地方改一行就行），它只需要改变具体工厂即可使用不同的产品配置。

  > 我们的设计不能去防止需求的更改，那么我们的理想便是让改动变得最小，现在如果你要更改数据库访问，我们只需要更改具体工厂就可以做到。

- **让具体的创建实例过程与客户端分离**。客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。

  > 比如换数据库的例子，客户端所认识的只有IUser和IDepartment，至于它是用SQL Server来实现还是Access来实现就不知道了。

### 缺点

- 如果需求来自添加功能（比如添加数据库中的一张表），需要增加三个类： IProject、SqlserverProject、AccessProject ，还需要更改三个类：IFactory 、SqlserverFactory 和AccessFactory才可以完全实现。
- 客户端程序类很多的情况下，还是需要改很多行 `IFactory factory = new AccessFactory()`这样的代码。

## 优化

### 1. 用简单工厂来改进抽象工厂

去除IFactory 、SqlserverFactory和AccessFactory三个工厂类，取而代之的是DataAccess类，用一个简单工厂模式来实现。

```java
public class DataAccess {
  
  private static String db = "Sqlserver"; // 数据库预设名称，可换成其他
  
  public static IUser createUser() {
    IUser result = null;
    
    switch(db) {
      case "Sqlserver":
        result = new SqlserverUser();
        break;
      case "Access":
        result = new AccessUser();
        break;
    }
    return result;
  }
}
```



这样当新增一个表时，只需要修改DataAccess一个类，而不是IFactory 、SqlserverFactory 和AccessFactory这三个类。

但当新增Oracle数据库时，抽象工厂只需要增加一个OracleFactory，而简单工厂需要在DataAccess类中的每个方法的switch语句中加对应的case。



### 2. 反射+抽象工厂

使用一种编程方式：依赖注入（Dependency Injection）。

方式：

1. 专门的IoC容器提供，比如Spring

2. Java反射技术

   将程序由编译时转为运行时。

   ```java
   // 常规的写法
   IUser result = new SqlserverUser();
   
   // 反射的写法
   IUser result = (IUser)Class.forName("pathxxx.xxx.abstractfactory.SqlserverUser").getDeclaredConstructor().newInstance();
   ```

   由于forName传参是字符串，所以可以用变量来处理，根据需要来更换。

   ```java
   // DataAccess类，用反射技术，取代IFactory、SqlserverFactory和AccessFactory
   import java.lang.reflect.InvocationTargetException;
   
   public class DataAccess {
     private static String assemblyName = "pathxxx.xxx.abstractfactory.";
     private static String db = "Sqlserver"; // 数据库预设名称，可换成其他
     
     public static IUser createUser() {
       return (IUser)getInstance(assemblyName + db + "User");
     }
     
     private static Object getInstance(String className) {
       Object result = null;
       try {
         result = Class.forName(className).getDeclaredConstructor().newInstance();
       }
       catch (IvocationTargetException e) {
         e.printStackTrace();
       }
       catch (NoSuchMethodException e) {
         e.printStackTrace();
       }
       catch (InstantiationException e) {
         e.printStackTrace();
       }
       catch (IllegalAccessException e) {
         e.printStackTrace();
       }
       catch (ClassNotFoundException e) {
         e.printStackTrace();
       }
       return result;
     }
   }
   ```

现在如果我们增加了Oracle数据访问，相关类的增加（如OracleUser, OracleDepartment）是不可避免的，这点无论我们用任何办法都解决不了，不过这叫扩展，**开放-封闭原则**告诉我们，**对于扩展，我们开放。但对于修改，我们应该要尽量关闭。**

现在如果需要增加Oracle数据库的访问，只需要更改 `private static String db ="Sqlserver";` 为`private static String db = "Oracle";`

如果要增加Project表产品，只需要增加三个与Project相关的类 IProject、SqlserverProject、AccessProject，再修改DataAccesss，在其中增加一个public static IProject createProject()方法即可。

### 3. 反射+配置文件+抽象工厂

反射+抽象工厂问题：

在更换数据库访问时，我还是需要去改程序（改db这个字符串的值）重编译，如果可以不改程序，那才是真正地符合开放-封闭原则。

解决：

利用配置文件来解决更改DataAccess的问题。读文件来给DB字符串赋值，在配置文件中写明是Sqlserver还是Access，这样就连DataAccess类也不用更改了。

1. 添加一个db.properties文件

   ```java
   db=Sqlserver
   ```

2. 再更改DataAccess类

   ```java
   // 添加与读取文件内容相关的包
   import java.io.BufferedReader;
   import java.io.FileReader;
   import java.io.IOException;
   import java.util.Properties;
   
   public class DataAccess {
     private static String assemblyName = "pathxxx.xxx.abstractfactory.";
     
     public static String getDb() {
       String result = "";
       try {
         Properties properties = new Properties();
         // 需要将db.properties文件放到要编译的class目录中，并确保下面path路径与实际db.properties文件路径一致。否则会报No such file or directory错误
         String path = System.getProperty("user.dir") + "/pathxxx/xxx/abstractfactory/db.properties";
         System.out.println("path: " + path);
         BufferedReader bufferedReader = new BufferedReader(new FileReader(path));
         properties.load(bufferedReader);
         result = properties.getProperty("db"); // 读取db.properties配置文件中db的内容
       }
       catch (IOExceprtion e) {
         e.printStackTrace();
       }
       return result;
     }
     
     public static IUser createUser() {
       String db = getDb();
       return (IUser)getInstance(assemblyName + db + "User");
     }
   }
   
   ```

将来要更换数据库，根本无须重新编译任何代码，只需要更改配置文件就好了。应用了反射+配置文件+抽象工厂模式解决了数据库访问时的可维护、可扩展的问题。

>所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合，解决它们难以应对变化，难以维护和扩展的诟病。
