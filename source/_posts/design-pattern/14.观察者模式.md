---
title: 设计模式14-观察者模式
categories:
	- Design Pattern
---

# 观察者模式

## 定义

观察者模式（Observer）定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

## 结构图

![观察者模式结构图.jpg](https://s2.loli.net/2023/10/10/LCoseQJmfYubWig.jpg)

### Subject类

即主题或抽象通知者，一般用一个抽象类或者一个接口实现。

它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。

### Observer类

抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫作更新接口。更新接口通常包含一个update()方法，这个方法叫作更新方法。

抽象观察者一般用一个抽象类或者一个接口实现。

### ConcreteSubject类

具体主题或具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。

具体主题角色通常用一个具体子类实现。

### ConcreteObserver类

具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。具体观察者角色可以保存一个**指向具体主题对象的引用**。

具体观察者角色通常用一个具体子类实现。

## 基本代码

Subject类：通知者抽象类

```java
abstract class Subject {
  private ArrayList<Observer> list = new ArrayList<Observer>(); // 针对抽象的Observer编程
  
  // 增加观察者
  public void attach(Observer observer) {
    list.add(observer);
  }
  
  // 减少观察者
  public void detach(Observer observer) {
    list.remove(observer);
  }
  
  // 通知观察者
  public void notifyObserver() {
    for (Observer item : list) {
      item.update();
    }
  }
  
  protected String subjectState;
  
  public String getSubjectState() {
    return this.subjectState;
  }
  
  public void setSubjectState(String value) {
    this.subjectState = value;
  }
}
```

Observer类：抽象观察者

```java
abstract class Observer {
  public abstract void update();
}
```

ConcreteSubject类：具体通知者

```java
class ConcreteSubject extends Subject {
  // 具体通知者的方法
}
```

ConcreteObserver类：具体观察者

```java
class ConcreteObserver extends Observer {
  private String name;
  private Subject sub;
  
  public ConcreteObserver(String name, Subject sub) {
    this.name = name;
    this.sub = sub;
  }
  
  public void update() {
    System.out.println("观察者" + this.name + "的新状态是" + this.sub.getSubjectState());
  }
}
```

客户端代码：

```java
Subject subject = new ConcreteSubject();
subject.attach(new ConcreteObserver("NameX", subject));
subject.attach(new ConcreteObserver("NameY", subject));
subject.attach(new ConcreteObserver("NameZ", subject));

subject setSubjectState("ABC");
subject.notifyObserver();
```

## 特点

### 问题

将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。

### 何时使用观察者模式？

1. 当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象有待改变时
2. 当一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用

### 总结

观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。

## Java内置接口实现

现实编程中，具体的观察者完全有可能是风马牛不相及的类，但它们都需要根据通知者的通知来做出update()的操作，此时不适合使用继承，要用接口来实现。

Java已经为观察者模式准备好了相关的接口和抽象类了：**观察者接口java.util.Observer** 和 **通知者类java.util.Observable** 。

Java内置的Observable是一个类，这样设计是有问题的。一个类，就只能继承它，但我们自己的类可能本身就需要继承其他抽象类，这就产生了麻烦。Java不支持多重继承，这就严重限制了Observable的复用潜力。所以，当你这段代码用javac编译时，会给出提示： `警告：［deprecation］ java.util中的Observable已过时。` 系统其实是建议你不要复用这样的方法。所以真实编程中，我们也要考虑怎么取舍，如何修改的问题。

### Java其他内建支持

JavaBean通过`PropertyChangeEvent`提供内建的支持。当一个Bean改变特定种类的属性时，该事件产生，并发送通知给`PropertyChangeListener`。

在处理异步流的Flow API中，也有相关的出版者/订阅者组件。