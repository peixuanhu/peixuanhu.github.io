---
title: 设计模式20-迭代器模式
categories:
	- Design Pattern
---

# 迭代器模式

## 定义

迭代器模式（Iterator），提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。

## 结构图

![迭代器模式结构图.jpg](https://s2.loli.net/2023/10/19/mKfRk7ElDi4Os1p.jpg)

需要有 `Iterator` 抽象类的原因：遍历方式可能有很多种，需要对不同方式做不同具体实现。

## 基本代码

`Aggregate` 聚集抽象类：

```java
abstract class Aggregate {
  
  // 创建迭代器
  public abstract Iterator createIterator();
}
```

`ConcreteAggregate` 具体聚集类：

```java
class ConcreteAggregate extends Aggregate {
  
  // 声明一个ArrayList泛型变量，用于存放聚合对象
  private ArrayList<Object> items = new ArrayList<Object>();
  
  public Iterator createIterator() {
    return new ConcreteIterator(this);
  }
  
  // 返回聚集总个数
  public int getCount() {
    return items.size();
  }
  
  // 增加新对象
  public void add(Object object) {
    items.add(object);
  }
  
  // 得到指定索引对象
  public Object getCurrentItem(int index) {
    return items.get(index);
  }
  
}
```

`Iterator` 迭代器抽象类：

```java
abstract class Iterator {
  
  public abstract Object first(); // 第一个
  public abstract Object next(); // 下一个
  public abstract boolean isDone(); // 是否到结尾
  public abstract Object currentItem(); // 当前对象
}
```

`ConcreteIterator` 具体迭代器类：

```java
class ConcreteIterator extends Iterator {
  private ConcreteAggregate aggregate;
  private int current = 0;
  
  // 初始化时将具体的聚集对象传入
  public ConcreteIterator(ConcreteAggregate aggregate) {
    this.aggregate = aggregate;
  }
  
  // 得到第一个对象
  public Object first() {
    return aggregate.getCurrentItem(0);
  }
  
  // 得到下一个对象
  public Object next() {
    Object ret = null;
    current ++;
    if (current < aggregate.getCount()) {
      ret = aggregate.getCurrentItem(current);
    }
    return ret;
  }
  
  // 判断当前是否遍历到结尾，到结尾返回true
  public boolean isDone() {
    return current >= aggregate.getCount() ? true : false;
  }
  
  // 返回当前的聚集对象
  public Object currentItem() {
    return aggregate.getCurrentItem(current);
  }
}
```

客户端代码：

```java
ConcreteAggregate ca = new ConcreteAggregate();
ca.add(1);
ca.add(2);
ca.add(3);

Iterator i = new ConcreteIterator(ca);

i.first();
while (!i.isDone()) {
  System.out.println(i.currentItem());
  i.next();
}
```

## Java的迭代器实现

java.util.Iterator支持对集合的简单迭代接口

```java
public interface Iterator {
  
  public boolean hasNext(); // 如果还有下一个元素，返回true
  
  public Object next(); // 返回迭代中的下一个元素
  
}
```

java.util.ListIterator支持对集合的任意方向上迭代接口

```java
public interface ListIterator {
  
  public boolean hasNext();
  public Object next();
  
  public boolean hasPrevious();
  public Object previous();
}
```

## 总结

迭代器（Iterator）模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责。

这样既可以做到**不暴露集合的内部结构**，又可以让外部代码**透明地访问集合内部的数据**。