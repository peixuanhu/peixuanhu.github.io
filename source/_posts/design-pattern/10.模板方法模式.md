---
title: 设计模式10-模板方法模式
categories:
	- Design Pattern
---

# 模板方法模式

## 定义

模板方法（Template Method）模式，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

模板方法使得子类可以在不改变一个算法的结构的情况下，重定义该算法的某些特定步骤。

## 结构图

![模板方法模式结构图.jpg](https://s2.loli.net/2023/10/06/cXdaetYSGvgoiw8.jpg)

### AbstractClass

AbstractClass是抽象类，其实也就是一个抽象模板，定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。

### ConcreteClass

ConcreteClass ， 实现父类所定义的一个或多个抽象方法。每一个AbstractClass 都可以有任意多个ConcreteClass 与之对应， 而每一个ConcreteClass都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。

## 基本代码

模板方法抽象类：

```java
abstract class AbstractClass {
    
    // 模板方法，给出逻辑骨架，而逻辑组成是一些相应的抽象操作，都推迟到子类实现
    public void templateMethod() {
        
        // 写一些可以被子类共享的代码
        
        this.primitiveOperation1();
        this.primitiveOperation2();
    }
    
    // 子类个性的行为，放到子类去实现
    public abstract void primitiveOperation1();
    public abstract void primitiveOperation2();
}
```

模板方法具体类：

```java
// 具体类A
class ConcreteClassA extends AbstractClass {
    
    public void primitiveOperation1() {
        System.out.println("具体类A方法1实现");
    }
    
    public void primitiveOperation2() {
        System.out.println("具体类A方法2实现");
    }
}

// 具体类B
class ConcreteClassB extends AbstractClass {
    
    public void primitiveOperation1() {
        System.out.println("具体类B方法1实现");
    }
    
    public void primitiveOperation2() {
        System.out.println("具体类B方法2实现");
    }
}
```

## 特点

模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势。

当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。

模板方法模式是很常用的模式，对继承和多态玩得好的人几乎都会在继承体系中多多少少用到它。比如在Java类库的设计中，通常都会利用模板方法模式提取类库中的公共行为到抽象类中。

## 例：试卷抄题与作答

### v1学生抄题

试卷内容和答案都放到具体某个学生类中实现

```java
class TestPaperA extends TestPaper {
    
    public void testQuestion1() {
        System.out.println("问题xxxx。a. xxx b. xxx c. xxx");
        System.out.println("答案：b");
    }
}
```



### v2打印试卷

考题试卷类作为父类，试卷内容在试卷类中实现。

学生答卷类继承试卷类，答案在学生答卷类中实现。

#### v2.1 试题方法在子类调用

```java
class TestPaperA extends TestPaper {
    
    public void testQuestion1() {
        super.testQuestion1();
        System.out.println("答案：b");
    }
}
```

#### v2.2 只有具体答案在子类实现

所有重复的代码都应该要上升到父类去，而不是让每个子类都去重复。

增加answer1()抽象方法，在子类重写

```java
// 考题试卷
abstract class TestPaper {
    
    public void testQuestion1() {
        System.out.println("问题xxxx。a. xxx b. xxx c. xxx");
        System.out.println("答案：" + this.answer1()); // 改成调用抽象方法answer1
    }
    
    protected abstract String answer1(); // 让继承的子类重写，因为每个人的答案不同
}
```



```java
// 学生答卷
class TestPaperA extends TestPaper {
    
    protected String answer1() {
        return "b";
    }
}
```

