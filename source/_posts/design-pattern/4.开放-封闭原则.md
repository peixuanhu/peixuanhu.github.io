---
title: 设计模式4-开放封闭原则
categories:
	- Design Pattern
---

SOLID原则中的O: **O**pen-Close Principle

# 准确解释

开放-封闭原则，是说软件实体（类、模块、函数等）应该可以扩展，但是不可修改。

## 两个特征

- Open for extension 对扩展开放
- Close for modification 对修改封闭

## 具体做法

面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本，而不会把整个程序推倒重来。

设计的时候，时刻要考虑，尽量让这个类足够好，写好了就不要去修改了，如果新需求来，我们增加一些类就完事了，原来的代码能不动则不动。

绝对的对修改关闭是不可能的。无论模块是多么的'封闭'，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块**应该对哪种变化封闭**做出选择。他必须先猜测出最有可能发生的变化种类，然后**构造抽象**来隔离那些变化。

我们是很难预先猜测，但我们却可以在发生小变化时，就及早去想办法应对发生更大变化的可能。也就是说，**等到变化发生时立即采取行动**。在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。

# 例子

简单工厂模式中的计算器。

1. 首先加法程序写在client类中。
2. 然后增加减法功能，发现需要修改原来类，违背OCP -> 考虑重构程序，增加抽象的运算类 -> 能够满足需求，并能应对变化
3. 增加乘除法功能，无需修改client类，只需增加乘法和除法的子类。

面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。

我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。（如：加减运算在很多地方应用了，再考虑抽象、考虑分离，就很困难）

# 总结

开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是**可维护、可扩展、可复用、灵活性好**。

开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。**拒绝不成熟的抽象和抽象本身一样重要**。
