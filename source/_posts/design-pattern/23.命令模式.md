---
title: 设计模式23-命令模式
categories:
	- Design Pattern
---

# 命令模式

## 定义

命令模式（Command），将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

## 结构图

![命令模式结构图.jpg](https://s2.loli.net/2023/10/29/DhKeTdnJQt6GuxX.jpg)

## 基本代码

`Command` 类：用来声明执行操作的接口

```java
abstract class Command {
  
  protected Receiver receiver;
  
  public Command(Receiver receiver) {
    this.receiver = receiver;
  }
  
  // 执行命令
  public abstract void executeCommand();
  
}
```

`ConcreteCommand` 类：将一个 `Receiver` 对象绑定于一个动作，调用 `Receiver` 相应的操作，以实现 `executeCommand`。

```java
class ConcreteCommand extends Command {
  
  public ConcreteCommand(Receiver receiver) {
    super(receiver);
  }
  
  public void executeCommand() {
    receiver.action();
  }
  
}
```

`Invoker` 类：要求 `Command` 执行请求。

```java
class Invoker {
  
  private Command command;
  
  public void setCommand(Command command) {
    this.command = command;
  }
  
  public void executeCommand() {
    command.executeCommand();
  }
  
}
```

`Receiver` 类：知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。

```java
class Receiver {
  
  public void action() {
    System.out.println("执行请求");
  }
  
}
```

客户端代码：

```java
Receiver receiver = new Receiver();
Command command = new ConcreteCommand(receiver);
Invoker invoker = new Invoker();

invoker.setCommand(command);
invoker.executeCommand();
```

## 进一步改进代码

`Invoker` 类中的 `Command` 属性可以修改成 `List`，以实现执行命令的批处理。

```java
class Invoker {
  
  private ArrayList<Command> commands = new ArrayList<Command>();
  
  // 设置命令
  public void setCommand(Command command) {
    String className = command.getClass().getSimpleName();
    
    if (className.equals("xxx")){ // 对无法完成的请求给予回绝
      // ...
    } else {
      this.commands.add(command);
      System.out.println("增加请求：" + className + "，时间：" + getNowTime());
    }
  }
  
  // 取消命令
  public void cancelCommand(Command command) {
    String className = command.getClass().getSimpleName();
    commands.remove(command);
    System.out.println("取消请求：" + className + "，时间：" + getNowTime());
  }
  
  // 通知执行
  public void notifyCommand() {
    for (Command command : commands)
      command.executeCommand();
  }
  
  private String getNowTime() {
    SimpleDataFormat formatter = new SimpleDateFormat("HH:mm:ss");
    return formatter.format(new Date()).toString();
  }
  
}
```

客户端代码：

```java
Receiver receiver = new Receiver();
Command command1 = new ConcreteCommand1(receiver);
Command command2 = new ConcreteCommand2(receiver);
Invoker invoker = new Invoker();

invoker.setCommand(command1);
invoker.setCommand(command2);
invoker.setCommand(command1);
invoker.setCommand(command1);

invoker.cancelCommand(command1);

invoker.setCommand(command2);

invoker.notifyCommand(); // 执行所有命令
```

## 作用

- 它能较容易地设计一个命令队列
- 在需要的情况下，可以较容易地将命令记录进日志
- 允许接受请求的一方决定是否要否决请求
- 可以容易地实现对请求的撤销与重做
- 由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易
- 把**请求一个操作**的对象与**知道怎么执行一个操作**的对象分隔开

>敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销／恢复操作等功能时，把原来的代码重构为命令模式才有意义。