---
title: 设计模式2-策略模式
categories:
	- Design Pattern
---

# 策略模式

## 定义

它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。

### 策略模式结构图

![策略模式结构图.jpg](https://s2.loli.net/2023/09/25/3FbYVIzrKk2hLA5.jpg)

### 策略模式基本代码

Strategy类，定义所有支持的算法的公共接口：

```java
// 抽象算法类
abstract class Strategy {
    // 算法方法
    public abstract void algorithmInterface();
}
```

ConcreteStrategy类，封装了具体的算法或行为，继承于Strategy：

```java
// 具体算法A
class ConcreteStrategyA extends Strategy {
    // 算法A实现方法
    public void algorithmInterface() {
        System.out.println("算法A实现");
    }
}

// 具体算法B
class ConcreteStrategyB extends Strategy {
    // 算法B实现方法
    public void algorithmInterface() {
        System.out.println("算法B实现");
    }
}

// 具体算法C
class ConcreteStrategyC extends Strategy {
    // 算法C实现方法
    public void algorithmInterface() {
        System.out.println("算法C实现");
    }
}
```

Context类，用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。

```java
// 上下文
class Context {
    Strategy strategy;
    
    // 初始化时，传入具体的策略对象
    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
    
    // 上下文接口
    public void contextInterface() {
        // 根据具体的策略对象，调用其算法的方法
        strategy.algorithmInterface();
    }
}
```

客户端代码：

```java
Context context;

// 实例化不同的策略
context = new Context(new ConcreteStrategyA());
context.contextInterface();

context = new Context(new ConcreteStrategyB());
context.contextInterface();

context = new Context(new ConcreteStrategyC());
context.contextInterface();
```



# 例：商场收银软件

## 原始版本

所有内容都写在一个程序中，如要需要修改任意代码，都需要重新安装在商场所有机器中。

```java
double price = 0d; // 商品单价
int num = 0; // 商品数量
double totalPrices = 0d; // 当前商品合计费用
double total = 0d; // 总计所有商品费用

Scanner sc = new Scanner(System.in);

do {
    System.out.println("请输入商品单价：");
    price = Double.parseDouble(sc.nextLine());
    System.out.println("请输入商品数量：");
    num = Integer.parseInt(sc.nextLine());
    System.out.println();
    
    if (price > 0 && num > 0) {
        totalPrices = price * num;
        total += totalPrices;
        
        System.out.println();
        System.out.println("单价：" + price + "元，数量：" + num + "，合计：" + totalPrices + "元");
        System.out.println();
        System.out.println("总计：" + total + "元");
        System.out.println();
    }
} while (price > 0 && num > 0);
```

## 增加打折

新增打折/返利功能

### 硬编码实现版本

写在客户端程序中。每新增打x折都要重新安装。用下拉框选择销售模式实现。

```java
    int discount = 0; // 商品销售模式：1.原价 2.八折 3.七折
    ...
    switch (discount) {
        case 1:
            totalPrices = price * num;
        case 2:
            totalPrices = price * num * 0.8;
        case 3:
            totalPrices = price * num * 0.7;
    }

    total += totalPrices;
```

### 简单工厂实现版本

用收费抽象类，让打折/返利继承抽象类，传入对应需要的参数灵活实现具体打几折、满多少返多少，需要新增时在工厂类中添加模式。

```java
// 收费抽象类
public abstract class CashSuper {
    
    // 收费抽象方法
    public abstract double acceptCash(double price, int num);
}

// 正常收费
public class CashNormal extends CashSuper {
    
    // 原价返回
    public double acceptCash(double price, int num) {
        return price * num;
    }
}

// 打折收费
public class CashRebate extends CashSuper {
    
    private double moneyRebate = 1d;
    
    // 初始化时输入折扣率
    public CashRebate(double moneyRebate) {
        this.moneyRebate = moneyRebate;
    }
    
    // 返回乘上折扣率的总价
    public double acceptCash(double price, int num) {
        return price * num * this.moneyRebate;
    }
}

// 返利收费
public class CashReturn extends CashSuper {
    
    private double moneyCondition = 0d; // 返利条件
    private double moneyReturn = 0d; // 返利值
    
    // 初始化时输入返利条件和返利值
    public CashReturn(double moneyCondition, double moneyReturn) {
        this.moneyCondition = moneyCondition;
        this.moneyReturn = moneyReturn;
    }
    
    // 返回返利后的总价
    public double acceptCash(double price, int num) {
        double result = price * num;
        if (moneyCondition > 0 && result >= moneyCondition) {
            result -= Math.floor(result / moneyCondition) * moneyReturn;
        }
        return result;
    }
}
```

收费工厂代码如下：

```java
public class CashFactory {
    
    public static CashSuper createCashAccept(int cashType) {
        CashSuper cs = null;
        switch (cashType) {
            case 1:
                cs = new CashNormal();
                break;
            case 2:
                cs = new CashRebate(0.8d);
                break;
            case 3:
                cs = new CashRebate(0.7d);
                break;
            case 4:
                cs = new CashReturn(300d, 100d);
                break;
        }
        return cs;
    }
}
```

客户端程序主要部分：

```java
CashSuper cashSuper = CashFactory.createCashAccept(cashType);
totalPrices = cashSuper.acceptCash(price, num);
total += totalPrices;
```

### 策略模式实现版本

跟简单工厂很像，只要加一个CashContext类，改写一下客户端代码即可。

CashContext类：

```java
public class CashContext {
    
    private CashSuper cs;
    
    // 构造方法传入具体的收费策略
    public CashContext(CashSuper csuper) {
        this.cs = csuper;
    }
    
    public double getResult(double price, int num) {
        // 根据收费策略的不同，获得计算结果
        return this.cs.acceptCash(price, num);
    }
}
```

客户端主要代码：

```java
CashContext cc = null;

switch (cashType) {
    case 1:
        cc = new CashContext(new CashNormal());
        break;
    case 2:
        cc = new CashContext(new CashRebate(0.8d));
        break;
    case 3:
        cc = new CashContext(new CashRebate(0.7d));
        break;
    case 4:
        cc = new CashContext(new CashReturn(300d, 100d));
        break;
}

// 通过Context的getResult方法调用，得到收费结果
// 让具体算法与客户完全隔离
totalPrices = cc.getResult(price, num);
total += totalPrices;
```

但这样是在客户端判断使用哪种算法，客户能看到具体的收费策略，可以将策略模式与简单工厂模式结合，把判断转移到工厂中。

### 策略与简单工厂结合版本

改进CashContext类

```java
public class CashContext {
    
    private CashSuper cs;
    
    // 在构造函数中传入type，根据type来实例化具体的收费策略
    public CashContext(int cashType) {
        switch (cashType) {
            case 1:
                this.cs = new CashNormal();
                break;
            case 2:
                this.cs = new CashRebate(0.8d);
                break;
            case 3:
                this.cs = new CashRebate(0.7d);
                break;
            case 4:
                this.cs = new CashReturn(300d, 100d);
                break;
        }
    }
    
    public double getResult(double price, int num) {
        // 根据收费策略的不同，获得计算结果
        return this.cs.acceptCash(price, num);
    }
}
```

客户端代码：

```java
CashContext cc = new CashContext(cashType);
totalPrices = cc.getResult(price, num);
total += totalPrices;
```

#### 与纯简单工厂模式对比

```java
// 简单工厂模式用法
CashSuper cs = CashFactory.createCashAccept(cashType);
totalPrices = cs.acceptCash(price, num);

// 策略模式与简单工厂模式结合的用法
CashContext cc = new CashContext(cashType);
totalPrices = cc.getResult(price, num);
```

简单工厂模式我需要让客户端认识两个类，CashSuper和CashFactory，而策略模式与简单工厂结合的用法，客户端就只需要认识一个类CashContext就可以了。耦合更加降低。

在客户端实例化的是CashContext的对象，调用的是CashContext的方法GetResult，这使得具体的收费算法彻底地与客户端分离。连算法的父类CashSuper都不让客户端认识了。

# 总结

## 策略模式优点

- 策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种**算法类**与**使用算法类**之间的耦合。**策略模式封装了变化。**
- 策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于**析取**出这些算法中的**公共功能**。如：收费算法公共的功能就是获得计算费用的结果GetResult，这使得算法间有了抽象的父类CashSuper.
- 简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口**单独测试**。

## 不足

收银系统中如果要新增折扣，还是需要修改CashContext中的switch语句，可以通过`反射技术`（抽象工厂模式章节）来解决这个问题。
