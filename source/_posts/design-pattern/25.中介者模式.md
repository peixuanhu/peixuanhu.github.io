---
title: 设计模式25-中介者模式
categories:
	- Design Pattern
---

# 中介者模式

迪米特法则的实现。

通过中介者对象，可以将系统的网状结构变成以中介者为中心的星状结构，每个具体对象不再通过直接的联系与另一个对象发生相互作用，而是通过"中介者"对象与另一个对象发生相互作用。

> 如联合国可以作为各个国家的中介者，用来转发消息，而不是让各个国家直接通信。

## 定义

中介者模式（Mediator），用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

## 结构图

![中介者模式结构图.jpg](https://s2.loli.net/2023/11/01/sf3KV7nBPTLixMy.jpg)

Colleague叫作抽象同事类，而ConcreteColleague是具体同事类，每个具体同事只知道自己的行为，而不了解其他同事类的情况，但他们却都认识中介者对象。

Mediator是抽象中介者，定义了同事对象到中介者对象的接口，ConcreteMediator是具体中介者对象，实现抽象类的方法，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令。

## 基本代码

`Colleague`类：抽象同事类

```java
abstract class Colleague {
  protected Mediator mediator;
  // 构造方法，得到中介者对象
  public Colleague(Mediator mediator) {
    this.mediator = mediator;
  }
}
```

`ConcreteColleague1`, `ConcreteColleague2`：具体同事类

```java
class ConcreteColleague1 extends Colleague {
  public ConcreteColleague1(Mediator mediator) {
    super(mediator);
  }
  
  public void send(String message) {
    this.mediator.send(message, this);
  }
  
  public void notify(String message) {
    System.out.println("同事1得到信息：" + message);
  }
}

class ConcreteColleague2 extends Colleague {
  public ConcreteColleague2(Mediator mediator) {
    super(mediator);
  }
  
  public void send(String message) {
    this.mediator.send(message, this);
  }
  
  public void notify(String message) {
    System.out.println("同事2得到信息：" + message);
  }
}
```

`Mediator`类：抽象中介者类

```java
abstract class Mediator {
  // 定义一个抽象的发送消息方法，得到同事对象和发送消息
  public abstract void send(String message, Colleague colleague);
}
```

`ConcreteMediator`类：具体中介者类

```java
class ConcreteMediator extends Mediator {
  private ConcreteColleague1 colleague1;
  private ConcreteColleague2 colleague2;
  
  // 需要了解所有的具体同事对象
  public void setColleague1(ConcreteColleague1 value) {
    this.colleague1 = value;
  }
  
  public void setColleague2(ConcreteColleague2 value) {
    this.colleague2 = value;
  }
  
  // 重写发送信息的方法，根据对象做出选择判断，通知对象
  public void send(String message, Colleague colleague) {
    if (colleague == colleague1) {
      colleague2.notify(message);
    } else {
      colleague1.notify(message);
    }
  }
}
```

客户端代码：

```java
ConcreteMediator m = new ConcreteMediator();

// 让两个具体同事类对象认识中介者对象
ConcreteColleague1 c1 = new ConcreteColleague1(m);
ConcreteColleague1 c2 = new ConcreteColleague2(m);

// 让中介者认识各个具体同事类对象
m.setColleague1(c1);
m.setColleague2(c2);

c1.send("notify c2");
c2.send("notify c1");
```

## 优缺点

中介者模式很容易在系统中应用，也很容易在系统中误用。当系统出现了'多对多'交互复杂的对象群时，不要急于使用中介者模式，而要先反思你的系统在设计上是不是合理。

### 优点

- Mediator的出现**减少了各个Colleague的耦合**，使得可以独立地改变和复用各个Colleague类和Mediator，比如任何国家的改变不会影响到其他国家，而只是与安理会发生变化。

- 由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个**更宏观的角度**去看待系统。

  >比如巴以冲突，本来只能算是国与国之间的矛盾，因此各自的看法可能都比较狭隘，但站在联合国安理会的角度，就可以从全球化、也更客观的角度来看待这个问题，在调停和维和上做出贡献。

### 缺点

- 由于ConcreteMediator控制了集中化，于是就把交互复杂性变为中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。

## 适用场景

中介者模式一般应用于：

- 一组**对象以定义良好但是复杂的方式进行通信**的场合，比如窗体Form对象或Web页面aspx
- 想定制一个分布在多个类中的行为，而又**不想生成太多的子类**的场合
