---
title: 设计模式6-装饰模式
categories:
	- Design Pattern
---

需求：需要把所需的功能按正确的顺序串联起来进行控制

# 装饰模式

## 定义

装饰模式（Decorator），动态地给一个对象添加一些额外的职责，就增加/扩展功能来说，装饰模式比生成子类更为灵活。

## 装饰模式结构图

![装饰模式结构图.jpg](https://s2.loli.net/2023/09/20/YdCDAhkco9ETLF6.jpg)

- Component是定义一个对象接口，可以给这些对象动态地添加职责。

- ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。

- Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无须知道Decorator的存在的。

- ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。

## 代码实现

Component类：

```java
abstract class Component {
    public abstract void operation();
}
```

ConcreteComponent类：

```java
class ConcreteComponent extends Component {
    
    public void operation() {
        System.out.println("具体对象的实际操作");
    }
}
```

Decorator类：

```java
abstract class Decorator extends Component {
    
    protected Component component;
    
    // 装饰一个Component对象
    public void setComponent(Component component) {
        this.component = component;
    }
    
    // 重写operation()，实际调用component的operation方法
    public void operation() {
        if (component != null) {
            component.operation();
        }
    }
}
```

ConcreteDecorator类：

```java
// ConcreteDecoratorA类
class ConcreateDecoratorA extends Decorator {
    
    public String addedState;  // 本类独有属性
    
    public void operation() {
        super.operation();  // 首先执行原有Component的operation()
        
        this.addedState = "具体装饰对象A的独有操作";  // 再执行本类独有功能
        System.out.println(this.addedState);
    }
}

// ConcreteDecoratorB类
class ConcreteDecoratorB extends Decorator {
    
    public void operation() {
        super.operation();  // 首先执行原有Component的operation()
        this.addedBehavior(); // 再执行本类独有功能
    }
    
    private void addedBehavior() {
        System.out.println("具体装饰对象B的独有操作");
    }
}
```

客户端程序：

```java
ConcreteComponent c = new ConcreteComponent();
ConcreteDecoratorA d1 = new ConcreteDecoratorA();
ConcreteDecoratorB d2 = new ConcreteDecoratorB();

d1.setComponent(c); // 首先用d1来包装c
d2.setComponent(d1); // 再用d2来包装d1
d2.operation(); // 最终执行d2的operation()
```

![装饰模式对象链.jpg](https://s2.loli.net/2023/09/20/Gx6ynzCtlqogS5F.jpg)

装饰模式是利用`setComponent`来对对象进行包装的。
这样每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。

## 例1：穿不同的服饰

![装饰模式例子.jpg](https://s2.loli.net/2023/09/20/U2GwI9iXWxH3mTJ.jpg)

`ICharacter`人物形象接口（`Component`）：

```java
public interface ICharacter {
    
    public void show();
}
```

`Person`类（`ConcreteComponent`）：

```java
public class Person implements ICharacter {
    
    private String name;
    
    public Person(String name) {
        this.name = name;
    }
    
    public void show() {
        System.out.println("装扮的" + name);
    }
}
```

`Finery`类（`Decorater`）：

```java
// Q: Finery不是一个实际存在的事物，为什么不设计成抽象类？
public abstract(?) class Finery implements ICharacter {
    
    protected ICharacter component;
    
    public void decorate(ICharacter component) {
        this.component = component;
    }
    
    public void show() {
        if (this.component != null) {
            this.component.show();
        }
    }
}
```

具体服饰类（`ConcreteDecorator`）：

```java
public class Tshirt extends Finery {
    
    public void show() {
        System.out.print("T恤");
        
        super.show();
    }
}
```

其他服饰同理。

客户端代码：

```java
Person p = new Person("Alice");

Sneakers sneakers = new Sneakers();
sneakers.decorate(p);

Trousers trousers = new Trousers();
trousers.decorate(sneakers);

Tshirt tshirt = new Tshirt();
tshirt.decorate(trousers);

tshirt.show(); // 打印:"T恤裤子运动鞋装扮的Alice"
```

## 例2：升级商场收银程序

如果需要在打折基础上又返现，不需要添加新的`CashReturnRebate`子类，依然是`CashNormal `、`CashReturn`、`CashRebate`三种基本算法子类。增加一个接口`ISale`，用作装饰模式里的`Component`。

![装饰模式例子2.jpg](https://s2.loli.net/2023/09/20/HthTDI9Zpz61acq.jpg)

装饰模式有一个重要的优点，把类中的装饰功能从类中搬移去除，这样可以简化原有的类。

`CashNormal`是最基础的类，可以把它作为`ConcreteComponent`。

![装饰模式例子2-改进.jpg](https://s2.loli.net/2023/09/20/Oq4yoQVPExWRgeD.jpg)

`ISale `接口（`Component`）：

```java
public interface ISale {
    
    public double acceptCash(double price, int num);
}
```

`CashSuper` 实现 `ISale ` 接口：

```java
public abstract(?) class CashSuper implements ISale {
    
    protected ISale component;
    
    public void decorate(ISale component) {
        this.component = component;
    }
    
    public double acceptCash(double price, int num) {
        double result = 0d;
        if (this.component != null) {
            // 若装饰对象存在，则执行装饰的算法运算
            result = this.component.acceptCash(price, num);
        }
        return result;
    }
}
```

`CashNormal` 类（`ConcreteComponent`），最基本的原价算法：

```java
public class CashNormal implements ISale {
    
    public double acceptCash(double price, int num) {
        return price * num;
    }
}
```

打折和返现的算法都继承自 `CashSuper` ，都为 `ConcreteDecorator`。

从外层向里层依次执行 `acceptCash` 方法。先执行自己的`acceptCash`方法，再调用 `super(CashSuper).acceptCash()` ，会执行 `this.component` （里层的装饰器）的 `acceptCash` ，将计算结果 `result` 传入。

```java
public class CashRebate extends CashSuper {
    
    private double moneyRebate = 1d; // 折扣率
    
    public CashRebate(double moneyRebate) {
        this.moneyRebate = moneyRebate;
    }
    
    public double acceptCash(double price, int num) {
        double result = price * num * this.moneyRebate;
        return super.acceptCash(result, 1); // result作为price传入，数量为1
    }
}

public class CashReturn extends CashSuper {
    
    private double moneyCondition = 0d; // 返利条件
    private double moneyReturn = 0d; // 返利值

    public CashReturn(double moneyCondition, double moneyReturn) {
        this.moneyCondition = moneyCondition;
        this.moneyReturn = moneyReturn;
    }
    
    public double acceptCash(double price, int num) {
        double result = price * num;
        if (moneyCondition > 0 && result >= moneyCondition) {
            result -= Math.floor(result / moneyCondition) * moneyReturn;
        }
        return super.acceptCash(result, 1);
    }
}
```

重点在 `CashContext` 类，因为涉及组合算法，所以用装饰模式的方式进行包装，这里需要注意包装的顺序，先打折后满多少返多少，与先满多少返多少，再打折会得到完全不同的结果。

```java
public class CashContext {
    
    private ISale cs;
    
    // 在构造函数中传入type，根据type来实例化具体的收费策略
    public CashContext(int cashType) {
        switch (cashType) {
            case 1:
                this.cs = new CashNormal();
                break;
            ...
            case 5:
                // 先打8折，再满300返100
                CashNormal cn = new CashNormal();
                CashReturn crt = new CashReturn(300d, 100d);
                CashRebate crb = new CashRebate(0.8d);
                
                crt.decorate(cn); // 用 满300返100算法 包装原价算法
                crb.decorate(crt); // 用 打8折算法 装饰 满300返100算法
                this.cs = crb;
                break;
        }
    }
    
    public double getResult(double price, int num) {
        // 根据收费策略的不同，获得计算结果
        return this.cs.acceptCash(price, num);
    }
}
```

现在无论如何组合算法，哪怕是先打折再返现，再打折再返现，都只需要更改`CashContext`类，很好地做到了开放封闭。

## 总结

装饰模式是为已有功能**动态地添加更多功能**的一种方式。

- 装饰者有和所装饰对象同样的超类型。
- 可以用任意多个装饰者包裹一个对象。
- **装饰者在委托给所装饰对象之前或（与）之后添加自己的行为，来做剩下的工作。**

缺点：带来了大量的小类，对使用者来说没那么直白（如Java I/O库中的一系列InpurStream）。

### 用装饰模式前

当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为（如：给Person添加新服饰）。

**问题**：它们在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度。而这些新加入的东西仅仅是为了满足一些只在某种**特定情况**下才会执行的特殊行为的需要。

### 用装饰模式后

它把每个要装饰的功能放在**单独的类**中，并让这个类**包装**它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。

**优点**：

- 把类中的装饰功能从类中搬移去除，这样可以简化原有的类（如：原价算法）。
- 有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑（如：无需重复编写 先打折后返现 & 先返现后打折）。对于装饰模式来说，只是多几种组合而已。

### 注意

**装饰顺序很重要。**

比如加密数据和过滤词汇都可以是数据持久化前的装饰功能，但若先加密了数据再用过滤功能就会出问题了。

最理想的情况，是保证装饰类之间彼此独立，这样它们就可以以任意的顺序进行组合了。
