---
title: 设计模式19-组合模式
categories:
	- Design Pattern
---

# 组合模式

## 定义

组合模式（Composite），将对象组合成树形结构以表示'部分-整体'的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

## 结构图

![组合模式结构图.jpg](https://s2.loli.net/2023/10/18/qbGU8Fy4LRCzDvO.jpg)

`Component` 接口/抽象类：为组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理 `Component` 的子部件。

`Leaf` 类：在组合中表示叶节点，无子节点。

`Composite` 类：定义非叶节点的行为。

## 基本代码

`Component` 类：

```java
abstract class Component {
  
  protected String name;
  
  public Component(String name) {
    this.name = name;
  }
  
  public abstract void add(Component component);
  
  public abstract void remove(Component component);
  
  public abstract void display(int depth);
  
}
```

`Leaf` 类：add和remove方法没有意义，但好处是可以消除叶节点和非叶节点在抽象层次的区别，它们具备完全一致的接口

```java
class Leaf extends Component {
  
  public Leaf(String name) {
    super(name);
  }
  
  public void add(Component component) {
    System.out.println("Cannot add to a leaf."); // 叶子无法增加子节点
  }
  
  public void remove(Component component) {
    System.out.println("Cannot remove from a leaf."); // 叶子无法移除子节点
  }
  
  public void display(int depth) {
    // 叶节点的具体显示方法
    for (int i = 0; i < depth; i ++)
      System.out.println("-");
    System.out.println(name);
  }
}
```

`Composite` 类：

```java
class Composite extends Component {
  
  private ArrayList<Component> children = new ArrayList<>(); // 存储其下属的非叶节点和叶节点
  
  public Composite(String name) {
    this.name = name;
  }
  
  public void add(Component component) {
    children.add(component);
  }
  
  public void remove(Component component) {
    children.remove(component);
  }
  
  public void display(int depth) {
    for (int i = 0; i < depth; i ++)
      System.out.println("-");
    System.out.println(name);
    // 对下一层进行遍历
    for (Component item : children) {
      item.display(depth + 1);
    }
  }
}
```

客户端代码：

```java
Composite root = new Composite("root");
root.add(new Leaf("Leaf A"));
root.add(new Leaf("Leaf B"));

Composite comp = new Composite("Composite X");
comp.add(new Leaf("Leaf XA"));
comp.add(new Leaf("Leaf XB"));
root.add(comp);

Composite comp2 = new Composite("Composite XY");
comp2.add(new Leaf("Leaf XYA"));
comp2.add(new Leaf("Leaf XYB"));
comp.add(comp2);

Leaf leaf = new Leaf("Leaf C");
root.add(leaf);

Leaf leaf2 = new Leaf("Leaf D");
root.add(leaf2);
root.remove(leaf2);

root.display(1);
/*
展示结果：
-root
--Leaf A
--Leaf B
--Composite X
---Leaf XA
---Leaf XB
---Composite XY
----LeafXYA
----LeafXYB
--Leaf C
*/
```

## 透明方式与安全方式

### 透明方式

在Component中声明所有用来管理子对象的方法，其中包括add、remove等。这样实现Component接口的所有子类都具备了add和remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。但问题也很明显，因为Leaf类本身不具备add()、remove()方法的功能，所以实现它是没有意义的。

### 安全方式

安全方式，也就是在Component接口中不去声明add和remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite中声明所有用来管理子类对象的方法，这样做就不会出现Leaf类也需要实现add()、remove()方法的问题，不过由于不够透明，所以树叶和树枝类将不具有相同的接口，客户端的调用需要做相应的判断，带来了不便。

## 使用场景

发现需求中是体现**部分与整体层次的结构**时，以及希望用户可以忽略组合对象与单个对象的不同，**统一地使用组合结构中的所有对象**时，就应该考虑用组合模式了。

## 好处

组合模式定义了包含基本对象和组合对象的类层次结构。基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象了。

并且，用户不用关心到底是处理一个叶节点还是处理一个组合组件，也就不用为定义组合而写一些选择判断语句了。组合模式让客户可以一致地使用组合结构和单个对象。