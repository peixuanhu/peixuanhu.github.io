---
title: 设计模式28-访问者模式
categories:
	- Design Pattern
---

# 访问者模式

## 定义

访问者模式（Visitor），表示一个作用于某对象结构中的各元素的操作。它使你可以在**不改变各元素的类**的前提下**定义作用于这些元素的新操作**。

## 结构图

![访问者模式结构图.jpg](https://s2.loli.net/2023/11/05/vbx824mMZzaQokf.jpg)

访问者模式适用于数据结构相对稳定（Element种类数量不变）的系统。

它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。

## 基本代码

`Visitor`类：为该对象结构中`ConcreteElement`的每一个类声明一个Visit操作

```java
abstract class Visitor {
  
  public abstract void visitConcreteElementA(ConcreteElementA concreteElementA);
  
  public abstract void visitConcreteElementB(ConcreteElementB concreteElementB);
  
}
```

`ConcreteVisitor1`和`ConcreteVisitor2`类：具体访问者， 实现每个由Visitor声明的操作。每个操作实现算法的一部分

```java
class ConcreteVisitor1 extends Visitor {
  
  public void visitConcreteElementA(ConcreteElementA concreteElementA) {
    System.out.println(concreteElementA.getClass().getSimpleName() + "被" + this.getClass().getSimpleName() + "访问");
  }
  
  public void visitConcreteElementB(ConcreteElementB concreteElementB) {
    System.out.println(concreteElementB.getClass().getSimpleName() + "被" + this.getClass().getSimpleName() + "访问");
  }
}

class ConcreteVisitor2 extends Visitor {
  
  public void visitConcreteElementA(ConcreteElementA concreteElementA) {
    System.out.println(concreteElementA.getClass().getSimpleName() + "被" + this.getClass().getSimpleName() + "访问");
  }
    
    public void visitConcreteElementB(ConcreteElementB concreteElementB) {
    System.out.println(concreteElementB.getClass().getSimpleName() + "被" + this.getClass().getSimpleName() + "访问");
  }
}
```

`Element`类：

```java
abstract class Element {
  
  public abstract void accept(Visitor visitor);
  
}
```

`ConcreteElementA`类和`ConcreteElementB`类：具体元素，实现accept操作

```java
class ConcreteElementA extends Element {
  
  public void accept(Visitor visitor) {
    visitor.visitConcreteElementA(this); // 利用双分派技术，实现处理与数据结构的分离
  }
  
  public void operationA() {
  }
}

class ConcreteElementB extends Element {
  
  public void accept(Visitor visitor) {
    visitor.visitConcreteElementB(this); // 利用双分派技术，实现处理与数据结构的分离
  }
  
  public void operationB() {
  }
}
```

`ObjectStructure`类：能枚举`ConcreteElement`，可以提供一个高层的接口以允许访问者访问它的元素。

```java
class ObjectStructure {
  
  private ArrayList<Element> elements = new ArrayList<>();
  
  public void attach(Element element) {
    elements.add(element);
  }
  
  public void detach(Element element) {
    elements.remove(element);
  }
  
  public void accept(Visitor visitor) {
    for (Element e : elements) {
      e.accept(visitor);
    }
  }
}
```

客户端代码：

```java
ObjectStructure o = new ObjectStructure();
o.attach(new ConcreteElementA());
o.attach(new ConcreteElementB());

ConcreteVisitor1 v1 = new ConcreteVisitor1();
ConcreteVisitor2 v2 = new ConcreteVisitor2();

o.accept(v1);
o.accept(v2);
```



## 总结

### 目的

访问者模式的目的是把**处理操作**从**元素的数据结构**分离出来。

>很多系统可以按照算法和数据结构分开，如果这样的系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较合适的，因为访问者模式使得算法操作的增加变得容易。

#### 优点

增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。

访问者模式将有关的行为集中到一个访问者对象中。

>通常ConcreteVisitor可以单独开发，不必跟ConcreteElementA或ConcreteElementB写在一起。正因为这样，ConcreteVisitor能提高ConcreteElement之间的独立性，如果把一个处理动作设计成ConcreteElementA和ConcreteElementB类的方法，每次想新增'处理'以扩充功能时就得去修改ConcreteElementA和ConcreteElementB了。

### 缺点

使增加新的数据结构（元素）变得困难。

>大多时候你并不需要访问者模式，但当一旦你需要访问者模式时，那就是真的需要它了。
>
>事实上，我们很难找到数据结构不变化的情况，所以用访问者模式的机会也就不太多了。

## 补充

### 双分派技术

双分派意味着得到执行的操作决定于请求的种类和两个接收者的类型。