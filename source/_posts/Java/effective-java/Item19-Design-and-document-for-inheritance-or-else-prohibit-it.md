---
title: Effective Java-19. Design and document for inheritance or else prohibit it
categories:
  - [Java, Effective Java]
---

# Item 19: Design and document for inheritance or else prohibit it

A class to be designed and documented for inheritance must document precisely the effects of overriding any method. In other words, **the class must document its** ***self-use*** **of overridable methods.**

For each **public or protected method** (including constructor), the documentation must indicate which overridable methods the method invokes, in what sequence, and how the results of each invocation affect subsequent processing. (By *overridable*, we mean nonfinal and either public or protected.)

> More generally, a class must document any circumstances under which it might invoke an overridable method. For example, invocations might come from background threads or static initializers.

## Example of the document

**A method that invokes overridable methods** contains a description of these invocations at the end of its documentation comment. The description is in a special section of the specification, labeled “**Implementation Requirements**,” which is generated by the Javadoc tag `@implSpec`. This section describes the inner workings of the method.

Example from `java.util.AbstractCollection`:

```java
public boolean remove(Object o)
```

Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that Objects.equals(o, e), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).

**Implementation Requirements:** This implementation iterates over the col- lection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator’s remove method. Note that this implementation throws an `UnsupportedOperationException` if the iterator returned by this collection’s iterator method does not implement the remove method and this collection contains the specified object.

> This documentation leaves no doubt that overriding the `iterator` method will affect the behavior of the `remove` method. It also describes exactly how the behavior of the `Iterator` returned by the `iterator` method will affect the behavior of the `remove` method.

But this violate the dictum that **good API documentation should describe *what* a given method does and not *how* it does it**.

This is an unfortunate consequence of the fact that **inheritance violates encapsulation**. To document a class so that it can be safely subclassed, you must describe implementation details that should otherwise be left unspecified.

## Restrictions of classes for inheritance

Designing a class for inheritance requires great effort and places substantial limitations on the class.

1. **Constructors must not invoke overridable methods,** directly or indirectly.

   Because the superclass constructor runs before the subclass constructor, so the overriding method in the subclass will get invoked before the subclass constructor has run.

   > Note that it *is* safe to invoke private methods, final methods, and static meth- ods, none of which are overridable, from a constructor.

2. For classes that implement `Cloneable`:

   **`Clone` method must not invoke overridable methods,** directly or indirectly.

   > Because the overriding method will run before the subclass’s clone method has a chance to fix the clone’s state.

3. For classes that implement `Serializable`:

   **`readObject` method must not invoke overridable methods,** directly or indirectly.

   >Because the overriding method will run before the subclass’s state has been deserialized.

   If the class has a `readResolve` or `writeReplace` method, you must make the `readResolve` or `writeReplace` method **protected** rather than private. If these methods are private, they will be silently ignored by subclasses.

## Note

### Provide hooks

To allow programmers to write efficient subclasses without undue pain, **a class may have to provide hooks into its internal workings in the form of judiciously chosen protected methods** or, in rare instances, protected fields.

Example: `removeRange` method from `java.util.AbstractList`:

```java
protected void removeRange(int fromIndex, int toIndex)
```

Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex == fromIndex, this operation has no effect.)

This method is called by the clear operation on this list and its sublists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the `clear` operation on this list and its sublists.

**Implementation Requirements:** This implementation gets a list iterator positioned before fromIndex and repeatedly calls `ListIterator.next` followed by `ListIterator.remove`, until the entire range has been removed. Note: If `ListIterator.remove` requires linear time, this implementation requires quadratic time.

### Write subclasses to test

So how do you decide what protected members to expose when you design a class for inheritance? You should expose as few protected members as possible because each one represents a commitment to an implementation detail. On the other hand, you must not expose too few because a missing protected member can render a class practically unusable for inheritance.

**The only way to test a class designed for inheritance is to write subclasses.** If you omit a crucial protected member, trying to write a subclass will make the omission painfully obvious. Conversely, if several subclasses are written and none uses a protected member, you should probably make it private.

> Experience shows that three subclasses are usually sufficient to test an extendable class. One or more of these subclasses should be written by someone other than the superclass author.

When you design for inheritance a class that is likely to achieve wide use, realize that you are **committing *forever*** to the self-use patterns that you document and to the implementation decisions implicit in its protected methods and fields. These commitments can make it difficult or impossible to improve the performance or functionality of the class in a subsequent release. Therefore, **you must test your class by writing subclasses** **before** **you release it.**

### For ordinary concrete classes

**The best solution is to prohibit subclassing in classes that are not designed and documented to be safely subclassed.** 

There are two ways to prohibit subclassing.

1. Declare the class final.

2. Make all the constructors private or package-private and to add public static factories in place of the constructors.

   > This way provides the flexibility to use subclasses internally (Item 17)

### For classes have to allow inheritance

If a concrete class does not implement a standard interface, then you may inconvenience some programmers by prohibiting inheritance. If you must allow inheritance from such a class, one reasonable approach is **to ensure that the class never invokes any of its overridable methods and to document this fact**. In other words, eliminate the class’s self-use of overridable methods entirely. In doing so, you’ll create a class that is reasonably safe to subclass. Overriding a method will never affect the behavior of any other method.

> You can eliminate a class’s self-use of overridable methods mechanically, without changing its behavior. Move the body of each overridable method to a private “helper method” and have each overridable method invoke its private helper method. Then replace each self-use of an overridable method with a direct invocation of the overridable method’s private helper method.

## Summary

Designing a class for inheritance is hard work. You must **document all of its self-use patterns**, and once you’ve documented them, you must commit to them for the life of the class. If you fail to do this, subclasses may become dependent on implementation details of the superclass and may break if the implementation of the superclass changes.

To allow others to write *efficient* subclasses, you may also have to **export one or more protected methods** (to be the hooks).

Unless you know there is a real need for subclasses, you are probably **better off prohibiting inheritance** by declaring your class final or ensuring that there are no accessible constructors.