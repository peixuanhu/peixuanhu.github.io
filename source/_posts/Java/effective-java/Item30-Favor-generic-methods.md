---
title: Effective Java-30. Favor generic methods
categories:
  - [Java, Effective Java]
---

# Item 30: Favor generic methods

## Occasion 1

On occasion, you will need to create an object that is immutable but applicable to many different types. Because generics are implemented by erasure (Item 28), you can use a single object for all required type parameterizations, but you need to write a *static factory method* to repeatedly dole out (分发) the object for each requested type parameterization. 

> This pattern, called the *generic singleton factory*, is used for function objects (Item 42) such as `Collections.reverseOrder`, and occasionally for collections such as `Collections.emptySet`.

### Example

Suppose that you want to write an identity function dispenser. 

> The libraries provide Function.identity, so there’s no reason to write your own (Item 59), but it is instructive. 

It would be wasteful to create a new identity function object time one is requested, because it’s stateless. If Java’s generics were reified, you would need one identity function per type, but since they’re erased a generic singleton will suffice. Here’s how it looks:

```java
// Generic singleton factory pattern
private static UnaryOperator<Object> IDENTITY_FN = (t) -> t;

@SuppressWarnings("unchecked")
public static <T> UnaryOperator<T> identityFunction() { 
  return (UnaryOperator<T>) IDENTITY_FN;
}
```

The cast of `IDENTITY_FN` to (`UnaryFunction<T>`) generates an unchecked cast warning, as `UnaryOperator<Object>` is not a `UnaryOperator<T>` for every T. But the identity function is special: it returns its argument unmodified, so we know that it is typesafe to use it as a UnaryFunction<T>, whatever the value of T. Therefore, we can confidently suppress the unchecked cast warning generated by this cast.

```java
// Sample program to exercise generic singleton
public static void main(String[] args) {
  
   String[] strings = { "jute", "hemp", "nylon" };
   UnaryOperator<String> sameString = identityFunction();
   for (String s : strings)
       System.out.println(sameString.apply(s));
  
   Number[] numbers = { 1, 2.0, 3L };
   UnaryOperator<Number> sameNumber = identityFunction();
   for (Number n : numbers)
       System.out.println(sameNumber.apply(n));
  
}
```

## Occasion 2

It is permissible, though relatively rare, for a type parameter to be bounded by some expression involving that type parameter itself. This is what’s known as a ***recursive type bound***. 

### Example

A common use of recursive type bounds is in connection with the `Comparable` interface, which defines a type’s natural ordering (Item 14). In practice, nearly all types can be compared only to elements of their own type. This interface is shown here:

```java
public interface Comparable<T> {
  int compareTo(T o);
}
```

Many methods take a collection of elements implementing `Comparable` to sort it, search within it, calculate its minimum or maximum, and the like. To do these things, it is required that every element in the collection be comparable to every other element in it, in other words, that the elements of the list be *mutually comparable (互相比较)*. Here is how to express that constraint:

```java
// Using a recursive type bound to express mutual comparability 
// Returns max value in a collection - uses recursive type bound
public static <E extends Comparable<E>> E max(Collection<E> c) { 
  if (c.isEmpty())
  	throw new IllegalArgumentException("Empty collection");
  E result = null;
  for (E e : c) {
    if (result == null || e.compareTo(result) > 0)
    	result = Objects.requireNonNull(e);
  }
  return result;
}
```

The type bound `<E extends Comparable<E>>` may be read as “any type E that can be compared to itself,” which corresponds more or less precisely to the notion of mutual comparability.

> Note that this method throws IllegalArgumentException if the list is empty. A better alternative would be to return an `Optional<E>` (Item 55).

## Summary

In summary, generic methods, like generic types, are safer and easier to use than methods requiring their clients to put explicit casts on input parameters and return values. 

Like types, you should make sure that your methods can be used **without casts**, which often means making them generic. 

And like types, you should generify existing methods whose use requires casts. This makes life easier for new users without breaking existing clients (Item 26).