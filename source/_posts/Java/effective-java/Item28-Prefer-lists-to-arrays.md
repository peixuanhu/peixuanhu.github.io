---
title: Effective Java-28. Prefer lists to arrays
categories:
  - [Java, Effective Java]
---

# Item 28: Prefer lists to arrays

## Difference between arrays and generic types

1. **Arrays are *covariant*, generics are *invariant*.**

   > If `Sub` is a subtype of `Super`, then the array type `Sub[]` is a subtype of the array type `Super[]`.
   >
   > For any two distinct types `Type1` and `Type2`, `List<Type1>` is neither a subtype nor a supertype of `List<Type2>`.

2. **Arrays are *reified*, generics are implemented by *erasure*.**

   Arrays know and enforce their element type at runtime.

   Generics enforce their type constraints only at compile time and discard (or *erase*) their element type information at runtime.

## Note

Because of the fundamental differences above, arrays and generics do not mix well.

For example, **it is illegal to create an array of a generic type, a parameterized type, or a type parameter**. Therefore, none of these array creation expressions are legal: `new List<E>[]`, `new List<String>[]`, `new E[]`. All will result in *generic array creation* errors at compile time.

> It is legal, though rarely useful, to create arrays of unbounded wildcard types.

### Why?

Because it isn’t typesafe. If it were legal, casts generated by the compiler in an otherwise correct program could fail at runtime with a `ClassCastException`. This would violate the fundamental guarantee provided by the generic type system.

```java
// Why generic array creation is illegal - won't compile! 
List<String>[] stringLists = new List<String>[1]; // Compile-time error, but let's pretend it is legal
List<Integer> intList = List.of(42);
Object[] objects = stringLists;
objects[0] = intList;
String s = stringLists[0].get(0); // ClassCastException
```

### Solution

When you get a generic array creation error or an unchecked cast warning on a cast to an array type, the best solution is often to **use the collection type `List<E>` in preference to the array type `E[]`.** You might sacrifice some conciseness or performance, but in exchange you get better type safety and interoperability.

#### Example

For example, suppose you want to write a `Chooser` class with a constructor that takes a collection, and a single method that returns an element of the collection chosen at random.

> Depending on what collection you pass to the constructor, you could use a chooser as a game die, a magic 8-ball, or a data source for a Monte Carlo simulation.

##### Simplistic implementation without generics:

```java
// Chooser - a class badly in need of generics!
public class Chooser {
  private final Object[] choiceArray;
  
  public Chooser(Collection choices) {
     choiceArray = choices.toArray();
  }
  
  public Object choose() {
     Random rnd = ThreadLocalRandom.current();
     return choiceArray[rnd.nextInt(choiceArray.length)];
  }
}
```

To use this class, you have to cast the choose method’s return value from Object to the desired type every time you use invoke the method, and the cast will fail at runtime if you get the type wrong.

##### We attempt to modify `Chooser` to make it generic (Item 29):

```java
// A first cut at making Chooser generic - won't compile 
public class Chooser<T> {
  private final T[] choiceArray;
  
  public Chooser(Collection<T> choices) { 
    choiceArray = (T[]) choices.toArray();
  }
  
  // choose method unchanged
}
```

You get a warning: `required: T[], found: Object[]`. The compiler is telling you that it can’t vouch for the safety of the cast at runtime because the program won’t know what type T represents—remember, element type information is erased from generics at runtime.

Will the program work? Yes, but the compiler can’t prove it. You could prove it to yourself, put the proof in a comment and suppress the warning with an annotation, but you’re better off eliminating the cause of warning (Item 27).

##### To eliminate the unchecked cast warning, use a list instead of an array:

```java
// List-based Chooser - typesafe
public class Chooser<T> {
  private final List<T> choiceList;
  
  public Chooser(Collection<T> choices) { 
    choiceList = new ArrayList<>(choices);
  }
  
  public T choose() {
    Random rnd = ThreadLocalRandom.current();
    return choiceList.get(rnd.nextInt(choiceList.size()));
  } 
}
```

This version is a tad more verbose, and perhaps a tad slower, but it’s worth it for the peace of mind that you won’t get a ClassCastException at runtime.

## Summary

Arrays and generics have very different type rules. Arrays are covariant and reified; generics are invariant and erased. As a consequence, arrays provide runtime type safety but not compile-time type safety, and vice versa for generics. 

As a rule, arrays and generics don’t mix well. If you find yourself mixing them and getting compile-time errors or warnings, your first impulse should be to replace the arrays with lists.