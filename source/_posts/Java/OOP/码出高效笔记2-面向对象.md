---
title: 码出高效读书笔记2-面向对象
categories:
  - [Java, OOP]
tags:
  - [Easy Coding]
---

# 面向对象

## 类

### 访问权限控制

![访问权限控制及可见范围.png](https://s2.loli.net/2023/10/26/hlvCdauSt7I6NMA.png)

- 如果不允许外部直接通过 new 创建对象，构造方法必须是 private。
- 工具类不允许有 public 或 default 构造方法。

### this和super

![this和super的异同点.png](https://s2.loli.net/2023/10/26/Fx2lKfmdSgryw8X.png)

- 在一个构造方法中， this 和 super 只能出现一个，且只能出现一次，否则在实例化对象时，会因子类调用到多个父类构造方法而造成混乱。

- 由于 this 和 super都在实例化阶段调用，所以不能在**静态方法**和**静态代码块**申使用 this 和 super 关键字。 

### 类关系

类与类之间的关系可分成两种·有关系与没关系，难点在于确定类与类之间是否存在相互作用。证明类之间没关系是一个涉及业务、架构、模块边界的问 题，往往由于业务模型的抽象角度不同而不同，是一件非常棘手的事情。如果找到了 没有关系的点，就可以如庖丁解牛一样，进行架构隔离、模块解耦等工作。

类与类有关系的情况，包括以下5种类型：

- 【继承】 extends (is-a)。
- 【实现】 implements (can-do)。
- 【组合】 类是成员变量 (contains-a)。
- 【聚合】 类是成员变量(has-a)。
- 【依赖】 import类(use-a)。

随着业务和架构的发展，类与类的关系是会发生变化的，必须用发展的眼光看待类图。

在业务重构过程中，往往会把原来强组合的关系拆开来，供其他模块调用，这就是类图的一种演变。

### 序列化

常见的序列化方式有三种：

1. **Java 原生序列化。**Java类通过实现 Serializable接口来实现该类对象的序列化，这个接口非常特殊，没有任何方法，只起标识作用。
   - 实现 Serializable 接口的类要显式设置 serialVersionUID 字段值，否则类源码修改后该值会发生变化。
     - 如果是兼容升级，请不要修改 seria!VersionUID 字段 ， 避免反序列化失败。
     - 如果是不兼容升级，需要修改 serialVersionUID 值，避免反序列化混乱。
   - Java 反序列化时不会调用类的无参构造方法，而 是调用 native 方法将成员变量赋值为对应类型的初始值。基于性能及兼容性考虑，不 推荐使用 Java 原生序列化。
2. **Hessian 序列化。**压缩编码，比Java原生序列化二进制流小且耗时短。特性：
   - 自描述序列化类型。不依赖外部描述文件或接口定义 ， 用一个字节表示常用 基础类型 ， 极大缩短二进制流。
   - 语言无关，支持脚本语言。
   - 协议简单，比 Java 原生序列化高效。
3. **JSON 序列化。**JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。JSON 序列化就是将数据对象转换为 JSON 字符串。在序列化过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确地反序列化。相比前两种方式， JSON 可读性比较好，方便调试。

## 方法

### 参数

#### 参数预处理

##### 1. 入参保护

人参保护实质上是对服务提供方的保护，常见于批量接口。

虽然批量接口能处理批数据，但其处理能力并不是无限的，因此需要**对入参的数据量进行判断和控制**，如果超出处理能力，可以直接返回错误给客户端。

##### 2. 参数校验

需要进行参数校验的场景：

- 调用频度低的方法。
- 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退或者错误，则得不偿失。
- 需要极高稳定性和可用性的方法。 
- 对外提供的开放接口。
- 敏感权限入口。

不需要进行参数校验的场景：

- 极有可能被**循环调用**的方法。但在方法说明里必须注明外部参数检查。
- **底层调用频度较高**的方法。参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同个应用中，部署在同一台服务器中，所以可以省略 DAO 的参数校验。
- 声明成 **private** 只会被自己代码调用的方法。如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。

### 构造方法

**单一职责**对于构造方法同样适用，构造方法的使命就是在构造对象时进行传参操作，所以不应该在构造方法中引入业务逻辑。

如果在一个对象生产中 ，需要完成初始化上下游对象、分配内存、执行静态方法、赋值句柄等繁重的工作，其中某个步骤出错，导致没有完成对象初始化，再将希望寄托于业务逻辑部分来处理异常就是一件不受控制的事情了。故推荐将初始化业务逻辑放在某个方法中，比如`init()`， 当对象确认完成所有初始化工作之后，再显式调用。