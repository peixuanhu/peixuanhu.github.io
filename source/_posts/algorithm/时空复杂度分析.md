---
title: 算法时空复杂度分析
categories:
  - [Algorithm]
---

# 时间复杂度

## 由数据范围反推算法复杂度以及算法内容

一般ACM或者笔试题的时间限制是1秒或2秒。
在这种情况下，C++代码中的操作次数控制在 $10^7∼10^8$ 为最佳。

下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：

1. $n≤30$ => 指数级别：dfs+剪枝，状态压缩DP
2. $n≤100$ => $O(n^3)$：Floyd，DP，高斯消元
3. $n≤1000$ => $O(n^2), O(n^2logn)$ ：DP，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford
4. $n≤10^4$ => $O(n*\sqrt n)$：块状链表、分块、莫队
5. $n≤10^5$ => $O(nlogn)$：各种sort，线段树、树状数组、set/map、heap、拓扑排序、Dijkstra+heap、Prim+heap、Kruskal、SPFA、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树
6. $n≤10^6$ => $O(n)$： 单调队列、hash、双指针扫描、BFS、并查集，KMP、AC自动机；以及常数比较小的$O(nlogn)$算法：sort、树状数组、heap、Dijkstra、SPFA
7. $n≤10^7$ => $O(n)$：双指针扫描、KMP、AC自动机、线性筛素数
8. $n≤10^9$ => $O(\sqrt n)$：判断质数
9. $n≤10^{18}$ => $O(logn)$：最大公约数，快速幂，数位DP
10. $n≤10^{1000}$ => $O((logn)^2)$：高精度加减乘除
11. $n≤10^{100000}$ => $O(logk * loglogk)$，k表示位数：高精度加减、FFT/NTT

> SPFA，匈牙利，最大流的理论复杂度高，但实际几乎为线性

## 分析时间复杂度的方法

1. 循环：看循环的层数
2. 递归：
   1. 主定理，看递推关系式$T(n) = aT(\frac{n}{b}) + f(n)$，然后分情况，较复杂
   2. 看层数，如快排，每层递归是$O(n)$，一共$logn$层，所以时间复杂度为$O(nlogn)$

# 空间复杂度

一般空间限制：$64MB$。

```
int: 4 Byte
char: 1 Byte
double, long long: 8 Byte

64MB = 2^26 Byte
能开多少int变量？
2^26 / 4 = 2 ^ 24
```

> 注：操作系统有优化，数组是用的时候再临时分配内存。
>
> 如果只开了数组，没有用那么多的话，用sizeof算出来超内存也不会MLE。

递归会使用系统栈，即使没有额外开数组，也会占用系统空间。如快排的额外空间复杂度是$O(logn)$的。