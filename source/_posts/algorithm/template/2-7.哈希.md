---
title: 算法模板2-7.哈希
categories:
  - [Algorithm, Template]
---

# 一般哈希

## 适用场景

把庞大的值域映射到一个比较小的空间。

如 `0~10^9 -> 0~10^5`。

> 与离散化的关系：离散化是需要保序的，可以看作一种特殊的哈希方式

## 步骤

### 1. x mod n

`n` 即数组长度，它是一个质数，并且这个质数要离2的整数次幂尽可能远。

> 这样取可以使冲突的概率最小。数学证明待补充

### 2. 解决冲突

有两种方法

#### 拉链法

数组的长度即为`n`，其中每个元素都是一个链表，取模之后结果相同的数存在链表里

#### 开放寻址法

只开一个一维数组，但长度应取为题给数据范围的2～3倍（经验值）。

取模之后存在数组对应的位置，如已有元素存在，则依次向后面的位置找，直到找到空位存下来。

## 代码模板

### 拉链法

```cpp
int h[N], e[N], ne[N], idx;
// h[]是数组（槽），数组中的每个元素是一个链表，其中有e[]（存值）和ne[]（存下一个节点的下标），idx为当前新插入节点编号

// 需要先初始化h数组元素为-1，代表空链表
memset(h, -1, sizeof(h)); // -1二进制为11111111，刚好可以按字节设置

// 向哈希表中插入一个数
void insert(int x) {
  // k即为哈希值
  int k = (x % N + N) % N; // 目的：让k在0～N范围内。cpp取模：原数是负数的话取模之后还是负数，所以要+N；但正数+N之后又大于N了，所以需要再取一次模
  
  // 以下代码实现了将新节点插入h[k]，作为新的头节点
  e[idx] = x;
  ne[idx] = h[k];
  h[k] = idx ++;
}

bool find(int x) {
  int k = (x % N + N) % N;
  
  for (int i = h[k]; ~i; i = ne[i]) // 从头节点往后找
    if (e[i] == x) return true;
  
  return false;
}
```



### 开放寻址法

```cpp
const int N = 200003, null = 0x3f3f3f3f; // null的值近似无穷大，代表数组该位置为空

int h[N];

// 需要先初始化h数组元素为0x3f3f3f3f，代表所有位置都空
memset(h, 0x3f, sizeof(h)); // memset按字节来设置

// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
int find(int x) {
  int t = (x % N + N) % N;
  while (h[t] != null && h[t] != x) {
    t ++;
    if (t == N) t = 0;
  }
  return t;
}

// 插入操作：
int k = find(x);
h[k] = x;

// 查找操作：
int k = find(x);
if (h[k] == null) puts("No");
else puts("Yes");
```

## 注意事项

1. 一般不需要删除元素。如果需要考虑删除，一般是另开一个布尔数组，来标记对应元素是否已删除。
