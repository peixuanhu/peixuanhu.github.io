---
title: 算法模板4-6.DP-状态压缩DP
categories:
  - [Algorithm, Template]
---

# 状态压缩DP

一般数据范围非常小。如蒙德里安的梦想：$1<=N, M<=11$

## 模板题

### 1. 蒙德里安的梦想

放1*2的小方块，把长m宽n的矩形放满。

核心：先放横着的，再放竖着的。

总方案数 = 只放横着的小方块的合法方案数

如何判断当前方案是否合法？ 所有剩余位置，能否填充满竖着的小方块。可以按列来看，每一列内部所有连续的空着的小方块需要是偶数个。

时间复杂度：`M * 2^N * 2^N`

#### 状态表示

`f[i, j]`表示已经将前`i - 1`列摆好，且从第`i - 1`列，伸出到第`i`列的状态是`j`的所有方案。

答案为`f[m, 0]`，即全部的列都已经摆好，且不再往外伸。

#### 状态计算

`f[i, j]`由`f[i - 1, k]`计算得出，其中`k`用二进制位来表示（e.g. 00100），有`2^n`种取值，每一行都可以选从`i - 2`列到第`i - 1`列伸或不伸。

所有的k需要满足两个条件才合法：

1. (j & k) == 0。即方块不能有重叠，已经放了就不能再放
2. 一列中所有连续空着的位置的长度必须是偶数。即要保证不重不漏地全摆上竖着的小方块。

#### 优化

预处理

1. `state[k][]`：可以从`k`状态更新到哪些`j`状态。
2. `st[]`：一列中所有连续的空白小方块是否是偶数个。

#### 代码

```cpp
#include<cstring>
#include<iostream>
#include<vector>

using namespace std;

typedef long long LL;

const int N = 12, M = 1 << N;

int n, m;
LL f[N][M];
vector<int> state[M];
bool st[M];

int main()
{
    
    while (cin >> n >> m, n || m)
    {
        // 预处理st数组：列中所有连续的空白小方块数量是否为偶数个
        for (int i = 0; i < 1 << n; i ++) // 遍历所有可能的列的状态
        {
            int cnt = 0;
            bool is_valid = true;
            for (int j = 0; j < n; j ++) // 遍历该列每个小方块
            {
                if ((i >> j) & 1)
                {
                    if (cnt & 1)
                    {
                        is_valid = false;
                        break;
                    }
                    cnt = 0; // 合法，空白方块数重新计数
                } else cnt ++;
            }
            if (cnt & 1) is_valid = false;
            st[i] = is_valid;
        }
        
        // 预处理state数组：从哪些j状态可以到达i状态
        for (int i = 0; i < 1 << n; i ++)
        {
            state[i].clear();
            for (int j = 0; j < 1 << n; j ++)
                if ((i & j) == 0 && st[i | j])
                    state[i].push_back(j);
        }
        
        memset(f, 0, sizeof f);
        f[0][0] = 1; // 初始化，从第-1列到第0列，伸出到全空的列的方案数为1
        for (int i = 1; i <= m; i ++)
            for (int j = 0; j < 1 << n; j ++)
                for (auto k : state[j])
                    f[i][j] += f[i - 1][k];
        
        cout << f[m][0] << endl;
    }
  
  	return 0;
}
```

### 2. 最短Hamilton路径

时间复杂度：`2^N * N`， `N`为点数

很重要的前提：图是完全图，并且两边之和大于第三边。

#### 状态表示

`f[i, j]`的含义：状态是`i`的情况下，最后停在点`j`，其中`i`表示哪些点被用过，可能的取值为`2^N`，`N`为点数

#### 状态计算

`f[state][j] = f[state_k][k] + weight[k][j]`，其中`state_k = state除掉j之后的集合，且state_k中要包含k`

#### 注意

两层循环，要外层先枚举状态，再枚举所有点

```
因为在进行状态转移时，f[i][j] 要由 f[i - (1 << j)][k] 转移过来，所以一定要保证在计算 f[i][j] 之前一定已经计算过 f[i - (1 << j)][k] 了，这样才能保证答案递推的连续性。

在 i 是外层循环中，是按照最外层为 状态依次从小到大 的顺序进行对答案的计算
因为状态 i - (1 << j) 一定是小于状态 i 的，所以符合递推的连续性。

在 j 是外层循环中，在计算 f[i][j] 时一定用到 f[i - (1 << j)][k]
而当 k>j 的情况时，此时的 f[i - (1 << j)][k] 并没有被计算过，因为你最外层循环还没循环到k呢。

例如： f[101011][3] = f[100011][5] + w[5][3]
按 i 外层循环，一定可以保证 f[100011][5] 在f[101011][3] 之前被计算出来。
而按 j 外层循环，由于 5 > 3 ，f[100011][5] 根本就没有被计算过，所以不可行。
```

#### 代码

```cpp
#include<cstring>
#include<iostream>

using namespace std;

const int N = 20, M = 1 << N;
int w[N][N];
int f[M][N];
int n;

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++)
        for (int j = 0; j < n; j ++)
            scanf("%d", &w[i][j]);
    
    memset(f, 0x3f, sizeof f);
    f[1][0] = 0; // 从起点出发，路径长度为0
    
    for (int i = 1; i < 1 << n; i ++)
        for (int j = 0; j < n; j ++) // 枚举当前终点j
        {
            if (i >> j & 1) // 路径经过j才合法
            {
                for (int k = 0; k < n; k ++)
                {
                    if (i - (1 << j) >> k & 1) // 路径经过k
                    {
                        f[i][j] = min(f[i][j], f[i - (1 << j)][k] + w[k][j]);
                    }
                }
            }
        }
    
    cout << f[(1 << n) - 1][n - 1] << endl; // 经过了所有点，且最终停在终点
  
  	return 0;
}
```

