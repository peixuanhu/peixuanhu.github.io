---
title: 算法模板3-3.树与图的遍历
categories:
  - [Algorithm, Template]
---

# 树与图的遍历

时间复杂度：`O(n + m)`，其中 `n` 表示点数， `m` 表示边数。

树是特殊的图，同样只需要考虑图的遍历即可。

## DFS

一般树和图的遍历，每个点只需要遍历一次。

需要一个状态数组 `st[]`，表示该点是否被遍历过。

### 代码模板

```cpp
int dfs(int u) {
  
  st[u] = true; // st[u] 表示点u已经遍历过
  
  for (int i = h[u]; ~i; i = ne[i]) {
    int j = e[i]; // 取到该边对应的点
    if (!st[j]) dfs(j);
  }
}
```

### 例题

#### 树的重心

重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。

##### 思路

在dfs的过程中从下往上算出以各个节点为根节点的子树节点的数量。

对每个节点n：求出`以其子节点为根节点的所有子树节点数量`和 `总节点数量减去以n为根节点的子树节点数量` （即剩余连通块点数）的最大值。再求所有最大值的最小值。



## BFS



### 代码模板

```cpp
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size()) {
  int t = q.front();
  q.pop();
  
  for (int i = h[t]; ~i; i = ne[i]) {
    int j = e[i];
    if (!st[j]) {
      st[j] = true; // 把j号点标记为已经被遍历过
      q.push(j);
    }
  }
}
```

### 例题

#### 图中点的层次

即从1号点开始一层层搜，计算每个点到1号点的最短距离。

### 应用

#### 拓扑排序

##### 拓扑序列

###### 定义

若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。

其实也就是把点排成拓扑序列之后，满足所有的边都是从前面的点指向后面的点的。

> 只有**有向图**有拓扑序列。

###### 性质

可以证明，一个有向无环图一定存在拓扑序列。

> 有向无环图也被称为拓扑图。
>
> 一个有向无环图，一定至少存在一个入度为0的点。

##### 拓扑排序

###### 步骤

所有入度为0的点都可以作为起点。（所以对于有环的图，这个环上的点永远不会入队，因为入度都不为0）

```
用bfs框架：
queue <- 所有入度为0的点

while queue 不空
{
	t <- 队头
	枚举t的所有出边t->j
		删掉t->j 即j号点的入度--：d[j] --;
		if (!d[j]) queue <- j
}
```

queue里的次序即为拓扑序。
