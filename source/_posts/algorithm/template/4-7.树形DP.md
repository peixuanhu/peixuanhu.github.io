---
title: 算法模板4-7.DP-树形DP
categories:
  - [Algorithm, Template]
---

# 树形DP

一般是DFS的形式。

## 模板题

### 没有上司的舞会

#### 状态表示

`f(i, 0)`和`f(i, 1)`分别表示在以`i`为根的子树中不选`i`和选`i`的最大值是多少。

#### 状态计算

`f[i, 0] = sum(max(f[i的子节点, 0], f[i的子节点, 1]))`

`f[i, 1] = sum(f[i的子节点, 0])`

#### 代码

```cpp
#include<iostream>
#include<cstring>

using namespace std;

const int N = 6010;

int n;
int w[N], f[N][2];
bool st[N]; // 为了找到根节点，值为false的话则为根节点
int idx, e[N], ne[N], h[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    f[u][0] = 0, f[u][1] = w[u]; // 快乐指数有负数，但如果不选该点则应该初始化为0
    
    for (int i = h[u]; ~i; i = ne[i]) // 遍历u的子节点
    {
        int t = e[i];
        dfs(t);
        f[u][0] += max(f[t][0], f[t][1]);
        f[u][1] += f[t][0];
    }
}

int main()
{
    cin >> n;
    
    for (int i = 1; i <= n; i ++) cin >> w[i];

    memset(h, -1, sizeof h);
    
    for (int i = 0; i < n - 1; i ++)
    {
        int a, b;
        cin >> a >> b;
        add(b, a);
        st[a] = true;
    }
    
    int root = 1;
    while (st[root]) root ++; // 找到根节点
    
    dfs(root);
    
    cout << max(f[root][0], f[root][1]) << endl;
    
    return 0;
}
```

