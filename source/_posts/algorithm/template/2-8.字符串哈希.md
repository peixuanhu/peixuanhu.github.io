---
title: 算法模板2-8.字符串哈希
categories:
  - [Algorithm, Template]
---

# 字符串哈希

## 适用场景

快速判断一个字符串中两个区间对应的子串是否完全相同。

> 除了求一个字符串的循环节只能用KMP之外，大部分时候字符串哈希都能代替KMP。

## 字符串前缀哈希法

```
str = "ABCABCDE"

把每一个前缀的哈希值算出来：
h[0] = 0
h[1] = "A"的哈希值
h[2] = "AB"的哈希值
h[3] = "ABC"的哈希值
...
```

**结果：**可以通过这些前缀的哈希值，算出 **`str` 任何一个子串**的哈希值。

## 如何定义某一前缀的哈希值？

把字符串str看成一个p进制的数。str中**每一个字符（的ASCII码）**对应这个**p进制数的每一位数字**。最后一个字符对应最低位。

> 例：hash("ABC") = (A * p^2 + B * p^1 + C * p^0)

### 步骤

**目标：**将str映射到0～Q-1的范围内。

**经验值：** ` p=131或13331`, `Q = 2^64`。用 `unsigned long long` 来存储哈希值，当它溢出时，刚好等价于取模。

#### 1. 算出这个p进制数x

##### 2. x mod Q

由于str的长度可能比较长，x可能为一个很大的数字，不好存。所以算出x之后，需要mod一个比较小的数Q。

### 注意

1. 不能把某一个字母映射成0。例："A"->0, "AA"->0，将不同的字符串映射成了同一个数。
2. 假定无冲突。这个算法没有考虑冲突情况。p和Q取经验值的情况下，起冲突的可能性很小。

## 如何算出任意子串的哈希值？

假设我们要算 `str` 第 `L` 位和第`R` 位之间这个子串的哈希值。

已知 `h[R]` 和 `h[L-1]` ：

`h[R] - h[L - 1] * p^(R - L + 1)` 即为子串的哈希值。

> `h[R]` 中第R个字符对应x的第0位，第1个字符对应x的第R-1位
>
> `h[L-1]`  中第L-1个字符对应x的第0位，第1个字符对应x的第L-2位
>
> h[L-1] * p^(R - L + 1)是为了将 `h[L-1]` 往左移，与 `h[R]` 对齐。



## 代码模板

```cpp
typedef unsigned long long ULL;

const int N = 100010, int P = 13331;
char str[N];
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值，p[k]存储 P^k mod 2^64（提前预处理减少重复计算）

// 初始化：注意str字符串是从1开始的，scanf("%s", str + 1)
p[0] = 1;
for (int i = 1; i <= n; i ++) {
  h[i] = h[i - 1] * P + str[i];
  p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r) {
  return h[r] - h[l - 1] * p[r - l + 1];
}
```

## 总结

### 核心思想

将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低

### 小技巧

取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果