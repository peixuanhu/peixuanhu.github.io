---
title: 算法模板4-1.DP-背包问题
categories:
  - [Algorithm, Template]
---

# 背包问题

# 通用问题描述

给定 `N` 个物品和容量是为 `V` 的背包。每一个物品 `i` 有两个属性：体积 `vi` 和价值 `wi` 。

求：在 `总体积<=V`的情况下，选出一些物品，它们的`最大价值之和`是多少。

## 01背包问题

### 问题描述

给定 `N` 个物品和容量是为 `V` 的背包。每一个物品 `i` 有两个属性：体积 `vi` 和价值 `wi` 。

求：在 `总体积<=V`的情况下，选出一些物品，它们的`最大价值之和`是多少。

**每件物品只能用一次或者不用。**

### 状态分析

#### 状态表示

`f(i, j)`

##### 集合

所有选法的集合。

满足条件：

1. 只从前 `i` 个物品中选
2. 选出来的物品的 `总体积 <= j`

##### 属性

`f(i, j)` 表示所有选法集合里的价值的最大值。

#### 状态计算

集合划分：`f(i, j)` 分成不含 `i` （一定存在）和含 `i`（不一定存在，只有j >= vi才存在） 两种情况的集合。

得出状态转移方程：

`f(i, j) = max(f(i - 1, j), f(i - 1, j - vi) + wi)`

### 代码

#### 朴素：二维

```cpp
int n, m; // n: N, m: V
int v[N], w[N];
int f[N][N];

for (int i = 1; i <= n; i ++)
  for (int j = 0; j <= m; j ++)
  {
    f[i][j] = f[i - 1][j]; // 不含i，一定存在
    if (j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); // 含i，需要判断条件
  }

cout << f[n][m] << endl;
```

#### 优化：一维

思路：

由于 `f[i]` 这一层只需要用到 `f[i - 1]` 层，所以可以优化成两层的滚动数组。

又两种情况：j和j-v[i]都是小于等于j的，说明不会同时用到当前列两边的数据，所以可以进一步优化成一层数组，即优化成一维数组。

需要注意：由于j-v[i]在j的左边，需要保证第i-1层循环中的`f[j - v[i]]`在被用到的时候没有被第i层更新过，所以内层循环j应从大到小枚举。

```cpp
for (int i = 1; i <= n; i ++)
  for (int j = m; j >= v[i]; j --)
  {
    f[j] = max(f[j], f[j - v[i]] + w[i]);
  }
```



## 完全背包问题

### 问题描述

给定 `N` 个物品和容量是为 `V` 的背包。每一个物品 `i` 有两个属性：体积 `vi` 和价值 `wi` 。

求：在 `总体积<=V`的情况下，选出一些物品，它们的`最大价值之和`是多少。

**每件物品有无限个。**

### 状态分析

#### 状态表示

`f(i, j)`

##### 集合

所有选法的集合。

满足条件：

1. 只从前 `i` 个物品中选
2. 选出来的物品的 `总体积 <= j`

##### 属性

`f(i, j)` 表示所有选法集合里的价值的最大值。

#### 状态计算

集合划分：`f(i, j)` 分成含`0~k` 个 `i` 的集合，其中`k`满足`j >= k*v[i]`。

得出状态转移方程：

`f(i, j) = max(f(i - 1, j), f(i - 1, j - k * vi) + k * wi), j >= k*v[i]`

### 代码

#### 朴素：二维，三重循环

```cpp
int n, m; // n: N, m: V
int v[N], w[N];
int f[N][N];

for (int i = 1; i <= n; i ++)
  for (int j = 0; j <= m; j ++)
    for (int k = 0; k * v[i] <= j; k ++)
      f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
```

#### 优化：一维，两重循环

```
f[i, j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2v] + 2w, f[i - 1][j - 3v] + 3w, ...)
=>f[i, j - v] = max(f[i - 1][j - v], f[i - 1][j - 2v] + w, f[i - 1][j - 3v] + 2w, ...)
可以推出：
f[i, j] = max(f[i - 1][j], f[i, j - v] + w)
```

`f[i, j - v]`用的是第`i`层的`f[j - v[i]]` 所以内层循环j从小到大枚举，这样`f[j - v[i]]` 刚好是被第`i`层更新过的。

```cpp
for (int i = 1; i <= n; i ++)
  for (int j = v[i]; j <= m; j ++)
      f[i][j] = max(f[j], f[j - v[i]] + w[i]);
```



## 多重背包问题

### 问题描述

给定 `N` 个物品和容量是为 `V` 的背包。每一个物品 `i` 有两个属性：体积 `vi` 和价值 `wi` 。

求：在 `总体积<=V`的情况下，选出一些物品，它们的`最大价值之和`是多少。

**每件物品有 `si` 个。**

### 状态分析

#### 状态表示

`f(i, j)`

##### 集合

所有选法的集合。

满足条件：

1. 只从前 `i` 个物品中选
2. 选出来的物品的 `总体积 <= j`

##### 属性

`f(i, j)` 表示所有选法集合里的价值的最大值。

#### 状态计算

集合划分：`f(i, j)` 分成含`0~s[i]` 个 `i` 的集合。

得出状态转移方程（和完全背包类似，只是k变成了s[i]）：

`f(i, j) = max(f(i - 1, j - k * vi) + k * wi), k=0, 1, ..., si`

### 代码

#### 朴素

时间复杂度：`N * V * S`

```cpp
for (int i = 1; i <= n; i ++)
  for (int j = 0; j <= m; j ++)
    for (int k = 0; k <= s[i] && k * v[i] <= j; k ++)
      f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
```



#### 优化：二进制优化

能不能像完全背包一样优化呢？

不能，它们是有区别的。

```cpp
// 完全背包
f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2v] + 2w, f[i - 1][j - 3v] + 3w, ...)
=>f[i][j - v] = max(f[i - 1][j - v], f[i - 1][j - 2v] + w, f[i - 1][j - 3v] + 2w, ...)
// 两个省略号是完全可以对齐的，因为只要满足第二维下标j-kv>=0即可
可以推出：
f[i][j] = max(f[i - 1][j], f[i][j - v] + w)
  
// 多重背包
f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2v] + 2w, f[i - 1][j - 3v] + 3w, ..., f[i - 1][j - sv] + sw)
=>f[i][j - v] = max(f[i - 1][j - v], f[i - 1][j - 2v] + w, f[i - 1][j - 3v] + 2w, ..., f[i - 1][j - (s+1)v] + sw)
// 两个省略号不一定是完全可以对齐的，因为有可能j-(s+1)v>=0，那么j-sv>=0也成立，但没有(s+1)那么多个物品，相当于提前结束了，此时第一个等式中没有一项与f[i - 1][j-(s+1)v]对齐
// 无法通过第二个等式来得出第一个等式中f[i][j]的最大值
```



优化方式：**二进制优化**，看成若干个01背包问题

时间复杂度：`N * V * logS`

对于一个一般的s（即物品个数），把它分成若干个组，其中前k+1组中第i组中有`2^i`个物品（`i=0~k`），最后一组中有`c`个物品（`c=(s-前k+1组中物品之和) && c < 2^(k+1)`），这样通过选或不选各个组，可以拼凑出取`0～s` 个物品的情况。

```cpp
const int N = n * logs, M = v;
int v[N], w[N];
int f[N];

// 预处理物品
cin >> n >> m;
int cnt = 0;
for (int i = 1; i <= n; i ++)
{
  int a, b, s; // 分别为当前物品的体积，价值和个数
  cin >> a >> b >> s;
  int k = 1;
  while (k <= s)
  {
    cnt ++;
    v[cnt] = a * k;
    w[cnt] = b * k;
    s -= k;
    k <<= 1;
  }
  if (s > 0) // 还剩下c个物品
  {
    cnt ++;
    v[cnt] = a * s;
    w[cnt] = b * s;
  }
}

// 转化成01背包求解
for (int i = 1; i < cnt; i ++)
  for (int j = m; j >= v[i]; j --)
    f[j] = max(f[j], f[j - v[i]] + w[i]);

cout << f[m] << endl;
```



## 分组背包问题

### 问题描述

给定 `N` 组物品和容量是为 `V` 的背包，每组物品里有若干件物品。每一个物品 `i` 有两个属性：体积 `vi` 和价值 `wi` 。

求：在 `总体积<=V`的情况下，选出一些物品，它们的`最大价值之和`是多少。

**每组物品中只能选1件。**

### 状态分析

#### 状态表示

`f(i, j)`

##### 集合

所有选法的集合。

满足条件：

1. 只从前 `i` 组物品中选
2. 选出来的物品的 `总体积 <= j`

##### 属性

`f(i, j)` 表示所有选法集合里的价值的最大值。

#### 状态计算

集合划分：`f(i, j)` 枚举：选第`i`组物品中的哪一个或者不选。

状态转移方程：`f(i, j) = max(f(i - 1, j), f(i - 1, j - v[i][k]) + w[i][k])`

### 代码

```cpp
for (int i = 1; i <= n; i ++)
  for (int j = m; j >= 0; j --) // 这里 j >= 0 而不是 j >= v[i] 是因为一组有多种物品，无法确定一个v[i]，放到循环内部去判断了
    for (int k = 0; k < s[i]; k ++) // s[i]为该组物品个数
      if (j >= v[i][k]) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
```

