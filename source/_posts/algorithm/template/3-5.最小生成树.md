---
title: 算法模板3-5.最小生成树
categories:
  - [Algorithm, Template]
---

# 最小生成树

定义：一个**连通加权无向图**中，一棵没有环的、权值最小的生成树。

注：权重的正负对最小生成树问题没有影响。

>应用举例：已知若干个城市的坐标，要在城市间铺设公路，使得各个城市能够连通，且公路长度最小。

## Prim算法

> 和Dijkstra算法的形式非常类似。

### 朴素版Prim算法

时间复杂度：`O(n^2 + m)` ，适合稠密图

#### 步骤

```cpp
集合S: 存储当前已经在连通块中的所有点
    
dist[i] <- +INF
    
for (i: 0~n)
  t <- 不在S中的距离S最近的点
  用t更新其他点到**集合S**的距离，即所有连向集合S的边中权重最小的边 // 注意：Dijkstra中是到起点的距离
  st[t] = true
```

#### 代码模板

```cpp
const int INF = 0x3f3f3f3f;

int n;
int g[N][N]; // 稠密图，用邻接矩阵存边权
int dist[N]; // 存储其他点到集合S中的距离
bool st[N]; // 记录每个点是否在S中

// 如果图不连通，则返回INF；否则返回最小生成树的边权之和
int prim()
{
	memset(dist, 0x3f, sizeof dist);
    
  int res = 0;
  for (int i = 0; i < n; i ++)
  {
    // 找到不在S中的距离S最近的点
    int t = -1;
    for (int j = 1; j <= n; j ++)
      if (!st[j] && (t == -1 || dist[j] < dist[t])) t = j;

    if (i && dist[t] == INF) return INF; // 表示图不连通

    if (i) res += dist[t]; // 从第二个点开始累加边权。注意这一步要写在更新距离前，以防负自环把自己的dist更新了

    st[t] = true; // 把该点加入S

    for (int j = 1; j <= n; j ++) dist[j] = min(dist[j], g[t][j]); // 更新其他点到S的距离
  }

  return res;
}
```



### 堆优化版Prim算法（略）

时间复杂度：`O(mlogn)` ，适合稀疏图

稀疏图一般用Kruskal算法，堆优化Prim算法不常用，因为Kruskal代码短很多，思路也更清晰。

## Kruskal算法

时间复杂度：`O(mlogm)`（瓶颈是对边做排序的步骤），适合稀疏图

### 步骤

```cpp
集合S：存储最小生成树中的边

// O(mlogm)
1. 将所有边按权重从小到大排序

// O(m), 因为并查集是O(1)的，一共m条边
2. 枚举每条边a-b，权重c
  if a,b不连通
    将这条边加入集合S中 // 并查集的应用
```

### 代码模板

```cpp
int n, m;
int p[N]; // 并查集中父节点数组

struct Edge // 由于只需要枚举所有边，可以用结构体来存储所有边
{
  int a, b, w;
  
  bool operator< (const Edge &W)const
  {
    return w < W.w;
  }
}edges[M];

int find(int x) // 并查集
{
  if (p[x] != x) p[x] = find(p[x]);
  return p[x];
}

int kruskal()
{
  sort(edges, edges + m);
  
  for (int i = 1; i <= n; i ++) p[i] = i;
  
  int res = 0, cnt = 0; // res是最小生成树中的边权之和，cnt是最小生成树中的边的数量
  for (int i = 0; i < m; i ++)
  {
    int a = edges[i].a, b = edges[i].b, w = edges[i].w;
    
    a = find(a), b = find(b); // 查找a和b所在的连通块
    if (a != b) // 如果两个连通块不连通，则合并两个连通块
    {
      p[a] = b;
      res += w;
      cnt ++;
    }
    
    if (cnt < n - 1) return INF;
    return res;
  }
}
```

