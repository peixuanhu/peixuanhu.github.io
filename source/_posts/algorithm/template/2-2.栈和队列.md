---
title: 算法模板2-2.栈和队列
categories:
  - [Algorithm, Template]
---

# 栈

LIFO

## 代码模板

```cpp
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[++ tt] = x;

// 从栈顶弹出一个数
tt --;

// 获得栈顶的值
stk[tt];

// 判断栈是否为空，如果 tt > 0，则表示不为空
if (tt > 0) {
    ...
}
```



# 队列

FIFO

## 普通队列

### 代码模板

```cpp
// hh 表示队头， tt 表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[++ tt] = x;

// 从队头弹出一个数
hh ++;

// 队头的值
q[hh];

// 判断队列是否为空，如果 hh <= tt，则表示不为空
if (hh <= tt) {
    ...
}
```



## 循环队列

### 代码模板

```cpp
// hh 表示队头，tt 表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空，如果hh != tt，则表示不为空
if (hh != tt) {
    ...
}
```

# 单调栈

## 代码模板

```cpp
int tt = 0;
for (int i = 1; i <= n; i ++) {
    while (tt && check(stk[tt], a[i])) tt --; // 栈不空且栈顶元素满足某种性质时，一直弹出栈顶元素
    stk[++ tt] = a[i]; // 当前元素压入栈中
}
```

## 常见模型

找出每个数左边离它最近的比它大/小的数

### 思路

先想出暴力思路，再观察有没有单调性

#### 暴力

两重循环 `O(n^2)`

```cpp
for (int i = 0; i < n; i ++)
    for (int j = i - 1; j >= 0; j --)
        if (a[j] < a[i]) {
            cout << a[j] << endl;
            break;
        }
```

#### 单调栈

**性质**：如果 `a[x] >= a[y] && x < y`，那么 `a[x]` 一定不会被 `y` 及 `y` 后面的元素用到，它可以被删掉

一重循环 `O(n)`，每个元素最多入栈一次、出栈一次

```cpp
for (int i = 0; i < n; i ++) {
    // 弹出不符合条件的元素
    while (tt && stk[tt] >= a[i]) tt --;
    // 输出结果
    if (tt) cout << stk[tt] << endl;
    else cout << -1 << endl;
    // 新元素入栈
    stk[++ tt] = a[i];
}
```



# 单调队列

## 代码模板

```cpp
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++) {
    while (hh <= tt && check_out(q[hh])) hh ++; // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt --;
    q[++ tt] = i; // 注意：此处队列里存的是下标，不是值
}
```

## 常见模型

找出滑动窗口中的最大值/最小值

### 思路

#### 暴力

从头到尾遍历元素，维护滑动窗口，每次遍历窗口内的所有元素找出最小值

时间复杂度 `O(nk)`，`k` 为窗口大小

#### 单调队列（双端队列）

时间复杂度 `O(n)`

**性质**：如果 `a[x] >= a[y] && x < y`，那么 `a[x]` 一定不会被用到，可以从队尾移除

额外维护一个严格单调递增的单调队列，取最小值时从队头取即可（记得判断队头元素是否已经在当前维护的滑动窗口之前了）

注意：队列里存的是下标，不是值

```cpp
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++) {
    while (hh <= tt && q[hh] < i - k + 1) hh ++; // 把滑动窗口之外的元素出队
    while (hh <= tt && a[q[tt]] >= a[i]) tt --; // 把队尾比a[i]大或相等的元素出队

    q[++ tt] = i; // 当前元素入队

    if (i >= k - 1) printf("%d ", a[q[hh]]); // 窗口完全进来了，输出队头元素（此时元素一定在滑动窗口范围内）
}
puts("");
```

