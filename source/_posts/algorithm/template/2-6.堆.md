---
title: 算法模板2-6.堆
categories:
  - [Algorithm, Template]
---

# 堆

## 性质

以小根堆为例：

堆中的每一个点都是小于等于左右儿子的。

所以根节点就是整个堆的最小值。

## 支持的操作

1. 插入一个数

   `heap[++ size] = x; up(size);`

2. 求集合当中的最小值

   `heap[1]`

3. 删除最小值

   用整个堆的最后一个元素覆盖堆顶元素：

   `heap[1] = heap[size --]; down(1);`

4. 删除任意一个元素

   与删除最小值类似，用最后一个元素覆盖下标为k的元素：

   `heap[k] = heap[size --]; up(k); down(k);`

   理论上是需要判断heap[k]的值变大还是变小再决定是up还是down。为了方便，可以直接up和down一遍

5. 修改任意一个元素

   `heap[k] = x; up(k); down(k);`

其中，插入和删除元素都是 `O(logn)` 的，求最小值是 `O(1)` 的。

> 后两种是手写堆特有的操作，STL无法直接实现。

以上所有操作都可以由两个操作组合实现：

### down

`down(x)`: 把下标为x的节点的值变大了

递归：与左右儿子相比，和最小的那个交换位置

### up

`up(x)`: 把下标为x的节点的值变小了

递归：与父节点相比，如果比父节点小，则交换位置

## 结构

堆是一个完全二叉树。

## 存储方式

用一个一位数组来存。下标为x的元素的左儿子下标是2x，右儿子的下标是2x + 1。

注：下标从1开始 

## 代码模板

带映射数组版本的模板：

```cpp
// h[N]存储堆中的值，h[1]是堆顶，x的左儿子是2x，右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置，p是下标，h是堆，ph的意思是插入顺序的下标映射到堆
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b) {
  swap(ph[hp[a]], ph[hp[b]]);
  swap(hp[a], hp[b]);
  swap(h[a], h[b]);
}

void down(int u) {
  int t = u;
  // t设为u及其左右儿子里值最小的那一个
  if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
  if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
  if (u != t) {
    heap_swap(u, t);
    down(t);
  }
}

void up(int u) {
  while (u / 2 && h[u] < h[u / 2]) {
    heap_swap(u, u / 2);
    u >>= 1;
  }
}

// O(n)建堆
for (int i = n / 2; i; i --) down(i);
```

## 应用

### 堆排序

先把数组建成堆，再依次输出堆顶元素

时间复杂度： `O(nlogn)`。

#### 建堆

如果一个一个元素插入，时间复杂度是 `O(nlogn)` 的。

`O(n)` 的建堆方式：

```cpp
for (int i = n / 2; i; i --) down(i);
```

从 n/2 开始往上的所有元素 down，其实就是从树的倒数第二层开始down。

时间复杂度证明：

```
n/4 * 1 + n/8 * 2 + n/16 * 3 + ...
= n (1/2^2 + 2/2^3 + 3/2^4 + ...)

S = 1/2^2 + 2/2^3 + 3/2^4 + ...
2S = 1/2 + 2/2^2 + 3/2^3 + ...
2S - S = S = 1/2 + 1/2^2 + 1/2^3 + ... < 1
```

### Dijkstra堆优化

需要用到hp, ph映射数组
