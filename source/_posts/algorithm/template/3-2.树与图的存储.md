---
title: 算法模板3-2.树与图的存储
categories:
  - [Algorithm, Template]
---

# 树和图的存储

树是一种特殊的图：无环连通图。与图的存储方式相同。

对于无向图中的边ab，存储两条有向边a->b, b->a。

因此我们可以只考虑有向图的存储。

## 存储方法一：邻接矩阵

```
g[a][b] 存储边a->b的权重(int)/有无(bool)
```

邻接矩阵不能存重边，不过一般存最短的就行。

## 存储方法二：邻接表

```cpp
const int N = 100010, M = N * 2; // N：点的数量，M：边的数量

// h[]对应点：对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头节点
// w[], e[], ne[]对应边：它们的下标都是边的编号，w[]值是边的权重，e[]值是指向的节点；ne[]存储某个节点的出边链表中，某条边的下一条边的编号
int h[N], w[M], e[M], ne[M], idx;

// 添加一条边a->b
void add(int a, int b) {
  e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h); // 让n个头节点都指向-1
```

