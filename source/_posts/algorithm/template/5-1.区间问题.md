---
title: 算法模板5-1.贪心-区间问题
categories:
  - [Algorithm, Template]
---

# 区间问题

## 思路

考虑按照左端点/右端点排序。

## 模板题

### 1. 区间选点

#### 算法

1. 将所有区间按右端点从小到大排序
2. 枚举每个区间
   1. 如果区间不包含当前点x，取区间右端点作为x
   2. 如果区间包含当前点x，跳过该区间

#### 证明

> 证明技巧：要证A=B, 可以证A>=B && A<=B

设点数最小值为`ans`，上述算法得出的值为`cnt`。

- 证`ans <= cnt`：`cnt`个点一定覆盖了所有区间，所以是一种合法方案，而`ans`是合法方案里的最小值。
- 证`ans >= cnt`：上述算法等价于将取点范围从所有区间缩小为了没有交集的`cnt`个区间，覆盖这`cnt`个区间至少要`cnt`个点。

#### 代码

```cpp
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1e5 + 10;
int n;

struct Range
{
    int l, r;
    
    bool operator<(const Range &W)const
    {
        return r < W.r;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    
    for (int i = 0; i < n; i ++)
    {
        int l, r;
        scanf("%d%d", &l, &r);
        range[i] = {l, r};
    }
    
    sort(range, range + n);
    
    int res = 0, ed = -2e9;
    for (int i = 0; i < n; i ++)
    {
        if (range[i].l <= ed && range[i].r >= ed) continue;
        ed = range[i].r; res ++;
    }
    
    printf("%d\n", res);
    
    return 0;
}
```

注：也可以自定义比较函数

```cpp
bool cmp(Range a,Range b){
    return a.r<b.r;
}
sort(range,range+n,cmp);
```

### 2. 最大不相交区间数量

选最多不相交的区间和上一题选最少的点等价。

#### 证明

设区间数最大值为`ans`，算法得出的值为`cnt`。

- 证`ans >= cnt`：上述算法等价于将取点范围从所有区间缩小为了没有交集的`cnt`个区间，所以是一种合法方案。
- 证`ans <= cnt`：反证，假设`ans > cnt`，即有`ans`个不相交的区间，那么至少需要`ans`个点才可以覆盖所有区间，但事实上`cnt`个点一定覆盖了所有区间，所以矛盾。

### 3. 区间分组

#### 算法

1. 将所有区间按左端点从小到大排序

2. 从前往后处理每个区间

   `L[i] > max_r`: 判断能否将其放到某个现有的组中：组中最大的右端点是否在当前区间左端点的左侧

   1. 是：将区间放入该组，更新当前组的max_r
   2. 否：创建一个新组，将其放进去

   > 为什么可以直接放入max_r最小的组，而不是max_r离当前区间左端点最近但不相交的组？
   >
   > 因为所有区间按左端点排序过了，下一个区间必定与上一个区间相交，或完全在其右侧，不可能完全在其左侧

#### 证明

设分组数最小值为`ans`，算法得出的分组数为`cnt`。

- 证`ans <= cnt`：上述算法能够将区间放到`cnt`个组中，且组中所有区间没有交集，所以是一种合法方案。
- 证`ans >= cnt`：既然开了新组，就说明存在一个点，每个组都能找到一个区间使得这个点在区间内（感觉不一定，因为算法只根据组内区间右端点的最大值来判断，有可能这个点在两个区间中间的空隙里），所以至少要有`cnt`个组保证这`cnt`个区间不重合。

#### 代码

```cpp
#include<iostream>
#include<queue>
#include<algorithm>

using namespace std;

const int N = 100010;

int n;

struct Range
{
    int l, r;
    bool operator<(const Range &W)const
    {
        return l < W.l;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    
    for (int i = 0; i < n; i ++) scanf("%d%d", &range[i].l, &range[i].r);
    
    sort(range, range + n);
    
    priority_queue<int, vector<int>, greater<int>> heap;
    
    for (int i = 0; i < n; i ++)
    {
        if (heap.empty() || heap.top() >= range[i].l) heap.push(range[i].r);
        else // 更新右端点最大值最小的组中右端点的最大值
        {
            heap.pop();
            heap.push(range[i].r);
        }
    }
    
    printf("%d\n", heap.size());
    
    return 0;
}
```

### 4. 区间覆盖

#### 算法

假设区间从start到end

1. 将所有区间按左端点从小到大排序
2. 从前往后依次枚举每个区间，在所有能覆盖start的区间中，选择右端点最大的区间，然后将start更新成右端点的最大值

#### 证明

设区间数最小值为`ans`，算法得出的区间数为`cnt`。

把最优解和算法的解的区间从小到大枚举，找到第一个不同的区间：因为算法选择的是右端点的最大值，所以可以把最优解的该区间替换成算法的区间（不亏，只会让右端点更长），以此类推，最终最优解可以转化成上述算法的解。

> 感觉和没证一样...

#### 代码

```cpp
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 100010;
int st, ed, n;

struct Range
{
    int l, r;
    bool operator<(const Range &W)const
    {
        return l < W.l;
    }
}range[N];

int main()
{
    scanf("%d%d%d", &st, &ed, &n);
    for (int i = 0; i < n; i ++) scanf("%d%d", &range[i].l, &range[i].r);
    
    sort(range, range + n);
    
    int res = 0;
    bool success = false;
    for (int i = 0; i < n; i ++)
    {
        int j = i, r = -2e9;
        while (j < n && range[j].l <= st)
        {
            r = max(r, range[j].r);
            j ++;
        }
        
        if (r < st) break; // 失败
        
        res ++;
        if (r >= ed)
        {
            success = true;
            break;
        }
        st = r, i = j - 1; // 因为i还要++的
    }
    
    if (success) printf("%d\n", res);
    else printf("-1\n");
    
    return 0;
}
```

