---
title: 算法模板6-1.数学-数论
categories:
  - [Algorithm, Template]
---

# 质数

## 定义

对所有大于1的整数，如果只包含`1和本身`这两个约数，就被称为质数，或者叫素数。

> 所有<=1的数，既不是质数也不是合数

## 判定：试除法

### 朴素做法

时间复杂度$O(n)$

```cpp
bool is_prime(int n)
{
    if (n < 2) return false;
    
    for (int i = 2; i < n; i ++)
        if (n % i == 0) return false;
    
    return true;
}
```

### 优化做法

利用性质：如果 $d\ |\ n$，那么也一定有 $\frac{n}{d}\ |\ n$。

> $d\ |\ n$ 表示d能被n整除，即n是d的约数。

所以对于每个$d$，只要枚举到 $d <= \frac{n}{d}$ 即可，即 $d^2 <= n$， 时间复杂度一定为 $O(\sqrt{n})$。

```cpp
bool is_prime(int n)
{
    if (n < 2) return false;
    
    for (int i = 2; i <= n / i; i ++)
        if (n % i == 0) return false;
    
    return true;
}
```

## 分解质因数：试除法

### 朴素做法

从小到大枚举所有可能的质因数，时间复杂度$O(n)$。

```cpp
void divide(int x)
{
    for (int i = 2; i < x; i ++)
        if (x % i == 0) // i一定是质数
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++;
            cout << i << ' ' << s << endl;
        }
    puts("");
}
```

### 优化做法

性质：n中最多只包含一个大于 $\sqrt{n}$ 的质因子。

所以枚举到 $\sqrt{n}$ 即可，时间复杂度最坏为 $O(\sqrt{n})$，因为n在枚举过程中在不断变小，最好时间复杂度仅为 $O(logn)$。

```cpp
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++)
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl; // 单独处理可能大于sqrt(n)的那个质因子
    puts("");
}
```

## 筛质数

### 朴素做法

从小到大枚举，把每个数所有的倍数删掉。如遍历到2，删除4，6，8，10，12。

时间复杂度：$O(nlogn)$

> 总运算次数：
>
> $\lim_{n\to INF}\frac{n}{2} + \frac{n}{3} + ... + \frac{n}{n}$
>
> $=\lim_{n\to INF} n (\frac{1}{2} + \frac{1}{3} + ... + \frac{1}{n})$
>
> $=n\ln(n)$

```cpp
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++)
    {
        if (!st[i])
        {
            prime[cnt ++] = i;
        }
        for (int j = i + i; j <= n; j += i) st[j] = true;
    }
}
```

### 优化做法：埃式筛法

只需要把质数的倍数筛掉即可。当一个数不是质数时，它的倍数一定已经被筛过了。

#### 时间复杂度分析：

质数定理：1~n中有$\frac{n}{ln(n)}$个质数

时间复杂度估计：$O(\frac{n}{ln(n)}\ ln(n)) = O(n)$。

> 实际上是$O(nloglogn)$，不过loglogn很接近常数。

#### 代码

```cpp
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++)
    {
        if (!st[i])
        {
            prime[cnt ++] = i;
            for (int j = i + i; j <= n; j += i) st[j] = true;
        }
    }
}
```

### 优化做法：线性筛法（实际使用）

时间复杂度$O(n)$。

当枚举到`i`时，把`已经筛出来的所有质数与i的乘积`筛出去。

核心思路：每个合数`x`只会被它的最小质因子筛掉。每个数只有一个最小质因子，所以每个数只会被筛一次，所以算法是线性的。

> 1. i % pj == 0 => pj一定是i的最小质因子，故pj一定是pj * i的最小质因子
> 2. i % pj != 0 => pj一定小于i的所有质因子（因为pj从小到大枚举，还没break），故pj也一定是pj * i的最小质因子

所有的合数都一定会被筛掉：

因为对于一个合数x，假设pj是x的最小质因子，i一定先枚举到x / pj，这个时候x已经被筛掉了。

```cpp
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++)
    {
        if (!st[i]) prime[cnt ++] = i;
      	for (int j = 0; prime[j] <= n / i; j ++) // 不用写j < cnt，因为当i为合数的时候，prime[j]枚举到i的最小质因子时就会停下来；当i为质数的时候，枚举到prime[j]=i时也会停下来
        {
          	st[prime[j] * i] = true;
          	if (i % prime[j] == 0) break; // 保证prime[j]一定是i的最小质因子
        }
    }
}
```



# 约数