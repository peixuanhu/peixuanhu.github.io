---
title: 算法模板3-1.DFS和BFS
categories:
  - [Algorithm, Template]
---

# 深度优先遍历 (DFS)

一条路走到底，无路可走了之后往回退**一步**，继续找一条其他的路一直往下走。

形势一般为递归。

## 概念

### 回溯

走到底了，返回的过程叫做回溯。

回来的时候要**恢复现场**。

```cpp
// 恢复现场的代码与修改状态的代码一般是对称的，例：
path[u] = i;
st[i] = true;
dfs(u + 1); // 下一层递归返回之后恢复
st[i] = false;
path[u] = 0;
```



### 剪枝

剪枝可以提高效率。

#### 可行性剪枝

在搜索的过程中判断，如果这个节点不合法，那么它的子树上的所有节点也都不合法，直接停止搜索。

#### 最优性剪枝

当前路径一定不如最优解，停止搜索。

## 要点

递归结束条件的选择+状态标记+递归后的恢复

### 顺序

## 例题

### 字典序输出

每一种输出都是一个叶子节点，第x位的遍历对应第x层的节点。整个搜索过程就是一棵搜索树（当然不需要自己存这棵树，系统栈会帮我们做这件事）。

path数组下标为当前遍历到的位数，存储的值为这一位填的数字。

### n-皇后

#### 进阶解法 - 以**行**作为一层来搜索

col数组记录该列是否有皇后。

额外开两个数组存储对角线和反对角线上是否有皇后，如果有代表不合法，剪枝。

对角线数组的长度是 `2n - 1`。

判断一个点在哪一条对角线/反对角线上：用截距。

```
x, y分别是行号和列号，b为对角线号。

y=x+b/ -> b=y-x+n (+n是因为数组下标要为正数)

y=-x+b -> b=y+x
```

时间复杂度：`O(n*n!)`

#### 原始解法 - 以**格子**作为一层来搜索

每一层dfs都往下拓展两种可能：一种是该格子放皇后；一种是该格子不放皇后。

> row数组记录该行是否有皇后。
>
> col数组记录该列是否有皇后。
>
> 额外开两个数组存储对角线和反对角线上是否有皇后，如果有代表不合法，剪枝。

时间复杂度：`O(2^(n^2))`

# 宽度优先遍历 (BFS)

一层一层遍历，某一层全部遍历完，再遍历该层第一个节点的第一个子节点，以此类推。

形势一般为迭代。

## 框架

```
模拟队列 q[N], d[N] 使用d数组标记状态

queue <- 初始状态
while queue不空
{
	t <- 队头
	拓展t
}
```

## 往上下左右四个方向拓展的小技巧

用向量数组

```cpp
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

for (int i = 0; i < 4; i ++)
  int x = a + dx[i], y = b + dy[i];
```

## 例题

### 走迷宫

以离起点距离为x的点为第x层

### 八数码

# 对比

| 算法 | 数据结构 | 空间复杂度 | 性质                   |
| ---- | -------- | ---------- | ---------------------- |
| DFS  | stack    | O(h)       |                        |
| BFS  | queue    | O(2^h^)    | 最短路（第一次搜到时） |

### 总结

DFS在空间上占优势；

但BFS具有“最短路”的性质（前提：边的权重为1）。
