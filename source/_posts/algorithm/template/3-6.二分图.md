---
title: 算法模板3-6.二分图
categories:
  - [Algorithm, Template]
---

# 二分图

通俗定义：一个图可以分成两个集合，每个集合内部没有边。

## 染色法 (DFS)

时间复杂度：`O(n + m)`

### 使用场景

判别一个图是否为二分图。

### 性质

一个图是二分图（等价于这个图可以被2染色），当且仅当图中不含奇数环。

#### 证明

- 必要性（二分图->不含奇数环）：反证法

  假设有奇数环：把环中每个点依次标记为1, 2, 1, 2, ... 标记到最后一个点的时候，应该为1。而它后一个点（也就是第一个点）也为1，矛盾。

- 充分性（不含奇数环->二分图）：

  先任意标记一个点为1，之后与它连通的所有点的数字都被确定。在不与它连通的点中，又任选一个点标记为1。

  由于图中不含奇数环，所以染色过程中一定没有矛盾。

  > 证明：反证法
  >
  > 如果染色过程中出现了矛盾，那么一定是1, 2, 1, 2, ..., 1, 1这种形式，最后两个1和1一定头尾相接（否则最后一个1可以被标记为2），那么环中点的数量一定为奇数，即图中一定含有奇数环

### 步骤

```cpp
for (i = 1; i <= n; i ++)
  if (i未被染色)
    dfs(i, 1) // 1表示染的颜色
    
// dfs过程
递归将所有相邻的点染成相反的颜色，并且判断能不能成功并返回
```

### 代码模板

```cpp
int n;
int h[N], e[M], ne[M], idx;
int color[N]; // 表示每个点的颜色，-1表示为染色，0表示白色，1表示黑色

// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
{
  color[u] = c;
  for (int i = h[u]; ~i; i = ne[i]) // 遍历所有相邻点
  {
    int j = e[i];
    if (color[j] == -1)
    {
      if (!dfs(j, !c)) return false; // 如果相邻点还没有染色，递归染色，传递的颜色是与当前点相反的颜色
    }
    else if (color[j] == c) return false;
  }
  
  return true;
}

bool check()
{
  memset(h, -1, sizeof h);
  memset(color, -1, sizeof color);
  
  for (int i = 1; i <= n; i ++)
    if (color[i] == -1)
      if (!dfs(i, 0)) return false;
  
  return true;
}
```



## 匈牙利算法

时间复杂度：理论最坏`O(mn)`，实际远小于 `O(mn)`（可能接近线性）

### 使用场景

求二分图的成功匹配的情况下，最大的匹配数量。

匹配：指的是边的数量。

匹配成功：不存在两条边共用一个点。

### 思路

```cpp
设左边集合为S1，右边集合为S2.
依次遍历S1中的每个点i，看能否匹配S2中的点：
  1. 如果有S2中的点没有被匹配，或者它匹配的S1中的点可以换一个点匹配，返回true
  2. 如果i指向的所有点都不能被匹配，返回false
```

### 代码模板

```cpp
int n1, n2; // n1表示S1中的点数，n2表示S2中的点数
int h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从S1指向S2的边
int match[N]; // 存储S2中的每一个点当前匹配的S1中的点是哪个
bool st[N]; // 表示S2中的每个点是否已经被遍历过

bool find(int x)
{
  for (int i = h[x]; ~i; i = ne[i]) // 遍历x结点指向S2集合的所有边
  {
    int j = e[i];
    if (!st[j])
    {
      st[j] = true;
      if (match[j] == 0 || find(match[j])) // S2中的j结点还没有被匹配，或者能够让j结点当前匹配的S1中的点换一个点匹配
      {
        match[j] = x;
        return true;
      }
    }
  }
  
  return false;
}

// 求最大匹配数量，依次枚举S1中的每一个点能否匹配S2中的点
int res = 0;
for (int i = 1; i <= n; i ++)
{
  memset(st, false, sizeof st); // 在枚举S1中每个点的时候都要把S2中所有点的状态置0，每个点都只需要考虑一次
  if (find(i)) res ++;
}
```

练习：372