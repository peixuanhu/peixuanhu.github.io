---
title: 算法模板2-1.链表
categories:
  - [Algorithm, Template]

---

# 实现方式

## 结构体+指针

```cpp
struct Node {
    int val;
    Node *next;
};

auto n = new Node(); // 非常慢
```

即动态链表。

一般面试中用得较多，笔试不常用，因为`new`操作效率低。

## 数组模拟（常用）

即静态链表。

### 单链表

主要用途：邻接表。

邻接表应用：存储树和图。

#### 实现

`e[N]`: 存储每个点的 `val`。`ne[N]`：存储每个点的 `next`。

```cpp
// head存储链表头，e[]存储结点的值，ne[]存储结点的next指针，idx表示当前用到了哪个结点
int head, e[N], ne[N], idx;

// 初始化
void init() {
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a (80%的情况都是插到头结点的位置)
void insert_to_head(int a) {
    e[idx] = a, ne[idx] = head, head = idx ++;
}

// 一般的插入操作：将a插入下标是k的结点后面
void insert(int k, int a) {
    e[idx] = a, ne[idx] = ne[k], ne[k] = idx ++;
}

// 将头结点删除，需要保证头结点存在
void remove_head() {
    head = ne[head];
}

// 一般的删除操作：将下标是k的点后面的点删掉
void remove(int k) {
    ne[k] = ne[ne[k]];
}
```



### 双链表

主要用途：优化某些问题。

#### 实现

让下标为0的点为`head`，下标为1的点为`tail`。

```cpp
// e[]表示结点的值，l[]表示结点的左指针，r[]表示结点的右指针，idx表示当前用到了哪个结点
int e[N], l[N], r[N], idx;

// 初始化
void init() {
    // 0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在结点k的右边插入一个数a
void insert(int k, int a) {
    e[idx] = a;
    l[idx] = k, r[idx] = r[k];
    l[r[k]] = idx, r[k] = idx;
    idx ++;
}
// 注：如果想在结点k的左边插入a，调用insert(l[k], a)即可

// 删除结点k
void remove(int k) {
    l[r[k]] = l[k];
    r[l[k]] = r[k];
}
```

