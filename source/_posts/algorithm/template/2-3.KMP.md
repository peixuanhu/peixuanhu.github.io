---
title: 算法模板2-3.KMP
categories:
  - [Algorithm, Template]
---

# KMP

## 使用场景

有两个字符串 `S` 和 `p`，其中 `S` 是原串（长），`p`是模板串（短）。

KMP用于字符串匹配：找到 `S` 中所有与 `p` 相同的子串，并返回每个子串开头字符的下标。

## 代码模板

```cpp
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度

// 求模式串的next数组
for (int i = 2, j = 0; i <= m; i ++) { // i从2开始的原因：ne[1]不用算，ne[1]=0，第一个字母失败了只能从头开始
  while (j && p[i] != p[j + 1]) j = ne[j];
  if (p[i] == p[j + 1]) j ++;
  ne[i] = j; // 记录当前i对应的ne[i]
}

// 匹配
for (int i = 1, j = 0; i <= n; i ++) {
  while (j && s[i] != p[j + 1]) j = ne[j]; // j没有回到第一个字符且s[i]和p[j + 1]不能匹配：一直往后移动p串使得p[j + 1]之前的子串是匹配的
  if (s[i] == p[j + 1]) j ++; // 如果匹配了，j往后移动
  if (j == m) { // 整个p串都匹配成功
    j = ne[j]; // j还得退一步（试了下如果不加也能ac，因为在下一次循环的while中如果不匹配的话，反正也会执行j=ne[j]的？）
    // 匹配成功之后的逻辑
  }
}
```

想不清楚的话拿个例子模拟一下：

```
s="abababc"
p="abababab"
```



## 思路

### 暴力算法

#### 时间复杂度 `O(n^2)`

```cpp
S[N], p[M]

vector<int> res;
  
for (int i = 1; i <= n; i ++) {
  bool flag = true;
  for (int j = 1; j <= m; j ++)
    if (S[i + j - 1] != p[j]) {
      flag = false;
      break;
    }
  if (flag) res.push_back(i);
}
```

### 优化

#### 时间复杂度 `O(n)`

分析：在 `i` 循环 `n` 次的过程中，每次循环 `j` 最多会+1，`j` 总共最多会+n，因此 `j=ne[j]` 再怎么减都最多减n

故总的时间复杂度是 `2n`，是 `O(n)` 的。

#### `next` 数组

对于模板串 `p` 中的每一个字符 `p[i]`，都进行一个预处理：求出一个最大长度 `x`，使得以 `p[i]` 为结尾的长度为 `x` 的子串和 `p` 开头的长度为 `x` 的子串相等。

`next[i] = j` 含义：`p[1, ..., j] = p[i - j + 1, ..., i]`

## 注意事项

模板中两个字符串的下标都是从1开始。

`p` 中每次和`S[i]` 匹配的是 `p[j + 1]`，可以理解为 `j` 比 `i` 往前错一位，每次都只是试探一下 `p[j+1]` 能不能和 `S[i]` 匹配。