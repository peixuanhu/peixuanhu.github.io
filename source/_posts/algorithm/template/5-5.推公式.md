---
title: 算法模板5-5.贪心-推公式
categories:
  - [Algorithm, Template]
---

# 推公式

## 模板题

### 耍杂技的牛

#### 算法

按照`wi+si`从小到大的顺序排，最大的危险系数一定是最小的

#### 证明

显然算法得出的答案 >= 最优解。

下面证明算法得出的答案 <= 最优解：

假设不是按照`wi+si`从小到大排序，那么从上到下，一定存在两头相邻的牛：`w[i] + s[i] > w[i + 1] + s[i + 1]`。交换这两头牛，不影响其他牛的危险系数。

- 对于第`i`头牛：危险系数从`w - s[i]`变成了`w + w[i + 1] - s[i]`

- 对于第`i+1`头牛：危险系数从`w + w[i] - s[i + 1]`变成了`w - s[i + 1]`

给每个数都加上`s[i] + s[i + 1] - w`：

- 对于第`i`头牛：危险系数从`s[i + 1]`变成了`w[i + 1] + s[i + 1]`

- 对于第`i+1`头牛：危险系数从`w[i] + s[i]`变成了`s[i]`

由于`w[i] + s[i] > w[i + 1] + s[i + 1]`，交换后的结果肯定会变小，所以可以调整为从小到大排序

#### 代码

```cpp
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 50010;
int n;

struct Cow {
    int w, s;
    bool operator<(const Cow &C)const
    {
        return w + s < C.w + C.s;
    }
}cow[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++) scanf("%d%d", &cow[i].w, &cow[i].s);
    
    sort(cow, cow + n);
    
    int res = -2e9, sum = 0;
    for (int i = 0; i < n; i ++)
    {
        res = max(res, sum - cow[i].s);
        sum += cow[i].w;
    }
    
    printf("%d\n", res);
    
    return 0;
}
```

