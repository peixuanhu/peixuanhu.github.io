---
title: 算法模板5-2.贪心-Huffman树
categories:
  - [Algorithm, Template]
---

# Huffman树

问题可以看作一颗完全二叉树。

Huffman树的总代价：对于每个叶子节点n，需要的代价是`n所处的层级*n的权重`，把它们求和

问题：如何排列所有叶子节点，使得总代价最小

解法：每次挑权重最小的两个节点合并。

可以证明：权重最小的两个点，在树中一定是最深的节点，且可以互为兄弟节点。

> 证明：
>
> 1. 如果最小节点深度不是最深，将其与最深的节点交换位置，代价一定减小；
> 2. 可以互为兄弟：在最深层可以任意交换位置。

## 模板题

### 1. 合并果子

> 和DP中的石子合并的区别：石子合并必须两堆石子相邻，果子没有这个限制。

Huffman树中所有叶子节点就是要合并的果子堆。

#### 代码

```cpp
#include<iostream>
#include<queue>

using namespace std;

const int N = 10010;
int n;

int main()
{
    scanf("%d", &n);
    
    priority_queue<int, vector<int>, greater<int>> heap;
    for (int i = 0; i < n; i ++)
    {
        int t;
        scanf("%d", &t);
        heap.push(t);
    }
    
    int res = 0;
    while (heap.size() > 1)
    {
        int a = heap.top(); heap.pop();
        int b = heap.top(); heap.pop();
        res += a + b;
        heap.push(a + b);
    }
    printf("%d\n", res);
    
    return 0;
}
```

