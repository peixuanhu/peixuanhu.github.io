---
title: 算法模板1-3.前缀和与差分模板
categories:
  - [Algorithm, Template]
---

# 前缀和

## 一维前缀和

### 问题

给定a数组，需要构造S数组，使得：`S[i] = a[1] + a[2] + ... a[i] (i = 1, 2, ...), S[0] = 0`

> 注：a数组下标从1开始，S[i]也从1算起，且S[0]必须赋值0（当l=1时会用到，S[l - 1] = S[0]）

### 如何构造 `S[i]` ?

从前往后推：

```cpp
for (int i = 1; i <= n; i ++)
    S[i] = S[i - 1] + a[i];
```

### 作用？

求a数组[l, r]的和 `a[l] + ... + a[r]`

- 如果没有S数组：时间复杂度`O(n)`，需要累加 `a[l] + a[l + 1] + ... + a[r]`；

- 有了S数组：时间复杂度 `O(1)`，直接 `S[r] - S[l - 1]`。

## 二维前缀和

```
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

### 如何构造 `S[i, j]` ?

二重循环：

```cpp
for (int i = 1; i <= n; i ++)
    for (int j = 1; j <= m; j ++)
	    S[i, j] = S[i - 1, j] + S[i, j - 1] - S[i - 1, j - 1] + a[i, j];
```

### 作用？

求a矩阵中：以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和

- 如果没有S矩阵：时间复杂度`O(n^2)`，需要二重循环累加；

- 有了S矩阵：时间复杂度 `O(1)`，直接 `S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]`。

# 差分

前缀和的逆运算

## 一维差分

### 问题？

给定a数组，需要构造b数组，使得：`a[i] = b[1] + b[2] + ... + b[i]`

> 满足上述条件的b数组称为a的差分

### 作用？

给a数组区间[l, r]中的每个数加上c

- 如果没有b数组：时间复杂度`O(n)`，需要遍历a数组
- 有了b数组：时间复杂度`O(1)`，`b[l] += c, b[r + 1] -= c`

```cpp
void insert(int l, int r, int c) {
    b[l] += c;
    b[r + 1] -= c;
}
```

### 如何构造 `b[i]` ?

首先假定a, b数组所有元素都是0，此时满足前缀和与差分关系。

然后其实a数组是有初始值的，这里等价于做n次操作：`给a数组区间[i, i]中的每个数都加上a[i]`，构造b数组：`b[i] += a[i], b[i + 1] -= a[i]` 即可

```cpp
for (int i = 1; i <= n; i ++)
    insert(i, i, a[i]);
```

### 最后用前缀和算法求操作后的a数组

做完若干+c操作后，用前缀和算法求最终答案

```cpp
for (int i = 1; i <= n; i ++) {
    b[i] += b[i - 1];
    printf("%d ", b[i]);
}
```



## 二维差分

```
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
b[x1, y1] += c, b[x2 + 1, y1] -= c, b[x1, y2 + 1] -= c, b[x2 + 1, y2 + 1] += c
```

### 问题？

给定a矩阵，需要构造b矩阵，使得：`a[i, j] = b矩阵第i行j列格子左上部分所有元素的和`

> 也就是构造b矩阵，使得a矩阵是b矩阵的前缀和

### 作用？

给a矩阵以(x1, y1)为左上角，(x2, y2)为右下角的的子矩阵中的每个数加上c

- 如果没有b矩阵：时间复杂度`O(n^2)`，需要遍历a矩阵
- 有了b矩阵：时间复杂度`O(1)`，`b[x1, y1] += c, b[x2 + 1, y1] -= c, b[x1, y2 + 1] -= c, b[x2 + 1, y2 + 1] += c`

```cpp
void insert(int x1, int y1, int x2, int y2, int c) {
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
```

### 如何构造 `b[i][j]` ?

与一维差分同理

其实具体构造不用管，就当作进行了n*m次修改操作即可

```cpp
for (int i = 1; i <= n; i ++)
    for (int j = 1; j <= m; j ++)
	    insert(i, j, i, j, a[i][j]);
```

### 最后用前缀和算法求操作后的a矩阵

做完若干+c操作后，用前缀和算法求最终答案

```cpp
for (int i = 1; i <= n; i ++) {
    for (int j = 1; j <= m; j ++) {
        b[i][j] += b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1];
		printf("%d ", b[i][j]);
    }
    puts("");
}
```

