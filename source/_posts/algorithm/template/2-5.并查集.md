---
title: 算法模板2-5.并查集
categories:
  - [Algorithm, Template]
---

# 并查集

## 支持的操作

在近乎 `O(1)` 的时间复杂度内支持以下两种操作：

1. 将两个集合合并
2. 询问两个元素是否在一个集合当中

注：有时也用于处理图论相关的问题。

## 基本原理

每个集合用一棵树来表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，`p[x]` 表示 `x` 的父节点。

## 思考

### 问题1: 如何判断树根？

```cpp
if (p[x] == x) 则为树根
```

### 问题2: 如何求x的集合编号？

```cpp
while (p[x] != x) x = p[x];
```

### 问题3: 如何合并两个集合？

```cpp
px是x的集合编号，py是y的集合编号
令p[px] = py即可
```

## 优化

### 1. 路径压缩

在 `find` 函数中通过 ` if (p[x] != x) p[x] = find(p[x]);` 实现把路径上所有点都直接指向祖宗节点

### 2. 按秩合并（待补充）

大致意思就是倾向于把短的树接到长的树上面

用得较少，一般不在代码中实现

## 代码模板

### 朴素并查集

```cpp
int p[N]; // 存储每个点的祖宗节点

// 返回x的祖宗节点
int find(int x) {
  if (p[x] != x) p[x] = find(p[x]); // 顺手做了路径压缩
  return p[x];
}

// 初始化，假定节点编号是1～n
for (int i = 0; i <= n; i ++) p[i] = i;

// 合并a和b所在的两个集合
p[find(a)] = find(b); // 让a的祖宗节点的父亲指向b的祖宗节点
```

### 维护size的并查集

```cpp
int p[N], size[N];
// p[]存储每个点的祖宗节点，size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

// 返回x的祖宗节点
int find(int x) {
  if (p[x] != x) p[x] = find(p[x]);
  return p[x];
}

// 初始化，假定节点编号是1～n
for (int i = 1; i <= n; i ++) {
  p[i] = i;
  size[i] = 1;
}

// 合并a和b所在的两个集合
size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```

### 维护到祖宗节点距离的并查集

例题：食物链

```cpp
int p[N], d[N];
// p[]存储每个点的祖宗节点，d[x]存储x到p[x]的距离

// 返回x的祖宗节点
int find(int x) {
  if (p[x] != x) {
    int u = find(p[x]);
    d[x] += d[p[x]];
    p[x] = u;
  }
  return p[x];
}

// 初始化，假定节点编号是1～n
for (int i = 0; i <= n; i ++) {
  p[i] = i;
  d[i] = 0;
}

// 合并a和b所在的两个集合
p[find(a)] = find(b); // 让a的祖宗节点的父亲指向b的祖宗节点
d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```

