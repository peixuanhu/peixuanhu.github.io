---
title: LeetCode15. 三数之和
categories:
  - [Algorithm, LeetCode]

---

# 来源

CodeTop字节高频题。

https://leetcode.cn/problems/3sum/description/

# 题目描述

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。



**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

 

**提示：**

- `3 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`

# 考察知识点

- 双指针

# 思路

- 时间复杂度：`O(n^2)`，i从头到尾：`O(n)`，对每个i：j和k加起来`O(n)`。
  - 暴力：`O(n^3)`

首先将数组排序（`O(nlogn)`）。使用双指针算法需要数组有序。

三个指针i, j, k，首先固定i，然后让j从i+1往后遍历。对于每个i, j：k从最后一个数往左移，直到找到最小的k，使得`nums[i] + nums[j] + nums[k] >= 0`。此时若三数之和为0，加入res。

去重方法：判断`i`和`i-1`、`j`和`j-1`(还得j不为第一个数即`j != i + 1`)下标对应的值是否相同，相同则代表这种情况已经考虑过了，直接continue。

### 自己写的非常不优雅的版本

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 1; i ++) {
            if (i && nums[i] == nums[i - 1]) continue; // 去除重复情况
            for (int j = i + 1, k = nums.size() - 1; j < k; j ++) {
                while (nums[j - 1] == nums[j] && i != j - 1 && j != k) j ++;
                while (j < k - 1 && nums[i] + nums[j] + nums[k - 1] >= 0) k --; // 获得当前i, j满足条件的k的最小坐标
                if (j != k && nums[i] + nums[j] + nums[k] == 0) res.push_back({nums[i], nums[j], nums[k]});
            }
        }

        return res;
    }
};
```

### 优雅版本

`while (nums[j - 1] == nums[j] && i != j - 1 && j != k) j ++;` 这一步可以用`continue`语句代替，之后的`j != k`也不需要判断了（只要在循环里没跳出，就一定满足`j < k`）。

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 1; i ++) {
            if (i && nums[i] == nums[i - 1]) continue; // 去除重复情况
            for (int j = i + 1, k = nums.size() - 1; j < k; j ++) {
                if (j > i + 1 && nums[j - 1] == nums[j]) continue; // 去除重复情况
                while (j < k - 1 && nums[i] + nums[j] + nums[k - 1] >= 0) k --; // 获得当前i, j满足条件的k的最小坐标
                if (nums[i] + nums[j] + nums[k] == 0) res.push_back({nums[i], nums[j], nums[k]});
            }
        }

        return res;
    }
};
```

