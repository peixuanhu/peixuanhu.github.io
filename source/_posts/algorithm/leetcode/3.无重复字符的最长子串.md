---
title: LeetCode3. 无重复字符的最长子串
categories:
  - [Algorithm, LeetCode]
---

# 来源

CodeTop字节高频题。

[https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

# 题目描述

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**提示：**

- `0 <= s.length <= 5 * 10^4`
- `s` 由英文字母、数字、符号和空格组成

# 考察知识点

- 哈希表
- 滑动窗口（双指针）

# 思路

## 原始思路

从头到尾遍历字符串s，hash存储每个字符最后出现的下标，p作为子串起始点，i为子串当前结束点。

i每次移动，更新对应字符下标。如果出现重复字符，将子串起点p更新到重复字符上一次出现位置的后一个位置（如果已经在它后面了就不动）。

i每次移动，都更新全局最大长度res。

代码：

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size(), res = 0;
        s = " " + s;
        unordered_map<char, int> hash;
        int p = 1;
        for (int i = 1; i <= n; i ++) {
            if (!hash[s[i]]) {
                hash[s[i]] = i;
            } else {
                // 将子串起点p更新到重复字符上一次出现位置的后一个位置（如果已经在它后面了就不动）
                p = max(p, hash[s[i]] + 1);
                hash[s[i]] = i;
            }
            res = max(res, i - p + 1);
        }
        return res;
    }
};
```

可以简写为：

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size(), res = 0;
        s = " " + s;
        unordered_map<char, int> hash;
        int p = 1;
        for (int i = 1; i <= n; i ++) {
            if (hash[s[i]]) p = max(p, hash[s[i]] + 1);
            hash[s[i]] = i;
            res = max(res, i - p + 1);
        }
        return res;
    }
};
```



## 另一种思路

i和j为子串右端点和左端点，hash存储每个字符在i和j之间出现的次数，如果出现次数大于1了，把左端点j往右移，直到该字符出现次数为1为止。

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size(), res = 0;
        unordered_map<char, int> hash;
        for (int i = 0, j = 0; i < n; i ++) {
            hash[s[i]] ++;
            while (hash[s[i]] > 1) hash[s[j ++]] --;
            res = max(res, i - j + 1);
        }
        return res;
    }
};
```

