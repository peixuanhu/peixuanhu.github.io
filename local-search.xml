<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Effective Java-19. Design and document for inheritance or else prohibit it</title>
    <link href="/2023/11/22/Java/effective-java/Item19-Design-and-document-for-inheritance-or-else-prohibit-it/"/>
    <url>/2023/11/22/Java/effective-java/Item19-Design-and-document-for-inheritance-or-else-prohibit-it/</url>
    
    <content type="html"><![CDATA[<h1 id="Item19-Design-and-document-for-inheritance-or-else-prohibit-it"><a href="#Item19-Design-and-document-for-inheritance-or-else-prohibit-it" class="headerlink" title="Item19: Design and document for inheritance or else prohibit it"></a>Item19: Design and document for inheritance or else prohibit it</h1><p>A class to be designed and documented for inheritance must document precisely the effects of overriding any method. In other words, <strong>the class must document its</strong> <em><strong>self-use</strong></em> <strong>of overridable methods.</strong></p><p>For each <strong>public or protected method</strong> (including constructor), the documentation must indicate which overridable methods the method invokes, in what sequence, and how the results of each invocation affect subsequent processing. (By <em>overridable</em>, we mean nonfinal and either public or protected.)</p><blockquote><p>More generally, a class must document any circumstances under which it might invoke an overridable method. For example, invocations might come from background threads or static initializers.</p></blockquote><h2 id="Example-of-the-document"><a href="#Example-of-the-document" class="headerlink" title="Example of the document"></a>Example of the document</h2><p><strong>A method that invokes overridable methods</strong> contains a description of these invocations at the end of its documentation comment. The description is in a special section of the specification, labeled “<strong>Implementation Requirements</strong>,” which is generated by the Javadoc tag <code>@implSpec</code>. This section describes the inner workings of the method.</p><p>Example from <code>java.util.AbstractCollection</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span><br></code></pre></td></tr></table></figure><p>Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that Objects.equals(o, e), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).</p><p><strong>Implementation Requirements:</strong> This implementation iterates over the col- lection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator’s remove method. Note that this implementation throws an <code>UnsupportedOperationException</code> if the iterator returned by this collection’s iterator method does not implement the remove method and this collection contains the specified object.</p><blockquote><p>This documentation leaves no doubt that overriding the <code>iterator</code> method will affect the behavior of the <code>remove</code> method. It also describes exactly how the behavior of the <code>Iterator</code> returned by the <code>iterator</code> method will affect the behavior of the <code>remove</code> method.</p></blockquote><p>But this violate the dictum that <strong>good API documentation should describe <em>what</em> a given method does and not <em>how</em> it does it</strong>.</p><p>This is an unfortunate consequence of the fact that <strong>inheritance violates encapsulation</strong>. To document a class so that it can be safely subclassed, you must describe implementation details that should otherwise be left unspecified.</p><h2 id="Restrictions-of-classes-for-inheritance"><a href="#Restrictions-of-classes-for-inheritance" class="headerlink" title="Restrictions of classes for inheritance"></a>Restrictions of classes for inheritance</h2><p>Designing a class for inheritance requires great effort and places substantial limitations on the class.</p><ol><li><p><strong>Constructors must not invoke overridable methods,</strong> directly or indirectly.</p><p>Because the superclass constructor runs before the subclass constructor, so the overriding method in the subclass will get invoked before the subclass constructor has run.</p><blockquote><p>Note that it <em>is</em> safe to invoke private methods, final methods, and static meth- ods, none of which are overridable, from a constructor.</p></blockquote></li><li><p>For classes that implement <code>Cloneable</code>:</p><p><strong><code>Clone</code> method must not invoke overridable methods,</strong> directly or indirectly.</p><blockquote><p>Because the overriding method will run before the subclass’s clone method has a chance to fix the clone’s state.</p></blockquote></li><li><p>For classes that implement <code>Serializable</code>:</p><p><strong><code>readObject</code> method must not invoke overridable methods,</strong> directly or indirectly.</p><blockquote><p>Because the overriding method will run before the subclass’s state has been deserialized.</p></blockquote><p>If the class has a <code>readResolve</code> or <code>writeReplace</code> method, you must make the <code>readResolve</code> or <code>writeReplace</code> method <strong>protected</strong> rather than private. If these methods are private, they will be silently ignored by subclasses.</p></li></ol><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="Provide-hooks"><a href="#Provide-hooks" class="headerlink" title="Provide hooks"></a>Provide hooks</h3><p>To allow programmers to write efficient subclasses without undue pain, <strong>a class may have to provide hooks into its internal workings in the form of judiciously chosen protected methods</strong> or, in rare instances, protected fields.</p><p>Example: <code>removeRange</code> method from <code>java.util.AbstractList</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span><br></code></pre></td></tr></table></figure><p>Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex &#x3D;&#x3D; fromIndex, this operation has no effect.)</p><p>This method is called by the clear operation on this list and its sublists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the <code>clear</code> operation on this list and its sublists.</p><p><strong>Implementation Requirements:</strong> This implementation gets a list iterator positioned before fromIndex and repeatedly calls <code>ListIterator.next</code> followed by <code>ListIterator.remove</code>, until the entire range has been removed. Note: If <code>ListIterator.remove</code> requires linear time, this implementation requires quadratic time.</p><h3 id="Write-subclasses-to-test"><a href="#Write-subclasses-to-test" class="headerlink" title="Write subclasses to test"></a>Write subclasses to test</h3><p>So how do you decide what protected members to expose when you design a class for inheritance? You should expose as few protected members as possible because each one represents a commitment to an implementation detail. On the other hand, you must not expose too few because a missing protected member can render a class practically unusable for inheritance.</p><p><strong>The only way to test a class designed for inheritance is to write subclasses.</strong> If you omit a crucial protected member, trying to write a subclass will make the omission painfully obvious. Conversely, if several subclasses are written and none uses a protected member, you should probably make it private.</p><blockquote><p>Experience shows that three subclasses are usually sufficient to test an extendable class. One or more of these subclasses should be written by someone other than the superclass author.</p></blockquote><p>When you design for inheritance a class that is likely to achieve wide use, realize that you are <strong>committing <em>forever</em></strong> to the self-use patterns that you document and to the implementation decisions implicit in its protected methods and fields. These commitments can make it difficult or impossible to improve the performance or functionality of the class in a subsequent release. Therefore, <strong>you must test your class by writing subclasses</strong> <strong>before</strong> <strong>you release it.</strong></p><h3 id="For-ordinary-concrete-classes"><a href="#For-ordinary-concrete-classes" class="headerlink" title="For ordinary concrete classes"></a>For ordinary concrete classes</h3><p><strong>The best solution is to prohibit subclassing in classes that are not designed and documented to be safely subclassed.</strong> </p><p>There are two ways to prohibit subclassing.</p><ol><li><p>Declare the class final.</p></li><li><p>Make all the constructors private or package-private and to add public static factories in place of the constructors.</p><blockquote><p>This way provides the flexibility to use subclasses internally (Item 17)</p></blockquote></li></ol><h3 id="For-classes-have-to-allow-inheritance"><a href="#For-classes-have-to-allow-inheritance" class="headerlink" title="For classes have to allow inheritance"></a>For classes have to allow inheritance</h3><p>If a concrete class does not implement a standard interface, then you may inconvenience some programmers by prohibiting inheritance. If you must allow inheritance from such a class, one reasonable approach is <strong>to ensure that the class never invokes any of its overridable methods and to document this fact</strong>. In other words, eliminate the class’s self-use of overridable methods entirely. In doing so, you’ll create a class that is reasonably safe to subclass. Overriding a method will never affect the behavior of any other method.</p><blockquote><p>You can eliminate a class’s self-use of overridable methods mechanically, without changing its behavior. Move the body of each overridable method to a private “helper method” and have each overridable method invoke its private helper method. Then replace each self-use of an overridable method with a direct invocation of the overridable method’s private helper method.</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Designing a class for inheritance is hard work. You must <strong>document all of its self-use patterns</strong>, and once you’ve documented them, you must commit to them for the life of the class. If you fail to do this, subclasses may become dependent on implementation details of the superclass and may break if the implementation of the superclass changes.</p><p>To allow others to write <em>efficient</em> subclasses, you may also have to <strong>export one or more protected methods</strong> (to be the hooks).</p><p>Unless you know there is a real need for subclasses, you are probably <strong>better off prohibiting inheritance</strong> by declaring your class final or ensuring that there are no accessible constructors.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-18. Favor composition over inheritance</title>
    <link href="/2023/11/21/Java/effective-java/Item18-Favor-composition-over-inheritance/"/>
    <url>/2023/11/21/Java/effective-java/Item18-Favor-composition-over-inheritance/</url>
    
    <content type="html"><![CDATA[<h1 id="Item18-Favor-composition-over-inheritance"><a href="#Item18-Favor-composition-over-inheritance" class="headerlink" title="Item18: Favor composition over inheritance"></a>Item18: Favor <em>composition</em> over <em>inheritance</em></h1><p>Inheritance is a powerful way to achieve code reuse, but it is not always the best tool for the job. Used inappropriately, it leads to fragile software. It is safe to use inheritance within a package, where the subclass and the superclass implementations are under the control of the same programmers. It is also safe to use inheritance when extending classes specifically designed and documented for extension (Item 19). Inheriting from ordinary concrete classes across package boundaries, however, is dangerous.</p><p><strong>Unlike method invocation, inheritance violates encapsulation.</strong> In other words, a subclass depends on the implementation details of its superclass for its proper function. The superclass’s implementation may change from release to release, and if it does, the subclass may break, even though its code has not been touched. As a consequence, a subclass must evolve in tandem with its superclass, unless the superclass’s authors have designed and documented it specifically for the purpose of being extended.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Forwarding-class"><a href="#Forwarding-class" class="headerlink" title="Forwarding  class"></a>Forwarding  class</h3><p>Instead of extending an existing class, give your new class <strong>a private field that references an instance of the existing class</strong>. This design is called <em><strong>composition</strong></em> because the existing class becomes a component of the new one.</p><p>Each instance method in the new class invokes the corresponding method on the contained instance of the existing class and returns the results. This is known as <em><strong>forwarding</strong></em>, and the methods in the new class are known as <em>forwarding methods</em>.</p><blockquote><p>The resulting class will be rock solid, with no dependencies on the implementation details of the existing class. Even adding new methods to the existing class will have no impact on the new class.</p></blockquote><h3 id="Wrapper-class"><a href="#Wrapper-class" class="headerlink" title="Wrapper class"></a>Wrapper class</h3><p>A class that “wraps” another forwarding class instance and adds some new function is known as a <em>wrapper</em> class, This is also known as the <em>Decorator</em> pattern. </p><blockquote><p>Sometimes the combination of composition and forwarding is loosely referred to as <em>delegation.</em> Technically it’s not delegation unless the wrapper object passes itself to the wrapped object.</p></blockquote><p>The disadvantages of wrapper classes are few. One caveat is that <em><strong>wrapper* classes are not suited for use in *callback frameworks</strong></em>, wherein objects pass self-references to other objects for subsequent invocations (“callbacks”). Because a wrapped object doesn’t know of its wrapper, it passes a reference to itself (this) and callbacks elude the wrapper. This is known as the <em>SELF problem</em>.</p><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>Inheritance is appropriate only in circumstances where the subclass really is a <em>subtype</em> of the superclass. In other words, a class <em>B</em> should extend a class <em>A</em> only if an <strong>“is-a”</strong> relationship exists between the two classes.</p><p>If you are tempted to have a class <em>B</em> extend a class <em>A</em>, ask yourself the question: <strong>Is every <em>B</em> really an <em>A</em>?</strong> If you cannot truthfully answer yes to this question, <em>B</em> should not extend <em>A</em>. If the answer is no, it is often the case that <em>B</em> should contain a private instance of <em>A</em> and expose a different API: <em>A</em> is not an essential part of <em>B</em>, merely a detail of its implementation.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令学习</title>
    <link href="/2023/11/20/Git/git-learning/"/>
    <url>/2023/11/20/Git/git-learning/</url>
    
    <content type="html"><![CDATA[<h1 id="Git常用命令学习"><a href="#Git常用命令学习" class="headerlink" title="Git常用命令学习"></a>Git常用命令学习</h1><p>推荐一个可视化git学习网站：<a href="https://learngitbranching.js.org/">https://learngitbranching.js.org/</a></p><h2 id="常用命令举例"><a href="#常用命令举例" class="headerlink" title="常用命令举例"></a>常用命令举例</h2><h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><ol><li><pre><code class="bash">git branch -f main HEAD~3# git branch -f main HEAD^: 往上移一个<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>   作用：（強制）移動 <span class="hljs-selector-tag">main</span> 指向從 HEAD 往上數的第三個 parent commit。<br><br><span class="hljs-number">2</span>. ```bash<br>   git rebase <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span><br>   <br>   # 等价于现在HEAD在<span class="hljs-selector-tag">b</span>，执行以下命令：<br>   git rebase <span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure>作用：把b及往父亲方向走直到和a的公共祖宗节点之前的路径上节点接到a的后面&gt; 如果b是a的祖宗，则没有效果怎么记？rebase a也就是换base为a，把当前commit（b）的base换成a，b接到a的后面</code></pre></li><li><pre><code class="bash">git checkout -b bugFix# 等价于：git branch bugFixgit checkout bugFix<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>   从当前commit新建一条分支`bugFix`，并切换到`bugFix`<br><br><span class="hljs-number">4</span>. 取消git修改：`git reset`或者`git revert`，例：<br><br>   ```bash<br>   git reset HEAD~<span class="hljs-number">3</span><br>   git revert HEAD<br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="bash">git cherry-pick a b c<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>   把commit a, b, c依次接到当前指针所在commit的后面<br><br>### 远端<br><br><span class="hljs-number">1.</span> ```bash<br>   git pull --rebase<br></code></pre></td></tr></table></figure>表示的是一個 fetch 以及一個 rebase。用于远端其他人提交新commit之后更新到本地，并与本地自己的更新合并（适用于在同一个分支开发）&gt; 本地在dev分支开发，如果远端master更新了，需要把变更合并到本地dev（本地的master一般不会动，如果动了就加个`--rebase`）：&gt;&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git pull<br>git rebase dev<br></code></pre></td></tr></table></figure>&gt;&gt; </code></pre></li><li><pre><code class="bash">git checkout -b totallyNotMain origin/main# 等价于git branch -u origin/main totallyNotMain<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><br>   建立一個新的 totallyNotMain branch 並且它會 <span class="hljs-built_in">track</span> <span class="hljs-built_in">origin</span>/main。<br><br><span class="hljs-number">3</span>. ```bash<br>   git <span class="hljs-built_in">push</span> &lt;remote&gt; &lt;place&gt;<br>   # 如：<br>   git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> main<br></code></pre></td></tr></table></figure>先到我的 repo 中的 &quot;main&quot; branch，抓下所有的 commit，然後到叫作 &quot;origin&quot; 的 remote 的 &quot;main&quot; branch，檢查 remote 的 commit 有沒有跟我的 repo 一致，如果沒有，就更新。&gt; 这个命令就不需要local当前指针一定指向main了</code></pre></li><li><pre><code class="bash">git push origin &lt;source&gt;:&lt;destination&gt;<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>   當我們的 source 以及 destination 是不同的<span class="hljs-keyword">branch的時候用</span><br><span class="hljs-keyword"></span><br><span class="hljs-number">5</span>. ```<span class="hljs-keyword">bash</span><br><span class="hljs-keyword"></span>   git fetch <span class="hljs-keyword">origin </span>foo<br></code></pre></td></tr></table></figure>git 會到 remote 上的 foo branch，抓下所有不在 local 上的 commit，然後將它們放到 local 的 o/foo branch。</code></pre></li><li><pre><code class="bash">git pull origin foo# 等价于git fetch origin foo; git merge o/foogit pull origin bar~1:bugFix# 等价于git fetch origin bar~1:bugFix; git merge bugFix</code></pre><p>git pull 表示 fetch 之後再 merge 所 fetch 的 commit，當使用 git fetch 時使用一樣的參數，之後再從 fetch 下來的 commit 所放置的位置做 merge。</p></li></ol><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="reset-vs-revert"><a href="#reset-vs-revert" class="headerlink" title="reset vs revert"></a>reset vs revert</h3><ol><li><code>reset</code>参数指针为当前指针所在branch需要回退到的位置；而<code>revert</code>参数指针为需要修改的那个指针</li><li><code>reset</code>可以往回退很多个commit；而<code>revert</code>只能取消修改一个commit（后面跟的参数是指针）</li><li><code>reset</code>相当于只把指针往回移动若干步，别人无法看到这个变化；而<code>revert</code>是把当前commit的前一个commit接到当前commit后面，对其他人也可见。</li></ol><h3 id="rebase-vs-merge"><a href="#rebase-vs-merge" class="headerlink" title="rebase vs merge"></a>rebase vs merge</h3><p><code>rebase</code>优点：rebase 使得你的 commit tree 看起來更為簡潔，因為任何的 commit 都在一條直線上面。</p><p><code>rebase</code>缺点：rebase 修改了 commit tree 的歷史紀錄。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浪潮之巅读书笔记5-英特尔与摩托罗拉</title>
    <link href="/2023/11/20/book-notes/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85/Intel-and-Motorola/"/>
    <url>/2023/11/20/book-notes/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85/Intel-and-Motorola/</url>
    
    <content type="html"><![CDATA[<h1 id="Intel"><a href="#Intel" class="headerlink" title="Intel"></a>Intel</h1><p>50多年来，英特尔公司成功的关键首先是赶上了个人电脑革命的浪潮，尤其是有微软这个强势的伙伴，IT业者甚至将整个PC时代称为WinTel时代，即微软的Windows操作系统加上Intel的处理器;其次，英特尔公司50多年来严格按照其创始人预言的惊人速度（摩尔定律）在为全世界PC提高着处理器的性能，用英特尔的宣传语来说，它给了每台PC一颗奔腾的芯。</p><h2 id="大事记"><a href="#大事记" class="headerlink" title="大事记"></a>大事记</h2><p>1968 英特尔成立。</p><p>1971 开发出英特尔第一个商用处理器Intel 4004。</p><p>197x 英特尔遭遇前所未有的发展困境，摩尔接替诺伊斯担任英特尔CEO，但是实际负责运营该公司的是他的学生格鲁夫，从此英特尔开始快速发展。</p><p>1978 英特尔开发出8086微处理器，后被用作IBM PC的CPU。</p><p>1982 80286处理器问世。</p><p>1985 32位80386处理器问世。</p><p>1986 英特尔公司上市。</p><p>1987 安迪·格鲁夫正式担任英特尔CEO，英特尔开始了快速发展的10年，并且成为全球最大的半导体公司。</p><p>1989 定点和浮点处理合一的80486处理器问世。</p><p>1993 奔腾系列处理器问世，在随后的十年里，英特尔推出了很多代的奔腾处理器。</p><p>2000 英特尔的手机处理器XScale问世。</p><p>2001 英特尔的64位服务器处理器Itanium问世，英特尔在服务器市场彻底超越RISC处理器的代表太阳公司。</p><p>2005 基于ARM的处理器占到了智能手机处理器市场的98%，英特尔在这个市场明显落后于高通公司和德州仪器公司。</p><p>2006 双核处理器问世。同年，英特尔将通信及移动处理器业务卖给了Marvell公司，从此退出手机处理器市场。</p><p>2009 四核处理器问世，英特尔继续在服务器处理器市场上占优势。</p><p>2012 英特尔宣布重返移动终端市场，但是效果不佳。</p><p>2017 英特尔公司以153亿美元的高价收购了开发图像识别和无人驾驶技术的Mobileye公司。</p><h2 id="英特尔的发展"><a href="#英特尔的发展" class="headerlink" title="英特尔的发展"></a>英特尔的发展</h2><h3 id="80x86系列"><a href="#80x86系列" class="headerlink" title="80x86系列"></a>80x86系列</h3><p>上个世纪70年代末，英特尔公司生产出了著名的16位8086处理器。但由于性能不如IBM、DEC和惠普等公司，在很长时间里，英特尔的处理器被认为是低性能、低价格的产品。英特尔的芯片性价比很高，但并不是尖端产品。</p><p>1981年，IBM为了短平快地搞出PC，也懒得自己设计处理器，拿来英特尔的8086就直接用上了。结果，英特尔一举成名。1982年，英特尔搞出了和8086完全兼容的第二代PC处理器 80286，用在了IBM PC&#x2F;AT上。由于IBM无法阻止别人制造兼容机，随着1985年康柏造出了世界上第一台IBM PC兼容机，兼容机厂商就像雨后春笋般在世界各地冒了出来。这些兼容机硬件不尽相同，但是为了兼容IBM PC，都选用了英特尔公司的处理器。</p><p>20世纪80年代，英特尔果断停掉传统的内存业务，将这个市场拱手让给了日本人，从此专心做处理器。1985年，英特尔公司继摩托罗拉之后，第二个研制出32位微处理器80386，开始扩大它在整个半导体工业的市场份额。这款芯片的研制费用超过3亿美元，在当时确实是一场豪赌，这笔研制费用超过中国当时在五年计划中对半导体科研全部投人的好几倍。英特尔靠80386完成了对IBM PC兼容机市场一统江湖的伟业。</p><p>到了1989年，英特尔推出了从80386到奔腾处理器的过渡产品80486，简单来说，这款CPU就是80386加一个浮点处理器80387及缓存。依靠80486的销售，英特尔一举超过所有的日本半导体公司，坐上了半导体行业的头把交椅。</p><h3 id="奔腾处理器"><a href="#奔腾处理器" class="headerlink" title="奔腾处理器"></a>奔腾处理器</h3><p>1993年，英特尔公司推出奔腾处理器。奔腾处理器的诞生，使英特尔甩掉了只会做低性能处理器的帽子。由于奔腾处理器的速度已经达到工作站处理器的水平，因此从那时起，高端的个人电脑开始取代低性能的图形工作站。</p><p>到今天，即使是最早生产工作站的太阳公司 (已被甲骨文公司收购)和世界上最大的计算机公司IBM，以及以前从不使用英特尔处理器的苹果公司，都开始在产品中使用英特尔的或与之兼容的处理器了。现在，英特尔已经垄断了个人电脑和服务器处理器市场。</p><h3 id="错失移动时代"><a href="#错失移动时代" class="headerlink" title="错失移动时代"></a>错失移动时代</h3><p>Google研究院院长、美国经典教科书《人工智能》的作者彼得·诺威格 (PeterNorvig)博士有一句话非常经典，在业界广为流传:一家公司的市场份额超过50%以后，就不用再想去将市场份额翻番了。言下之意，这家公司就必须去挖掘新的成长点了。在2000年后，英特尔公司就是处于这样一个地位。</p><p>但它在PC的外围芯片和手机Atom处理器上的尝试都失败了。原因如下：</p><ol><li>英特尔公司的商业模式历来是靠<strong>大投入、大批量</strong>来挣钱的，同一代的芯片，英特尔的销量可能是太阳公司的10倍，甚至更多，因此，它可以比其他公司多花几倍的经费来开发一种芯片。但是，当一种芯片市场较小时，英特尔公司便很难做到盈利，而很多新的市场一开始规模总是很小的，这是英特尔面临的一个根本问题。</li><li>CISC的<strong>高功耗</strong>问题。高功耗低性能的Atom处理器在移动终端上无法和高性能的ARM处理器竞争。</li></ol><p>不过，随着云计算的兴起，基于服务器端的软件和服务对新处理器的需求弥补了个人电脑销售的疲软，因此安迪–比尔定律对英特尔的正面影响还会持续较长的时间。</p><h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>2017年，英特尔公司以153亿美元的高价收购了开发图像识别和无人驾驶技术的Mobileye公司，并与欧美的一些汽车厂商成立了合资企业，开发无人驾驶技术。但是，做芯片出身的英特尔公司是否具有人工智能技术和系统集成技术的基因，大家对此依然颇有疑问。</p><h2 id="英特尔的战争"><a href="#英特尔的战争" class="headerlink" title="英特尔的战争"></a>英特尔的战争</h2><h3 id="英特尔与摩托罗拉"><a href="#英特尔与摩托罗拉" class="headerlink" title="英特尔与摩托罗拉"></a>英特尔与摩托罗拉</h3><p>在个人电脑时代，英特尔公司遇到的唯一重量级对手只有上个世纪80年代的摩托罗拉。正如罗马帝国的崛起是通过在部落战争中打败原有的霸主迦太基而完成的，英特尔的崛起是靠击败老牌半导体公司摩托罗拉而实现的。</p><p>摩托罗拉并没有败在技术和资金上，20世纪80年代以前，摩托罗拉在资金、技术等各方面都明显强于英特尔。在很长时间里，摩托罗拉处理器的性能要优于英特尔的同类产品。摩托罗拉之败，首先是微软的因素，即英特尔有了微软这个没有签约的同盟军。此外，摩托罗拉自身在商业、管理和市场诸方面也有很多失误。假如经营得当，摩托罗拉今天应该能通过RISC处理器守住工作站和苹果的市场。</p><p><strong>英特尔胜利的原因：</strong></p><h4 id="1-这是两家不同时代的公司"><a href="#1-这是两家不同时代的公司" class="headerlink" title="1. 这是两家不同时代的公司"></a>1. 这是两家不同时代的公司</h4><p>总部在美国中部伊利诺伊州的摩托罗拉虽然也是一家高科技公司，也经历了20世纪80年代的信息革命，但是它完全还是20世纪五六十年代的传统公司。</p><p>摩托罗拉的员工在工资和福利待遇上不错，但是公司和员工，基本上还是传统的雇佣关系，公司内部管理层级较多，大部分员工没有多少<strong>股票期权</strong>。因此，<strong>公司的业绩和员工的利益关系不大</strong>。英特尔公司则是一家典型的硅谷公司，每个员工的<strong>工作强度</strong>比摩托罗拉要大很多，但是每个人平均的股票期权也多很多。</p><blockquote><p>硅谷几个比较好的学区，不少房子都被英特尔公司的早期员工买走了，而这些房子只靠工资一辈子也买不起。</p></blockquote><blockquote><p>几年前，美国历史频道(History Channel)在节目中评论了中日甲午战争。美国的历史学家认为，这是两个不同时代军队之间的战争，虽然双方武器相差不多，战争的结果不会有任何悬念，因为处在专制的农业时代后期的军队很难打赢一支新兴的工业化国家的军队。英特尔和摩托罗拉之间的竞争也是如此。</p></blockquote><h4 id="2-两家公司的统帅水平相去甚远"><a href="#2-两家公司的统帅水平相去甚远" class="headerlink" title="2. 两家公司的统帅水平相去甚远"></a>2. 两家公司的统帅水平相去甚远</h4><p>英特尔公司上个世纪八九十年代的 CEO格鲁夫虽然是工程师出身，但他同时也是个人电脑时代最优秀的领导者和管理者，几次被评为世界上最好的CEO。上个世纪70年代初，英特尔公司发展遇到瓶颈，当时的CEO诺伊斯甚至一度想出售公司。这时格鲁夫临危受命，和摩尔一道将英特尔公司扭亏为盈，并目将该公司打造成连续三十年发展速度超过半导体行业平均水平的明星公司。</p><p>摩托罗拉公司由高尔文(Galvin)兄弟创办，上个世纪60年代传到了儿子手里，上个世纪八九十年代传到了孙子手里，是个典型的家族公司。俗话说“富不过三代”，这话果然应验在高尔文家族上，三代人可以说是一代不如一代。孙子辈的克里斯托弗·高尔文虽然是被“选成”CEO的，但是如果他不姓高尔文，他可能永远都当不了摩托罗拉的CEO，甚至进不了工业界的高层。</p><h4 id="3-英特尔比摩托罗拉更专注"><a href="#3-英特尔比摩托罗拉更专注" class="headerlink" title="3. 英特尔比摩托罗拉更专注"></a>3. 英特尔比摩托罗拉更专注</h4><p>在业务上，半导体只是摩托罗拉的一个部门，而处理器又只是其半导体部门的一项业务，对于英特尔来讲处理器芯片却是全部。因此，摩托罗拉即使完全退出计算机处理器市场也不过是损失一些地盘，而英特尔一旦失败，则会面临灭顶之灾。</p><p>一般来讲，华尔街总是希望上市公司有尽可能多的而不是单一的收人来源，摩托罗拉确实是这么做的，它曾经在计算机的处理器、通信的数字信号处理器、对讲机、BP机、手机和电视接收器等很多领域发展。结果每个领域都很难做大。英特尔公司从一开始就非常专注。虽然它早期的主要产品是计算机的动态存储器，但是后来为了专注于个人电脑的处理器，主动放弃了动态存储器的业务。英特尔在每一代处理器的研发过程中，都集中了大量的人力和资金，每一次都是只能成功不能失败。这就像一把散线和一股绳，散线很容易被绳扯断。因此，专注的英特尔最终把计算机处理器的业务做大做强，而业务多元化的摩托罗拉最后除了在计算机处理器上败给了英特尔，在手机上碰到了诺基亚，在信号处理器(DSP)上又败给了德州仪器。</p><blockquote><p>有时候，一家好的公司不能完全按华尔街的意愿办事。</p></blockquote><h3 id="CISC-vs-RISC"><a href="#CISC-vs-RISC" class="headerlink" title="CISC vs RISC"></a>CISC vs RISC</h3><p>当今的计算机系统结构可以根据指令集分成复杂指令集(CISC)和精简指令集(RISC)两种。一个计算机程序最终要变成一系列指令才能在处理器上运行。每种处理器的指令集不一定相同。</p><h4 id="CISC处理器"><a href="#CISC处理器" class="headerlink" title="CISC处理器"></a>CISC处理器</h4><p>CISC处理器在设计的时候，尽可能地实现各种各样、功能齐全的指令，这包括早期IBM和DEC的全部处理器，今天的英特尔和AMD的处理器等。</p><p>CISC处理器的优势：可以实现很复杂的指令。</p><p>CISC处理器的问题：</p><ol><li>设计复杂，实现同样的性能需要很高的集成度;</li><li>每个指令执行时间不一样长，处理器内部各个部分很难流水作业，处理器会出现不必要的等待</li><li>CISC处理器芯片高集成度的高功耗。</li></ol><h4 id="RISC处理器"><a href="#RISC处理器" class="headerlink" title="RISC处理器"></a>RISC处理器</h4><p>上个世纪80年代，计算机科学家们提出了RISC处理器设计思想。精简指令集只保留很少的常用指令，一条复杂的指令会用几条简单的指令代替。RISC处理器每条指令的执行时间相同，处理器内各部分可以很好地流水作业，处理器速度比同时期的CISC处理器要来得快。</p><p>使用精简指令集设计的处理器，过去主要是很多工作站的处理器。现在低端的主要是手机中的处理器，高端的则是专门处理图形和图像的GPU(Graphics Processing Unit)。</p><h4 id="英特尔的表现"><a href="#英特尔的表现" class="headerlink" title="英特尔的表现"></a>英特尔的表现</h4><ol><li><strong>英特尔坚持自己系列产品的兼容性</strong>，即保证以往的软件程序能在新款处理器上运行。这样时间一长，用户便积累了很多在英特尔处理器上运行的软件。每次处理器升级，用户原来的软件都能使用，非常方便。因此大家就不愿意轻易换用其他厂商的处理器，即使那些处理器更快。而其他处理器厂商这点做得都没有英特尔好，它们常常每过几年就重起炉灶，害得用户以前很多软件都不能用了，必须花钱买新的。时间一长，用户就换烦了。</li><li><strong>英特尔利用规模经济的优势，大力投入研发，让业界普遍看衰的CISC处理器一代代更新。</strong>在上个世纪90年代初，英特尔的x86系列和RISC处理器相比在实数运算上要略逊一筹。但是，英特尔十几年来坚持不懈地努力，后来居上，而其他厂商因为各自市场不够大，每一款单独的处理器芯片的投人远远不如英特尔，因此反倒落在了后面。</li><li><strong>英特尔并没有拒绝新技术</strong>，它也曾经研制出两款不错的RISC处理器，只是看到它们前途不好时，立即停掉了。市场的倾向说明了用户对兼容性的要求比性能更重要。</li><li>英特尔运气很好，在RISC处理器阵营中，群龙无首。这一战，看似英特尔单挑诸多处理器领域的老大。但是，这几家做RISC处理器的公司因为彼此在工作站方面是竞争对手，自然不会用对手的产品，而目各自为战，互相拆台打价格战。</li></ol><h3 id="英特尔与AMD"><a href="#英特尔与AMD" class="headerlink" title="英特尔与AMD"></a>英特尔与AMD</h3><p>AMD不同于英特尔以往的对手，它从来没有另起炉灶做一种和英特尔不同的芯片，而是不断推出和英特尔兼容的、更便宜的替代品。AMD的这种做法和它的基因有很大关系。从血缘上讲，AMD算是英特尔的族弟，也是从仙童半导体公司分出来的，也在硅谷，只比英特尔晚几年，而且也和英特尔一样，从半导体存储器做起。</p><p>AMD的创始人是搞销售出身的，AMD的这种基因决定了它不是自己会做什么就做什么，而是市场导向的，市场需要什么就做什么。在AMD创建不久，它就成功地解剖了英特尔的一款8位处理器芯片。上个世纪80年代，IBM的采购原则是必须有两家以上的公司参加竞标，所以在很长时间里，英特尔主动让AMD将它生产的芯片卖给IBM等公司。</p><p>在整个20世纪90年代，英特尔和AMD易然总是打打闹闹，但是它们在开拓x86市场，对抗精简指令集的工作站芯片方面利益是一致的。因此，它们在市场上的依存要多于竞争。</p><p>英特尔并不想把AMD彻底打死，因为留着AMD对它利大于弊。首先，它避免了反垄断的很多麻烦。2012年6月，AMD的市值只有英特尔的3%左右，后者靠手中的现金就足以买下前者。但是，英特尔不能这么做，否则会有反垄断的大麻烦。其次，留着AMD这个对手对英特尔自身的技术进步有好处。</p><blockquote><p>柳宗元在他的“敌戒”一文中指出，“秦有六国，兢兢以强;六国既除，訑訑乃亡”。这条规律对于英特尔也适用。</p></blockquote><h2 id="摘抄与思考"><a href="#摘抄与思考" class="headerlink" title="摘抄与思考"></a>摘抄与思考</h2><p>在PC工业生态链中，只有作为<strong>操作系统开发商的Microsoft</strong>和作为<strong>处理器制造商的Intel</strong>处于不可替代的地位。因此，Intel的崛起就成为历史的必然，正所谓时势造英雄。（初期英特尔的成功有一定运气成分，IBM由于时间原因没有自己开发处理器，而是让IBM PC直接用了英特尔的8086，大量兼容机也跟着选用，使得英特尔占了很大的市场份额）</p><p>从英特尔和AMD的关系可以看出，一个公司只是一味仿制，靠更低的利润率来竞争，从长远来看，命运还是掌握在别人手里。</p>]]></content>
    
    
    <categories>
      
      <category>Book Notes</category>
      
      <category>浪潮之巅</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-17. Minimize mutability</title>
    <link href="/2023/11/20/Java/effective-java/Item17-Minimize-mutability/"/>
    <url>/2023/11/20/Java/effective-java/Item17-Minimize-mutability/</url>
    
    <content type="html"><![CDATA[<h1 id="Item17-Minimize-mutability"><a href="#Item17-Minimize-mutability" class="headerlink" title="Item17: Minimize mutability"></a>Item17: Minimize mutability</h1><p>An immutable class is simply a class whose instances cannot be modified. All of the information contained in each instance is <strong>fixed</strong> for the lifetime of the object, so no changes can ever be observed.</p><blockquote><p>The Java platform libraries contain many immutable classes, including <em>String</em>, the <em>boxed primitive classes</em>, and <em>BigInteger</em> and <em>BigDecimal</em>.</p></blockquote><h2 id="Rules-for-making-a-class-immutable"><a href="#Rules-for-making-a-class-immutable" class="headerlink" title="Rules for making a class immutable"></a>Rules for making a class immutable</h2><ol><li><p><strong>Don’t provide methods that modify the object’s state</strong> (known as <em>mutators</em>).</p></li><li><p><strong>Ensure that the class can’t be extended.</strong> This prevents careless or malicious subclasses from compromising the immutable behavior of the class by behaving as if the object’s state has changed.</p><p>Preventing subclassing is generally accomplished by:</p><ol><li><p>Making the class final;</p></li><li><p>Or making all of its constructors private or package-private and add public static factories in place of the public constructors (Item 1), which is more flexible.</p><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Immutable class with static factories instead of constructors</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> re;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> im;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Complex</span><span class="hljs-params">(<span class="hljs-type">double</span> re, <span class="hljs-type">double</span> im)</span> &#123;<br>    <span class="hljs-built_in">this</span>.re = re;<br><span class="hljs-built_in">this</span>.im = im;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Complex <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">double</span> re, <span class="hljs-type">double</span> im)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Complex</span>(re, im);<br>  &#125;<br>   ... <span class="hljs-comment">// Remainder unchanged</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p><strong>Make all fields final.</strong> This clearly expresses your intent in a manner that is enforced by the system. Also, it is necessary to ensure correct behavior if a reference to a newly created instance is passed from one thread to another without synchronization, as spelled out in the <em>memory model</em>.</p></li><li><p><strong>Make all fields private, use <em>accessor</em> to access them.</strong> This prevents clients from obtaining access to mutable objects referred to by fields and modifying these objects directly.</p><blockquote><p>While it is technically permissible for immutable classes to have public final fields containing primitive values or references to immutable objects, it is not recommended because it precludes changing the internal representation in a later release (Items 15 and 16).</p></blockquote></li><li><p><strong>Ensure exclusive access to any mutable components.</strong> If your class has any fields that refer to <strong>mutable objects</strong>, ensure that clients of the class <em>cannot</em> obtain references to these objects. Never initialize such a field to a client-provided object reference or return the field from an accessor.</p><blockquote><p>Make <em>defensive copies</em> (Item 50) in constructors, accessors, and <code>readObject</code> methods (Item 88).</p></blockquote></li></ol><h2 id="Pros-cons-of-immutable-objects"><a href="#Pros-cons-of-immutable-objects" class="headerlink" title="Pros &amp; cons of immutable objects"></a>Pros &amp; cons of immutable objects</h2><h3 id="Pros"><a href="#Pros" class="headerlink" title="Pros"></a>Pros</h3><ol><li><p><strong>Immutable objects are simple.</strong> An immutable object can be in exactly one state, the state in which it was created. If you make sure that all constructors establish class invariants, then it is guaranteed that these invariants will remain true for all time, with no further effort on your part or on the part of the programmer who uses the class.</p><blockquote><p>Mutable objects, on the other hand, can have arbitrarily complex state spaces. If the documentation does not provide a precise description of the state transitions performed by <em>mutator</em> methods, it can be difficult or impossible to use a mutable class reliably.</p></blockquote></li><li><p><strong>Immutable objects are inherently thread-safe; they require no synchronization.</strong> They cannot be corrupted by multiple threads accessing them concurrently. This is far and away the easiest approach to achieve thread safety.</p><blockquote><p>Since no thread can ever observe any effect of another thread on an immutable object, <strong>immutable objects can be shared freely.</strong> Immutable classes should therefore encourage clients to reuse existing instances wherever possible. One easy way to do this is to <strong>provide public static final constants for commonly used values</strong>. For example, the <code>Complex</code> class might provide these constants:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Complex</span> <span class="hljs-variable">ZERO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Complex</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Complex</span> <span class="hljs-variable">ONE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Complex</span> <span class="hljs-variable">I</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Complex</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>An immutable class can provide <strong>static factories</strong> (Item 1) that cache frequently requested instances to avoid creating new instances when existing ones would do.</p></blockquote></li><li><p><strong>Not only can you share immutable objects, but they can share their internals.</strong> </p><blockquote><p>For example, the <code>BigInteger</code> class uses a sign-magnitude representation internally. The sign is represented by an int, and the magnitude is represented by an int array. The negate method produces a new BigInteger of like magnitude and opposite sign. It does not need to copy the array even though it is mutable; the newly created <code>BigInteger</code> <strong>points to the same internal array as the original</strong>.</p></blockquote></li><li><p><strong>Immutable objects make great building blocks for other objects,</strong> whether mutable or immutable. It’s much easier to maintain the invariants of a complex object if you know that its component objects will not change underneath it.</p><blockquote><p>A special case of this principle is that immutable objects make great map keys and set elements: you don’t have to worry about their values changing once they’re in the map or set, which would destroy the map or set’s invariants.</p></blockquote></li><li><p><strong>Immutable objects provide failure atomicity for free</strong> (Item 76). Their state never changes, so there is no possibility of a temporary inconsistency.</p></li></ol><h3 id="Cons"><a href="#Cons" class="headerlink" title="Cons"></a>Cons</h3><p><strong>The major disadvantage of immutable classes is that they require a separate object for each distinct value.</strong> Creating these objects can be costly, especially if they are large.</p><p>The package-private mutable companion class approach works fine if you can accurately predict which complex operations clients will want to perform on your immutable class. If not, then your best bet is to provide a <em>public</em> mutable companion class.</p><blockquote><p>The main example of this approach in the Java platform libraries is the String class, whose mutable companion is <code>StringBuilder</code> (and its obsolete predecessor, <code>StringBuffer</code>).</p></blockquote><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li>If you choose to have your immutable class implement <code>Serializable</code> and it contains one or more fields that refer to mutable objects, you must provide an explicit <code>readObject</code> or <code>readResolve</code> method, or use the <code>ObjectOutputStream.writeUnshared</code> and <code>ObjectInputStream.readUnshared</code> methods, even if the default serialized form is acceptable. <strong>Otherwise an attacker could create a mutable instance of your class.</strong> This topic is covered in detail in Item 88.</li><li><strong>Constructors should create fully initialized objects with all of their invari- ants established.</strong> Don’t provide a public initialization method separate from the constructor or static factory unless there is a <em>compelling</em> reason to do so. Similarly, don’t provide a “reinitialize” method that enables an object to be reused as if it had been constructed with a different initial state. Such methods generally provide little if any performance benefit at the expense of increased complexity.</li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To summarize, resist the urge to write a setter for every getter. <strong>Classes should be immutable unless there’s a very good reason to make them mutable.</strong> Immutable classes provide many advantages, and their only disadvantage is the potential for performance problems under certain circumstances. You should provide a public mutable companion class for your immutable class <em>only</em> once you’ve confirmed that it’s necessary to achieve satisfactory performance (Item 67).</p><blockquote><p>You should always make small value objects, such as <code>PhoneNumber</code> and Complex, immutable. (There are several classes in the Java platform libraries, such as <code>java.util.Date</code> and <code>java.awt.Point</code>, that should have been immutable but aren’t.) You should seriously consider making larger value objects, such as <code>String</code> and <code>BigInteger</code>, immutable as well.</p></blockquote><p>There are some classes for which immutability is impractical. <strong>If a class cannot be made immutable, limit its mutability as much as possible.</strong> Reducing the number of states in which an object can exist makes it easier to reason about the object and reduces the likelihood of errors. Therefore, make every field final unless there is a compelling reason to make it nonfinal. Combining the advice of this item with that of Item 15, your natural inclination should be to <strong>declare every field <code>private final</code> unless there’s a good reason to do otherwise.</strong></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IoC容器</title>
    <link href="/2023/11/19/backend/Spring/IoC/IoC-container/"/>
    <url>/2023/11/19/backend/Spring/IoC/IoC-container/</url>
    
    <content type="html"><![CDATA[<h1 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h1><h2 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h2><p>容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。</p><p>Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。</p><h2 id="IoC原理"><a href="#IoC原理" class="headerlink" title="IoC原理"></a>IoC原理</h2><p>IoC全称Inversion of Control，直译为控制反转。</p><p>如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。</p><p>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。</p><p>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制。</p><p>不直接<code>new</code>一个<code>DataSource</code>，而是注入一个<code>DataSource</code>，这个小小的改动虽然简单，却带来了一系列好处：</p><ol><li><code>BookService</code>不再关心如何创建<code>DataSource</code>，因此，不必编写读取数据库配置之类的代码；</li><li><code>DataSource</code>实例被注入到<code>BookService</code>，同样也可以注入到<code>UserService</code>，因此，共享一个组件非常简单；</li><li>测试<code>BookService</code>更容易，因为注入的是<code>DataSource</code>，可以使用内存数据库，而不是真实的MySQL配置。</li></ol><blockquote><p>因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。</p></blockquote><p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;HikariDataSource&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;BookService&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;UserService&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为<code>dataSource</code>的组件通过属性<code>dataSource</code>（即调用<code>setDataSource()</code>方法）注入到另外两个组件中。</p><p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</p><h2 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h2><p>Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。</p><h3 id="1-set"><a href="#1-set" class="headerlink" title="1. set()"></a>1. set()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookService</span> &#123;<br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDataSource</span><span class="hljs-params">(DataSource dataSource)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dataSource = dataSource;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookService</span> &#123;<br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BookService</span><span class="hljs-params">(DataSource dataSource)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dataSource = dataSource;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无侵入容器"><a href="#无侵入容器" class="headerlink" title="无侵入容器"></a>无侵入容器</h2><p>在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：</p><ol><li>应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；</li><li>测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1282381977747489">https://www.liaoxuefeng.com/wiki/1252599548343744/1282381977747489</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Backend</category>
      
      <category>Spring</category>
      
      <category>IoC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-16. In public classes, use accessor methods, not public fields</title>
    <link href="/2023/11/19/Java/effective-java/Item16-In-public-classes,use-accessor-methods,not-public-fields/"/>
    <url>/2023/11/19/Java/effective-java/Item16-In-public-classes,use-accessor-methods,not-public-fields/</url>
    
    <content type="html"><![CDATA[<h1 id="Item16-In-public-classes-use-accessor-methods-not-public-fields"><a href="#Item16-In-public-classes-use-accessor-methods-not-public-fields" class="headerlink" title="Item16: In public classes, use accessor methods, not public fields"></a>Item16: In public classes, use accessor methods, not public fields</h1><h2 id="Public-class"><a href="#Public-class" class="headerlink" title="Public class"></a>Public class</h2><p><strong>If a class is accessible outside its package, provide accessor methods</strong> to preserve the flexibility to change the class’s internal representation. If a public class exposes its data fields, all hope of changing its representation is lost because client code can be distributed far and wide.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Encapsulation of data by accessor methods and mutators</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> y;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>    <span class="hljs-built_in">this</span>.x = x;<br>    <span class="hljs-built_in">this</span>.y = y;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getX</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> x; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getY</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> y; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setX</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> &#123; <span class="hljs-built_in">this</span>.x = x; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setY</span><span class="hljs-params">(<span class="hljs-type">double</span> y)</span> &#123; <span class="hljs-built_in">this</span>.y = y; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>If <strong>a class has no access control identifier</strong>, it has default access control characteristics. This default access control stipulates that <strong>the class can only be accessed and referenced by classes in the same package</strong>, and cannot be used by classes in other packages, even if there are subclasses of this class in other packages. This access feature is also called package access (package private).</p></blockquote><p>While it’s never a good idea for a public class to expose fields directly, it is less harmful if the fields are <strong>immutable</strong>. You can’t change the representation of such a class without changing its API, and you can’t take auxiliary actions when a field is read, but you can enforce invariants.</p><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Public class with exposed immutable fields - questionable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HOURS_PER_DAY</span>    <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MINUTES_PER_HOUR</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hour;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> minute;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Time</span><span class="hljs-params">(<span class="hljs-type">int</span> hour, <span class="hljs-type">int</span> minute)</span> &#123;<br>    <span class="hljs-keyword">if</span> (hour &lt; <span class="hljs-number">0</span> || hour &gt;= HOURS_PER_DAY)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Hour: &quot;</span> + hour);<br>    <span class="hljs-keyword">if</span> (minute &lt; <span class="hljs-number">0</span> || minute &gt;= MINUTES_PER_HOUR)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Min: &quot;</span> + minute);<br>    <span class="hljs-built_in">this</span>.hour = hour;<br>    <span class="hljs-built_in">this</span>.minute = minute;<br>&#125;<br>   ... <span class="hljs-comment">// Remainder omitted</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Package-private-private-nested-class"><a href="#Package-private-private-nested-class" class="headerlink" title="Package-private &#x2F; private nested class"></a>Package-private &#x2F; private nested class</h2><p>However, <strong>if a class is package-private or is a private nested class, there is nothing inherently wrong with exposing its data fields</strong>—assuming they do an adequate job of describing the abstraction provided by the class.</p><p>This approach generates less visual clutter than the accessor-method approach, both in the class definition and in the client code that uses it.</p><blockquote><p>While the client code is tied to the class’s internal representation, this code is <strong>confined to the package</strong> containing the class. If a change in representation becomes desirable, you can make the change without touching any code outside the package. In the case of a private nested class, the scope of the change is further restricted to the enclosing class.</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, <strong>public classes should never expose mutable fields</strong>. It is less harmful, though still questionable, for public classes to expose immutable fields.</p><p>It is, however, sometimes desirable for <strong>package-private or private nested classes</strong> to <strong>expose fields</strong>, whether mutable or immutable.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-15. Minimize the accessibility of classes and members</title>
    <link href="/2023/11/18/Java/effective-java/Item15-Minimize-the-accessibility-of-classes-and-members/"/>
    <url>/2023/11/18/Java/effective-java/Item15-Minimize-the-accessibility-of-classes-and-members/</url>
    
    <content type="html"><![CDATA[<h1 id="Item-15-Minimize-the-accessibility-of-classes-and-members"><a href="#Item-15-Minimize-the-accessibility-of-classes-and-members" class="headerlink" title="Item 15: Minimize the accessibility of classes and members"></a>Item 15: Minimize the accessibility of classes and members</h1><p>The single most important factor that distinguishes a well-designed component from a poorly designed one is the degree to which <strong>the component hides its internal data and other implementation details from other components</strong>.</p><p>A well-designed component <strong>hides all its implementation details, cleanly separating its API from its implementation</strong>. Components then <strong>communicate only through their APIs</strong> and are oblivious to each others’ inner workings. This concept, known as <em>information hiding</em> or <em><strong>encapsulation</strong></em>, is a fundamental tenet of software design.</p><h2 id="The-importance-of-information-hiding"><a href="#The-importance-of-information-hiding" class="headerlink" title="The importance of information hiding"></a>The importance of <em>information hiding</em></h2><ul><li><p>It <em><strong>decouples</strong></em> the components that comprise a system, allowing them to be developed, tested, optimized, used, understood, and modified <strong>in isolation</strong>. This speeds up system development because components can be developed in parallel.</p></li><li><p>It eases the burden of <strong>maintenance</strong> because components can be understood more quickly and debugged or replaced with little fear of harming other components.</p><blockquote><p>Once a system is complete and profiling has determined which components are causing performance problems (Item 67), those components can be optimized without affecting the correctness of others.</p></blockquote></li><li><p>It increases software <strong>reuse</strong> because components that aren’t tightly coupled often prove useful in other contexts besides the ones for which they were developed.</p></li><li><p>It decreases the risk in building large systems because individual components may prove successful even if the system does not.</p></li></ul><h2 id="Approach-to-aid-in-information-hiding-access-control"><a href="#Approach-to-aid-in-information-hiding-access-control" class="headerlink" title="Approach to aid in information hiding - access control"></a>Approach to aid in information hiding - <em>access control</em></h2><p>The <em>access control</em> mechanism specifies the <em>accessibility</em> of classes, interfaces, and members. The accessibility of an entity is determined by the <strong>location of its declaration</strong> and by which, if any, of the <strong>access modifiers</strong> (<code>private</code>, <code>protected</code>, and <code>public</code>) is present on the declaration. Proper use of these modifiers is essential to information hiding.</p><h3 id="Specific-rules-for-classes"><a href="#Specific-rules-for-classes" class="headerlink" title="Specific rules for classes"></a>Specific rules for classes</h3><p>The rule of thumb is simple: <strong>make each class or member as inaccessible as possible.</strong> In other words, <strong>use the lowest possible access level</strong> consistent with the proper functioning of the software that you are writing.</p><p>If a top-level class or interface can be made package-private, it should be. By making it <strong>package-private</strong>, you make it part of the implementation rather than the exported API, and <strong>you can modify it, replace it, or eliminate it in a subsequent release without fear of harming existing clients</strong>. If you make it public, you are obligated to support it forever to maintain compatibility.</p><p>If a package-private top-level class or interface is used by <strong>only one class</strong>, consider making the top-level class <strong>a private static nested class</strong> of the sole class that uses it (Item 24).</p><blockquote><p>But it is far more important to reduce the accessibility of a <strong>gratuitously public class</strong> than of a package-private top-level class: the public class is part of the package’s API, while the package-private top- level class is already part of its implementation.</p></blockquote><h3 id="Specific-rules-for-members"><a href="#Specific-rules-for-members" class="headerlink" title="Specific rules for members"></a>Specific rules for members</h3><p>For members (fields, methods, nested classes, and nested interfaces), there are four possible access levels, listed here in order of increasing accessibility:</p><ul><li><strong>private</strong>—The member is accessible only from the top-level class where it is declared.</li><li><strong>package-private</strong>—The member is accessible from any class in the package where it is declared. Technically known as <em>default</em> access, this is the access level you get if no access modifier is specified (except for interface members, which are public by default).</li><li><strong>protected</strong>—The member is accessible from subclasses of the class where it is declared (subject to a few restrictions [JLS, 6.6.2]) and from any class in the package where it is declared.</li><li><strong>public</strong>—The member is accessible from anywhere.</li></ul><p>After carefully designing your class’s <strong>public API</strong>, your reflex should be to make all other members <strong>private</strong>. Only if another class in the same package really needs to access a member should you remove the private modifier, making the member package-private.</p><blockquote><p>These fields can, however, “leak” into the exported API if the class implements <code>Serializable</code> (Items 86 and 87).</p></blockquote><h4 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h4><p>If a method <strong>overrides a superclass method</strong>, it <strong>cannot</strong> have a <strong>more restrictive access level</strong> in the subclass than in the superclass. This is necessary to ensure that an instance of the subclass is usable anywhere that an instance of the superclass is usable (the <em>Liskov substitution principle</em>).</p><h4 id="Members-of-public-classes"><a href="#Members-of-public-classes" class="headerlink" title="Members of public classes"></a>Members of public classes</h4><p>For members of public classes, a huge increase in accessibility occurs when the access level goes from <strong>package-private</strong> to <strong>protected</strong>. A protected member is part of the class’s exported API and must be supported forever. Also, a protected member of an exported class represents a public commitment to an implementa- tion detail (Item 19). <strong>The need for protected members should be relatively rare.</strong></p><p><strong>Instance fields of public classes should rarely be public</strong> (Item 16). If an instance field is <strong>nonfinal</strong> or is a reference to a mutable object, then by making it public, you <strong>give up the ability to limit the values</strong> that can be stored in the field. Also, you <strong>give up the ability to take any action when the field is modified</strong>, so classes with public mutable fields are <strong>not</strong> generally <strong>thread-safe</strong>.</p><blockquote><p>Even if a field is <strong>final</strong> and refers to an immutable object, by making it public you <strong>give up the flexibility to switch to a new internal data representation</strong> in which the field does not exist.</p></blockquote><h4 id="Array-field"><a href="#Array-field" class="headerlink" title="Array field"></a>Array field</h4><p>Note that a nonzero-length array is always mutable, so <strong>it is wrong for a class to have a public static final array field, or an accessor that returns such a field.</strong> If a class has such a field or accessor, clients will be able to modify the contents of the array. This is a frequent source of security holes:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Potential security hole!</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Things[] VALUES = &#123; ... &#125;;<br></code></pre></td></tr></table></figure><p>Beware of the fact that some IDEs generate accessors that return references to pri- vate array fields, resulting in exactly this problem.</p><h5 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h5><p>You can make the public array private and add a public immutable list:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;Thing&gt; VALUES =<br>    Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));<br></code></pre></td></tr></table></figure><h5 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h5><p>Alternatively, you can make the array private and add a public method that returns a copy of a private array:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Thing[] values() &#123;<br>   <span class="hljs-keyword">return</span> PRIVATE_VALUES.clone();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>As of Java 9, there are two additional, implicit access levels introduced as part of the <em>module system</em>.</p><p>A module may explicitly export some of its packages via <em>export declarations</em> in its <em>module declaration</em> (which is by convention contained in a source file named <code>module-info.java</code>).</p><p>Public and protected members of unexported packages in a module are inaccessible outside the module; within the module, accessibility is unaffected by export declarations. Using the module system allows you to <strong>share classes among packages within a module without making them visible to the entire world</strong>.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To summarize, you should reduce accessibility of program elements as much as possible (within reason).</p><p>After carefully designing a <strong>minimal public API</strong>, you should prevent any stray classes, interfaces, or members from becoming part of the API.</p><p>With the exception of public static final fields (which serve as constants), <strong>public classes should have no public fields</strong>. Ensure that objects referenced by public static final fields are immutable.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浪潮之巅读书笔记4-信息产业的发展规律</title>
    <link href="/2023/11/17/book-notes/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85/IT-laws/"/>
    <url>/2023/11/17/book-notes/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85/IT-laws/</url>
    
    <content type="html"><![CDATA[<h1 id="信息产业的生态链"><a href="#信息产业的生态链" class="headerlink" title="信息产业的生态链"></a>信息产业的生态链</h1><h2 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h2><p>计算机和整个IT行业的发展比传统工业要快得多。比尔·盖茨说，如果汽车工业能够像计算机领域一样发展，那么今天，买一辆汽车只需要25美元，一升汽油能跑400公里。</p><p>英特尔公司的创始人戈登·摩尔(Gordon Moore) 博士最早看到了这个现象。在1965年，他就提出，至多在10年内，集成电路的集成度会每两年翻一番。后来，大家把这个周期缩短到18个月。</p><p>当今世界经济的前五大行业，即<strong>金融、IT(包括电信)、医疗和制药、能源及日用消费品</strong>，只有IT一个行业能够以持续翻番的速度进步。在人类文明史上，还没有任何其他行业能够做到这一点。</p><p>和任何其他商品相比，制造IT产品所需的原材料非常少，成本几乎是零。IT行业硬件的成本主要是<strong>制造设备的成本和研发成本</strong>。</p><h3 id="摩尔定律主导着IT行业的发展"><a href="#摩尔定律主导着IT行业的发展" class="headerlink" title="摩尔定律主导着IT行业的发展"></a>摩尔定律主导着IT行业的发展</h3><p><strong>首先，为了不断提升芯片性能，IT公司必须在比较短的时间内完成下一代产品的开发。这</strong>就要求IT公司在研发上必须投入大量的资金，这使得每个产品的市场都不会有太多的竞争者。</p><blockquote><p>在美国，主要IT市场大都只有一大一小两个主要竞争者。比如，在计算机处理器芯片方面，只有英特尔和AMD两家;在高性能图形处理器(GPU)方面，只有英伟达一家;在手机处理器方面，只有高通(Qualcomm)、三星、苹果和华为旗下的海思这几家(后两家只自用，不外卖)，而它们使用的都还是ARM公司设计好的系统结构。</p></blockquote><p><strong>其次，由于有了强有力的硬件支持，以前想都不敢想的应用会不断涌现。</strong></p><blockquote><p>比如，20多年前，将高清晰度电影(1920×1080分辨率)数字化的计算量连IBM的大型机也无法胜任;现在，一台笔记本大小的索尼游戏机就可以做到，而新的一代电视机则能播放4K(即4000线的分辨率)的视频节目了。</p><p>这就为一些新兴公司的诞生创造了条件。比如，在2000年以前，不会有人想办一家YouTube这样的公司，因为那时候网络的速度无法满足在网上看录像的要求，而现在YouTube已经融入了许多人的生活。</p></blockquote><p><strong>第三，摩尔定律使得各个公司现在的研发必须针对多年后的市场。</strong></p><blockquote><p>在 Google内部，每一次基础架构(Infrastructure)的升级，都要按照目前计算能力和存储量的10倍来设计，因为达到那个水平，不过是三四年的时间，这在传统行业是无法想象的。</p></blockquote><p>从1965年到2019年，摩尔定律历经了半个多世纪的时光。在未来的20年里，工程师们考虑的将是在<strong>单位能耗</strong>的基础上争取让处理器的性能和容量翻番，而不是简单地追求每一颗芯片本身性能的翻番。</p><blockquote><p>英伟达和Google的人工智能芯片就是很好的例子，它们在机器学习等领域可以将单位能耗的计算能力提高近千倍。与50年前不同的是，今天各种处理器无所不在，它们消耗了大量的能源，而在50年前，半导体芯片耗能总量在全球能源消耗中的占比非常低。因此，在未来我们依然能看到摩尔定律给我们带来的惊喜。</p></blockquote><h2 id="安迪-比尔定律"><a href="#安迪-比尔定律" class="headerlink" title="安迪 - 比尔定律"></a>安迪 - 比尔定律</h2><p>摩尔定律给所有的计算机消费者带来一个希望，即如果我今天嫌计算机太贵买不起，那么我等18个月就可以用一半的价钱来买。要真是这么简单的话，计算机的销售量就上不去了。想要买计算机的人会多等几个月，已经有计算机的人也没有动力更新计算机。其他的IT产品也将是如此。IT行业也就成了传统行业，没有什么发展了。</p><p>是什么动力促使人们不断地主动更新自己的硬件呢？IT界把它总结成安迪–比尔定律，它的原话是“比尔要拿走安迪所给的 (<strong>What Andy gives， Bill takes away.</strong>)。”</p><blockquote><p>安迪是英特尔公司已故的带有传奇色彩的CEO安迪·格鲁夫 (Andy Grove)，而比尔是微软公司创始人比尔·盖茨。</p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在过去的40多年里，英特尔处理器的处理速度每18个月翻一番，计算机内存和硬盘的容量则以更快的速度增长。但是，微软的操作系统和应用软件却越来越慢，也越做越大。所以，现在的计算机虽然比10年前快了100倍，软件的运行速度感觉上还是和以前差不多。</p><p>为什么操作系统和应用软件越做越大？是因为现在的软件开发人员不再像二三十年前那样精打细算了。用汇编语言编程，工作效率是极低的，而且写出来的程序可读性很差，不符合软件工程的要求，也无法完成越来越复杂的功能。今天，有了足够的硬件资源，软件工程师做事情更讲究开发效率、程序的规范化和可读性，等等。</p><blockquote><p>另外，由于人工成本的提高，为了节省软件工程师编写和调试程序的时间，编程语言越来越好用，同时执行效率却越来越低。比如，今天的那些脚本语言比十年前用的Java效率低得多，Java则比C++效率低得多，C++又比30多年前的C效率低。因此，即使是同样功能的软件，今天的比昨天的占用硬件资源多就在所难免。</p></blockquote><h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p>虽然用户很是反感新的软件把硬件提升所带来的好处几乎全部用光了，但是在IT领域，各个硬件厂商恰恰是靠软件开发商用光自己提供的硬件资源得以生存的。</p><h4 id="PC时代产业格局：WinTel"><a href="#PC时代产业格局：WinTel" class="headerlink" title="PC时代产业格局：WinTel"></a>PC时代产业格局：WinTel</h4><p><strong>个人电脑工业的整个生态链</strong>：以微软为首的软件开发商吃掉硬件提升带来的全部好处，迫使用户更新机器，让惠普和戴尔等公司受益，而这些PC厂商再向英特尔等半导体公司订购新的芯片，同时向希捷等外设厂商购买新的外设。</p><blockquote><p>软件开发商-&gt;PC厂商-&gt;芯片厂商&amp;外设厂商</p></blockquote><p>在安迪–比尔定律中，“安迪”像是个天使，他总在不断给用户更多的东西，而“比尔”则像是个魔鬼，总和大家做对。但是，如果比尔这个魔鬼消失了，安迪就不复存在了。</p><p>从2011年开始，由于个人电脑产业受到移动智能设备的冲击而不再景气，软件厂商在PC上更新旧软件和开发新软件的动力就不足。在人们通常的想象中，如果软件不再占用更多的资源，硬件还在进步，我们应该感到计算机越来越快，越来越好用才对，但这件事情并没有发生。</p><p>个人电脑进步慢，是因为它性能的提升压力减小了。在Windows 7之后，微软在PC上也没有做出什么新产品，用了几十年的 Office功能和过去还是差不多。这样一来，英特尔就不再重视个人电脑处理器性能的提升了，它在这方面主要是做改进工作，然后将科研的重点转到了服务器的处理器以及其他产品上了。</p><blockquote><p>在IT工业的产业链中，处于上游的是“看不见摸不着”的软件和IT服务业，而下游才是“看得见摸得着”的硬件和半导体。因此，从事IT业，<strong>要想获得高额利润，就得从上游入手</strong>。从微软，到Google，再到Facebook，无不如此。唯一的例外是苹果公司，它是通过硬件实现软件的价值，因为在过去10多年里它的产品已经成为了一种时尚和潮流。</p></blockquote><h4 id="智能手机时代产业格局：Android-ARM"><a href="#智能手机时代产业格局：Android-ARM" class="headerlink" title="智能手机时代产业格局：Android-ARM"></a>智能手机时代产业格局：Android-ARM</h4><p>有趣的是，在手机领域，魔鬼比尔还存在，天使安迪不得不努力工作，于是十多年下来此消彼长，今天手机的很多功能，特别是图像处理功能，已经超过了PC。</p><p>2007年，Google成立了安卓(Android)联盟，它包括世界上一大半处理器芯片制造商、手机厂商和移动运营商，其核心是围绕开源的安卓手机操作系统，打造一个开放而兼容的移动通信产业。</p><p>很快一个类似于当年WinTel的格局就形成了。只不过起到当年微软 Windows作用的是Google的<strong>Android</strong>，而高通、博通和美满电子这一大两小的基于 <strong>ARM</strong> (Advanced RISC Machine)的手机芯片公司起到了当年英特尔和AMD的作用。这个格局可以描述成 Android-ARM，甚至可以简单地把它看成是2.0版的安迪–比尔定律。</p><blockquote><p>随后三星和海思(华为的半导体子公司)取代了博通和美满电子，小米、华为和OPPO &#x2F;vivo在手机市场分到了一杯羹。</p></blockquote><h2 id="反摩尔定律"><a href="#反摩尔定律" class="headerlink" title="反摩尔定律"></a>反摩尔定律</h2><p>Google前CEO埃里克·施密特(Eric Schmidt)在一次采访中指出，如果你反过来看摩尔定律，<strong>一个IT公司如果今天和18个月前卖掉同样多的、同样的产品，它的营业额就要降一半</strong>。</p><h3 id="消极影响"><a href="#消极影响" class="headerlink" title="消极影响"></a>消极影响</h3><p>对于IT公司而言，反摩尔定律是非常可怕的，因为一个IT公司付出同样的劳动，却只得到以前一半的收入。<strong>反摩尔定律逼着所有的硬件设备公司都必须赶上摩尔定律规定的更新速度</strong>。事实上，所有的硬件和设备生产商活得都非常辛苦。</p><h3 id="积极影响"><a href="#积极影响" class="headerlink" title="积极影响"></a>积极影响</h3><p><strong>它促成了科技领域质的进步，并为新兴公司提供生存和发展的可能。</strong></p><p>和所有事物的发展一样，IT领域的技术进步也有量变和质变两种。比如说，同一种处理器在系统结构上没有太大变化，而只是主频提高了，这种进步就是量变的进步。当处理器由16位上升到32位，再到64位时，就有了小的质变。如果哪一天能用到纳米技术或生物技术，那么就做到了质的飞跃，半导体的集成度会有上百倍的提高。为了赶上摩尔定律预测的发展速度，光靠量变是不够的。每一种技术，过不了多少年，量变的潜力就会被挖掘光，这时就必须要有革命性的创造发明诞生。</p><p>在科技进步<strong>量变的过程中，新的小公司是无法和老的大公司竞争的</strong>，因为后者在老的技术方面拥有无与伦比的优势。</p><blockquote><p>比如，木工厂出身的诺基亚在老式模拟手机上是无法和传统的通信设备老大摩托罗拉竞争的。</p></blockquote><p>但是，在<strong>抓住质变的机遇上，有些小公司会做得比大公司更好而后来居上</strong>，因为它们没有包袱，也比大公司灵活。</p><blockquote><p>2015年后，当3G手机逐步取代2G手机时，PC时代不起眼的三星公司一跃成为全球最大的智能手机厂商，而过去没有做过手机的华为，以前默默无闻的小米和OPPO&#x2F;vivo也及时踏上安卓的快船。苹果和众多安卓手机厂商把诺基亚这个2G时代的龙头老大逼上了当年摩托罗拉的老路。这也是硅谷等新兴地区出现了众多新技术公司的原因。</p></blockquote><blockquote><p>数字电话传输率本身限制在64kbit&#x2F;s，因此调制解调器的传输率最大到56kbit&#x2F;s就到顶了。但是，到了上个世纪90年代后期，出现了DSL技术，可以将电话线上的数据传输速度提高近200倍，斯坦福大学的约翰·查菲教授带着自己的几个学生，办起了一家做DSL的小公司Amati，之后以4亿美元的高价把Amati公司卖给了德州仪器。在调制解调器发展的量变阶段，不会出现Amati这样的小公司，即使出现了，也无法和德州仪器竞争。但是，一旦调制解调器速度接近原有的极限，能够突破这个极限的新兴公司就有机会登上历史的舞台。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Book Notes</category>
      
      <category>浪潮之巅</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-14. Consider implmenting Comparable</title>
    <link href="/2023/11/17/Java/effective-java/Item14-Consider-implementing-Comparable/"/>
    <url>/2023/11/17/Java/effective-java/Item14-Consider-implementing-Comparable/</url>
    
    <content type="html"><![CDATA[<h2 id="Item-14-Consider-implementing-Comparable"><a href="#Item-14-Consider-implementing-Comparable" class="headerlink" title="Item 14: Consider implementing Comparable"></a>Item 14: Consider implementing <em>Comparable</em></h2><p>If you are writing <strong>a value class with an obvious natural ordering</strong>, such as alphabetical order, numerical order, or chronological order, you should implement the <code>Comparable</code> interface:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T t)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="General-contract-of-compareTo-method"><a href="#General-contract-of-compareTo-method" class="headerlink" title="General contract of compareTo method"></a>General contract of <em>compareTo</em> method</h2><p>Compares this object with the specified object for order.</p><p>Returns a <strong>negative integer, zero, or a positive integer</strong> as this object is <strong>less than, equal to, or greater than</strong> the specified object.</p><p>Throws <code>ClassCastException</code> if the specified object’s type prevents it from being compared to this object.</p><ul><li><p>The implementor must ensure that <code>sgn(x.compareTo(y)) == -sgn(y. compareTo(x))</code> for all x and y.</p></li><li><p>The implementor must also ensure that the relation is transitive: <code>(x. compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0)</code> implies <code>x.compareTo(z) &gt; 0</code>.</p></li><li><p>Finally, the implementor must ensure that <code>x.compareTo(y) == 0</code> implies that <code>sgn(x.compareTo(z)) == sgn(y.compareTo(z))</code>, for all z.</p></li><li><p>It is strongly recommended, but not required, that <code>(x.compareTo(y) == 0) == (x.equals(y))</code>.</p><p>Generally speaking, any class that implements the <code>Comparable</code> interface and violates this condition should <strong>clearly indicate this fact</strong>. The recommended language is “Note: This class has a natural ordering that is inconsistent with equals.”</p></li></ul><h2 id="compareTo-and-equals"><a href="#compareTo-and-equals" class="headerlink" title="compareTo and equals"></a><em>compareTo</em> and <em>equals</em></h2><p>Unlike the <code>equals</code> method, which imposes a global equivalence relation on all objects, <code>compareTo</code> <strong>doesn’t have to work across objects of different types</strong>: when confronted with objects of different types, <code>compareTo</code> is permitted to throw <code>ClassCastException</code>.</p><p>Writing a <code>compareTo</code> method is similar to writing an <code>equals</code> method, but there are a few key differences. Because the <code>Comparable</code> interface is parameterized, the <code>compareTo</code> method is statically typed, so you <strong>don’t need to type check or cast its argument</strong>. If the argument is of the wrong type, the invocation won’t even compile. If the argument is null, the invocation should throw a <code>NullPointerException</code>, and it will, as soon as the method attempts to access its members.</p><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>If a class has <strong>multiple significant fields</strong>, the order in which you compare them is critical. Start with <strong>the most significant field</strong> and work your way down.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Multiple-field Comparable with primitive fields</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(PhoneNumber pn)</span> &#123;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Short.compare(areaCode, pn.areaCode);<br>   <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>)  &#123;<br>       result = Short.compare(prefix, pn.prefix);<br>       <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>)<br>           result = Short.compare(lineNum, pn.lineNum);<br>&#125;<br>   <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>In Java 8, the <code>Comparator</code> interface was outfitted with a set of <em>comparator construction methods</em>, which enable fluent construction of comparators. These comparators can then be used to implement a <code>compareTo</code> method, as required by the <code>Comparable</code> interface.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Comparable with comparator construction methods</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR =<br>       comparingInt((PhoneNumber pn) -&gt; pn.areaCode)<br>         .thenComparingInt(pn -&gt; pn.prefix)<br>         .thenComparingInt(pn -&gt; pn.lineNum);<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(PhoneNumber pn)</span> &#123;<br>   <span class="hljs-keyword">return</span> COMPARATOR.compare(<span class="hljs-built_in">this</span>, pn);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>There are also comparator construction methods for object reference types. The static method, named <code>comparing</code>.</p></blockquote><h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a><em>Comparator</em></h2><p>If a class does not implement <code>Comparable</code> or you need a nonstandard ordering, use a <code>Comparator</code> instead.</p><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Comparator based on static compare method</span><br> <span class="hljs-keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;&gt;() &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;<br>     <span class="hljs-keyword">return</span> Integer.compare(o1.hashCode(), o2.hashCode());<br>   &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, whenever you implement a value class that has a sensible ordering, you should have the class implement the <code>Comparable</code> interface so that <strong>its instances can be easily sorted, searched, and used in comparison-based collections.</strong> </p><p>When comparing field values in the implementations of the <code>compareTo</code> methods, avoid the use of the &lt; and &gt; operators. Instead, use the <strong>static <code>compare</code> methods</strong> in the boxed primitive classes or the <strong>comparator construction methods</strong> in the <code>Comparator</code> interface.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浪潮之巅读书笔记3-苹果与微软</title>
    <link href="/2023/11/16/book-notes/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85/Apple-and-Microsoft/"/>
    <url>/2023/11/16/book-notes/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85/Apple-and-Microsoft/</url>
    
    <content type="html"><![CDATA[<h1 id="Apple"><a href="#Apple" class="headerlink" title="Apple"></a>Apple</h1><h2 id="大事记"><a href="#大事记" class="headerlink" title="大事记"></a>大事记</h2><p>1976 苹果计算机公司成立，推出Apple I个人电脑。</p><p>1977 推出第一款系列个人电脑Apple II。</p><p>1984 推出采用图像视窗界面操作系统的麦金托什(Macintosh)电脑。</p><p>1985 乔布斯和新CEO斯卡利开始权力斗争，前者失败离开苹果公司。</p><p>1994 苹果告微软的视窗操作系统抄袭麦金托什操作系统，官司最终和解。</p><p>1997 乔布斯以顾问的身份回到苹果公司，经过权力斗争，1997年9月接管了多年亏损的公司;同年，与微软的官司以微软注资苹果而得到和解。</p><p>1998 iMac诞生，苹果重新盈利。</p><p>2001 iPod诞生，颠覆了音乐产业。</p><p>2007 iPhone诞生，颠覆了整个手机行业。</p><p>2010 iPad诞生，同年苹果公司的市值再次超过微软，成为全球最值钱的IT公司。</p><p>2011 苹果创始人乔布斯去世，此前，他将CEO一职交给了蒂姆·库克，同年苹果超过埃克森美孚石油公司，成为全球市值最高的公司。</p><p>2015 苹果公司推出智能手表Apple Watch。</p><p>2018 苹果公司的市值一度突破1万亿美元，成为有史以来第一个达到这个市值规模的西方公司。</p><h2 id="苹果的发展"><a href="#苹果的发展" class="headerlink" title="苹果的发展"></a>苹果的发展</h2><h3 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h3><p>麦金托什是世界上第一款普通老百姓买得起、拥有交互式图形界面并且使用鼠标的个人电脑。</p><p>但苹果走了一条封闭的道路，不允许别人制造兼容机，后来导致市场越来越小。但苹果将计就计，走高端产品路线，避免了与微软、戴尔和惠普的正面竞争。慢慢地，苹果的产品成了时尚的象征。</p><blockquote><p>不过乔布斯后来在苹果电脑中逐渐采用了英特尔的通用处理器，同时采用FreeBSD作为新的苹果操作系统内核。用相对开放的体系吸引全社会大量有兴趣的开源工程师，让他们能很容易地为苹果开发软件。</p></blockquote><h3 id="iPod"><a href="#iPod" class="headerlink" title="iPod"></a>iPod</h3><p>上个世纪最后10年，以互联网和多媒体技术为核心的一场技术革命开始了。随着声音和图像压缩技术的出现，数字化了的音乐和录像很容易在互联网上传播。同时，市场上出现了一些小型音乐播放器。</p><p>乔布斯看到了两点最重要的事实:</p><ul><li><p>第一，虽然已经有了不少音乐播放器，但是做得都不好，尤其是在音乐数量多了以后，查找和管理都很难。从一千首歌里面顺序找到自己想听的可能要花几分钟时间。另外，要将几十张CD上的歌曲导到播放器上更是麻烦。</p><p>解决：</p><ul><li>2000年3月，苹果公司收购SoundJam，在此基础上开发了iTunes软件，并于2001年1月发布。</li><li>2001年10月，苹果公司又推出了iPod音乐播放器，并在次年发布的第二代iPod上采用了手转圈划动查找音乐的方法，用户很快就能找到自己要听的歌曲。</li><li>同时，iTunes可与iPod无缝对接，自动将电脑和光盘上的音乐传到iPod中。</li><li>另外，iPod充电一次，播放时长可达10小时，比以往的各种播放器都要长得多。苹果iPod的外观设计非常漂亮，一经推出，就俘获了大批爱听音乐的年轻人。</li></ul></li><li><p>第二，广大用户已经习惯戴着耳机从播放器中听歌而不是随身带着便携的CD唱机和几十张光盘。因此，它不需要花钱和时间培养出一个市场。</p></li></ul><h3 id="iPhone"><a href="#iPhone" class="headerlink" title="iPhone"></a>iPhone</h3><p>iPod彻底改变了音乐市场，而iPhone继而颠覆了通信行业。制造手机本来是摩托罗拉和诺基亚这些公司的事情，和计算机公司似乎无关。但是随着手机中信号处理的重要性逐渐下降，或者说这些技术难点已经不存在了，打电话的功能在逐渐淡化；性能的要求、上网的需求在上升，智能手机制造商开始崛起。最早的智能手机代表是黑莓手机(Blackberry)，制造该手机的RIM公司一度垄断了智能手机市场，接下来是诺基亚。它们的智能手机基本上还没有摆脱传统手机的框框，手机加上E-mail的功能，只是比传统的手机好用些。</p><p>但是，智能手机到了乔布斯的手里，就完全不同了。它已经超出一个普通手机加iPod播放器，它还具有一个完整的、联网的计算机和一般电视机的主要功能。</p><h3 id="iPad"><a href="#iPad" class="headerlink" title="iPad"></a>iPad</h3><p>2010年，苹果公司又推出了极具人气的iPad触摸型平板电脑，可以通过触摸输入文字和指令来上网或使用各种应用软件，对PC产业同样具有颠覆性，是颠覆整个PC工业生态链(WinTel体系)的重要一环。</p><p>从功能上讲，iPad可以替代90%，甚至更多我们对个人电脑的需求。而且，iPad方便易用，在大多数场合，我们更倾向于使用iPad，而不是台式计算机甚至笔记本电脑。</p><h3 id="最近"><a href="#最近" class="headerlink" title="最近"></a>最近</h3><p>乔布斯去世后苹果真正自主发布的第一款产品新 iPad(即iPad 3)的销路并不是很好，2012年，苹果公司在美国以半价回购iPad 2，希望对新版iPad销售有所提振。iPad 3的优点不如大家想象的明显，但是使用起来明显烫手这个产品缺陷，乔布斯还在世的话是一定不会允许出现的。</p><p>从2010年开始，外界就在期待苹果公司能推出可穿戴式设备—一智能手表，竞争对手也都先后推出了各种各样的智能手表。直到2015年，苹果才推出市场反应并不算良好的Apple Watch，但至今它都没有能够成为该公司主要的收入增长点。</p><p>此后，苹果一直在靠每年翻新一次苹果手机挣老用户的钱。今天，苹果依然是全球市值最高的公司之一，但是它不断推出新产品的黄金期已经过去了。</p><h2 id="乔布斯与盛田昭夫"><a href="#乔布斯与盛田昭夫" class="headerlink" title="乔布斯与盛田昭夫"></a>乔布斯与盛田昭夫</h2><p>乔布斯退学后，继续在学校旁听自己感兴趣的课，比如书法课。事实证明，乔布斯的艺术修养使得苹果公司所有的产品都设计得非常漂亮。比如 Macintosh 计算机漂亮的界面和字体。</p><p>上个世纪八九十年代，工作站很红火，乔布斯在被逐出苹果公司后创立了一家设计制造工作站的公司NeXT，不是很成功。1986年，乔布斯用500万美元买下了电影《星球大战》导演卢卡斯创办的一个极不成功的动画制作室，将它重构成一个用图形工作站做动画的工作室Pixar公司，这是今天世界上最好的动画工作室，后来被迪士尼公司以74亿美元的高价收购。乔布斯从Pixar挣到的钱比他从苹果挣到的还多。</p><p>苹果的每一款产品都非它的原创，但是，苹果把每一款产品做到了极致，这很大程度上是因为乔布斯达到了一个将技术和艺术结合得炉火纯青的境界。</p><p>“当键盘越变越好用的时候，乔布斯想要的却是另一个东西:只有屏幕，没有键盘的电脑”。这些想法导致了后来的麦金托什和iPad。可见乔布斯这些改变世界的发明绝非一时的灵感所致，而是数十年的深思熟虑和经验的积累。</p><p>当第一次看到CD的时候，乔布斯拿起一张，里面也就只存5首歌。他把CD插进硕大的播放器，回来后穿过董事会的桌子，对大家说，看，这个东西会成为未来！那个年代，他已经在琢磨里面的内容(音乐)意味着什么。<strong>他的远见，经常穿透时间，直接看到他想象中的结果。</strong>从现在看，也是乔布斯，通过他的产品iPod，一手把CD送往终点。从见到CD到iPod问世，又是20年的时间，看似是灵机一动，岂不知已经孕育了两个十年。</p><p>乔布斯安在洛斯加托斯的家，是一座很大的西班牙式建筑。院子里停着一辆黑色的宝马自行车(他极少碰那辆车，只是喜欢它的设计)，偌大的房间里，只有餐桌和旁边的两把椅子，加上客厅里的一架白色的Bösendorfer三角钢琴。房间里面空空荡荡，因为对产品品质格外偏执的乔布斯几乎看不上任何家具。这就是他生活的样子，简单，少量，专注。</p><p>而盛田昭夫是上个世纪70年代的乔布斯。或者说乔布斯是21世纪初期的盛田昭夫。</p><p>在苹果进入i十年以前，索尼公司在电子产品上的地位和今天的苹果相当，这在很大程度上是盛田昭夫的功劳。作为优秀的产品设计者，盛田昭夫直接领导了Walkman随声听的设计和开发，这款听音乐的产品当时在世界上的轰动效应完全抵得上后来的iPod。</p><p>作为领导者的盛田昭夫，是少有的能够和西方人无隔阂沟通的东方人，兼具东方式的文雅谦和与西方式的坦诚直白，打动了许多西方的企业家和政治家。在盛田昭夫的努力下，索尼不仅成为日本第一个被全球认可，同时在美国上市的公司，而且把索尼从一个简单的日本制造的公司变成引领全球电子产品时尚的跨国公司。</p><p>乔布斯和盛田昭夫有很多相似之处。首先，两个人都有着<strong>通过产品改变人们生活</strong>的远大抱负。两个人又都有着无穷的好奇心和与凡人不同的新思维，导致两家公司不断推出出众而广为人知的新产品。两个人都将品牌视为生命，乔布斯对产品品质的执著和苛刻自不必说，而盛田昭夫一生为“让索尼享誉全球”而工作。</p><p>盛田昭夫和乔布斯另一个有趣的相似之处是都不看重学历。乔布斯自己辍学不必说了，盛田昭夫虽然是大阪大学的毕业生，但是在用人上一直强调注重个人能力而非学业背景。他还为此写了一本《学历无用论》的书，从上个世纪60年代起多次再版，成为畅销书。</p><p>另一方面，乔布斯和盛田昭夫的经历和为人又有很大的不同。盛田昭夫作为家族企业盛田酒业原本的继承人，虽然经历了二战后的贫困，但作为社会上层人士，给人留下的总是积极向上的活力和可亲品行。乔布斯是个被遗弃的孤儿，从小品行乖张，同时对别人缺乏信任。盛田昭夫和他的合作伙伴、索尼的另一位创始人井深大一辈子兄弟般的友谊一直被业界誉为美谈。</p><h2 id="摘抄与思考"><a href="#摘抄与思考" class="headerlink" title="摘抄与思考"></a>摘抄与思考</h2><p>关于股票期权制度：在传统的公司里，一个员工的薪酬福利包括奖金和退休金等现金。一般员工并不拥有公司的一部分。很多高科技公司为了将员工的利益和公司的前途绑在一起，发给员工一些股票的期权。所谓期权(Option)就是在一定时间，比如十年内，按一定价格，比如当前市场价购买股票的权利。获得期权的员工，会对公司有主人翁般的责任感。如果公司股价上涨，那么拥有股票期权的人可以以过去较低的价格买进股票，即所谓的行权(Exercise)，然后以现在较高的价格卖出，从中赚到差价。当然，期权只有在公司股价不断上涨时才有意义。</p><p>在乔布斯做的大多数“改变世界”的事情中，原创并非他自己，但是拿着魔术棒“点石成金”的人却是他。如果我们承认乔布斯的创作力，那么创新就远不止是原创，而更多的是发现价值，点石成金。</p><p>大多数产品经理之所以做不出改变世界的产品，是因为他们只看见了成功者最后的临门一脚，而忽视了别人的长期思考。</p><p>永远渴望，大智若愚。 Stay Hungry, Stay Foolish.</p>]]></content>
    
    
    <categories>
      
      <category>Book Notes</category>
      
      <category>浪潮之巅</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-13. Override clone judiciously</title>
    <link href="/2023/11/16/Java/effective-java/Item13-Override-clone-judiciously/"/>
    <url>/2023/11/16/Java/effective-java/Item13-Override-clone-judiciously/</url>
    
    <content type="html"><![CDATA[<h1 id="Item-13-Override-clone-judiciously"><a href="#Item-13-Override-clone-judiciously" class="headerlink" title="Item 13: Override clone judiciously"></a>Item 13: Override <em>clone</em> judiciously</h1><p>The <code>Cloneable</code> interface was intended as a <em>mixin interface</em> (Item 20) for classes to advertise that they permit cloning. Unfortunately, it fails to serve this purpose. Its primary flaw is that it lacks a <code>clone</code> method, and <em>Object</em>’s <code>clone</code> method is protected.</p><blockquote><p>You cannot, without resorting to <em>reflection</em> (Item 65), invoke clone on an object merely  because it implements <code>Cloneable</code>. Even a reflective invocation may fail, because there is no guarantee that the object has an accessible <code>clone</code> method.</p></blockquote><h2 id="Effect-of-Cloneable"><a href="#Effect-of-Cloneable" class="headerlink" title="Effect of Cloneable"></a>Effect of <em>Cloneable</em></h2><p>It determines the behavior of <em>Object</em>’s protected <code>clone</code> implementation: if a class implements <code>Cloneable</code>, <em>Object</em>’s <code>clone</code> method returns a <strong>field-by-field copy of the object</strong>; otherwise it throws <code>CloneNotSupportedException</code>.</p><blockquote><p>This is a highly atypical use of interfaces and not one to be emulated. Normally, implementing an interface says something about what a class can do for its clients. In this case, it modifies the behavior of a protected method on a superclass.</p></blockquote><p><strong>In practice, a class implementing</strong> <strong><code>Cloneable</code></strong> <strong>is expected to provide a properly functioning public</strong> <strong><code>clone</code></strong> <strong>method.</strong></p><h2 id="General-contract-of-clone"><a href="#General-contract-of-clone" class="headerlink" title="General contract of clone"></a>General contract of <em>clone</em></h2><p>Creates and returns a copy of this object. The precise meaning of “copy” may depend on the class of the object.</p><ul><li><code>x.clone() != x</code> will be true</li><li><code>x.clone().getclass() == x.getclass()</code> will be true</li><li><code>x.clone().equals(x)</code> will be true</li><li>By convention, the object returned by this method should be obtained by calling <code>super.clone()</code>.</li><li>By convention, <strong>the returned object should be independent of the object being cloned</strong>. To achieve this independence, it may be necessary to modify one or more fields of the object returned by super.clone before returning it.</li></ul><blockquote><p>If a class’s clone method returns an instance that is <em>not</em> obtained by calling <code>super.clone</code> but by calling a constructor, the compiler won’t complain, but if a subclass of that class calls <code>super.clone</code>, the resulting object will have the wrong class.</p></blockquote><h2 id="How-to-implment-clone-method"><a href="#How-to-implment-clone-method" class="headerlink" title="How to implment clone method"></a>How to implment <em>clone</em> method</h2><h3 id="1-Immutable-class"><a href="#1-Immutable-class" class="headerlink" title="1. Immutable class"></a>1. Immutable class</h3><p><strong>Immutable classes should never provide a</strong> <strong><code>clone</code></strong> <strong>method</strong> because it would merely encourage wasteful copying.</p><h3 id="2-Class-with-no-references-to-mutable-state"><a href="#2-Class-with-no-references-to-mutable-state" class="headerlink" title="2. Class with no references to mutable state"></a>2. Class with no references to mutable state</h3><p>First impelement <code>Cloneable</code> interface.</p><p>The <code>clone</code> method would look like:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Clone method for class with no references to mutable state</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PhoneNumber <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> (PhoneNumber) <span class="hljs-built_in">super</span>.clone();<br>  &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(); <span class="hljs-comment">// Can&#x27;t happen</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Class-with-fields-that-refer-to-mutable-objects"><a href="#3-Class-with-fields-that-refer-to-mutable-objects" class="headerlink" title="3. Class with fields that refer to mutable objects"></a>3. Class with fields that refer to mutable objects</h3><p>Example: the <em>Stack</em> class in Item 7</p><p>If simply call <code>super.clone()</code>, its <em>elements</em> field will refer to the <strong>same array</strong> as the original <em>Stack</em> instance.</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>Call <code>clone</code> recursively on the <em>elements</em> array:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Clone method for class with no references to mutable state</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Stack <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Stack</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (Stack) <span class="hljs-built_in">super</span>.clone();<br>    result.elements = elements.clone();<br>    <span class="hljs-keyword">return</span> result;<br>  &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>Note that we do not have to cast the result of elements.clone to Object[]. Calling clone on an array returns an array whose runtime and compile-time types are identical to those of the array being cloned. This is the preferred idiom to duplicate an array. In fact, <strong>arrays are the sole compelling use of the clone facility</strong>.</li><li>Note also that the earlier solution would not work if the elements field were <strong>final</strong> because clone would be prohibited from assigning a new value to the field. This is a fundamental problem: like serialization, <strong>the</strong> <strong><code>Cloneable</code></strong> <strong>architecture is incompatible with normal use of final fields referring to mutable objects</strong>. In order to make a class cloneable, it may be necessary to remove final modifiers from some fields.</li></ol></blockquote><h3 id="4-Class-with-inner-class"><a href="#4-Class-with-inner-class" class="headerlink" title="4. Class with inner class"></a>4. Class with inner class</h3><p>Example: HashTable implemented using its own linked list</p><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>Add a <code>deepCopy</code> method to the inner class.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Iteratively copy the linked list headed by this Entry</span><br>Entry <span class="hljs-title function_">deepCopy</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">Entry</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value, next);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> result; p.next != <span class="hljs-literal">null</span>; p = p.next)<br>    p.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(p.next.key, p.next.value, p.next.next);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>clone</code> method of <em>HashTable</em> class:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> HashTable <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">HashTable</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (HashTable) <span class="hljs-built_in">super</span>.clone();<br>    result.buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[buckets.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; buckets.length; i ++)<br>      <span class="hljs-keyword">if</span> (buckets[i] != <span class="hljs-literal">null</span>)<br>        result.buckets[i] = buckets[i].deepCopy();<br>    <span class="hljs-keyword">return</span> result;<br>  &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>Call <code>super.clone</code>, set all of the fields in the resulting object to their <strong>initial state</strong>, and then call higher-level methods to regenerate the state of the original object.</p><p>In the case of our HashTable example, the buckets field would be initialized to a new bucket array, and the put(key, value) method would be invoked for each key-value mapping in the hash table being cloned.</p><blockquote><p>It is antithetical to the whole Cloneable architecture because it blindly overwrites the field-by-field object copy that forms the basis of the architecture.</p></blockquote><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p>Like a constructor, a <code>clone</code> method must <strong>never invoke an overridable method on the clone</strong> under construction (Item 19). If clone invokes a method that is overridden in a subclass, this method will execute before the subclass has had a chance to fix its state in the clone, quite possibly leading to corruption in the clone and the original.</p><blockquote><p>Therefore, the put(key, value) method discussed in the previous paragraph should be either final or private. (If it is private, it is presumably the “helper method” for a nonfinal public method.)</p></blockquote></li><li><p><em>Object</em>’s <code>clone</code> method is declared to throw <code>CloneNotSupportedException</code>, but overriding methods need not. <strong>Public</strong> <strong><code>clone</code></strong> <strong>methods should omit the</strong> <strong>throws</strong> <strong>clause</strong>, as methods that don’t throw checked exceptions are easier to use (Item 71).</p></li><li><p>You have two choices when designing a <strong>class for inheritance</strong> (Item 19), but whichever one you choose, the class <strong>should <em>not</em> implement <code>Cloneable</code>.</strong></p><ul><li><p>You may choose to mimic the behavior of <em>Object</em> by <strong>implementing a properly functioning protected <code>clone</code> method that is declared to throw <code>CloneNotSupportedException</code>.</strong> This gives subclasses the freedom to implement Cloneable or not, just as if  dthey extended <em>Object</em> directly.</p></li><li><p>Alternatively, you may choose <strong><em>not</em> to implement a working <code>clone</code> method</strong>, and to <strong>prevent subclasses from implementing</strong> one, by providing the following <strong>degenerate <code>clone</code></strong> implementation:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// clone method for extendable class not supporting Cloneable</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CloneNotSupportedException</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>If you write a <strong>thread-safe class</strong> that implements Cloneable, remember that its <strong><code>clone</code> method must be properly synchronized</strong>, just like any other method (Item 78). <em>Object</em>’s clone method is not synchronized.</p></li></ol><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>To recap, all classes that implement <code>Cloneable</code> should override <code>clone</code> with a public method whose <strong>return type is the class itself</strong>. This method should first <strong>call <code>super.clone</code></strong>, then <strong>fix any fields</strong> that need fixing.</p><p>Typically, this means copying any mutable objects that comprise the internal “deep structure” of the object and replacing the clone’s references to these objects with references to their copies.</p><p>If the class contains only primitive fields or references to immutable objects, then it is likely the case that no fields need to be fixed. There are exceptions to this rule. For example, a field representing a serial number or other unique ID will need to be fixed even if it is primitive or immutable.</p><h2 id="Better-approaches-to-object-copying"><a href="#Better-approaches-to-object-copying" class="headerlink" title="Better approaches to object copying"></a>Better approaches to object copying</h2><p><strong>A better approach to object copying is to provide a <em>copy constructor</em> or <em>copy factory</em>.</strong></p><p>A copy constructor is simply a constructor that takes a single argument whose type is the class containing the constructor, for example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Copy constructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Yum</span><span class="hljs-params">(Yum yum)</span> &#123; ... &#125;;<br></code></pre></td></tr></table></figure><p>A copy factory is the static factory (Item 1) analogue of a copy constructor:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Copy factory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Yum <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Yum yum)</span> &#123; ... &#125;;<br></code></pre></td></tr></table></figure><h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><ul><li><p>they don’t rely on a risk-prone extralinguistic object creation mechanism;</p></li><li><p>they don’t demand unenforceable adherence to thinly documented conventions;</p></li><li><p>they don’t conflict with the proper use of <strong>final fields</strong>;</p></li><li><p>they don’t throw unnecessary <strong>checked exceptions</strong>;</p></li><li><p>they don’t require <strong>type casts</strong>.</p></li><li><p>a copy constructor or factory can take <strong>an argument</strong> whose type is <strong>an interface implemented by the class</strong>.</p><blockquote><p>For example, suppose you have a HashSet, s, and you want to copy it as a TreeSet. The clone method can’t offer this functionality, but it’s easy with a conversion constructor: new TreeSet&lt;&gt;(s).</p></blockquote></li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Given all the problems associated with <code>Cloneable</code>, new <strong>interfaces</strong> should not extend it, and new <strong>extendable classes</strong> should not implement it.</p><p>While it’s less harmful for <strong>final classes</strong> to implement <code>Cloneable</code>, this should be viewed as a performance optimization, reserved for the rare cases where it is justified (Item 67).</p><p>As a rule, <em>copy</em> functionality is best provided by <strong>constructors or factories</strong>.</p><blockquote><p>A notable exception to this rule is <strong>arrays</strong>, which are best copied with the <code>clone</code> method.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浪潮之巅读书笔记2-硅谷</title>
    <link href="/2023/11/15/book-notes/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85/silicon-valley/"/>
    <url>/2023/11/15/book-notes/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85/silicon-valley/</url>
    
    <content type="html"><![CDATA[<h1 id="“八叛徒”与硅谷"><a href="#“八叛徒”与硅谷" class="headerlink" title="“八叛徒”与硅谷"></a>“八叛徒”与硅谷</h1><h2 id="肖克利半导体公司"><a href="#肖克利半导体公司" class="headerlink" title="肖克利半导体公司"></a>肖克利半导体公司</h2><p>1947年，肖克利发现了半导体P-N结的单向导电等诸多特性，并利用这一原理发明了晶体管。同 时巴丁和布拉顿也发现了一种三极管。从此，人类进人半导体时代。这三名科学家后来获得了诺贝尔物理学奖，那也是贝尔实验室所获得的众多诺贝尔奖中的第一个。</p><p>1956年，肖克利搬到加州的山景城，以便照顾住在帕洛阿尔托乡下的母亲。他的朋友贝克曼出资，肖克利在加州办起了自己的实验室一一肖克利半导体实验室(Shockley Semiconductor Laboratory)，专门研制和生产肖克利所发明的半导体。</p><p>他主动打电话邀请了诺伊斯和摩尔等英才加入，而大家愿意追随他，完全是出于对这位大发明家的崇拜，对这一点，后来发明集成电路的诺伊斯讲得很清楚。</p><p>肖克利是个非常有个性的科学家，很难共事，贝尔实验室的同事都知道他的这一不足之处，以至于大家不愿意跟随他创业。公司办到第二年，摩尔等七人实在忍受不了肖克利的独裁作风，打算集体“叛逃”，在“叛逃”之前他们去劝说公司的二号人物诺伊斯和他们一起走。出乎他们的意料，诺伊斯马上爽快地答应了，因为他也在肖克利手底下受够了。</p><h2 id="仙童公司"><a href="#仙童公司" class="headerlink" title="仙童公司"></a>仙童公司</h2><h3 id="“八叛徒”"><a href="#“八叛徒”" class="headerlink" title="“八叛徒”"></a>“八叛徒”</h3><p>诺伊斯和摩尔等人准备离开肖克利的公司另起炉灶单干，但是却没有资金。如果放在今天，以他们八个人的水平，很容易找到风险投资。但是在1957年，今天意义上的风险投资并不存在，融资并不容易。</p><p>阿瑟·洛克(Arthur Rock)和老板科伊尔(Alfred Coyle)对新兴的半导体很有兴趣，于是说服了自己的，两人一起来到旧金山和诺伊斯等人会面。在听了这八个人对未来将要开始的一场电子工业革命的描述后，洛克和科伊尔动了心。</p><blockquote><p>不过，由于来得匆忙，洛克和科伊尔根本没有准备合同，甚至没有带办公用纸，所幸的是科伊尔脑子转得很快，当即掏出10张一美元的钞票，放在桌子上。”接下来，信息行业伟大的时刻来到了，诺伊斯、摩尔、洛克和科伊尔等10人分别在这10张钞票上签了名。这10张钞票后来很多已经丢失，但其中的一张保存在斯坦福大学图书馆里，成为硅谷诞生的历史见证。</p></blockquote><p>IBM当时最大的股东菲尔柴尔德家族愿意投资半导体技术。在说服菲尔柴尔德的过程中，诺伊斯是这样形容未来的半导体产业的一一这些本质上是沙子和金属导线的基本物质将使未来晶体管材料的成本趋近于零，于是竞争将转向制造工艺，如果菲尔柴尔德投资，他将赢得这场竞争。届时，廉价的晶体管将使得消费电子产品的成本急剧下降，以至于制造它们比修理它们更便宜。</p><p>八个人委托洛克设计了未来公司的股权结构：公司分为1325股，诺伊斯等人每人100股，洛克和科伊尔所在的海登–斯通投资公司(Hayden， Stone &amp; Co.)占225股，剩下300股留给公司日后的管理层和员工。菲尔柴尔德给即将成立的公司一笔138万美元的18个月贷款，作为回报条件，他虽然不占股，但是拥有对公司的决策权(投票权)，并目有权在8年内的任何时间以300万美元的价格收购所有股份。</p><p>1957年9月18日，他们八人向肖克利提交了辞职报告，这一天后来被《纽约时报》称为人类历史上10个最重要的日子之一，因为他们将创办一个伟大的公司，开创一个巨大的产业。但是，这对肖克利来讲却是无法忍受的。肖克利当时大怒，称他们为“八叛徒”(Traitorous Eight) ，因为在肖克利这位旧式科学家看来，他们的行为不同于一般的辞职，而是学生背叛老师。在加入公司之前，这八个人除了诺伊斯有一些晶体管的研究经验外，其他人都是在他的指导下才掌握了晶体管技术，因此在他看来这如同欺师灭祖。</p><h3 id="蒸蒸日上"><a href="#蒸蒸日上" class="headerlink" title="蒸蒸日上"></a>蒸蒸日上</h3><p>由于技术先进以及菲尔柴尔德和IBM的关系，仙童拿到了大量晶体管合同，确立了它在世界半导体行业的领先地位。</p><p>1959年，菲尔柴尔德根据协议回购了全部的股份。诺伊斯等每人大约获得了25万美元，这在当时是相当大的一笔钱，抵得上他们半辈子的工资。</p><blockquote><p>不过没有了公司股权，诺伊斯等人最终是要和菲尔柴尔德分手的，只不过当时公司快速发展，业绩掩盖了一切潜在的矛盾。</p></blockquote><h3 id="集成电路"><a href="#集成电路" class="headerlink" title="集成电路"></a>集成电路</h3><p>当时用来制造晶体管的半导体锗容易破碎，而目热稳定性较差。为了解决这个问题，诺伊斯等人就尝试用非常结实的硅来取代锗。相比锗，硅太硬，不好加工。最后霍尔尼的小组发明了一种平面工艺，可以将硅加工成晶体管。使用这种工艺，仙童公司制造出很可靠的硅三极管，而且成本下降很多。</p><blockquote><p>步骤：</p><ol><li>将设计好的晶体管内部的电路拍照</li><li>复制很多份，铺在一个平面上</li><li>把硅片放到底版(阻光膜)下面，用光照在上面进行光刻。这样就在硅片上一次刻出很多个三极管</li><li>把刻好的一个个三极管切割下来进行封装</li></ol></blockquote><p>1958年，诺伊斯从霍尔尼的平面工艺中受到启发。他在想，与其把一个个晶体管的硅片切割下来，让生产线上的女工们用细小的镊子在放大镜下装上导线，封装成一个个晶体管成品，最后等到制造电子设备时再将一个个晶体管焊到电路板上，还不如将电子设备的所有电路和一个个元件都制成底版，然后刻在一个硅片上。就这样，诺伊斯发明了集成电路。</p><p>集成电路的发明改变了世界。和过去的分立元件电路相比，集成电路不仅体积小，重量轻，可靠性高，而目它的性能可以呈指数提升(即摩尔定律)。</p><h3 id="不断拆分"><a href="#不断拆分" class="headerlink" title="不断拆分"></a>不断拆分</h3><p>早在1959年，当仙童公司的投资人菲尔柴尔德收回公司股权之后，总经理(当时还不习惯于使用CEO一词)爱德华·鲍德温(Edward Baldwin) 就带领八名员工创办了自己的半导体公司Rheem，Rheem也成为仙童公司下出的第一枚“金蛋”。</p><p>当鲍德温等人离开仙童后，不断有人也离开仙童出去创业，而诺伊斯也不断吸引新的人才加入，这种进出的平衡维持了一段时间，终于随着一位重量级创始人的离开而打破，这个人就是“八叛徒”之一的拉斯特。不过，拉斯特等人的离开虽然让仙童公司损失巨大，却也促成了该公司所在的旧金山湾区整个地区半导体产业的发展。后来这个地区便成长为今天人们熟知的硅谷。</p><p>在诺伊斯等人发明了集成电路之后的头两年里，集成电路的制造成本比较高，以至于放弃掉原有的晶体管业务单独发展集成电路是无法挣钱的。仙童的老板菲尔柴尔德和公司内的高管在公司的业务上就发生了严重的分歧。以“八叛徒”之一的拉斯特为代表的一部分经理认为应该优先发展集成电路，并且在做新的一年的预算时，提出应该优先建一个制造集成电路的工厂。而菲尔柴尔德则认为应该优先制造当时技术成熟市场需求更大的晶体管，并且首先将钱用于扩大晶体管的产能。1961年，拉斯特拉上“八叛徒”中的霍尔尼和罗伯茨在洛克和Teledyne公司的支持下创办了Amelco半导体公司。Amelco和它的母公司Teledyne很快成为了美国军方(包括航天工业)重要的半导体器件提供商，并且直接和仙童公司竞争。</p><p>1968年，诺伊斯和摩尔希望发展超大规模集成电路，即将过去很多小规模的集成电路集成到一个芯片中，这样对顾客有很大的好处，而作为公司老板的菲尔柴尔德则希望多卖芯片。如果将十个芯片减少为一个芯片，仙童公司短期内的收入必然会减少。最终，诺伊斯和摩尔发现在这家他们创办的公司中，两人已经没有发言权了，就干脆离开仙童，创办了一家新的半导体公司——英特尔公司。</p><p>就在诺伊斯和摩尔离开仙童之后，“八叛徒”中的另外两个人格里尼克和布兰克也陆续离开了，至此，仙童公司的传奇画上了句号。它对世界半导体产业的影响力就此结束，一个时代终结了。</p><p>仙童公司成就半导体产业的做法听起来匪夷所思，它并非靠自身发明了多少产品，创造了多大的市场，而是靠不断地分离出子公司和孙公司，让半导体公司在旧金山湾区遍地开花。截止到2017年，从仙童公司直接和间接分离出去的大中型公司多达近百家，它们包括英特尔、AMD等知名公司。另外，苹果公司第三位创始人、公司第一任董事长马库拉也来自于仙童公司。这些公司的市值加起来接近30000亿美元。可以说，旧金山湾区之所以能成为硅谷，很大程度上是因为有了仙童公司。（区域经济）</p><h2 id="摘抄与思考"><a href="#摘抄与思考" class="headerlink" title="摘抄与思考"></a>摘抄与思考</h2><p>肖克利以及诺伊斯等八个人一起创造了“八叛徒”这个词。此后，“叛徒”这个词在硅谷的文化中成了褒义词，它代表着一种叛逆传统的创业精神。这种精神不仅缔造了硅谷的传奇，而目激励着硅谷的几代人不断调整传统，勇于开拓未来。</p><p>诺伊斯在正式成为仙童公司的总经理之后，吸取了肖克利的教训，努力营造一种轻松的工作氛围和没有等级差异的公司文化。在这样的氛围里，上下级之间只是分工不同而已，没有传统公司里那种发号施令和服从的关系，而是可以自由争论的合作关系。员工之间可以充分信任，对现有的员工来讲可以激励他们工作的主动性，对于外部的人才则可以将他们吸引进公司。（对硅谷工作氛围的影响）</p><p>仙童公司股权结构的问题（菲尔柴尔德将股权全部收走）直接导致了鲍德温等人的离职创业。当创始团队和管理团队不拥有公司的股份时，他们除了在经济利益上与公司老板会有冲突外，在管理上出现矛盾时，没有股权的前者也缺乏话语权。</p><p>信息时代企业的一个重要特征：一家公司很难也没有必要像工业时代那样通过拥有生产资料来把大家组织到一起了，另立门户的成本非常低。这也促成了硅谷的另一种文化——从现有的著名公司中离职，直接创业。（信息产业生产资料的可获得性造成了它与传统工业的本质区别）</p><h1 id="硅谷的出现"><a href="#硅谷的出现" class="headerlink" title="硅谷的出现"></a>硅谷的出现</h1><p>硅谷为什么出现在旧金山湾区，这里面有很多巧合的因素，而那些巧合的背后，又有着必然的联系。在诸多因素中，有三个因素具有决定性。</p><ol><li>1951年，斯坦福大学的特曼教授为了帮助大学解决财政问题，提议大学拿出2.7平方公里(600多英亩)土地创立了斯坦福工业园(今天叫做斯坦福研究园)，吸引来很多高科技公司。</li><li>1952年，IBM在旧金山南部100公里的圣荷西市建立了西海岸研究实验室，即今天的IBM爱曼登研究中心(Almanden Research Center)，让远离东部科技中心的北加州地区有机会站在了科技产业前沿。</li><li>有能够不断生出“金蛋”的仙童公司，在当地孕育出完整的半导体产业，当然这同时也伴随着仙童公司最终的解体。在这个过程中，拉斯特等创始人的离开使得半导体技术的扩散和仙童公司的解体变得无法逆转。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Book Notes</category>
      
      <category>浪潮之巅</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-12. Always override toString</title>
    <link href="/2023/11/15/Java/effective-java/Item12-Always-override-toString/"/>
    <url>/2023/11/15/Java/effective-java/Item12-Always-override-toString/</url>
    
    <content type="html"><![CDATA[<h1 id="Item-12-Always-override-toString"><a href="#Item-12-Always-override-toString" class="headerlink" title="Item 12: Always override toString"></a>Item 12: Always override <em>toString</em></h1><p>While <em>Object</em> provides an implementation of the <em>toString</em> method, the string that it returns is generally not what the user of your class wants to see. It consists of <strong>the class name</strong> followed by an “at” sign (<strong>@</strong>) and the unsigned hexadecimal representation of the <strong>hash code</strong>, for example, <code>PhoneNumber@163b91</code>.</p><p>The general contract for <em>toString</em> says:</p><ul><li>The returned string should be “a <strong>concise but informative</strong> representation that is easy for a person to read.”</li><li>It is recommended that <strong>all subclasses</strong> override this method.</li></ul><p>While it isn’t as critical as obeying the equals and hashCode contracts (Items 10 and 11), <strong>providing a good</strong> <strong>toString</strong> <strong>implementation makes your class much more pleasant to use and makes systems using the class easier to debug</strong>.</p><blockquote><p>The toString method is automatically invoked when an object is passed to <strong>println</strong>, <strong>printf</strong>, the string concatenation operator (<strong>+</strong>), or <em><strong>assert</strong></em>, or is printed by a debugger. </p></blockquote><h2 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h2><p><strong>When practical, the</strong> <strong>toString</strong> <strong>method should return</strong> <strong>all</strong> <strong>of the interesting information contained in the object</strong>. Ideally, the string should be self-explanatory.</p><blockquote><p>It is impractical if the object is large or if it contains state that is not conducive to string representation. Under these circumstances, <em>toString</em> should return a <strong>summary</strong>.</p></blockquote><h2 id="Important-decision"><a href="#Important-decision" class="headerlink" title="Important decision"></a>Important decision</h2><p>One important decision you’ll have to make when implementing a <em>toString</em> method is <strong>whether to specify the format of the return value in the documentation</strong>.</p><p>It is recommended that you do this for <em><strong>value classes</strong></em>, such as phone number or matrix.</p><blockquote><p>If you specify the format, it’s usually a good idea to provide a matching <strong>static factory</strong> or <strong>constructor</strong>, so programmers can easily translate back and forth between the <strong>object</strong> and <strong>its string representation</strong>.</p></blockquote><h3 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h3><p>It serves as a standard, unambiguous, human-readable representation of the object. This representation can be used for input and output and in persistent human-readable data objects, such as CSV files.</p><h3 id="Disadvantage"><a href="#Disadvantage" class="headerlink" title="Disadvantage"></a>Disadvantage</h3><p>Once you’ve specified it, you’re stuck with it for life, assuming your class is widely used. Programmers will write code to parse the representation, to generate it, and to embed it into persistent data. If you change the representation in a future release, you’ll break their code and data, and they will yowl.</p><p>By choosing not to specify a format, you preserve the flexibility to add information or improve the format in a subsequent release.</p><h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><ol><li><p>Whether or not you decide to specify the format, <strong>you should clearly document your intentions.</strong></p><p>If you specify the format, you should do so precisely. Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Returns the string representation of this phone number.</span><br><span class="hljs-comment">* The string consists of twelve characters whose format is</span><br><span class="hljs-comment">* &quot;XXX-YYY-ZZZZ&quot;, where XXX is the area code, YYY is the</span><br><span class="hljs-comment">* prefix, and ZZZZ is the line number. Each of the capital</span><br><span class="hljs-comment">* letters represents a single decimal digit.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* If any of the three parts of this phone number is too small</span><br><span class="hljs-comment">* to fill up its field, the field is padded with leading zeros.</span><br><span class="hljs-comment">* For example, if the value of the line number is 123, the last * four characters of the string representation will be &quot;0123&quot;.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%03d-%03d-%04d&quot;</span>, areaCode, prefix, lineNum);<br>&#125;<br></code></pre></td></tr></table></figure><p>If you decide not to specify a format, the documentation comment should read something like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Returns a brief description of this potion. The exact details * of the representation are unspecified and subject to change, * but the following may be regarded as typical:</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &quot;[Potion #9: type=love, smell=turpentine, look=india ink]&quot;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure></li><li><p>Whether or not you specify the format, <strong>provide programmatic access to the information contained in the value returned by <em>toString</em>.</strong> </p><blockquote><p>For example, the PhoneNumber class should contain accessors for the area code, prefix, and line number.</p></blockquote><p>If you fail to do this, you <em>force</em> programmers who need this information to parse the string. Besides reducing performance and making unnecessary work for programmers, this process is error-prone and results in fragile systems that break if you change the format.</p></li></ol><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p>It <strong>makes no sense</strong> to write a <em>toString</em> method in a <strong>static utility class</strong> (Item 4). Nor should you write a <em>toString</em> method in most <strong>enum types</strong> (Item 34) because Java provides a perfectly good one for you. </p></li><li><p>You <strong>should</strong> write a <em>toString</em> method in <strong>any abstract class whose subclasses share a common string representation</strong>.</p><blockquote><p>For example, the toString methods on most collection implemen- tations are inherited from the abstract collection classes.</p></blockquote></li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To recap, override <em>Object</em>’s <em>toString</em> implementation in <strong>every instantiable class you write</strong>, unless a superclass has already done so. It makes classes much more pleasant to use and aids in debugging. The <em>toString</em> method should return a concise, useful description of the object, in an aesthetically pleasing format.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-11. Always override hashCode when you override equals</title>
    <link href="/2023/11/14/Java/effective-java/Item11-Always-override-hashCode-when-you-override-equals/"/>
    <url>/2023/11/14/Java/effective-java/Item11-Always-override-hashCode-when-you-override-equals/</url>
    
    <content type="html"><![CDATA[<h1 id="Item-11-Always-override-hashCode-when-you-override-equals"><a href="#Item-11-Always-override-hashCode-when-you-override-equals" class="headerlink" title="Item 11: Always override hashCode when you override equals"></a>Item 11: Always override <em>hashCode</em> when you override <em>equals</em></h1><h2 id="General-contract-for-hashCode"><a href="#General-contract-for-hashCode" class="headerlink" title="General contract for hashCode"></a>General contract for <em>hashCode</em></h2><ul><li>When the <em>hashCode</em> method is invoked on an object repeatedly during <strong>an execution of an application</strong>, it <strong>must consistently return the same value</strong>, provided no information used in equals comparisons is modified. This value need not remain consistent from one execution of an application to another.</li><li>If two objects are <strong>equal</strong> according to the <em>equals(Object)</em> method,then calling <em><strong>hashCode</strong></em> on the two objects must produce the <strong>same integer result</strong>.</li><li>If two objects are unequal according to the <em>equals(Object)</em> method,it is <em>not</em> required that calling hashCode on each of the objects must produce distinct results. However, the programmer should be aware that producing distinct results for unequal objects may improve the performance of hash tables.</li></ul><p><strong>The key provision that is violated when you fail to override</strong> <em><strong>hashCode</strong></em> <strong>is the second one: equal objects must have equal hash codes.</strong> Two distinct instances may be logically equal according to a class’s equals method, but to Object’s <em>hashCode</em> method, they’re just two objects with nothing much in common. Therefore, Object’s <em>hashCode</em> method returns two seemingly random numbers instead of two equal numbers as required by the contract.</p><h2 id="The-recipe-to-implement-a-good-hashCode-method"><a href="#The-recipe-to-implement-a-good-hashCode-method" class="headerlink" title="The recipe to implement a good hashCode method"></a>The recipe to implement a good <em>hashCode</em> method</h2><ol><li><p>Declare an int variable named <code>result</code>, and initialize it to the hash code <code>c</code> for the <strong>first significant field</strong> in your object, as computed in step 2.a. (Recall from Item 10 that a significant field is a field that affects equals comparisons.)</p></li><li><p>For every <strong>remaining significant field</strong> <code>f</code> in your object, do the following: </p><p>a. Compute an int hash code <code>c</code> for the field:</p><ol><li><p>If the field is of a primitive type, compute <code>Type.hashCode(f)</code>, where Type is the boxed primitive class corresponding to <code>f</code>’ s type.</p></li><li><p>If the field is an <strong>object reference</strong> and this class’s <em>equals</em> method compares the field by recursively invoking <em>equals</em>, <strong>recursively invoke hashCode on the field</strong>.</p><p>If a more complex comparison is required, compute a “canonical representation” for this field and invoke hashCode on the canonical representation. If the value of the field is null, use 0 (or some other constant, but 0 is traditional).</p></li><li><p>If the field is an array, treat it as if each significant element were a separate field. That is, compute a hash code for each significant element by applying these rules recursively, and combine the values per step 2.b. If the array has no significant elements, use a constant, preferably not 0. If all elements are significant, use <code>Arrays.hashCode</code>.</p></li></ol><p>b. Combine the hash code c computed in step 2.a into result as follows: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">result = <span class="hljs-number">31</span> * result + c;<br></code></pre></td></tr></table></figure><blockquote><p>Makes the result depend on the <strong>order</strong> of the fields, yielding a much better hash function if the class has multiple similar fields.</p></blockquote></li><li><p>Return result.</p></li></ol><p>Example for the <code>PhoneNumber</code> class:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Typical hashCode method</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Short.hashCode(areaCode);<br>  result = <span class="hljs-number">31</span> * result + Short.hashCode(prefix);<br>  result = <span class="hljs-number">31</span> * result + Short.hashCOde(lineNum);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Exclude <em>derived fields</em> from the hash code computation.</p></blockquote><blockquote><p>While the recipe in this item yields reasonably good hash functions, they are not state-of-the-art. They are comparable in quality to the hash functions found in the Java platform libraries’ value types and are adequate for most uses. If you have a bona fide need for hash functions <strong>less likely to produce collisions</strong>, see Guava’s <code>com.google.common.hash.Hashing</code> [Guava].</p></blockquote><h3 id="Objects-hash-static-method"><a href="#Objects-hash-static-method" class="headerlink" title="Objects.hash static method"></a>Objects.hash static method</h3><p>The <em>Objects</em> class has a static method that takes an arbitrary number of objects and returns a hash code for them. This method, named <code>hash</code>, lets you write <strong>one-line</strong> hashCode methods whose quality is comparable to those written according to the recipe in this item.</p><p>Unfortunately, they <strong>run more slowly</strong> because they entail array creation to pass a variable number of arguments, as well as boxing and unboxing if any of the arguments are of primitive type. This style of hash function is recommended for use only in situations where <strong>performance is not critical</strong>. </p><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// One-line hashCode method - mediocre performance</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> Objects.hash(lineNum, prefix, areaCode);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Cache-hashCode"><a href="#Cache-hashCode" class="headerlink" title="Cache hashCode"></a>Cache hashCode</h3><p>If a class is <strong>immutable</strong> and the <strong>cost of computing the hash code is significant</strong>, you might consider <strong>caching</strong> the hash code in the object rather than recalculating it each time it is requested.</p><p>If you believe that most objects of this type will be used as <strong>hash keys</strong>, then you should calculate the hash code <strong>when the instance is created</strong>. Otherwise, you might choose to <em><strong>lazily initialize</strong></em> the hash code the first time <em>hashCode</em> is invoked. Some care is required to ensure that the class remains thread-safe in the presence of a lazily initialized field (Item 83).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// hashCode method with lazily initialized cached hash Code</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hashCode; <span class="hljs-comment">// Automatically initialized to 0</span><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> hashCode;<br>  <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>    result = Short.hashCode(areaCode);<br>    result = <span class="hljs-number">31</span> * result + Short.hashCode(prefix);<br>    result = <span class="hljs-number">31</span> * result + Short.hashCOde(lineNum);<br>    hashCode = result;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Note that the initial value for the hashCode field (in this case, 0) should not be the hash code of a commonly created instance:</p></blockquote><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p><strong>Do not be tempted to exclude significant fields from the hash code computation to improve performance.</strong> While the resulting hash function may run faster, its poor quality may degrade hash tables’ performance to the point where they become unusable.</p><p>In particular, the hash function may be confronted with a large collection of instances that differ mainly in regions you’ve chosen to ignore. If this happens, the hash function will map all these instances to a few hash codes, and programs that should run in linear time will instead run in quadratic time.</p></li><li><p><strong>Don’t provide a detailed specification for the value returned by <em>hashCode</em>, so clients can’t reasonably depend on it; this gives you the flexibility to change it.</strong> Many classes in the Java libraries, such as <em>String</em> and <em>Integer</em>, specify the exact value returned by their <em>hashCode</em> method as <em>a function of the instance value</em>. This is <em>not</em> a good idea but a mistake that we’re forced to live with: It impedes the ability to improve the hash function in future releases. If you leave the details unspecified and a flaw is found in the hash function or a better hash function is discovered, you can change it in a subsequent release.</p></li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, you <em>must</em> override <em>hashCode</em> every time you override <em>equals</em>, or your program will not run correctly. Your <em>hashCode</em> method must obey the <strong>general contract specified in <em>Object</em></strong> and must do a reasonable job assigning unequal hash codes to unequal instances. This is easy to achieve, if slightly tedious, using the <strong>recipe</strong>.</p><p>As mentioned in Item 10, the <em><strong>AutoValue</strong></em> framework provides a fine alternative to writing <em>equals</em> and <em>hashCode</em> methods manually, and <em><strong>IDEs</strong></em> also provide some of this functionality.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-10. Obey the general contract when overriding equals</title>
    <link href="/2023/11/13/Java/effective-java/Item10-Obey-the-general-contract-when-overriding-equals/"/>
    <url>/2023/11/13/Java/effective-java/Item10-Obey-the-general-contract-when-overriding-equals/</url>
    
    <content type="html"><![CDATA[<h1 id="Item-10-Obey-the-general-contract-when-overriding-equals"><a href="#Item-10-Obey-the-general-contract-when-overriding-equals" class="headerlink" title="Item 10: Obey the general contract when overriding equals"></a>Item 10: Obey the general contract when overriding <em>equals</em></h1><h2 id="Conditions-for-not-overriding-the-equals-method"><a href="#Conditions-for-not-overriding-the-equals-method" class="headerlink" title="Conditions for not overriding the equals method"></a>Conditions for <strong>not</strong> overriding the <em>equals</em> method</h2><ul><li><p><strong>Each instance of the class is inherently unique.</strong> This is true for classes such as <strong>Thread</strong> that represent active entities rather than values. The equals implementation provided by Object has exactly the right behavior for these classes.</p></li><li><p><strong>There is no need for the class to provide a “logical equality” test.</strong> For example, java.util.regex.Pattern could have overridden equals to check whether two Pattern instances represented exactly the same regular expression, but the designers didn’t think that clients would need or want this functionality. Under these circumstances, the <em>equals</em> implementation inherited from <em>Object</em> is ideal.</p></li><li><p><strong>A super class has already overridden <em>equals</em>, and the superclass behavior is appropriate for this class.</strong> For example, most <em>Set</em> implementations inherit their equals implementation from <em>AbstractSet</em>, <em>List</em> implementations from <em>AbstractList</em>, and <em>Map</em> implementations from <em>AbstractMap</em>.</p></li><li><p><strong>The class is private or package-private,and you are certain that its <em>equals</em> method will never be invoked.</strong> If you are extremely risk-averse, you can override the equals method to ensure that it isn’t invoked accidentally:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(); <span class="hljs-comment">// Method is never called</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Overriding-the-equals-method"><a href="#Overriding-the-equals-method" class="headerlink" title="Overriding the equals method"></a>Overriding the <em>equals</em> method</h2><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Adds a value component without violating the equals contract</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ColorPoint</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Point point;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Color color;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ColorPoint</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, Color color)</span> &#123;<br>     point = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(x, y);<br>     <span class="hljs-built_in">this</span>.color = Objects.requireNonNull(color);<br>  &#125;<br>  <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Returns the point-view of this color point.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> Point <span class="hljs-title function_">asPoint</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> point;<br>  &#125;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>   <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> ColorPoint))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   <span class="hljs-type">ColorPoint</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> (ColorPoint) o;<br>   <span class="hljs-keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);<br>&#125;<br>  ...  <span class="hljs-comment">// Remainder omitted</span><br>&#125;<br></code></pre></td></tr></table></figure><p>“Favor composition over inheritance.”</p><h3 id="When"><a href="#When" class="headerlink" title="When?"></a>When?</h3><p>When a class has a notion of <em>logical equality</em> that differs from mere object identity and a superclass has not already overridden equals. This is generally the case for <em>value classes.</em></p><blockquote><p>A value class is simply a class that represents a value, such as Integer or String.</p></blockquote><p>A programmer who compares references to value objects using the <em>equals</em> method expects to find out whether they are <strong>logically equivalent</strong>, not whether they refer to the same object.</p><p>Not only is overriding the equals method necessary to satisfy programmer expectations, it enables instances to serve as <strong>map keys or set elements</strong> with predictable, desirable behavior.</p><blockquote><p>One kind of value class that does <em>not</em> require the <em>equals</em> method to be overridden is a class that uses <strong>instance control</strong> (Item 1) to ensure that <strong>at most one object exists with each value</strong>. <em>Enum</em> types (Item 34) fall into this category. For these classes, logical equality is the same as object identity, so Object’s <em>equals</em> method functions as a logical equals method.</p></blockquote><h3 id="General-contract-of-overriding-equals"><a href="#General-contract-of-overriding-equals" class="headerlink" title="General contract of overriding equals"></a>General contract of overriding <em>equals</em></h3><ul><li><p><em><strong>Reflexivity</strong></em>: For any non-null reference value x, <strong>x.equals(x)</strong> must return <strong>true</strong>.</p></li><li><p><em><strong>Symmetry</strong></em>: For any non-null reference values x and  y, <strong>x.equals(y)</strong> must return true if and only if <strong>y.equals(x)</strong> returns true.</p></li><li><p><em><strong>Transitivity</strong></em>: For any non-null reference values x, y, z, if <strong>x.equals(y)</strong>  returns true and <strong>y.equals(z)</strong> returns true, then <strong>x.equals(z)</strong> must return true.</p></li><li><p><em><strong>Consistency</strong></em>: For any non-null reference values x and y, <strong>multiple invocations</strong> of x.equals(y) must consistently return true or consistently return false, provided no information used in equals comparisons is modified.</p></li><li><p><em><strong>Non-nullity</strong></em>: For any non-null reference value x, <strong>x.equals(null) must return false.</strong></p><p>Type check is enough, no need to test “if o &#x3D;&#x3D; null”. The <em>instanceof</em> operator is specified to return false if its first operand is null, regardless of what type appears in the second operand.</p></li></ul><h3 id="Recipe-for-a-high-quality-equals-method"><a href="#Recipe-for-a-high-quality-equals-method" class="headerlink" title="Recipe for a high-quality equals method"></a>Recipe for a high-quality <em>equals</em> method</h3><ol><li><p><strong>Use the</strong> <strong>&#x3D;&#x3D;</strong> <strong>operator to check if the argument is a reference to this object.</strong> If so, return true. This is just a performance optimization but one that is worth doing if the <strong>comparison is potentially expensive</strong>.</p></li><li><p><strong>Use the <em>instanceof</em> operator to check if the argument has the correct type.</strong> If not, return false. Typically, the correct type is the <strong>class</strong> in which the method occurs.</p><blockquote><p>Occasionally, it is some interface implemented by this class. Use an interface if the class implements an interface that refines the equals contract to permit comparisons across classes that implement the interface. Collection interfaces such as Set, List, Map, and Map.Entry have this property.</p></blockquote></li><li><p><strong>Cast the argument to the correct type.</strong> Because this cast was preceded by an instanceof test, it is guaranteed to succeed.</p></li><li><p><strong>For each “significant” field in the class, check if that field of the argument matches the corresponding field of this object.</strong> If all these tests succeed, return true; otherwise, return false. If the type in Step 2 is an interface, you must access the argument’s fields via interface methods; if the type is a class, you may be able to access the fields directly, depending on their accessibility.</p><p>For primitive fields whose type is not float or double, use the &#x3D;&#x3D; operator for comparisons.</p><p>For object reference fields, call the equals method recursively.</p><p>For float fields, use the static <em>Float.compare(float, float)</em> method; and for double fields, use <em>Double.compare(double, double)</em>. The special treatment of float and double fields is made necessary by the existence of Float.NaN, -0.0f and the analogous double values.</p><p>For array fields, apply these guidelines to each element. If every element in an array field is significant, use one of the Arrays.equals methods.</p><blockquote><p>Some object reference fields may <strong>legitimately contain null</strong>. To avoid the possibility of a NullPointerException, check such fields for equality using the static method <strong>Objects.equals(Object, Object)</strong>.</p></blockquote></li><li><p>The performance of the equals method may be affected by the <strong>order</strong> in which fields are compared. For best performance, you should first compare fields that are <strong>more likely to differ, less expensive to compare</strong>, or, ideally, both.</p><p>You must <strong>not compare fields that are not part of an object’s logical state</strong>, such as lock fields used to synchronize operations.</p><p>You need <strong>not compare <em>derived fields</em></strong>, which can be calculated from “significant fields,” but doing so may improve the performance of the equals method. If a derived field amounts to a summary description of the entire object, comparing this field will save you the expense of comparing the actual data if the comparison fails.</p></li><li><p>Write unit tests to check, unless you used <em>AutoValue</em> to generate your equals method, in which case you can safely omit the tests.</p></li></ol><h3 id="Final-caveats"><a href="#Final-caveats" class="headerlink" title="Final caveats"></a>Final caveats</h3><ul><li><p><strong>Always override hashCode when you override <em>equals</em></strong>(Item11).</p></li><li><p><strong>Don’t try to be too clever.</strong> If you simply test fields for equality, it’s not hard to adhere to the equals contract. If you are overly aggressive in searching for equivalence, it’s easy to get into trouble. It is generally a bad idea to take any form of aliasing into account. For example, the File class shouldn’t attempt to equate symbolic links referring to the same file. Thankfully, it doesn’t.</p></li><li><p>**Don’t substitute another type for <em>Object</em> in the <em>equals</em> declaration.**Itisnot uncommon for a programmer to write an equals method that looks like this and then spend hours puzzling over why it doesn’t work properly:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Broken - parameter type must be Object!</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(MyClass o)</span> &#123;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><p>The problem is that this method does not <em>override</em> Object.equals, whose argument is of type Object, but <em>overloads</em> it instead (Item 52).</p><p>Consistent use of the <em>@Override</em> annotation, will prevent you from making this mistake (Item 40), it won’t compile and the error message will tell you exactly what is wrong.</p></li></ul><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><p>Writing and testing equals (and hashCode) methods is tedious, and the resulting code is mundane. An excellent alternative to writing and testing these methods manually is to use <strong>Google’s open source AutoValue framework</strong>, which automatically generates these methods for you, triggered by a single annotation on the class . In most cases, the methods generated by AutoValue are essentially identical to those you’d write yourself.</p><p><strong>IDEs</strong>, too, have facilities to generate equals and hashCode methods, but the resulting source code is more verbose and less readable than code that uses AutoValue, does not track changes in the class automatically, and therefore requires testing. That said, having IDEs generate equals (and hashCode) methods is generally preferable to implementing them manually because IDEs do not make careless mistakes, and humans do.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, don’t override the <em>equals</em> method unless you have to: <strong>in many cases, the implementation inherited from Object does exactly what you want.</strong></p><p>If you do override equals, make sure to compare all of the class’s significant fields and to compare them in a manner that preserves all **five provisions of the equals contract.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浪潮之巅读书笔记1-AT&amp;T与IBM</title>
    <link href="/2023/11/13/book-notes/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85/AT&amp;T-and-IBM/"/>
    <url>/2023/11/13/book-notes/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85/AT&amp;T-and-IBM/</url>
    
    <content type="html"><![CDATA[<h1 id="AT-T"><a href="#AT-T" class="headerlink" title="AT&amp;T"></a>AT&amp;T</h1><h2 id="大事记"><a href="#大事记" class="headerlink" title="大事记"></a>大事记</h2><p>1875 贝尔和沃森发明电话。</p><p>1877 美国贝尔电话公司成立。</p><p>1880 贝尔长途电话业务开通。</p><p>1892 长途电话业务进入美国中部芝加哥地区。</p><p>1913 和美国政府达成第一次反垄断协议。</p><p>1915 电话业务进入美国西部旧金山地区。</p><p>1925 贝尔实验室成立。</p><p>1972 UNIX操作系统和C语言诞生于贝尔实验室。</p><p>1982 美国司法部打赢了长达8年的针对贝尔电话公司的反垄断官司。</p><p>1984 美国贝尔电话公司被拆成AT&amp;T和8家地区性贝尔公司。</p><p>1996 AT&amp;T主动地一分为三，包括新AT&amp;T、朗讯和NCR。</p><p>2000 朗讯的移动部门Avaya单独上市。</p><p>2001 AT&amp;T再次主动拆分，变为独立的AT&amp;T(含企业服务和个人业务)、AT&amp;T移动和AT&amp;T宽带等公司。</p><p>2004 AT&amp;T被<em>道琼斯指数</em>除名，从地区性贝尔公司发展起来的SBC替代了它在该指数中的位置。</p><p>2005 AT&amp;T被SBC并购，成为新AT&amp;T。此前，从AT&amp;T分出的几家独立公司均被竞争对手或业界同行收购。</p><p>2006 朗讯被法国的阿尔卡特并购，原来的美国贝尔电话公司(AT&amp;T)从此消亡。</p><blockquote><p>道琼斯工业指数在20世纪初包括20家上市公司，后来扩大到30家。这30家公司是美国支柱产业的大公司。因此道琼斯又称为蓝筹股(blue chips)，因为蓝色的筹码是赌局中面值最大的筹码。</p></blockquote><h3 id="详细的时间点事件"><a href="#详细的时间点事件" class="headerlink" title="详细的时间点事件"></a>详细的时间点事件</h3><p>1996年，如日中天的AT&amp;T公司重组，分离成AT&amp;T、朗讯 (Lucent Technologies)和NCR三家公司。AT&amp;T旗下举世闻名的科研机构贝尔实验室也被一分为二。朗讯公司获得了一半的科研机构和贝尔实验室的名称。划归AT&amp;T的一半研究室组成了AT&amp;T实验室(后来更名为香农实验室，Shannon Labs)。2005年，AT&amp;T被SBC公司并购，而朗讯则于2006年被法国阿尔卡特(Alcatel)公司并购。2016年，阿尔卡特–朗讯又被诺基亚收购。</p><p>1995年可以说是AT&amp;T公司的顶峰，接下来短短的10年里，它便分崩离析，不复存在了。AT&amp;T不紧不慢地向上走过了百年，才爬到顶点，走下坡路却只是短短的10年。今天我们看到的AT&amp;T实际上是由当年小贝尔公司之一的西南贝尔公司(SBC)几次以小吃大合并出的类似于水电公司的设施服务公司，这类公司在美国统称为资源服务公司，毫无技术可言。</p><p>2014年，贝尔实验室推倒了它的第一栋实验大楼，虽然目的是不再想维护那栋没有太多人使用的老楼，但是外界把这解读成一个时代的终结。有媒体评论道:“非常遗憾它被推倒了，但是更遗憾的是居然没有人觉得这算是一回事。”</p><h2 id="贝尔实验室"><a href="#贝尔实验室" class="headerlink" title="贝尔实验室"></a>贝尔实验室</h2><p>1925年，AT&amp;T公司成立了研发机构——贝尔实验室(Bell Laboratories，简称Bell Labs)。贝尔实验室是历史上最大、最成功的私有实验室。AT&amp;T公司从电信业获得了巨额的垄断利润，将**销售额的3%**用于贝尔实验室的研发工作。</p><p>在很长一段时间里，贝尔实验室总是用<strong>“无须为经费发愁”</strong>这一条理由来吸引优秀的科学家到该实验室工作，这使得贝尔实验室不仅在通信领域长期执牛耳，而且在射电天文学、晶体管和半导体、计算机科学等领域也都领先于世界，其闻名于世的发明包括<strong>射电天文望远镜、晶体管、数字交换机、计算机的UNIX操作系统和C语言</strong>等。此外，贝尔实验室还发现了电子的波动性，提出了信息论，组织发射了第一颗商用通信卫星，铺设了第一条商用光纤。</p><p>在相当长的时间内，贝尔实验室不仅仅是信息领域科学家最向往的地方，也是基础研究领域学者梦寐以求的地方。那个时代，能进入贝尔实验室的人是很幸运的。如果确有才华，他可以成为业界的领袖，甚至得到诺贝尔奖、香农奖或图灵奖。即使是一般的研究员和工程师，也会有很好的收入、可靠的退休保障及受人尊重的社会地位。</p><h2 id="AT-T衰落的原因"><a href="#AT-T衰落的原因" class="headerlink" title="AT&amp;T衰落的原因"></a>AT&amp;T衰落的原因</h2><p>不是反垄断。AT&amp;T 100年来发展得非常健康。虽然它一直受反垄断法的约束，但是美国政府司法部并没有真正要过它的命，每一次反垄断其实是帮助 AT&amp;T 修枝剪叶，让它发展得更好。</p><p>真正的原因是<strong>AT&amp;T的设备制造部门的执行官们短视地提出分家的建议</strong>。</p><h3 id="内因：华尔街和AT-T自身的贪婪和短视"><a href="#内因：华尔街和AT-T自身的贪婪和短视" class="headerlink" title="内因：华尔街和AT&amp;T自身的贪婪和短视"></a>内因：华尔街和AT&amp;T自身的贪婪和短视</h3><p>AT&amp;T几个执行官的股票远不如华尔街投资银行控制的多。事实上，AT&amp;T的总裁们非但不真正拥有公司，而且一些人的个人利益还和公司的利益有冲突。即使他们之中不乏有远见者，但是根本左右不了董事会。正是因为公司的长期利益和这些高管们没有太大关系，所以他们如果能在任期内狠狠捞一把，何乐而不为呢?至于华尔街的投资公司，关心的是手中的股票何时能翻番，关注的是时机，而1995年正是一个机会。整个股市形势很好，在这时将设备制造部门和电信服务部门分开，那么前者的股票一定会飞涨，毕竟短期内将获得Sprint和MCI的订单。华尔街看到了这一点，公司的老总们懂得这一点，公司大量拥有股权的员工也明白这一点。</p><p>随着移动通信业务的兴起，已经日渐衰落的朗讯居然再一次杀鸡取卵，将公司由那个后来在惠普做得很糟糕的女总裁卡莉·菲奥莉娜(Carly Fiorina)经手再次拆分，主要是将它的无线设备部门Avaya分出去单独上市。当然，华尔街的投资银行和朗讯的一些高管，尤其是菲奥莉娜又在已经鼓鼓的钱包中赚到了一大笔钱。</p><blockquote><p>看重短期利益而不是公司的长远发展</p></blockquote><h4 id="放弃贝尔实验室的核心竞争力"><a href="#放弃贝尔实验室的核心竞争力" class="headerlink" title="放弃贝尔实验室的核心竞争力"></a>放弃贝尔实验室的核心竞争力</h4><p>原来的贝尔实验室因为有AT&amp;T这座大靠山，从来不为经费发愁。后来，朗讯的利润已不足以养活有两万人的巨型实验室，于是开始要求那里的科学家和工程师将重心转移到<strong>能尽快赚钱的研究</strong>上来(我在以后会谈到AT&amp;T这种大实验室的弊端)。贝尔实验室此时已不是过去以研究为主的地方了，它的<strong>创新能力不复存在</strong>，从1995年起，贝尔实验室没有再搞出轰动世界的发明。</p><p>我们今天最通用的高速上网方式<strong>DSL</strong>最初诞生于贝尔实验室，但是AT&amp;T并没有把它作为今后可持续发展的利器，而是扔到了某个无人注意的角落。而曾经在贝尔实验室工作过的美国通信领域著名科学家约翰·查菲(John Cioffi)教授后来在斯坦福大学将它实用化，成为“DSL之父”。在科技发展最快的20世纪90年代，AT&amp;T浪费掉的技术和机会远不止这些。</p><h4 id="借钱给小公司买自己的设备当作销售额"><a href="#借钱给小公司买自己的设备当作销售额" class="headerlink" title="借钱给小公司买自己的设备当作销售额"></a>借钱给小公司买自己的设备当作销售额</h4><p>从MCI和Sprint带来的销售额增长几乎是一次性的。华尔街在预测朗讯盈利时，已经把这笔收入计算进去了。朗讯的股票要继续增长，它的销售额和利润就必须不断超过华尔街的预期。可是，朗讯其实根本做不到这一点。为了能支撑高股价，朗讯走了一步后来被证明是败笔的险棋。在互联网泡沫时代，有无数的中小公司在兴起，大公司在膨胀，朗讯决定“促销”自家电信设备。具体做法是由朗讯借钱给各公司来买朗讯的设备。<strong>只要设备运离公司，朗讯就在每季度的财务报表中，计入销售额。</strong>仔细读朗讯的财报，人们可以发现朗讯总有一笔很大的“应收款项”，这笔钱其实从未进到朗讯公司。2000年互联网泡沫破裂后，借钱购买设备的公司纷纷倒闭，朗讯的这笔“应收款项”一下子变成了净亏损。</p><h3 id="外因：互联网的兴起"><a href="#外因：互联网的兴起" class="headerlink" title="外因：互联网的兴起"></a>外因：互联网的兴起</h3><p>在互联网兴起以前，固定电话几乎是人类唯一的交互通信手段。互联网兴起，当人们有了一种不要钱的实时通信方式后，就没人为一分钟3美元的国际长途电话买单了。为了促销，所有的长途电话公司都不得不通过降价来维持生计。到了2004年，由于AT&amp;T公司的影响力越来越小，终于被道琼斯工业指数除名。</p><blockquote><p>取代它的SBC公司正是1984年从AT&amp;T分出去的8家小贝尔公司中最小的西南贝尔公司，经过几轮小吃大，接连兼并兄弟贝尔公司，SBC成为美国第二大电信公司。一年后，SBC再次上演蛇吞象的一幕，不过这一次它吞下了老祖母AT&amp;T，只不过SBC考虑到AT&amp;T的名气更大，新公司采用了AT&amp;T的名称。因此，今天的这个AT&amp;T已经不是当年的那个AT&amp;T了。</p></blockquote><p>互联网对朗讯的冲击也是同样的。在互联网时代，全球对<strong>数据交换设备</strong>的需求渐渐超过对语音交换设备的需求。前者是新兴公司思科的长项，而后者才是朗讯的强项。后来，像<strong>思科、华为</strong>这样的新一代电信设备公司战胜朗讯，又成为一股不可阻挡的潮流。</p><h2 id="摘抄和思考"><a href="#摘抄和思考" class="headerlink" title="摘抄和思考"></a>摘抄和思考</h2><p>在第二次世界大战期间，贝尔实验室的天才青年科学家香农提出了信息论。信息论是整个现代通信的基础，并与控制论、系统论一道，成为信息时代的科学基础。</p><p>为什么美国小公司能很快成为跨国公司？其中一个原因是<strong>反垄断法逼着公司追求技术进步</strong>。当一家公司开始垄断一个行业时，它会更多地倾向于利用自己的垄断资源，而不是靠技术进步获得更多的利润，毕竟前者比后者容易得多。</p><p>在2000年前后，短线投资者发现<strong>最快的挣钱方法不是把一家企业搞好，而是炒作和包装上市</strong>。将公司的一部分拆了卖无疑挣钱最快。（但拆分之后业务种类单一，抗风险能力降低，对公司本身或许不利）</p><p>随着AT&amp;T的没落，很多优秀的科学家和工程师，包括UNIX操作系统和C语言的发明人之一肯·汤普森(Ken Thompson)，都来到了新兴的Google公司，他们成为了Google技术的中坚。<strong>评价一家上市公司的好坏，其实只要看那些最优秀的人是流进这家公司，还是流出这家公司即可。</strong></p><p>互联网的崛起，对原贝尔实验室研究的影响也是巨大的。比如，语音的自动识别曾经被认为是人类最伟大的梦想之一，现在随着电话时代的过去也变得不重要了。今天，世界上主要的语<strong>音识别公司</strong>只剩下<strong>Nuance</strong>一家，2012年美国整个语音识别市场的规模一年只有15亿美元，不及Google半个月的收入。而同时，<strong>对文字处理、图像处理技术的需求则随着互联网的普及不断增加</strong>。（2023年是否依然如此？）</p><p>在工业史上，新技术代替旧的技术是不以人的意志为转移的。<strong>互联网对传统电话业务的冲击，就如同数码相机对胶卷制造业的冲击一样，是从根本上断绝了它的生存基础。</strong>今天，互联网虽然还不能完全代替固定电话，但是前者已经大大挤压了后者的发展空间，因为它可以提供更灵活、更丰富，而且更便宜的通信手段。</p><h1 id="IBM"><a href="#IBM" class="headerlink" title="IBM"></a>IBM</h1><p>IBM公司可能是世界上为数不多的成功逃过历次经济危机，并且在历次技术革命中实现成功转型的公司之一。在很多人的印象中，IBM仅仅是一个大型计算机制造商，并且在个人电脑和互联网越来越普及的今天，它已经过气了。其实，IBM并没有这么简单，它至今仍然是<strong>世界上最大的服务公司、第二大软件和IT服务公司、第三大数据库公司</strong>。IBM拥有当今<strong>工业界最大的实验室IBM Research</strong>(虽然规模只有贝尔实验室全盛时期的1&#x2F;10)，是<strong>世界第一的专利申请大户</strong>，另外，它还是<strong>全球最大的RISC服务器制造商</strong>。</p><h2 id="大事记-1"><a href="#大事记-1" class="headerlink" title="大事记"></a>大事记</h2><p>1924 老沃森控股原制表机公司，改名IBM。</p><p>1925 进人日本市场，此前制表机公司已经开始逐渐进人欧洲市场。</p><p>1933 IBM工程实验室成立。</p><p>1936 在罗斯福新政时，IBM获得美国政府大订单。</p><p>1940 20世纪40年代进入亚洲市场。</p><p>1943 IBM研制出真空管放大器。</p><p>1945 沃森实验室成立。</p><p>1952 小沃森成为IBM总裁，开始了快速发展的20年计算机时代。</p><p>1953 研制出使用磁鼓的计算器。</p><p>1962 IBM开始最早期的语音识别研究，是识别10个数字和加、减、乘、除等六个单词。</p><p>1964 IBM S&#x2F;360大型计算机问世。</p><p>1969 开始从事语音识别的研究。司法部对IBM展开反垄断调查。</p><p>1971 小沃森退休。</p><p>1973 江崎玲于奈(Leo Esaki)博士因在电子隧道效应上的研究为IBM获得第一个诺贝尔奖。</p><p>1981 IBM PC诞生。</p><p>1993 郭士纳执掌IBM，开创IBM的黄金十年。</p><p>1997 计算机深蓝战胜国际象棋世界冠军卡斯帕罗夫。</p><p>2005 IBM将PC业务卖给联想，从此退出PC市场。</p><p>2006 IBM和Google、亚马逊一道，成为最早提出今天云计算概念的公司。</p><p>2014 IBM将x86服务器业务卖给联想，表明它进军云计算市场的决心。</p><p>2016 IBM宣布它的Watson医疗服务机器人在癌症诊断方面达到了和人类医生99%的一致性。</p><h2 id="IBM的发展历程"><a href="#IBM的发展历程" class="headerlink" title="IBM的发展历程"></a>IBM的发展历程</h2><h3 id="机械革命"><a href="#机械革命" class="headerlink" title="机械革命"></a>机械革命</h3><p>IBM的前身：CTR公司。1911年，国际时间记录公司、计算尺公司和霍勒里斯的制表机器公司这三家公司合并，成立了计算–制表–记录公司 (Computing-Tabulating-Recording Company)。</p><p>早期的IBM，产品主要是一些办公管理用的机械，诸如打孔机、制表机等，服务对象是政府部门和企业。IBM从那时起，就锁定了政府部门和企事业单位为它的主要客户，直到今天。很多人奇怪为什么最早推出主流PC(即以英特尔处理器和微软操作系统为核心的PC)的IBM没有成为PC之王。实际上，IBM的基因决定了它不可能领导以个人用户为核心的PC产业。</p><p>1929-1933大萧条后，随着经济的恢复，办公机械的市场开始复苏。尤其是罗斯福推行新政，雇用了大量政府工作人员。政府对制表机的需求大大增加。除了正常的生意，IBM还将大量打孔机、制表机等设备卖给了德国纳粹政府。不过，IBM从未回避这段不光彩的历史。</p><p>二战中IBM还将其生产线民用转军用。IBM为军方研制了世界上第一台继电器式计算机。此外，IBM还间接地参与了研制原子弹的曼哈顿计划。</p><p>二战后，整个世界都在重建之中，对各种工业品的需求都在增加。尤其是杜鲁门总统完成了美国的社会保障制度后，有大量的统计工作需要用到制表机等机械。这一切都对IBM的核心业务给予了强有力的支持。IBM很轻易地再将生产线军用转民用。</p><h3 id="电子革命"><a href="#电子革命" class="headerlink" title="电子革命"></a>电子革命</h3><p>二战后，IBM的情况和日本类似，它显然面临着两种选择，是继续发展它的电动机械制表机，还是发展新兴的电子工业。这两派争执不下，而代表人物恰恰是沃森父子。老沃森认为电子的东西不可靠，世界上至今还有不少人持老沃森的观点。而小沃森则坚持认为电子工业是今后的发展趋势。这场争论以小沃森的胜利而告终。1952年，小沃森成为IBM的新总裁。IBM从此开始领导电子技术革命的浪潮。</p><p>IBM的小沃森认为计算机在今后的社会生活中将会扮演一个非常重要的角色，便决定投资发展计算机，并请来冯·诺伊曼做顾问。IBM还请来了很多工程师，并且把麻省理工学院作为它强大的技术支撑。小沃森将IBM的研发经费从他父亲时代公司营业额的3%增加到9%。到20世纪60年代，IBM生产出著名的 IBM System&#x2F;360 (S&#x2F;360，下文简称IBM 360)为止，IBM在计算机研制和生产上的总投入高达50亿美元，相当于整个马歇尔计划的1&#x2F;3。</p><blockquote><p>马歇尔计划，又称为欧洲复兴计划，是二战结束后美国对被战争破坏的西欧各国进行经济援助、协助重建的计划，对欧洲国家的发展和世界政治格局产生了深远的影响。该计划于1948年4月正式启动，并整整持续了4个财政年度之久。在这段时期内，西欧各国通过参加当时的欧洲经济合作组织(OECD)，总共接受了美国包括金融、技术、设备等各种形式的援助合计131.5亿美元。</p></blockquote><p>小沃森上台后短短5年，就将IBM的营业额提高了3倍。在小沃森执掌IBM的20年里，IBM的平均年增长率高达30%，这在世界上可能是绝无仅有的，他的父亲也没有做到这一点。</p><p>从20世纪70年代初到80年代初，美国司法部和IBM打了10年的<strong>反垄断</strong>官司，最终于1982年和解。一般认为，这是IBM的胜利。但是，IBM也为此付出了很大的代价。主要有两方面：</p><ol><li>IBM分出了一部分服务部门，让它们成为独立的公司；</li><li>IBM必须公开一些技术，从而导致了后来无数IBM PC兼容机公司的出现。</li></ol><h3 id="信息革命"><a href="#信息革命" class="headerlink" title="信息革命"></a>信息革命</h3><p>为了应付美国司法部提出的反垄断诉讼，卡里耗费了大量时间，但一直在密切注视着新技术的发展。对于个人电脑，IBM观望了几年。这对IBM这样一家大公司来讲是非常有必要的。IBM成功的秘诀是保守，它基本上是不见兔子不撒鹰。如果苹果公司失败了，IBM无需做任何事情。要是苹果公司成功了，IBM依靠它强大的技术储备完全可以后发制人。</p><p>IBM没有让它力量最强的沃森实验室(T. J. Watson Labs)来做这件事，而是将它交给了IBM在佛罗里达的一个十几人的小组。为了最快地研制出一台PC，这个只有十几人的小组不得不打破以前IBM包办计算机全部软硬件的习惯，而是采用了英特尔公司的 8088 芯片作为该电脑的处理器，同时委托独立软件公司为它配置各种软件。这样，仅一年之后，1981年，IBM PC就问世了。它比苹果公司的Apple系列已经好很多了，足以应付当时的字处理、编程等应用。IBM PC一上市就大受欢迎，当年就卖掉10万台，占领了3&#x2F;4的个人电脑市场。IBM在和苹果的竞争中真可谓是后发制人。直到今天，IBM PC还是个人电脑的代名词。</p><p>当时《时代周刊》评选IBM PC为20世纪最伟大的产品。《华尔街日报》也高度评价了IBM的这一贡献。但是个人电脑时代的最终领导者是微软和英特尔，而不是IBM。随着2005年IBM将个人电脑业务卖给了中国的联想公司，IBM彻底退出了个人电脑的舞台。</p><h4 id="IBM退出PC市场的原因"><a href="#IBM退出PC市场的原因" class="headerlink" title="IBM退出PC市场的原因"></a>IBM退出PC市场的原因</h4><ol><li><p><strong>IBM的基因</strong>。主要客户群基本上是政府部门、军方、银行、大企业和科研院所。IBM都是将计算机和服务绑在一起卖。</p></li><li><p><strong>反垄断的后遗症</strong>。1982年，IBM和美国司法部在反垄断官司中达成和解。和解的一个条件是，IBM得允许竞争对手发展。IBM PC很容易仿制，只好看着康柏(Compaq)、戴尔(Dell)等公司做大了。</p></li><li><p><strong>微软的崛起</strong>。</p><p>对于OS，IBM来不及自己开发，而是招标。盖茨没有让IBM买断DOS，而是从每台IBM PC中收一笔不太起眼的版权费。而且，IBM和微软签的协议中没有指明微软是否可以将DOS再卖给别人。盖茨后来抓住了这个漏洞，到处兜售DOS。</p><p>盖茨明修栈道，暗渡陈仓，一方面和IBM合作开发OS&#x2F;2，挣了一点短期的钱；另一方面下大力气开发Windows操作系统。当Windows 3.1推出时，微软帝国也就形成了。</p><blockquote><p>十几年后，硅谷一位最成功的CEO讲，凡是和微软合作的公司，最后都没有好结果。IBM也许是其中第一个吃亏的。</p></blockquote></li></ol><p>到20世纪80年代末，由于性能每18个月就翻一番，个人电脑慢慢开始胜任一些以前只有大型机才能做的工作。这样，个人电脑开始蚕食大型机的市场。1993年，IBM出现了严重的亏损，有史以来第一次开始大规模裁员。这段时期，是IBM历史上最艰难的时期。</p><h3 id="成功转型"><a href="#成功转型" class="headerlink" title="成功转型"></a>成功转型</h3><p>1993年，从未在IBM工作过的路易斯·郭士纳(Louis Gerstner)临危受命，出任IBM的首席执行官。他领导IBM从一个计算机硬件制造公司成功转变为一家以服务和软件为核心的服务型公司，复兴了这个百年老店，并开创了IBM的10年持续发展局面。</p><blockquote><p>郭士纳原来是一家食品公司的总裁，更早则任职于美国运通信用卡公司，根本不懂计算机。在英语中，计算机的芯片和薯片是一个词一一chip，因此，大家就开他的玩笑说，他也是做(芯)片的，但做的是薯片(He also made chips， but potato chips.)。这句原先是嘲笑他的话，以后成为他传奇的象征。</p></blockquote><p>郭士纳上台后的第一件事就是对IBM进行<strong>大规模改组，开源节流</strong>。他裁掉了一些冗余的部门和一些毫无前途的项目，还卖掉了一些资产。</p><p>接下来，他对公司的一些<strong>机构和制度进行改革</strong>。首先，他不声不响地将分出去的一些服务公司买回来，然后将IBM的硬件制造、软件开发和服务合成一体。在公司内部，他引入竞争机制，一个项目可能有多个组背靠背地开发。为了防止互相拆台，加强合作，郭士纳将每个人的退休金与全公司的而不是之前各部门的效益挂钩。</p><p>在研究方面，郭士纳将研发经费从营业额的9%降到6%。郭士纳砍掉了一些偏重于理论而没有效益 的研究，并且<strong>将研究和开发结合起来</strong>。一旦一个研究项目进入实用阶段，他就将整个研究组从实验室挪到产品部门。到后期，他甚至要求IBM所有的研究员必须从产品项目中挣一定的工资。为了弥补IBM的长线研究和基础研究的损失，IBM加强了和大学的合作，在几十所大学开展科研合作，或者设立奖学金。</p><p>在郭士纳的领导下，IBM很快走出了困境。IBM将自身确立为一个服务型的技术公司，并将用户群定位在企业级，而放弃了自己并不在行的终端消费者市场。</p><h2 id="评价：经营上保守，技术上创新"><a href="#评价：经营上保守，技术上创新" class="headerlink" title="评价：经营上保守，技术上创新"></a>评价：经营上保守，技术上创新</h2><p>IBM在经营上相当的保守，它一直固守自己的核心领域，很谨慎地开拓新的领域。从机械的制表机到大型计算机，到今天的Linux开源服务器，IBM始终牢牢地控制着美国政府部门、军队、大公司和银行的业务。</p><blockquote><p>保守的好处是不容易出错，因为像IBM这样服务于美国乃至世界各国核心部门的公司，产品上出一点错就会造成不可弥补的损失（美国主要银行对计算机系统的要求是一年宕机时间不能超过5分钟）。IBM这种保守的做法让大客户们很放心，因此，即使它的产品和服务比别人贵，政府和企业还是很愿意，或者说不得不用IBM的产品和服务。</p></blockquote><p>从技术上讲，IBM又是一家极富创新精神的公司。几十年来，如果说在工业界哪个实验室有资格和贝尔实验室相提并论，恐怕就只有IBM实验室了。IBM一直是美国专利大户，每年都有几千个专利，IBM用奖金和升职加薪点数来大力鼓励员工申请专利。</p><blockquote><p>但现在，IBM的很多研究员只能从研究项目中拿到一大半而不是全部的工资，另一小半必须通过参加产品项目而获得，有些单纯搞研究的科学家便不得不离开。IBM的目的非常清楚:科研必须和产品相结合。</p></blockquote><h2 id="摘抄和思考-1"><a href="#摘抄和思考-1" class="headerlink" title="摘抄和思考"></a>摘抄和思考</h2><p>IBM能成为科技界的常青树，要归功于它的二字秘诀——<strong>保守</strong>。保守让IBM失去了无数次发展机会，但是也让它能专注于做最重要的事，并因此立于不败之地。</p><p><strong>第二次世界大战可以看作是机械时代和电子时代的分水岭</strong>。英国在二战后很长时间里试图恢复它的机械工业，虽然它做到了，但是也已经落伍了。而一片焦土的日本，已经没有剩下什么工业基础了，因此另起炉灶，发展电子工业，成为世界第二经济大国，直到近几年才被中国超越。</p><p>恩格斯说过，<strong>社会的需求对科技进步的作用要超过10所大学</strong>。计算机就是在这种背景下发明出来的。美国研制计算机的直接目的是在第二次世界大战中为军方计算弹道。在流体力学中，计算量常常大到手工的计算尺无法计算的地步，因此，对通用计算机的需求就产生了。</p><p>小沃森想到将计算机从政府军方推广到民间，这一方面是他的天分，另一方面则源自IBM长期制造表格处理机械，了解这方面的需求。</p><p>从开始做计算机起，IBM基本上遵循<strong>性能优先于价格</strong>和<strong>集中式服务</strong>的原则。高性能、支持多用户的主机一直是IBM硬件制造的重点，直到20世纪90年代才略有转变。IBM的许多大型机，成为计算机系统结构设计的经典之作。</p><p>IBM的<strong>研究水平</strong>很高，还参与制定了很多标准。因此，它在商业竞争中，同时扮演着<strong>运动员和裁判员</strong>的双重角色。从20世纪50年代到80年代初，IBM在计算机领域基本上是独孤求败。（<strong>工程</strong>实验室的实用研究很重要）</p><p>上个世纪90年代，IBM和AT&amp;T走了两条截然相反的路。AT&amp;T是将一家好端端的公司拆散卖掉，IBM则是将分出去的公司整合回来，打造了一艘从硬件到软件到服务一条龙的航空母舰。从IBM和AT&amp;T的不同结果可以看出，一个有远见的经营者和一群贪婪的短期投机者在管理方针和水平上的巨大差别。</p>]]></content>
    
    
    <categories>
      
      <category>Book Notes</category>
      
      <category>浪潮之巅</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-9. Prefer try-with-resources to try-finally</title>
    <link href="/2023/11/12/Java/effective-java/Item9-Prefer-try-with-resources-to-try-finally/"/>
    <url>/2023/11/12/Java/effective-java/Item9-Prefer-try-with-resources-to-try-finally/</url>
    
    <content type="html"><![CDATA[<h1 id="Item-9-Prefer-try-with-resources-to-try-finally"><a href="#Item-9-Prefer-try-with-resources-to-try-finally" class="headerlink" title="Item 9: Prefer try-with-resources to try-finally"></a>Item 9: Prefer <em>try-with-resources</em> to <em>try-finally</em></h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>The Java libraries include many resources that must be closed manually by invok- ing a close method. Examples include InputStream, OutputStream, and java.sql.Connection.</p><p>Closing resources is often overlooked by clients, with predictably dire performance consequences. While many of these resources use finalizers as a safety net, finalizers don’t work very well (Item 8).</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="1-try-finally"><a href="#1-try-finally" class="headerlink" title="1. try-finally"></a>1. try-finally</h3><p>Historically, a try-finally statement was the best way to guarantee that a resource would be closed properly, even in the face of an exception or return.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// try-finally - No longer the best way to close resources!</span><br><span class="hljs-keyword">static</span> String <span class="hljs-title function_">firstLineOfFile</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path));<br>  <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-keyword">return</span> br.readLine();<br>   &#125; <span class="hljs-keyword">finally</span> &#123;<br>       br.close();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>But it gets worse when you add a second resource:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// try-finally is ugly when used with more than one resource!</span><br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(String src, String dst)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>     <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dst);<br>         <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[BUFFER_SIZE];<br>             <span class="hljs-type">int</span> n;<br>             <span class="hljs-keyword">while</span> ((n = in.read(buf)) &gt;= <span class="hljs-number">0</span>)<br>                 out.write(buf, <span class="hljs-number">0</span>, n);<br>         &#125; <span class="hljs-keyword">finally</span> &#123;<br>             out.close();<br>         &#125;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         in.close();<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h4><ul><li><p>It’s complicated when dealing with multiple resources. It may be hard to believe, but even good programmers got this wrong most of the time.</p></li><li><p>The code in both the try block and the finally block is capable of throwing exceptions. There is no record of the first exception in the exception stack trace, which can greatly complicate debugging in real systems—usually it’s the first exception that you want to see in order to diagnose the problem.</p><blockquote><p>For example, in the <em>firstLineOfFile</em> method, the call to readLine could throw an exception due to a failure in the underlying physical device, and the call to close could then fail for the same reason. Under these circumstances, the second exception completely obliterates the first one.</p></blockquote></li></ul><h3 id="2-try-with-resources"><a href="#2-try-with-resources" class="headerlink" title="2. try-with-resources"></a>2. try-with-resources</h3><p>All of these problems were solved in one fell swoop when Java 7 introduced the try-with-resources statement.</p><p>To be usable with this construct, a resource must implement the <strong>AutoCloseable</strong> interface, which consists of a single void-returning close method.</p><blockquote><p>Many classes and interfaces in the Java libraries and in third-party libraries now implement or extend AutoCloseable. If you write a class that represents a resource that must be closed, your class should implement AutoCloseable too.</p></blockquote><p>Examples:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// try-with-resources - the the best way to close resources!</span><br> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">firstLineOfFile</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>     <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path))) &#123;<br>         <span class="hljs-keyword">return</span> br.readLine();<br>     &#125;<br> &#125;<br><br><span class="hljs-comment">// try-with-resources on multiple resources - short and sweet</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(String src, String dst)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>      <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dst)) &#123;<br>    <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[BUFFER_SIZE];<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> ((n = in.read(buf)) &gt;= <span class="hljs-number">0</span>)<br>      out.write(buf, <span class="hljs-number">0</span>, n);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Not only are the try-with-resources versions shorter and more <strong>readable</strong> than the originals, but they provide far better <strong>diagnostics</strong>.</p><blockquote><p>Consider the <em>firstLineOfFile</em> method. If exceptions are thrown by both the readLine call and the (invisible) close, <strong>the latter exception is <em>suppressed</em> in favor of the former</strong>. In fact, multiple exceptions may be suppressed in order to preserve the exception that you actually want to see.</p><p>These suppressed exceptions are not merely discarded; they are printed in the stack trace with a notation saying that they were suppressed. You can also <strong>access</strong> them programmatically with the <strong>getSuppressed</strong> method, which was added to Throwable in Java 7.</p></blockquote><h4 id="catch-clauses"><a href="#catch-clauses" class="headerlink" title="catch clauses"></a>catch clauses</h4><p>You can put catch clauses on try-with-resources statements, just as you can on regular try-finally statements. This allows you to handle exceptions without sullying your code with another layer of nesting.</p><p>Here’s a version our firstLineOfFile method that does not throw exceptions, but takes a default value to return if it can’t open the file or read from it:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// try-with-resources with a catch clause</span><br><span class="hljs-keyword">static</span> String <span class="hljs-title function_">firstLineOfFile</span><span class="hljs-params">(String path, String defaultVal)</span> &#123;<br>   <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path))) &#123;<br>       <span class="hljs-keyword">return</span> br.readLine();<br>   &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>       <span class="hljs-keyword">return</span> defaultVal;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p><strong>Always use try-with-resources</strong> in preference to try-finally when working with <strong>resources that must be closed</strong>.</p><p>The resulting code is shorter and clearer, and the exceptions that it generates are more useful. The try-with-resources statement makes it easy to write correct code using resources that must be closed, which was practically impossible using try-finally.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-8. Avoid finalizers and cleaners</title>
    <link href="/2023/11/11/Java/effective-java/Item8-Avoid-finalizers-and-cleaners/"/>
    <url>/2023/11/11/Java/effective-java/Item8-Avoid-finalizers-and-cleaners/</url>
    
    <content type="html"><![CDATA[<h1 id="Item-8-Avoid-finalizers-and-cleaners"><a href="#Item-8-Avoid-finalizers-and-cleaners" class="headerlink" title="Item 8: Avoid finalizers and cleaners"></a>Item 8: Avoid finalizers and cleaners</h1><p><strong>Finalizers are unpredictable, often dangerous, and generally unnecessary.</strong></p><p><strong>Cleaners (Java 9) are less dangerous than finalizers, but still unpredictable, slow, and generally unnecessary.</strong></p><h2 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h2><h3 id="1-There-is-no-guarantee-they’ll-be-executed-promptly"><a href="#1-There-is-no-guarantee-they’ll-be-executed-promptly" class="headerlink" title="1. There is no guarantee they’ll be executed (promptly)"></a>1. There is no guarantee they’ll be executed (promptly)</h3><h4 id="never-do-anything-time-critical-in-a-finalizer-or-cleaner"><a href="#never-do-anything-time-critical-in-a-finalizer-or-cleaner" class="headerlink" title="never do anything time-critical in a finalizer or cleaner"></a>never do anything time-critical in a finalizer or cleaner</h4><p>It can take arbitrarily long between the time that an object becomes unreachable and the time its finalizer or cleaner runs. This means that you should <strong>never do anything time-critical in a finalizer or cleaner.</strong></p><blockquote><p>For example, it is a grave error to depend on a finalizer or cleaner to close files because open file descriptors are a limited resource. If many files are left open as a result of the system’s tardiness in running finalizers or cleaners, a program may fail because it can no longer open files.</p></blockquote><p>The promptness with which finalizers and cleaners are executed is primarily a function of the <em>garbage collection algorithm</em>, which varies widely across implementations. The behavior of a program that depends on the promptness of finalizer or cleaner execution may likewise vary.</p><blockquote><p>It is entirely possible that such a program will run perfectly on the JVM on which you test it and then fail miserably on the one favored by your most important customer.</p></blockquote><h4 id="never-depend-on-a-finalizer-or-cleaner-to-update-persistent-state"><a href="#never-depend-on-a-finalizer-or-cleaner-to-update-persistent-state" class="headerlink" title="never depend on a finalizer or cleaner to update persistent state"></a>never depend on a finalizer or cleaner to update persistent state</h4><p>Not only does the specification provide no guarantee that finalizers or cleaners will run promptly; it provides <strong>no guarantee that they’ll run at all</strong>. It is entirely possible, even likely, that a program terminates without running finalizer or cleaner on some objects that are no longer reachable. As a consequence, you should <strong>never depend on a finalizer or cleaner to update persistent state.</strong></p><blockquote><p>For example, depending on a finalizer or cleaner to release a persistent lock on a shared resource such as a database is a good way to bring your entire distributed system to a grinding halt.</p></blockquote><h3 id="2-An-uncaught-exception-thrown-during-finalization-is-ignored"><a href="#2-An-uncaught-exception-thrown-during-finalization-is-ignored" class="headerlink" title="2. An uncaught exception thrown during finalization is ignored"></a>2. An uncaught exception thrown during finalization is ignored</h3><p>Another problem with finalizers is that an uncaught exception thrown during finalization is ignored, and finalization of that object terminates. Uncaught exceptions can leave other objects in a corrupt state.</p><p>If another thread attempts to use such a corrupted object, arbitrary nondeterministic behavior may result. Normally, an uncaught exception will terminate the thread and print a stack trace, but not if it occurs in a finalizer—it won’t even print a warning.</p><blockquote><p>Cleaners do not have this problem because a library using a cleaner has control over its thread.</p></blockquote><h3 id="3-There-is-a-severe-performance-penalty-for-using-finalizers-and-cleaners"><a href="#3-There-is-a-severe-performance-penalty-for-using-finalizers-and-cleaners" class="headerlink" title="3. There is a severe performance penalty for using finalizers and cleaners"></a>3. There is a severe performance penalty for using finalizers and cleaners</h3><p>It is about 50 times slower to create and destroy objects with finalizers compared to using <em>try-with-resources</em>. This is primarily because finalizers inhibit efficient garbage collection.</p><p>Cleaners are comparable in speed to finalizers if you use them to clean all instances of the class, but cleaners are much faster if you use them only as a <strong>safety net</strong>.</p><h3 id="4-Security-problem-finalizers-open-your-class-up-to-finalizer-attacks"><a href="#4-Security-problem-finalizers-open-your-class-up-to-finalizer-attacks" class="headerlink" title="4. Security problem: finalizers open your class up to finalizer attacks"></a>4. Security problem: finalizers <strong>open your class up to</strong> <em>finalizer attacks</em></h3><blockquote><p>The idea behind a finalizer attack is simple: If an exception is thrown from a constructor or its serialization equivalents—the <em>readObject</em> and <em>readResolve</em> methods (Chapter 12)—the finalizer of a malicious subclass can run on the partially constructed object that should have “died on the vine.”(半途夭折) This finalizer can record a reference to the object in a static field, preventing it from being garbage collected. Once the malformed object has been recorded, it is a simple matter to invoke arbitrary methods on this object that should never have been allowed to exist in the first place. <strong>Throwing an exception from a constructor should be sufficient to prevent an object from coming into existence; in the presence of finalizers, it is not.</strong> </p></blockquote><p>Final classes are immune to finalizer attacks because no one can write a malicious subclass of a final class. <strong>To protect nonfinal classes from finalizer attacks, write a final</strong> <strong>finalize</strong> <strong>method that does nothing.</strong></p><h2 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h2><h3 id="1-Can-act-as-a-safety-net-in-case-the-owner-of-a-resource-neglects-to-call-its-close-method"><a href="#1-Can-act-as-a-safety-net-in-case-the-owner-of-a-resource-neglects-to-call-its-close-method" class="headerlink" title="1. Can act as a safety net in case the owner of a resource neglects to call its close method"></a>1. Can act as a safety net in case the owner of a resource neglects to call its close method</h3><p>While there’s no guarantee that the cleaner or finalizer will run promptly (or at all), it is better to free the resource late than never if the client fails to do so. If you’re considering writing such a safety-net finalizer, think long and hard about whether the protection is <strong>worth the cost</strong>.</p><blockquote><p>Some Java library classes, such as FileInputStream, FileOutputStream, ThreadPoolExecutor, and java.sql.Connection, have finalizers that serve as safety nets.</p></blockquote><h3 id="2-Concerns-objects-with-native-peers"><a href="#2-Concerns-objects-with-native-peers" class="headerlink" title="2. Concerns objects with native peers"></a>2. Concerns objects with <em>native peers</em></h3><blockquote><p>A native peer is a native (non-Java) object to which a normal object delegates via native methods. </p></blockquote><p>Because a native peer is not a normal object, the garbage collector doesn’t know about it and can’t reclaim it when its Java peer is reclaimed.</p><p>A cleaner or finalizer may be an appropriate vehicle for this task, assuming the performance is acceptable and the native peer holds no critical resources. If the performance is unacceptable or the native peer holds resources that must be reclaimed promptly, the class should have a <em>close</em> method, as described earlier.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>What should you do instead of writing a finalizer or cleaner for a class whose objects encapsulate resources that require termination, such as files or threads?</p><p>Just <strong>have your class implement</strong> <strong>AutoCloseable</strong>, and require its clients to invoke the close method on each instance when it is no longer needed, typically using try-with-resources to ensure termination even in the face of exceptions (Item 9).</p><blockquote><p>One detail worth mentioning is that the instance must keep track of whether it has been closed: <strong>the close method must record in a field that the object is no longer valid</strong>, and other methods must check this field and throw an <strong>IllegalStateException</strong> if they are called after the object has been closed.</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, don’t use cleaners, or in releases prior to Java 9, finalizers, except as a safety net or to terminate noncritical native resources. Even then, beware the indeterminacy and performance consequences.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-7. Eliminate obsolete object references</title>
    <link href="/2023/11/10/Java/effective-java/Item7-Eliminate-obsolete-object-references/"/>
    <url>/2023/11/10/Java/effective-java/Item7-Eliminate-obsolete-object-references/</url>
    
    <content type="html"><![CDATA[<h1 id="Item-7-Eliminate-obsolete-object-references"><a href="#Item-7-Eliminate-obsolete-object-references" class="headerlink" title="Item 7: Eliminate obsolete object references"></a>Item 7: Eliminate obsolete object references</h1><h2 id="Example-of-memory-leak"><a href="#Example-of-memory-leak" class="headerlink" title="Example of memory leak"></a>Example of memory leak</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Can you spot the &quot;memory leak&quot;?</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br>  <span class="hljs-keyword">private</span> Object[] elements;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span> &#123;<br>    elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Object e)</span> &#123;<br>    ensureCapacity();<br>    elements[size++] = e;<br>  &#125;<br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyStackException</span>();<br>    <span class="hljs-keyword">return</span> elements[--size];<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Ensure space for at least one more element, roughly</span><br><span class="hljs-comment">  * doubling the capacity each time the array needs to grow.</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (elements.length == size)<br>      elements = Arrays.copyOf(elements, <span class="hljs-number">2</span> * size + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Where-is-the-memory-leak"><a href="#Where-is-the-memory-leak" class="headerlink" title="Where is the memory leak?"></a>Where is the memory leak?</h3><p>If a stack grows and then shrinks, the objects that were popped off the stack will not be garbage collected, even if the program using the stack has no more references to them. This is because the stack maintains <strong>obsolete references</strong> to these objects. An obsolete reference is simply a reference that will never be dereferenced again.</p><blockquote><p>The memory leak can silently manifest itself as reduced performance due to increased garbage collector activity or increased memory footprint. In extreme cases, such memory leaks can cause <strong>disk paging</strong> and even program failure with an <strong>OutOfMemoryError</strong>, but such failures are relatively rare.</p></blockquote><h3 id="Fix-for-the-memory-leak"><a href="#Fix-for-the-memory-leak" class="headerlink" title="Fix for the memory leak"></a>Fix for the memory leak</h3><p>Fix: null out references once they become obsolete.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyStackException</span>();<br>  <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> elements[--size];<br>  elements[size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Eliminate obsolete reference</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Nulling-out-obsolete-references"><a href="#Nulling-out-obsolete-references" class="headerlink" title="Nulling out obsolete references"></a>Nulling out obsolete references</h2><h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><ul><li>avoid memory leak</li><li>if they are subsequently dereferenced by mistake, the program will immediately fail with a NullPointerException, rather than quietly doing the wrong thing. It is always beneficial to detect programming errors as quickly as possible.</li></ul><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p><strong>Nulling out object references should be the exception rather than the norm.</strong> The best way to eliminate an obsolete reference is to let the variable that contained the reference fall out of scope. This occurs naturally if you define each variable in the narrowest possible scope (Item 57).</p><h2 id="Sources-of-memory-leaks"><a href="#Sources-of-memory-leaks" class="headerlink" title="Sources of memory leaks"></a>Sources of memory leaks</h2><h3 id="1-A-class-manages-its-own-memory"><a href="#1-A-class-manages-its-own-memory" class="headerlink" title="1. A class manages its own memory"></a>1. A class manages its own memory</h3><p>Whenever a class manages its own memory, the programmer should be alert for memory leaks. Whenever an element is freed, any object references contained in the element should be nulled out.</p><h3 id="2-Caches"><a href="#2-Caches" class="headerlink" title="2. Caches"></a>2. Caches</h3><p>Once you put an object reference into a cache, it’s easy to forget that it’s there and leave it in the cache long after it becomes irrelevant.</p><h4 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>Represent the cache as a <strong>WeakHashMap</strong></p><ul><li><p>Situation: an entry is relevant(有意义) exactly when there are references to its key outside of the cache, entries will be removed automatically after they become obsolete.</p></li><li><p>Remember that <em>WeakHashMap</em> is useful only if the desired lifetime of cache entries is determined by external references to the <strong>key</strong>, not the value.</p></li></ul></li><li><p>Use a background thread (perhaps a <strong>ScheduledThreadPoolExecutor</strong>) to cleanse the cache occasionally, or as a side effect of adding new entries to the cache(method <strong>removeEldestEntry</strong> of <strong>LinkedHashMap</strong>).</p></li><li><p>For more sophisticated caches, you may need to use <strong>java.lang.ref</strong> directly.</p></li></ul><h3 id="3-Listeners-and-callbacks"><a href="#3-Listeners-and-callbacks" class="headerlink" title="3. Listeners and callbacks"></a>3. Listeners and callbacks</h3><p>If you implement an API where clients register callbacks but <strong>don’t deregister them explicitly</strong>, they will accumulate unless you take some action.</p><p>One way to ensure that callbacks are garbage collected promptly is to <strong>store only weak references to them</strong>, for instance, by storing them only as keys in a <em>WeakHashMap</em>.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-1. Consider static factory methods instead of constructors</title>
    <link href="/2023/11/10/Java/effective-java/Item1-Consider-static-factory-methods-instead-of-constructors/"/>
    <url>/2023/11/10/Java/effective-java/Item1-Consider-static-factory-methods-instead-of-constructors/</url>
    
    <content type="html"><![CDATA[<h1 id="Item-1-Consider-static-factory-methods-instead-of-constructors"><a href="#Item-1-Consider-static-factory-methods-instead-of-constructors" class="headerlink" title="Item 1: Consider static factory methods instead of constructors"></a>Item 1: Consider static factory methods instead of constructors</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="1-静态工厂方法有名称"><a href="#1-静态工厂方法有名称" class="headerlink" title="1. 静态工厂方法有名称"></a>1. 静态工厂方法有名称</h3><p>能够确切描述被返回的对象。</p><h3 id="2-不必在每次调用它们时都创建一个新对象"><a href="#2-不必在每次调用它们时都创建一个新对象" class="headerlink" title="2. 不必在每次调用它们时都创建一个新对象"></a>2. 不必在每次调用它们时都创建一个新对象</h3><p>与享元模式类似。节约资源。</p><h3 id="3-可以返回原返回类型的任何子类型的对象"><a href="#3-可以返回原返回类型的任何子类型的对象" class="headerlink" title="3. 可以返回原返回类型的任何子类型的对象"></a>3. 可以返回原返回类型的任何子类型的对象</h3><p>通过接口来引用被返回的对象，而不是通过它的实现类。</p><h3 id="4-所返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值"><a href="#4-所返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值" class="headerlink" title="4. 所返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值"></a>4. 所返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值</h3><blockquote><p>如：Enumset只有静态工厂方法，它返回两种子类之一的实例，具体取决于底层枚举类型的大小：</p><ul><li>如果它的元素小于等于64个，则像大多数枚举类型一样，返回一个RegularEnumset，用单个long支持；</li><li>如果枚举类型有大于64个元素，工厂返回JumboEnumset，用一个long数组支持</li></ul></blockquote><h3 id="5-方法返回的对象所属的类，在编写包含该静态方法的类时可以不存在"><a href="#5-方法返回的对象所属的类，在编写包含该静态方法的类时可以不存在" class="headerlink" title="5. 方法返回的对象所属的类，在编写包含该静态方法的类时可以不存在"></a>5. 方法返回的对象所属的类，在编写包含该静态方法的类时可以不存在</h3><p>Such flexible static factory methods form the basis of <em>service provider frameworks</em>, like the Java Database Connectivity API (JDBC).</p><blockquote><p>A service provider framework is a system in which providers implement a service, and the system makes the implementations available to clients, decoupling the clients from the implementations.</p></blockquote><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="1-类如果不含public-protected-constructor，就不能被子类化"><a href="#1-类如果不含public-protected-constructor，就不能被子类化" class="headerlink" title="1. 类如果不含public&#x2F;protected constructor，就不能被子类化"></a>1. 类如果不含public&#x2F;protected constructor，就不能被子类化</h3><p>For example, it is impossible to subclass any of the convenience implementation classes in the Collections Framework.</p><h3 id="2-程序员很难发现静态工厂方法"><a href="#2-程序员很难发现静态工厂方法" class="headerlink" title="2. 程序员很难发现静态工厂方法"></a>2. 程序员很难发现静态工厂方法</h3><p>以下是静态工厂方法的一些惯用名称：</p><ul><li>from</li><li>of</li><li>valueOf</li><li>instance &#x2F; getInstance</li><li>create &#x2F; newInstance</li><li>getType: Type表示工厂方法所返回的对象类型</li><li>newType</li><li>type</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-2. Consider a builder when faced with many constructor parameters</title>
    <link href="/2023/11/10/Java/effective-java/Item2-Consider-a-builder-when-faced-with-many-constructor-parameters/"/>
    <url>/2023/11/10/Java/effective-java/Item2-Consider-a-builder-when-faced-with-many-constructor-parameters/</url>
    
    <content type="html"><![CDATA[<h1 id="Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters"><a href="#Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters" class="headerlink" title="Item 2: Consider a builder when faced with many constructor parameters"></a>Item 2: Consider a builder when faced with many constructor parameters</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Consider the case of a class representing the Nutrition Facts label that appears on packaged foods. These labels have a few required fields—serving size, servings per container, and calories per serving— and more than twenty optional fields—total fat, saturated fat, trans fat, cholesterol, sodium, and so on. Most products have nonzero values for only a few of these optional fields.</p><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><h3 id="1-Telescoping-Constructor"><a href="#1-Telescoping-Constructor" class="headerlink" title="1. Telescoping Constructor"></a>1. Telescoping Constructor</h3><p>Provide a constructor with only the required parameters, another with a single optional parameter, a third with two optional parameters, and so on, culminating in a constructor with all the optional parameters.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Telescoping constructor pattern - does not scale well!</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NutritionFacts</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servingSize;  <span class="hljs-comment">// required</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servings;<span class="hljs-comment">// required</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> calories; <span class="hljs-comment">// optional</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> fat; <span class="hljs-comment">// optional</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> sodium; <span class="hljs-comment">// optional</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> carbohydrate; <span class="hljs-comment">// optional</span><br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings)</span> &#123;<br>      <span class="hljs-built_in">this</span>(servingSize, servings, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings,</span><br><span class="hljs-params">          <span class="hljs-type">int</span> calories)</span> &#123;<br>      <span class="hljs-built_in">this</span>(servingSize, servings, calories, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings,</span><br><span class="hljs-params">          <span class="hljs-type">int</span> calories, <span class="hljs-type">int</span> fat)</span> &#123;<br>      <span class="hljs-built_in">this</span>(servingSize, servings, calories, fat, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings,</span><br><span class="hljs-params">          <span class="hljs-type">int</span> calories, <span class="hljs-type">int</span> fat, <span class="hljs-type">int</span> sodium)</span> &#123;<br>      <span class="hljs-built_in">this</span>(servingSize, servings, calories, fat, sodium, <span class="hljs-number">0</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings, <span class="hljs-type">int</span> calories, <span class="hljs-type">int</span> fat, <span class="hljs-type">int</span> sodium, <span class="hljs-type">int</span> carbohydrate)</span> &#123;<br>    <span class="hljs-built_in">this</span>.servingSize = servingSize;<br>    <span class="hljs-built_in">this</span>.servings = servings;<br>    <span class="hljs-built_in">this</span>.calories = calories;<br>    <span class="hljs-built_in">this</span>.fat = fat;<br>    <span class="hljs-built_in">this</span>.sodium = sodium;<br>    <span class="hljs-built_in">this</span>.carbohydrate = carbohydrate;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// create an instance</span><br><span class="hljs-type">NutritionFacts</span> <span class="hljs-variable">cocaCola</span> <span class="hljs-operator">=</span><br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">NutritionFacts</span>(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">35</span>, <span class="hljs-number">27</span>);<br></code></pre></td></tr></table></figure><p><strong>The telescoping constructor pattern works, but it is hard to write client code when there are many parameters, and harder still to read it.</strong></p><h3 id="2-JavaBeans"><a href="#2-JavaBeans" class="headerlink" title="2. JavaBeans"></a>2. JavaBeans</h3><p>Call a parameterless constructor to create the object and then call setter methods to set each required parameter and each optional parameter of interest.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JavaBeans Pattern - allows inconsistency, mandates mutability</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NutritionFacts</span> &#123;<br>  <span class="hljs-comment">// Parameters initialized to default values (if any)</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">servingSize</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//Required; no default value</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">servings</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//Required; no default value</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">calories</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">fat</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sodium</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">carbohydrate</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">()</span> &#123; &#125;<br>  <br>  <span class="hljs-comment">// Setters</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServingSize</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123; servingSize = val; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServings</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123; servings = val; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCalories</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123; calories = val; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFat</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;fat = val;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSodium</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123; sodium = val; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCarbohydrate</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123; carbohydrate = val; &#125;<br><br>&#125;<br><br><span class="hljs-comment">// a bit wordy to create an instance</span><br><span class="hljs-type">NutritionFacts</span> <span class="hljs-variable">cocaCola</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NutritionFacts</span>();<br>cocaCola.setServingSize(<span class="hljs-number">240</span>);<br>cocaCola.setServings(<span class="hljs-number">8</span>);<br>cocaCola.setCalories(<span class="hljs-number">100</span>);<br>cocaCola.setSodium(<span class="hljs-number">35</span>);<br>cocaCola.setCarbohydrate(<span class="hljs-number">27</span>);<br></code></pre></td></tr></table></figure><p>Disadvantages:</p><ul><li>a JavaBean may be in an inconsistent state partway through its construction.</li><li>the JavaBeans pattern precludes the possibility of making a class immutable.</li></ul><h3 id="3-Builder"><a href="#3-Builder" class="headerlink" title="3. Builder"></a>3. Builder</h3><p>Instead of making the desired object directly, the client calls a constructor (or static factory) with all of the required parameters and gets a <em>builder object</em>. Then the client calls setter-like methods on the builder object to set each optional parameter of interest. Finally, the client calls a parameterless build method to generate the object, which is typically immutable.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Builder Pattern</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NutritionFacts</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servingSize;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servings;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> calories;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> fat;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> sodium;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> carbohydrate;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-comment">// Required parameters</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servingSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servings;<br>    <span class="hljs-comment">// Optional parameters - initialized to default values</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">calories</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">fat</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sodium</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">carbohydrate</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings)</span> &#123;<br>      <span class="hljs-built_in">this</span>.servingSize = servingSize;<br>      <span class="hljs-built_in">this</span>.servings    = servings;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">calories</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>        &#123; calories = val;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">fat</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>        &#123; fat = val;           <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">sodium</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>        &#123; sodium = val;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">carbohydrate</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>        &#123; carbohydrate = val;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>    <span class="hljs-keyword">public</span> NutritionFacts <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NutritionFacts</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(Builder builder)</span> &#123;<br>    servingSize = builder.servingSize;<br>    servings = builder.servings;<br>    calories = builder.calories;<br>    fat = builder.fat;<br>    sodium = builder.sodium;<br>    carbohydrate = builder.carbohydrate;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// using a fluent API (chained) to create an instance</span><br><span class="hljs-type">NutritionFacts</span> <span class="hljs-variable">cocaCola</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NutritionFacts</span>.Builder(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>)<br>           .calories(<span class="hljs-number">100</span>).sodium(<span class="hljs-number">35</span>).carbohydrate(<span class="hljs-number">27</span>).build();<br></code></pre></td></tr></table></figure><p>Disadvantages:</p><ul><li>In order to create an object, you must <strong>first create its builder</strong>. While the cost of creating this builder is unlikely to be noticeable in practice, it could be a <strong>problem in performance-critical situations</strong>.</li><li>Also, the Builder pattern is more verbose than the telescoping constructor pattern, so it should be used only if there are enough parameters to make it worthwhile, say four or more.</li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>The Builder pattern is a good choice when designing classes whose constructors or static factories would have <strong>more than a handful of parameters</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-3. Enforce the singleton property with a private constructor or an enum type</title>
    <link href="/2023/11/10/Java/effective-java/Item3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/"/>
    <url>/2023/11/10/Java/effective-java/Item3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type/</url>
    
    <content type="html"><![CDATA[<h1 id="Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type"><a href="#Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type" class="headerlink" title="Item 3: Enforce the singleton property with a private constructor or an enum type"></a>Item 3: Enforce the singleton property with a private constructor or an enum type</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>A <em>singleton</em> is simply a class that is instantiated exactly once. Singletons typically represent either a stateless object such as a function (Item 24) or a system component that is intrinsically unique.</p><h2 id="Implementations"><a href="#Implementations" class="headerlink" title="Implementations"></a>Implementations</h2><h3 id="Public-field-approach"><a href="#Public-field-approach" class="headerlink" title="Public field approach"></a>Public field approach</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Singleton with public final field</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Elvis</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Elvis</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Elvis</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Elvis</span><span class="hljs-params">()</span> &#123; ... &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leaveTheBuilding</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Advantages:</p><ul><li>the API makes it clear that the class is a singleton: the public static field is final, so it will always contain the same object reference.</li><li>it’s simpler.</li></ul><blockquote><p>A privileged client can <strong>invoke the private constructor reflectively</strong> (Item 65) with the aid of the AccessibleObject.setAccessible method. If you need to defend against this attack, modify the <strong>constructor</strong> to make it <strong>throw an exception</strong> if it’s asked to create a second instance.</p></blockquote><h3 id="Static-factory-approach"><a href="#Static-factory-approach" class="headerlink" title="Static factory approach"></a>Static factory approach</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Singleton with static factory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Elvis</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Elvis</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Elvis</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Elvis</span><span class="hljs-params">()</span> &#123; ... &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Elvis <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> INSTANCE; &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leaveTheBuilding</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Advantages:</p><ul><li>it gives you the flexibility to change your mind about whether the class is a singleton without changing its API.</li><li>you can write a <em>generic singleton factory</em> if your application requires it (Item 30).</li><li>a <em>method reference</em> can be used as a supplier, for example <code>Elvis::instance</code> is a <code>Supplier&lt;Elvis&gt;</code>.</li></ul><blockquote><p>Unless one of these advantages is relevant, the public field approach is preferable.</p></blockquote><h3 id="Single-element-enum-approach"><a href="#Single-element-enum-approach" class="headerlink" title="Single-element enum approach"></a>Single-element enum approach</h3><p><strong>A single-element enum type is often the best way to implement a singleton</strong>.</p><p>This approach is similar to the public field approach, but it is more concise, provides the serialization machinery for free, and provides an <strong>ironclad guarantee against multiple instantiation</strong>, even in the face of <strong>sophisticated serialization</strong> or <strong>reflection attacks</strong>.</p><blockquote><p>Note that you <strong>can’t</strong> use this approach if your singleton must <strong>extend a superclass other than Enum</strong> (though you <em>can</em> declare an enum to implement interfaces).</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Enum singleton - the preferred approach</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Elvis</span> &#123;<br>  INSTANCE;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leaveTheBuilding</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>To make a singleton class that uses either of <strong>public field &#x2F; static factory approaches</strong> <em>serializable</em> (Chapter 12), it is not sufficient merely to add implements Serializable to its declaration.</p><p>To maintain the singleton guarantee, declare all instance fields transient and provide a <em>readResolve</em> method (Item 89). Otherwise, each time a serialized instance is deserialized, a new instance will be created, leading, in the case of our example, to spurious Elvis sightings.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// readResolve method to preserve singleton property</span><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// Return the one true Elvis and let the garbage collector take care of the Elvis impersonator</span><br>  <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-4. Enforce noninstantiability with a private constructor</title>
    <link href="/2023/11/10/Java/effective-java/Item4-Enforce-noninstantiability-with-a-private-constructor/"/>
    <url>/2023/11/10/Java/effective-java/Item4-Enforce-noninstantiability-with-a-private-constructor/</url>
    
    <content type="html"><![CDATA[<h1 id="Item-4-Enforce-noninstantiability-with-a-private-constructor"><a href="#Item-4-Enforce-noninstantiability-with-a-private-constructor" class="headerlink" title="Item 4:  Enforce noninstantiability with a private constructor"></a>Item 4:  Enforce noninstantiability with a private constructor</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Write a class that is just a grouping of static methods and static fields.</p><p>Such <em>utility classes</em> were not designed to be instantiated: an instance would be nonsensical. In the absence of explicit constructors, however, the compiler pro- vides a public, parameterless <em>default constructor</em>. To a user, this constructor is indistinguishable from any other. It is not uncommon to see unintentionally instantiable classes in published APIs.</p><h2 id="Approaches-for-enforcing-noninstantiability"><a href="#Approaches-for-enforcing-noninstantiability" class="headerlink" title="Approaches for enforcing noninstantiability"></a>Approaches for enforcing noninstantiability</h2><h3 id="1-Making-a-class-abstract"><a href="#1-Making-a-class-abstract" class="headerlink" title="1. Making a class abstract"></a>1. Making a class abstract</h3><p><strong>Attempting to enforce noninstantiability by making a class abstract does not work.</strong> </p><p>The class can be subclassed and the subclass instantiated. Furthermore, it misleads the user into thinking the class was designed for inheritance (Item 19).</p><h3 id="2-Including-a-private-constructor"><a href="#2-Including-a-private-constructor" class="headerlink" title="2. Including a private constructor"></a>2. Including a private constructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Noninstantiable utility class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UtilityClass</span> &#123;<br>  <span class="hljs-comment">// Suppress default constructor for noninstantiablity</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">UtilityClass</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>  &#125;<br>  ... <span class="hljs-comment">// Remainder omitted</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h4><p>Because the explicit constructor is <strong>private</strong>, it is <strong>inaccessible outside the class.</strong></p><p>The <strong>AssertionError</strong> isn’t strictly required, but it provides insurance in case the constructor is accidentally invoked from within the class. It guarantees the class will never be instantiated under any circumstances.</p><p>This idiom is mildly counter- intuitive because the constructor is provided expressly so that it cannot be invoked. It is therefore wise to include a <strong>comment</strong>.</p><h4 id="Disdvantages"><a href="#Disdvantages" class="headerlink" title="Disdvantages"></a>Disdvantages</h4><p>This idiom also prevents the class from being <strong>subclassed</strong>. All constructors must invoke a superclass constructor, explicitly or implicitly, and a subclass would have no accessible superclass constructor to invoke.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-5. Prefer dependency injection to hardwiring resources</title>
    <link href="/2023/11/10/Java/effective-java/Item5-Prefer-dependency-injection-to-hardwiring-resources/"/>
    <url>/2023/11/10/Java/effective-java/Item5-Prefer-dependency-injection-to-hardwiring-resources/</url>
    
    <content type="html"><![CDATA[<h1 id="Item-5-Prefer-dependency-injection-to-hardwiring-resources"><a href="#Item-5-Prefer-dependency-injection-to-hardwiring-resources" class="headerlink" title="Item 5: Prefer dependency injection to hardwiring resources"></a>Item 5: Prefer dependency injection to hardwiring resources</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Many classes depend on one or more underlying resources. For example, a spell checker depends on a dictionary.</p><p>It is not uncommon to see such classes implemented as static utility classes (Item 4):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Inappropriate use of static utility - inflexible &amp; untestable!</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpellChecker</span> &#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lexicon</span> <span class="hljs-variable">dictionary</span> <span class="hljs-operator">=</span> ...;<br>     <span class="hljs-keyword">private</span> <span class="hljs-title function_">SpellChecker</span><span class="hljs-params">()</span> &#123;&#125; <span class="hljs-comment">// Noninstantiable</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String word)</span> &#123; ... &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">suggestions</span><span class="hljs-params">(String typo)</span> &#123; ... &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>Similarly, it’s not uncommon to see them implemented as singletons (Item 3):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Inappropriate use of singleton - inflexible &amp; untestable!</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpellChecker</span> &#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lexicon</span> <span class="hljs-variable">dictionary</span> <span class="hljs-operator">=</span> ...;<br>     <span class="hljs-keyword">private</span> <span class="hljs-title function_">SpellChecker</span><span class="hljs-params">(...)</span> &#123;&#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpellChecker</span>(...);<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String word)</span> &#123; ... &#125;<br>     <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">suggestions</span><span class="hljs-params">(String typo)</span> &#123; ... &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>Neither of these approaches is satisfactory, because they assume that there is only <strong>one dictionary</strong> worth using. In practice, each language has its own dictionary, and special dictionaries are used for special vocabularies. Also, it may be desirable to use a special dictionary for <strong>testing</strong>.</p><blockquote><p>You could try to have SpellChecker support multiple dictionaries by making the dictionary field <strong>nonfinal</strong> and <strong>adding a method to change the dictionary in an existing spell checker</strong>, would be awkward, error-prone, and unworkable in a concurrent setting.</p></blockquote><p><strong>Static utility classes and singletons are inappropriate for classes whose behavior is parameterized by an underlying resource.</strong></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>What is required is the ability to support <strong>multiple instances of the class</strong> (in our example, SpellChecker), each of which uses the <strong>specific type of resource</strong> desired by the client (in our example, the dictionary). </p><h3 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a>Dependency Injection</h3><p><strong>Dependency Injection pattern:</strong> pass the resource into the constructor when creating a new instance.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Dependency injection provides flexibility and testability</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpellChecker</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lexicon dictionary;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SpellChecker</span><span class="hljs-params">(Lexicon dictionary)</span> &#123;<br>    <span class="hljs-built_in">this</span>.dictionary = Objects.requireNonNull(dictionary);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String word)</span> &#123; ... &#125;<br>  <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">suggestions</span><span class="hljs-params">(String typo)</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>It preserves <strong>immutability</strong> (Item 17), so multiple clients can share dependent objects (assuming the clients desire the same underlying resources).</p><p>Dependency injection is equally applicable to <strong>constructors</strong>, <strong>static factories</strong> (Item 1), and <strong>builders</strong> (Item 2).</p><h4 id="Variant"><a href="#Variant" class="headerlink" title="Variant"></a>Variant</h4><p>A useful variant of the pattern is to pass a resource <em>factory</em> to the constructor. A factory is an object that can be called repeatedly to create instances of a type. Such factories embody the <em>Factory Method</em> pattern.</p><p>For example, here is a method that makes a mosaic using a client-provided factory to produce each tile:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Mosaic <span class="hljs-title function_">create</span><span class="hljs-params">(Supplier&lt;? extends Tile&gt; tileFactory)</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><blockquote><p>The <code>Supplier&lt;T&gt;</code> interface, introduced in Java 8, is perfect for representing factories.</p><p>Methods that take a <code>Supplier&lt;T&gt;</code> on input should typically constrain the factory’s type parameter using a <em>bounded wildcard type</em> (Item 31) to allow the client to pass in a factory that creates any <strong>subtype of a specified type.</strong></p></blockquote><h4 id="Pros-Cons"><a href="#Pros-Cons" class="headerlink" title="Pros &amp; Cons"></a>Pros &amp; Cons</h4><p>Dependency injection greatly improves <strong>flexibility</strong> and <strong>testability</strong>.</p><p>But it can <strong>clutter up large projects</strong>, which typically contain <strong>thousands of dependencies</strong>.</p><blockquote><p>This clutter can be all but eliminated by using a <em>dependency injection framework</em>, such as Dagger, Guice, or Spring.</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Do not use a singleton or static utility class to implement a class that depends on one or more underlying resources whose behavior affects that of the class, and do not have the class create these resources directly.</p><p>Instead, pass the resources, or factories to create them, into the constructor (or static factory or builder). This practice, known as dependency injection, will greatly enhance the <strong>flexibility, reusability, and testability of a class</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-6. Avoid creating unnecessary objects</title>
    <link href="/2023/11/10/Java/effective-java/Item6-Avoid-creating-unnecessary-objects/"/>
    <url>/2023/11/10/Java/effective-java/Item6-Avoid-creating-unnecessary-objects/</url>
    
    <content type="html"><![CDATA[<h1 id="Item-6-Avoid-creating-unnecessary-objects"><a href="#Item-6-Avoid-creating-unnecessary-objects" class="headerlink" title="Item 6: Avoid creating unnecessary objects"></a>Item 6: Avoid creating unnecessary objects</h1><h2 id="Reuse-object-instead-of-creating-new-equivalent-object"><a href="#Reuse-object-instead-of-creating-new-equivalent-object" class="headerlink" title="Reuse object instead of creating new equivalent object"></a>Reuse object instead of creating new equivalent object</h2><p>It is often appropriate to reuse a single object instead of creating a new functionally equivalent object each time it is needed. Reuse can be both faster and more stylish. An object can always be reused if it is <strong>immutable</strong> (Item 17). In addition, you can also reuse mutable objects if you know they won’t be modified.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>For example, suppose you want to write a method to determine whether a string is a valid Roman numeral.</p><p>The easiest way:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Performance can be greatly improved</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRomanNumeral</span><span class="hljs-params">(String s)</span> &#123;<br>  <span class="hljs-keyword">return</span> s.matches(<span class="hljs-string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br>+ <span class="hljs-string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>While</strong> <strong>String.matches</strong> <strong>is the easiest way to check if a string matches a regular expression, it’s not suitable for repeated use in performance-critical situations.</strong> The problem is that it internally creates a Pattern instance for the regular expression and uses it only once, after which it becomes eligible for garbage collection.</p><p>To improve the performance, explicitly compile the regular expression into a Pattern instance (which is immutable) as part of class initialization, cache it, and reuse the same instance for every invocation of the isRomanNumeral method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Reusing expensive object for improved performance</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RomanNumerals</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">ROMAN</span> <span class="hljs-operator">=</span> Pattern.compile(<br>           <span class="hljs-string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br>           + <span class="hljs-string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);<br>  <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRomanNumeral</span><span class="hljs-params">(String s)</span> &#123;<br>      <span class="hljs-keyword">return</span> ROMAN.matcher(s).matches();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Use-static-factory-methods-in-preference-to-constructors-on-immutable-classes"><a href="#Use-static-factory-methods-in-preference-to-constructors-on-immutable-classes" class="headerlink" title="Use static factory methods in preference to constructors on immutable classes"></a>Use <em>static factory methods</em> in preference to <em>constructors</em> on immutable classes</h2><p>You can often avoid creating unnecessary objects by using <em>static factory methods</em> (Item 1) in preference to constructors on <strong>immutable classes</strong> that provide both. The constructor <em>must</em> create a new object each time it’s called, while the factory method is never required to do so and won’t in practice.</p><blockquote><p>For example, the factory method Boolean.valueOf(String) is preferable to the constructor Boolean(String), which was deprecated in Java 9. </p></blockquote><h2 id="Prefer-primitives-to-boxed-primitives-and-watch-out-for-unintentional-autoboxing"><a href="#Prefer-primitives-to-boxed-primitives-and-watch-out-for-unintentional-autoboxing" class="headerlink" title="Prefer primitives to boxed primitives, and watch out for unintentional autoboxing"></a>Prefer primitives to boxed primitives, and watch out for unintentional autoboxing</h2><p><strong>Autoboxing blurs but does not erase the distinction between primitive and boxed primitive types.</strong></p><p>Consider the following method, which calculates the sum of all the positive int values. To do this, the program has to use long arithmetic because an int is not big enough to hold the sum of all the positive int values:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Hideously slow! Can you spot the object creation?</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">Long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= Integer.MAX_VALUE; i++)<br>     sum += i;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>The variable sum is declared as a Long instead of a long, which means that the program constructs about 231 unnecessary Long instances (roughly one for each time the long i is added to the Long sum).</p><p>The lesson is clear: <strong>prefer primitives to boxed primitives, and watch out for unintentional autoboxing.</strong></p><h2 id="Additional-information"><a href="#Additional-information" class="headerlink" title="Additional information"></a>Additional information</h2><p>This item should not be misconstrued to imply that object creation is expensive and should be avoided. On the contrary, the creation and reclamation of small objects whose constructors do little explicit work is cheap, especially on modern JVM implementations. <strong>Creating additional objects to enhance the clarity, simplicity, or power of a program is generally a good thing.</strong></p><p>Conversely, avoiding object creation by maintaining your own <em>object pool</em> is a bad idea unless the objects in the pool are extremely heavyweight. The <strong>classic example</strong> of an object that <em>does</em> justify an object pool is a <strong>database connection</strong>. The cost of establishing the connection is sufficiently high that it makes sense to reuse these objects. </p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Effective Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板6-1.数学-数论</title>
    <link href="/2023/11/07/algorithm/template/6-1.%E6%95%B0%E8%AE%BA/"/>
    <url>/2023/11/07/algorithm/template/6-1.%E6%95%B0%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对所有大于1的整数，如果只包含<code>1和本身</code>这两个约数，就被称为质数，或者叫素数。</p><blockquote><p>所有&lt;&#x3D;1的数，既不是质数也不是合数</p></blockquote><h2 id="判定：试除法"><a href="#判定：试除法" class="headerlink" title="判定：试除法"></a>判定：试除法</h2><h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>时间复杂度$O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化做法"><a href="#优化做法" class="headerlink" title="优化做法"></a>优化做法</h3><p>利用性质：如果 $d\ |\ n$，那么也一定有 $\frac{n}{d}\ |\ n$。</p><blockquote><p>$d\ |\ n$ 表示d能被n整除，即n是d的约数。</p></blockquote><p>所以对于每个$d$，只要枚举到 $d &lt;&#x3D; \frac{n}{d}$ 即可，即 $d^2 &lt;&#x3D; n$， 时间复杂度一定为 $O(\sqrt{n})$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i ++)<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分解质因数：试除法"><a href="#分解质因数：试除法" class="headerlink" title="分解质因数：试除法"></a>分解质因数：试除法</h2><h3 id="朴素做法-1"><a href="#朴素做法-1" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>从小到大枚举所有可能的质因数，时间复杂度$O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; x; i ++)<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) <span class="hljs-comment">// i一定是质数</span><br>        &#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;<br>        &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化做法-1"><a href="#优化做法-1" class="headerlink" title="优化做法"></a>优化做法</h3><p>性质：n中最多只包含一个大于 $\sqrt{n}$ 的质因子。</p><p>所以枚举到 $\sqrt{n}$ 即可，时间复杂度最坏为 $O(\sqrt{n})$，因为n在枚举过程中在不断变小，最好时间复杂度仅为 $O(logn)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++)<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl; <span class="hljs-comment">// 单独处理可能大于sqrt(n)的那个质因子</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h2><h3 id="朴素做法-2"><a href="#朴素做法-2" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>从小到大枚举，把每个数所有的倍数删掉。如遍历到2，删除4，6，8，10，12。</p><p>时间复杂度：$O(nlogn)$</p><blockquote><p>总运算次数：</p><p>$\lim_{n\to INF}\frac{n}{2} + \frac{n}{3} + … + \frac{n}{n}$</p><p>$&#x3D;\lim_{n\to INF} n (\frac{1}{2} + \frac{1}{3} + … + \frac{1}{n})$</p><p>$&#x3D;n\ln(n)$</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            prime[cnt ++] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i) st[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化做法：埃式筛法"><a href="#优化做法：埃式筛法" class="headerlink" title="优化做法：埃式筛法"></a>优化做法：埃式筛法</h3><p>只需要把质数的倍数筛掉即可。当一个数不是质数时，它的倍数一定已经被筛过了。</p><h4 id="时间复杂度分析："><a href="#时间复杂度分析：" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h4><p>质数定理：1~n中有$\frac{n}{ln(n)}$个质数</p><p>时间复杂度估计：$O(\frac{n}{ln(n)}\ ln(n)) &#x3D; O(n)$。</p><blockquote><p>实际上是$O(nloglogn)$，不过loglogn很接近常数。</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            prime[cnt ++] = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i) st[j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化做法：线性筛法（实际使用）"><a href="#优化做法：线性筛法（实际使用）" class="headerlink" title="优化做法：线性筛法（实际使用）"></a>优化做法：线性筛法（实际使用）</h3><p>时间复杂度$O(n)$。</p><p>当枚举到<code>i</code>时，把<code>已经筛出来的所有质数与i的乘积</code>筛出去。</p><p>核心思路：每个合数<code>x</code>只会被它的最小质因子筛掉。每个数只有一个最小质因子，所以每个数只会被筛一次，所以算法是线性的。</p><blockquote><ol><li>i % pj &#x3D;&#x3D; 0 &#x3D;&gt; pj一定是i的最小质因子，故pj一定是pj * i的最小质因子</li><li>i % pj !&#x3D; 0 &#x3D;&gt; pj一定小于i的所有质因子（因为pj从小到大枚举，还没break），故pj也一定是pj * i的最小质因子</li></ol></blockquote><p>所有的合数都一定会被筛掉：</p><p>因为对于一个合数x，假设pj是x的最小质因子，i一定先枚举到x &#x2F; pj，这个时候x已经被筛掉了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) prime[cnt ++] = i;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; prime[j] &lt;= n / i; j ++) <span class="hljs-comment">// 不用写j &lt; cnt，因为当i为合数的时候，prime[j]枚举到i的最小质因子时就会停下来；当i为质数的时候，枚举到prime[j]=i时也会停下来</span><br>        &#123;<br>          st[prime[j] * i] = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 保证prime[j]一定是i的最小质因子</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h1>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式28-访问者模式</title>
    <link href="/2023/11/05/design-pattern/28.%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/11/05/design-pattern/28.%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>访问者模式（Visitor），表示一个作用于某对象结构中的各元素的操作。它使你可以在<strong>不改变各元素的类</strong>的前提下<strong>定义作用于这些元素的新操作</strong>。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/11/05/vbx824mMZzaQokf.jpg" alt="访问者模式结构图.jpg"></p><p>访问者模式适用于数据结构相对稳定（Element种类数量不变）的系统。</p><p>它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Visitor</code>类：为该对象结构中<code>ConcreteElement</code>的每一个类声明一个Visit操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Visitor</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitConcreteElementA</span><span class="hljs-params">(ConcreteElementA concreteElementA)</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitConcreteElementB</span><span class="hljs-params">(ConcreteElementB concreteElementB)</span>;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteVisitor1</code>和<code>ConcreteVisitor2</code>类：具体访问者， 实现每个由Visitor声明的操作。每个操作实现算法的一部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitor1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Visitor</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitConcreteElementA</span><span class="hljs-params">(ConcreteElementA concreteElementA)</span> &#123;<br>    System.out.println(concreteElementA.getClass().getSimpleName() + <span class="hljs-string">&quot;被&quot;</span> + <span class="hljs-built_in">this</span>.getClass().getSimpleName() + <span class="hljs-string">&quot;访问&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitConcreteElementB</span><span class="hljs-params">(ConcreteElementB concreteElementB)</span> &#123;<br>    System.out.println(concreteElementB.getClass().getSimpleName() + <span class="hljs-string">&quot;被&quot;</span> + <span class="hljs-built_in">this</span>.getClass().getSimpleName() + <span class="hljs-string">&quot;访问&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitor2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Visitor</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitConcreteElementA</span><span class="hljs-params">(ConcreteElementA concreteElementA)</span> &#123;<br>    System.out.println(concreteElementA.getClass().getSimpleName() + <span class="hljs-string">&quot;被&quot;</span> + <span class="hljs-built_in">this</span>.getClass().getSimpleName() + <span class="hljs-string">&quot;访问&quot;</span>);<br>  &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitConcreteElementB</span><span class="hljs-params">(ConcreteElementB concreteElementB)</span> &#123;<br>    System.out.println(concreteElementB.getClass().getSimpleName() + <span class="hljs-string">&quot;被&quot;</span> + <span class="hljs-built_in">this</span>.getClass().getSimpleName() + <span class="hljs-string">&quot;访问&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Element</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Element</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span>;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteElementA</code>类和<code>ConcreteElementB</code>类：具体元素，实现accept操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;<br>    visitor.visitConcreteElementA(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 利用双分派技术，实现处理与数据结构的分离</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationA</span><span class="hljs-params">()</span> &#123;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;<br>    visitor.visitConcreteElementB(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 利用双分派技术，实现处理与数据结构的分离</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationB</span><span class="hljs-params">()</span> &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ObjectStructure</code>类：能枚举<code>ConcreteElement</code>，可以提供一个高层的接口以允许访问者访问它的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectStructure</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> ArrayList&lt;Element&gt; elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Element element)</span> &#123;<br>    elements.add(element);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Element element)</span> &#123;<br>    elements.remove(element);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Element e : elements) &#123;<br>      e.accept(visitor);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectStructure</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectStructure</span>();<br>o.attach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteElementA</span>());<br>o.attach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteElementB</span>());<br><br><span class="hljs-type">ConcreteVisitor1</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteVisitor1</span>();<br><span class="hljs-type">ConcreteVisitor2</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteVisitor2</span>();<br><br>o.accept(v1);<br>o.accept(v2);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>访问者模式的目的是把<strong>处理操作</strong>从<strong>元素的数据结构</strong>分离出来。</p><blockquote><p>很多系统可以按照算法和数据结构分开，如果这样的系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较合适的，因为访问者模式使得算法操作的增加变得容易。</p></blockquote><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。</p><p>访问者模式将有关的行为集中到一个访问者对象中。</p><blockquote><p>通常ConcreteVisitor可以单独开发，不必跟ConcreteElementA或ConcreteElementB写在一起。正因为这样，ConcreteVisitor能提高ConcreteElement之间的独立性，如果把一个处理动作设计成ConcreteElementA和ConcreteElementB类的方法，每次想新增’处理’以扩充功能时就得去修改ConcreteElementA和ConcreteElementB了。</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>使增加新的数据结构（元素）变得困难。</p><blockquote><p>大多时候你并不需要访问者模式，但当一旦你需要访问者模式时，那就是真的需要它了。</p><p>事实上，我们很难找到数据结构不变化的情况，所以用访问者模式的机会也就不太多了。</p></blockquote><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="双分派技术"><a href="#双分派技术" class="headerlink" title="双分派技术"></a>双分派技术</h3><p>双分派意味着得到执行的操作决定于请求的种类和两个接收者的类型。</p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法时空复杂度分析</title>
    <link href="/2023/11/04/algorithm/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <url>/2023/11/04/algorithm/%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="由数据范围反推算法复杂度以及算法内容"><a href="#由数据范围反推算法复杂度以及算法内容" class="headerlink" title="由数据范围反推算法复杂度以及算法内容"></a>由数据范围反推算法复杂度以及算法内容</h2><p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 $10^7∼10^8$ 为最佳。</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><ol><li>$n≤30$ &#x3D;&gt; 指数级别：dfs+剪枝，状态压缩DP</li><li>$n≤100$ &#x3D;&gt; $O(n^3)$：Floyd，DP，高斯消元</li><li>$n≤1000$ &#x3D;&gt; $O(n^2), O(n^2logn)$ ：DP，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</li><li>$n≤10^4$ &#x3D;&gt; $O(n*\sqrt n)$：块状链表、分块、莫队</li><li>$n≤10^5$ &#x3D;&gt; $O(nlogn)$：各种sort，线段树、树状数组、set&#x2F;map、heap、拓扑排序、Dijkstra+heap、Prim+heap、Kruskal、SPFA、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</li><li>$n≤10^6$ &#x3D;&gt; $O(n)$： 单调队列、hash、双指针扫描、BFS、并查集，KMP、AC自动机；以及常数比较小的$O(nlogn)$算法：sort、树状数组、heap、Dijkstra、SPFA</li><li>$n≤10^7$ &#x3D;&gt; $O(n)$：双指针扫描、KMP、AC自动机、线性筛素数</li><li>$n≤10^9$ &#x3D;&gt; $O(\sqrt n)$：判断质数</li><li>$n≤10^{18}$ &#x3D;&gt; $O(logn)$：最大公约数，快速幂，数位DP</li><li>$n≤10^{1000}$ &#x3D;&gt; $O((logn)^2)$：高精度加减乘除</li><li>$n≤10^{100000}$ &#x3D;&gt; $O(logk * loglogk)$，k表示位数：高精度加减、FFT&#x2F;NTT</li></ol><blockquote><p>SPFA，匈牙利，最大流的理论复杂度高，但实际几乎为线性</p></blockquote><h2 id="分析时间复杂度的方法"><a href="#分析时间复杂度的方法" class="headerlink" title="分析时间复杂度的方法"></a>分析时间复杂度的方法</h2><ol><li>循环：看循环的层数</li><li>递归：<ol><li>主定理，看递推关系式$T(n) &#x3D; aT(\frac{n}{b}) + f(n)$，然后分情况，较复杂</li><li>看层数，如快排，每层递归是$O(n)$，一共$logn$层，所以时间复杂度为$O(nlogn)$</li></ol></li></ol><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>一般空间限制：$64MB$。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span>: <span class="hljs-number">4</span> <span class="hljs-keyword">Byte</span><br><span class="hljs-keyword">char</span>: <span class="hljs-number">1</span> <span class="hljs-keyword">Byte</span><br><span class="hljs-keyword">double</span>, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>: <span class="hljs-number">8</span> <span class="hljs-keyword">Byte</span><br><br><span class="hljs-number">64</span>MB = <span class="hljs-number">2</span>^<span class="hljs-number">26</span> <span class="hljs-keyword">Byte</span><br>能开多少<span class="hljs-keyword">int</span>变量？<br><span class="hljs-number">2</span>^<span class="hljs-number">26</span> / <span class="hljs-number">4</span> = <span class="hljs-number">2</span> ^ <span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><blockquote><p>注：操作系统有优化，数组是用的时候再临时分配内存。</p><p>如果只开了数组，没有用那么多的话，用sizeof算出来超内存也不会MLE。</p></blockquote><p>递归会使用系统栈，即使没有额外开数组，也会占用系统空间。如快排的额外空间复杂度是$O(logn)$的。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式27-解释器模式</title>
    <link href="/2023/11/04/design-pattern/27.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/11/04/design-pattern/27.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>解释器模式（interpreter），给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/11/04/aJBM9Oxve8oF2tH.jpg" alt="解释器模式结构图.jpg"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>AbstractExpression</code>类：声明一个抽象的解释操作，为抽象语法树中的所有节点所共享</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br>  <br>  <span class="hljs-comment">// 解释操作</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>TerminalExpression</code>（终结符表达式）：实现与文法中的终结符相关联的解释操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TerminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;终端解释器&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NonterminalExpression</code>（非终结符表达式）：为文法中的非终结符实现解释操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NonterminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;非终端解释器&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Context</code>类：包含解释器之外的一些全局信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> String input;<br>  <span class="hljs-keyword">private</span> String output;<br>  <br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getInput</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.input;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInput</span><span class="hljs-params">(String value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.input = value;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getOutput</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.output;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOutput</span><span class="hljs-params">(String value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.output = value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：构建表示该文法定义的语言中一个特定的句子的抽象语法树。调用解释操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<br>ArrayList&lt;AbstractExpression&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>());<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NonterminalExpression</span>());<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>());<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>());<br><br><span class="hljs-keyword">for</span> (AbstractExpression exp : list) &#123;<br>  exp.interpret(context);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>通常当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>容易改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。</li><li>也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写。</li></ul><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p>解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。</p><blockquote><p>高级语言（如Java）的开发：当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理。</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>正则表达式</li><li>浏览器（解释HTML，渲染页面）</li><li>机器人指令</li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板5-5.贪心-推公式</title>
    <link href="/2023/11/03/algorithm/template/5-5.%E6%8E%A8%E5%85%AC%E5%BC%8F/"/>
    <url>/2023/11/03/algorithm/template/5-5.%E6%8E%A8%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="推公式"><a href="#推公式" class="headerlink" title="推公式"></a>推公式</h1><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="耍杂技的牛"><a href="#耍杂技的牛" class="headerlink" title="耍杂技的牛"></a>耍杂技的牛</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>按照<code>wi+si</code>从小到大的顺序排，最大的危险系数一定是最小的</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>显然算法得出的答案 &gt;&#x3D; 最优解。</p><p>下面证明算法得出的答案 &lt;&#x3D; 最优解：</p><p>假设不是按照<code>wi+si</code>从小到大排序，那么从上到下，一定存在两头相邻的牛：<code>w[i] + s[i] &gt; w[i + 1] + s[i + 1]</code>。交换这两头牛，不影响其他牛的危险系数。</p><ul><li><p>对于第<code>i</code>头牛：危险系数从<code>w - s[i]</code>变成了<code>w + w[i + 1] - s[i]</code></p></li><li><p>对于第<code>i+1</code>头牛：危险系数从<code>w + w[i] - s[i + 1]</code>变成了<code>w - s[i + 1]</code></p></li></ul><p>给每个数都加上<code>s[i] + s[i + 1] - w</code>：</p><ul><li><p>对于第<code>i</code>头牛：危险系数从<code>s[i + 1]</code>变成了<code>w[i + 1] + s[i + 1]</code></p></li><li><p>对于第<code>i+1</code>头牛：危险系数从<code>w[i] + s[i]</code>变成了<code>s[i]</code></p></li></ul><p>由于<code>w[i] + s[i] &gt; w[i + 1] + s[i + 1]</code>，交换后的结果肯定会变小，所以可以调整为从小到大排序</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50010</span>;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cow</span> &#123;<br>    <span class="hljs-type">int</span> w, s;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Cow &amp;C)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> w + s &lt; C.w + C.s;<br>    &#125;<br>&#125;cow[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;cow[i].w, &amp;cow[i].s);<br>    <br>    <span class="hljs-built_in">sort</span>(cow, cow + n);<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">-2e9</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        res = <span class="hljs-built_in">max</span>(res, sum - cow[i].s);<br>        sum += cow[i].w;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板5-4.贪心-绝对值不等式</title>
    <link href="/2023/11/03/algorithm/template/5-4.%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    <url>/2023/11/03/algorithm/template/5-4.%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="绝对值不等式"><a href="#绝对值不等式" class="headerlink" title="绝对值不等式"></a>绝对值不等式</h1><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="货仓选址"><a href="#货仓选址" class="headerlink" title="货仓选址"></a>货仓选址</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>总距离：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">f(x) = |<span class="hljs-string">x1 - x</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">x2 - x</span>|<span class="hljs-string"> + ... + </span>|<span class="hljs-string">xn - x</span>|<span class="hljs-string"> 求最小值</span><br><span class="hljs-string">= (</span>|<span class="hljs-string">x1 - x</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">xn - x</span>|<span class="hljs-string">) + (</span>|<span class="hljs-string">x2 - x</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">xn-1 - x</span>|<span class="hljs-string">) + ... 两两分组</span><br><span class="hljs-string">&gt;= (xn - x1) + (xn-1 - x2) + ... 当x在每组的两个数之间时，等号成立</span><br><span class="hljs-string">商店数量为奇数时，x取中位数，商店数量为偶数时，取最中间的两个数之间的任意一个位置</span><br></code></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>绝对值公式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <br>    <span class="hljs-built_in">sort</span>(a, a + n);<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) res += <span class="hljs-built_in">abs</span>(a[i] - a[n / <span class="hljs-number">2</span>]);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>双指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <br>    <span class="hljs-built_in">sort</span>(a, a + n);<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>; i &lt; j; i ++, j --) res += a[j] - a[i];<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板5-3.贪心-排序不等式</title>
    <link href="/2023/11/03/algorithm/template/5-3.%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    <url>/2023/11/03/algorithm/template/5-3.%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h1><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="排队打水"><a href="#排队打水" class="headerlink" title="排队打水"></a>排队打水</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>总等待时间：<code>t1 * (n-1) + t2 * (n-2) + ... + tn * 0</code></p><p>时间长的人放在后面，时间短的人放在前面</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, t[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t[i]);<br>    <br>    <span class="hljs-built_in">sort</span>(t, t + n);<br>    <br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) res += t[i] * (n - i - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式26-享元模式</title>
    <link href="/2023/11/03/design-pattern/26.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/11/03/design-pattern/26.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>享元模式（Flyweight），运用共享技术有效地支持大量细粒度的对象。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/11/03/bMCrOhWLicHdA4y.jpg" alt="享元模式结构图.jpg"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Flyweight</code>类：所有具体享元类的超类&#x2F;接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyweight</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(<span class="hljs-type">int</span> extrinsicstate)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteFlyweight</code>：继承<code>Flyweight</code>超类或实现<code>Flyweight</code>接口，并为内部状态增加存储空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要共享的具体Flyweight子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFlyweight</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Flyweight</span> &#123;<br>  pubilc <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(<span class="hljs-type">int</span> extrinsicstate)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;具体Flyweight：&quot;</span> + extrinsicstate);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>UnsharedConcreteFlyweight</code>：不需要共享的<code>Flyweight</code>子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不需要共享的Flyweight子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsharedConcerteFlyweight</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Flyweight</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(<span class="hljs-type">int</span> extrinsicstate)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;不共享的具体Flyweight：&quot;</span> + extrinsicstate);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FlyweightFactory</code>：享元工厂，用来创建并管理<code>Flyweight</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> Hashtable&lt;String, Flyweight&gt; flyweights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>  <br>  <span class="hljs-comment">// 初始化工厂时，先生成三个实例</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">FlyweightFactory</span><span class="hljs-params">()</span> &#123;<br>    flyweights.put(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyweight</span>));<br>    flyweights.put(<span class="hljs-string">&quot;Y&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyweight</span>));<br>    flyweights.put(<span class="hljs-string">&quot;Z&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyweight</span>));<br>  &#125;<br>  <br>  <span class="hljs-comment">// 根据客户端请求，获得已生成的实例</span><br>  <span class="hljs-keyword">public</span> Flyweight <span class="hljs-title function_">getFlyweight</span><span class="hljs-params">(String key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!flyweights.contains(key)) &#123;<br>      flyweights.put(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyweight</span>(key));<br>    &#125;<br>    <span class="hljs-keyword">return</span> (Flyweight)flyweights.get(key);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">extrinsicstate</span> <span class="hljs-operator">=</span> <span class="hljs-number">22</span>;<br><br><span class="hljs-type">FlyweightFactory</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlyweightFactory</span>();<br><br><span class="hljs-type">Flyweight</span> <span class="hljs-variable">fx</span> <span class="hljs-operator">=</span> f.getFlyweight(<span class="hljs-string">&quot;X&quot;</span>);<br>fx.operation(--extrinsicstate);<br><br><span class="hljs-type">Flyweight</span> <span class="hljs-variable">fy</span> <span class="hljs-operator">=</span> f.getFlyweight(<span class="hljs-string">&quot;Y&quot;</span>);<br>fy.operation(--extrinsicstate);<br><br><span class="hljs-type">Flyweight</span> <span class="hljs-variable">fz</span> <span class="hljs-operator">=</span> f.getFlyweight(<span class="hljs-string">&quot;Z&quot;</span>);<br>fz.operation(--extrinsicstate);<br><br><span class="hljs-type">Flyweight</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsharedConcreteFlyweight</span>();<br>uf.operation(--extrinsicstate);<br></code></pre></td></tr></table></figure><p>注：</p><ul><li><code>FlyweightFactory</code>初始化时不一定需要生成对象实例。也可以到需要时，再去根据对象是否为null来决定是否实例化。</li><li><code>UnsharedConcreteFlyweight</code>存在的原因：尽管我们大部分时间都需要共享对象来降低内存的损耗，但个<br>别时候也有可能不需要共享，那么此时的<code>UnsharedConcreteFlyweight</code>子类就有存在的必要了，它可以解决那些不需要共享对象的问题。</li></ul><h2 id="内部状态与外部状态"><a href="#内部状态与外部状态" class="headerlink" title="内部状态与外部状态"></a>内部状态与外部状态</h2><ul><li>内部状态：在享元对象内部并且不会随环境改变而改变的共享部分</li><li>外部状态：随环境改变而改变的、不可以共享的状态</li></ul><blockquote><p>享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了<strong>几个参数</strong>外基本上都是相同的，有时就能够大幅度地减少需要实例化的类的数量。如果能把那些参数<strong>移到类实例的外面</strong>，<strong>在方法调用时将它们传递进来</strong>，就可以通过共享大幅度地减少单个实例的数目。</p></blockquote><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>一个应用程序使用了<strong>大量的对象</strong>，而大量的这些对象造成了很大的存储开销</li><li>对象的<strong>大多数状态可以是外部状态</strong>，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象</li></ul><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>非常好地解决了<strong>对象的开销问题</strong>。</p><p>因为用了享元模式，所以有了共享对象，实例总数就大大减少了，如果共享的对象越多，存储节约也就越多，节约量随着共享状态的增多而增大。</p><blockquote><p>例：Java中的String就运用了Flyweight模式。</p><p>‘&#x3D;&#x3D;’可以用来确定titleA与titleB是否是相同的实例，返回值为boolean值。当用new String()方法时，两个对象titleA和titleB的引用地址是不相同的，但当titleC和titleD都使用赋值的方式时，两个字符串的引用地址竟然是相同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">titleA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;test1&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">titleB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;test1&quot;</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">titleC</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test2&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">titleD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test2&quot;</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">==: 比较内存引用地址</span><br><span class="hljs-comment">equals(): 比较字符串的值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">titleA == titleB: false</span><br><span class="hljs-comment">titleA.equals(titleB): true</span><br><span class="hljs-comment">titleC == titleD: true</span><br><span class="hljs-comment">titleC.equals(titleD): true</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ul><li><p>使用享元模式需要维护一个<strong>记录了系统已有的所有享元的列表</strong>，而这本身需要耗费资源，另外享元模式使得系统更加复杂。</p></li><li><p>为了使对象可以共享，需要将一些<strong>状态外部化</strong>，这使得程序的逻辑复杂化。</p></li></ul><p>因此，应当在有<strong>足够多的对象实例</strong>可供共享时才值得使用享元模式。</p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板5-2.贪心-Huffman树</title>
    <link href="/2023/11/01/algorithm/template/5-2.Huffman%E6%A0%91/"/>
    <url>/2023/11/01/algorithm/template/5-2.Huffman%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h1><p>问题可以看作一颗完全二叉树。</p><p>Huffman树的总代价：对于每个叶子节点n，需要的代价是<code>n所处的层级*n的权重</code>，把它们求和</p><p>问题：如何排列所有叶子节点，使得总代价最小</p><p>解法：每次挑权重最小的两个节点合并。</p><p>可以证明：权重最小的两个点，在树中一定是最深的节点，且可以互为兄弟节点。</p><blockquote><p>证明：</p><ol><li>如果最小节点深度不是最深，将其与最深的节点交换位置，代价一定减小；</li><li>可以互为兄弟：在最深层可以任意交换位置。</li></ol></blockquote><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="1-合并果子"><a href="#1-合并果子" class="headerlink" title="1. 合并果子"></a>1. 合并果子</h3><blockquote><p>和DP中的石子合并的区别：石子合并必须两堆石子相邻，果子没有这个限制。</p></blockquote><p>Huffman树中所有叶子节点就是要合并的果子堆。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> t;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);<br>        heap.<span class="hljs-built_in">push</span>(t);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> a = heap.<span class="hljs-built_in">top</span>(); heap.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> b = heap.<span class="hljs-built_in">top</span>(); heap.<span class="hljs-built_in">pop</span>();<br>        res += a + b;<br>        heap.<span class="hljs-built_in">push</span>(a + b);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板5-1.贪心-区间问题</title>
    <link href="/2023/11/01/algorithm/template/5-1.%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/01/algorithm/template/5-1.%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑按照左端点&#x2F;右端点排序。</p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="1-区间选点"><a href="#1-区间选点" class="headerlink" title="1. 区间选点"></a>1. 区间选点</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol><li>将所有区间按右端点从小到大排序</li><li>枚举每个区间<ol><li>如果区间不包含当前点x，取区间右端点作为x</li><li>如果区间包含当前点x，跳过该区间</li></ol></li></ol><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><blockquote><p>证明技巧：要证A&#x3D;B, 可以证A&gt;&#x3D;B &amp;&amp; A&lt;&#x3D;B</p></blockquote><p>设点数最小值为<code>ans</code>，上述算法得出的值为<code>cnt</code>。</p><ul><li>证<code>ans &lt;= cnt</code>：<code>cnt</code>个点一定覆盖了所有区间，所以是一种合法方案，而<code>ans</code>是合法方案里的最小值。</li><li>证<code>ans &gt;= cnt</code>：上述算法等价于将取点范围从所有区间缩小为了没有交集的<code>cnt</code>个区间，覆盖这<code>cnt</code>个区间至少要<code>cnt</code>个点。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Range</span><br>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Range &amp;W)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> r &lt; W.r;<br>    &#125;<br>&#125;range[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>        range[i] = &#123;l, r&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(range, range + n);<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (range[i].l &lt;= ed &amp;&amp; range[i].r &gt;= ed) <span class="hljs-keyword">continue</span>;<br>        ed = range[i].r; res ++;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：也可以自定义比较函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Range a,Range b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.r&lt;b.r;<br>&#125;<br><span class="hljs-built_in">sort</span>(range,range+n,cmp);<br></code></pre></td></tr></table></figure><h3 id="2-最大不相交区间数量"><a href="#2-最大不相交区间数量" class="headerlink" title="2. 最大不相交区间数量"></a>2. 最大不相交区间数量</h3><p>选最多不相交的区间和上一题选最少的点等价。</p><h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>设区间数最大值为<code>ans</code>，算法得出的值为<code>cnt</code>。</p><ul><li>证<code>ans &gt;= cnt</code>：上述算法等价于将取点范围从所有区间缩小为了没有交集的<code>cnt</code>个区间，所以是一种合法方案。</li><li>证<code>ans &lt;= cnt</code>：反证，假设<code>ans &gt; cnt</code>，即有<code>ans</code>个不相交的区间，那么至少需要<code>ans</code>个点才可以覆盖所有区间，但事实上<code>cnt</code>个点一定覆盖了所有区间，所以矛盾。</li></ul><h3 id="3-区间分组"><a href="#3-区间分组" class="headerlink" title="3. 区间分组"></a>3. 区间分组</h3><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ol><li><p>将所有区间按左端点从小到大排序</p></li><li><p>从前往后处理每个区间</p><p><code>L[i] &gt; max_r</code>: 判断能否将其放到某个现有的组中：组中最大的右端点是否在当前区间左端点的左侧</p><ol><li>是：将区间放入该组，更新当前组的max_r</li><li>否：创建一个新组，将其放进去</li></ol><blockquote><p>为什么可以直接放入max_r最小的组，而不是max_r离当前区间左端点最近但不相交的组？</p><p>因为所有区间按左端点排序过了，下一个区间必定与上一个区间相交，或完全在其右侧，不可能完全在其左侧</p></blockquote></li></ol><h4 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h4><p>设分组数最小值为<code>ans</code>，算法得出的分组数为<code>cnt</code>。</p><ul><li>证<code>ans &lt;= cnt</code>：上述算法能够将区间放到<code>cnt</code>个组中，且组中所有区间没有交集，所以是一种合法方案。</li><li>证<code>ans &gt;= cnt</code>：既然开了新组，就说明存在一个点，每个组都能找到一个区间使得这个点在区间内（感觉不一定，因为算法只根据组内区间右端点的最大值来判断，有可能这个点在两个区间中间的空隙里），所以至少要有<code>cnt</code>个组保证这<code>cnt</code>个区间不重合。</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Range</span><br>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Range &amp;W)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> l &lt; W.l;<br>    &#125;<br>&#125;range[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;range[i].l, &amp;range[i].r);<br>    <br>    <span class="hljs-built_in">sort</span>(range, range + n);<br>    <br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (heap.<span class="hljs-built_in">empty</span>() || heap.<span class="hljs-built_in">top</span>() &gt;= range[i].l) heap.<span class="hljs-built_in">push</span>(range[i].r);<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 更新右端点最大值最小的组中右端点的最大值</span><br>        &#123;<br>            heap.<span class="hljs-built_in">pop</span>();<br>            heap.<span class="hljs-built_in">push</span>(range[i].r);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, heap.<span class="hljs-built_in">size</span>());<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-区间覆盖"><a href="#4-区间覆盖" class="headerlink" title="4. 区间覆盖"></a>4. 区间覆盖</h3><h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><p>假设区间从start到end</p><ol><li>将所有区间按左端点从小到大排序</li><li>从前往后依次枚举每个区间，在所有能覆盖start的区间中，选择右端点最大的区间，然后将start更新成右端点的最大值</li></ol><h4 id="证明-3"><a href="#证明-3" class="headerlink" title="证明"></a>证明</h4><p>设区间数最小值为<code>ans</code>，算法得出的区间数为<code>cnt</code>。</p><p>把最优解和算法的解的区间从小到大枚举，找到第一个不同的区间：因为算法选择的是右端点的最大值，所以可以把最优解的该区间替换成算法的区间（不亏，只会让右端点更长），以此类推，最终最优解可以转化成上述算法的解。</p><blockquote><p>感觉和没证一样…</p></blockquote><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> st, ed, n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Range</span><br>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Range &amp;W)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> l &lt; W.l;<br>    &#125;<br>&#125;range[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;st, &amp;ed, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;range[i].l, &amp;range[i].r);<br>    <br>    <span class="hljs-built_in">sort</span>(range, range + n);<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> j = i, r = <span class="hljs-number">-2e9</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; range[j].l &lt;= st)<br>        &#123;<br>            r = <span class="hljs-built_in">max</span>(r, range[j].r);<br>            j ++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (r &lt; st) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 失败</span><br>        <br>        res ++;<br>        <span class="hljs-keyword">if</span> (r &gt;= ed)<br>        &#123;<br>            success = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        st = r, i = j - <span class="hljs-number">1</span>; <span class="hljs-comment">// 因为i还要++的</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (success) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-8.DP-记忆化搜索</title>
    <link href="/2023/11/01/algorithm/template/4-8.%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A0/"/>
    <url>/2023/11/01/algorithm/template/4-8.%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h3><p>前提：图是拓扑图，不存在环（循环依赖）。</p><p>时间复杂度：<code>O(n^2)</code></p><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f[i, j]</code>表示所有从点(i, j)开始滑的路径长度的最大值。</p><h4 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h4><p>分成四个子集，分别为往四个方向滑的路径的最大值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">310</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N][N], f[N][N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> &amp;v = f[x][y];<br>    <br>    <span class="hljs-keyword">if</span> (v != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> v; <span class="hljs-comment">// 如果已经搜索过了，直接返回即可，否则时间复杂度是指数级别</span><br>    <br>    v = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>        <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; n &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; m &amp;&amp; h[a][b] &lt; h[x][y])<br>            v = <span class="hljs-built_in">max</span>(v, <span class="hljs-built_in">dp</span>(a, b) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;h[i][j]);<br>    <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f); <span class="hljs-comment">// 初始化，-1表示还没有搜索过</span><br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">dp</span>(i, j)); <span class="hljs-comment">// 枚举起点</span><br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式25-中介者模式</title>
    <link href="/2023/11/01/design-pattern/25.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/11/01/design-pattern/25.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>迪米特法则的实现。</p><p>通过中介者对象，可以将系统的网状结构变成以中介者为中心的星状结构，每个具体对象不再通过直接的联系与另一个对象发生相互作用，而是通过”中介者”对象与另一个对象发生相互作用。</p><blockquote><p>如联合国可以作为各个国家的中介者，用来转发消息，而不是让各个国家直接通信。</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>中介者模式（Mediator），用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/11/01/sf3KV7nBPTLixMy.jpg" alt="中介者模式结构图.jpg"></p><p>Colleague叫作抽象同事类，而ConcreteColleague是具体同事类，每个具体同事只知道自己的行为，而不了解其他同事类的情况，但他们却都认识中介者对象。</p><p>Mediator是抽象中介者，定义了同事对象到中介者对象的接口，ConcreteMediator是具体中介者对象，实现抽象类的方法，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Colleague</code>类：抽象同事类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Colleague</span> &#123;<br>  <span class="hljs-keyword">protected</span> Mediator mediator;<br>  <span class="hljs-comment">// 构造方法，得到中介者对象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Colleague</span><span class="hljs-params">(Mediator mediator)</span> &#123;<br>    <span class="hljs-built_in">this</span>.mediator = mediator;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteColleague1</code>, <code>ConcreteColleague2</code>：具体同事类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteColleague1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Colleague</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteColleague1</span><span class="hljs-params">(Mediator mediator)</span> &#123;<br>    <span class="hljs-built_in">super</span>(mediator);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>    <span class="hljs-built_in">this</span>.mediator.send(message, <span class="hljs-built_in">this</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;同事1得到信息：&quot;</span> + message);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteColleague2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Colleague</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteColleague2</span><span class="hljs-params">(Mediator mediator)</span> &#123;<br>    <span class="hljs-built_in">super</span>(mediator);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>    <span class="hljs-built_in">this</span>.mediator.send(message, <span class="hljs-built_in">this</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;同事2得到信息：&quot;</span> + message);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Mediator</code>类：抽象中介者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;<br>  <span class="hljs-comment">// 定义一个抽象的发送消息方法，得到同事对象和发送消息</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message, Colleague colleague)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteMediator</code>类：具体中介者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteMediator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mediator</span> &#123;<br>  <span class="hljs-keyword">private</span> ConcreteColleague1 colleague1;<br>  <span class="hljs-keyword">private</span> ConcreteColleague2 colleague2;<br>  <br>  <span class="hljs-comment">// 需要了解所有的具体同事对象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColleague1</span><span class="hljs-params">(ConcreteColleague1 value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.colleague1 = value;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColleague2</span><span class="hljs-params">(ConcreteColleague2 value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.colleague2 = value;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 重写发送信息的方法，根据对象做出选择判断，通知对象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message, Colleague colleague)</span> &#123;<br>    <span class="hljs-keyword">if</span> (colleague == colleague1) &#123;<br>      colleague2.notify(message);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      colleague1.notify(message);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ConcreteMediator</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteMediator</span>();<br><br><span class="hljs-comment">// 让两个具体同事类对象认识中介者对象</span><br><span class="hljs-type">ConcreteColleague1</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteColleague1</span>(m);<br><span class="hljs-type">ConcreteColleague1</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteColleague2</span>(m);<br><br><span class="hljs-comment">// 让中介者认识各个具体同事类对象</span><br>m.setColleague1(c1);<br>m.setColleague2(c2);<br><br>c1.send(<span class="hljs-string">&quot;notify c2&quot;</span>);<br>c2.send(<span class="hljs-string">&quot;notify c1&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>中介者模式很容易在系统中应用，也很容易在系统中误用。当系统出现了’多对多’交互复杂的对象群时，不要急于使用中介者模式，而要先反思你的系统在设计上是不是合理。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>Mediator的出现<strong>减少了各个Colleague的耦合</strong>，使得可以独立地改变和复用各个Colleague类和Mediator，比如任何国家的改变不会影响到其他国家，而只是与安理会发生变化。</p></li><li><p>由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个<strong>更宏观的角度</strong>去看待系统。</p><blockquote><p>比如巴以冲突，本来只能算是国与国之间的矛盾，因此各自的看法可能都比较狭隘，但站在联合国安理会的角度，就可以从全球化、也更客观的角度来看待这个问题，在调停和维和上做出贡献。</p></blockquote></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于ConcreteMediator控制了集中化，于是就把交互复杂性变为中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>中介者模式一般应用于：</p><ul><li>一组<strong>对象以定义良好但是复杂的方式进行通信</strong>的场合，比如窗体Form对象或Web页面aspx</li><li>想定制一个分布在多个类中的行为，而又<strong>不想生成太多的子类</strong>的场合</li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-7.DP-树形DP</title>
    <link href="/2023/10/30/algorithm/template/4-7.%E6%A0%91%E5%BD%A2DP/"/>
    <url>/2023/10/30/algorithm/template/4-7.%E6%A0%91%E5%BD%A2DP/</url>
    
    <content type="html"><![CDATA[<h1 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h1><p>一般是DFS的形式。</p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h3><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f(i, 0)</code>和<code>f(i, 1)</code>分别表示在以<code>i</code>为根的子树中不选<code>i</code>和选<code>i</code>的最大值是多少。</p><h4 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h4><p><code>f[i, 0] = sum(max(f[i的子节点, 0], f[i的子节点, 1]))</code></p><p><code>f[i, 1] = sum(f[i的子节点, 0])</code></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N], f[N][<span class="hljs-number">2</span>];<br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 为了找到根节点，值为false的话则为根节点</span><br><span class="hljs-type">int</span> idx, e[N], ne[N], h[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    f[u][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, f[u][<span class="hljs-number">1</span>] = w[u]; <span class="hljs-comment">// 快乐指数有负数，但如果不选该点则应该初始化为0</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) <span class="hljs-comment">// 遍历u的子节点</span><br>    &#123;<br>        <span class="hljs-type">int</span> t = e[i];<br>        <span class="hljs-built_in">dfs</span>(t);<br>        f[u][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(f[t][<span class="hljs-number">0</span>], f[t][<span class="hljs-number">1</span>]);<br>        f[u][<span class="hljs-number">1</span>] += f[t][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; w[i];<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(b, a);<br>        st[a] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> root = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (st[root]) root ++; <span class="hljs-comment">// 找到根节点</span><br>    <br>    <span class="hljs-built_in">dfs</span>(root);<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">max</span>(f[root][<span class="hljs-number">0</span>], f[root][<span class="hljs-number">1</span>]) &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-6.DP-状态压缩DP</title>
    <link href="/2023/10/30/algorithm/template/4-6.%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
    <url>/2023/10/30/algorithm/template/4-6.%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/</url>
    
    <content type="html"><![CDATA[<h1 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h1><p>一般数据范围非常小。如蒙德里安的梦想：$1&lt;&#x3D;N, M&lt;&#x3D;11$</p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="1-蒙德里安的梦想"><a href="#1-蒙德里安的梦想" class="headerlink" title="1. 蒙德里安的梦想"></a>1. 蒙德里安的梦想</h3><p>放1*2的小方块，把长m宽n的矩形放满。</p><p>核心：先放横着的，再放竖着的。</p><p>总方案数 &#x3D; 只放横着的小方块的合法方案数</p><p>如何判断当前方案是否合法？ 所有剩余位置，能否填充满竖着的小方块。可以按列来看，每一列内部所有连续的空着的小方块需要是偶数个。</p><p>时间复杂度：<code>M * 2^N * 2^N</code></p><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f[i, j]</code>表示已经将前<code>i - 1</code>列摆好，且从第<code>i - 1</code>列，伸出到第<code>i</code>列的状态是<code>j</code>的所有方案。</p><p>答案为<code>f[m, 0]</code>，即全部的列都已经摆好，且不再往外伸。</p><h4 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h4><p><code>f[i, j]</code>由<code>f[i - 1, k]</code>计算得出，其中<code>k</code>用二进制位来表示（e.g. 00100），有<code>2^n</code>种取值，每一行都可以选从<code>i - 2</code>列到第<code>i - 1</code>列伸或不伸。</p><p>所有的k需要满足两个条件才合法：</p><ol><li>(j &amp; k) &#x3D;&#x3D; 0。即方块不能有重叠，已经放了就不能再放</li><li>一列中所有连续空着的位置的长度必须是偶数。即要保证不重不漏地全摆上竖着的小方块。</li></ol><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>预处理</p><ol><li><code>state[k][]</code>：可以从<code>k</code>状态更新到哪些<code>j</code>状态。</li><li><code>st[]</code>：一列中所有连续的空白小方块是否是偶数个。</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">12</span>, M = <span class="hljs-number">1</span> &lt;&lt; N;<br><br><span class="hljs-type">int</span> n, m;<br>LL f[N][M];<br>vector&lt;<span class="hljs-type">int</span>&gt; state[M];<br><span class="hljs-type">bool</span> st[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m)<br>    &#123;<br>        <span class="hljs-comment">// 预处理st数组：列中所有连续的空白小方块数量是否为偶数个</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++) <span class="hljs-comment">// 遍历所有可能的列的状态</span><br>        &#123;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">bool</span> is_valid = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++) <span class="hljs-comment">// 遍历该列每个小方块</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> ((i &gt;&gt; j) &amp; <span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>)<br>                    &#123;<br>                        is_valid = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 合法，空白方块数重新计数</span><br>                &#125; <span class="hljs-keyword">else</span> cnt ++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) is_valid = <span class="hljs-literal">false</span>;<br>            st[i] = is_valid;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 预处理state数组：从哪些j状态可以到达i状态</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++)<br>        &#123;<br>            state[i].<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1</span> &lt;&lt; n; j ++)<br>                <span class="hljs-keyword">if</span> ((i &amp; j) == <span class="hljs-number">0</span> &amp;&amp; st[i | j])<br>                    state[i].<span class="hljs-built_in">push_back</span>(j);<br>        &#125;<br>        <br>        <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化，从第-1列到第0列，伸出到全空的列的方案数为1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1</span> &lt;&lt; n; j ++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> k : state[j])<br>                    f[i][j] += f[i - <span class="hljs-number">1</span>][k];<br>        <br>        cout &lt;&lt; f[m][<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-最短Hamilton路径"><a href="#2-最短Hamilton路径" class="headerlink" title="2. 最短Hamilton路径"></a>2. 最短Hamilton路径</h3><p>时间复杂度：<code>2^N * N</code>， <code>N</code>为点数</p><p>很重要的前提：图是完全图，并且两边之和大于第三边。</p><h4 id="状态表示-1"><a href="#状态表示-1" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f[i, j]</code>的含义：状态是<code>i</code>的情况下，最后停在点<code>j</code>，其中<code>i</code>表示哪些点被用过，可能的取值为<code>2^N</code>，<code>N</code>为点数</p><h4 id="状态计算-1"><a href="#状态计算-1" class="headerlink" title="状态计算"></a>状态计算</h4><p><code>f[state][j] = f[state_k][k] + weight[k][j]</code>，其中<code>state_k = state除掉j之后的集合，且state_k中要包含k</code></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>两层循环，要外层先枚举状态，再枚举所有点</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">因为在进行状态转移时，f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> 要由 f<span class="hljs-selector-attr">[i - (1 &lt;&lt; j)]</span><span class="hljs-selector-attr">[k]</span> 转移过来，所以一定要保证在计算 f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> 之前一定已经计算过 f<span class="hljs-selector-attr">[i - (1 &lt;&lt; j)]</span><span class="hljs-selector-attr">[k]</span> 了，这样才能保证答案递推的连续性。<br><br>在 <span class="hljs-selector-tag">i</span> 是外层循环中，是按照最外层为 状态依次从小到大 的顺序进行对答案的计算<br>因为状态 <span class="hljs-selector-tag">i</span> - (<span class="hljs-number">1</span> &lt;&lt; j) 一定是小于状态 <span class="hljs-selector-tag">i</span> 的，所以符合递推的连续性。<br><br>在 j 是外层循环中，在计算 f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> 时一定用到 f<span class="hljs-selector-attr">[i - (1 &lt;&lt; j)]</span><span class="hljs-selector-attr">[k]</span><br>而当 k&gt;j 的情况时，此时的 f<span class="hljs-selector-attr">[i - (1 &lt;&lt; j)]</span><span class="hljs-selector-attr">[k]</span> 并没有被计算过，因为你最外层循环还没循环到k呢。<br><br>例如： f<span class="hljs-selector-attr">[101011]</span><span class="hljs-selector-attr">[3]</span> = f<span class="hljs-selector-attr">[100011]</span><span class="hljs-selector-attr">[5]</span> + w<span class="hljs-selector-attr">[5]</span><span class="hljs-selector-attr">[3]</span><br>按 <span class="hljs-selector-tag">i</span> 外层循环，一定可以保证 f<span class="hljs-selector-attr">[100011]</span><span class="hljs-selector-attr">[5]</span> 在f<span class="hljs-selector-attr">[101011]</span><span class="hljs-selector-attr">[3]</span> 之前被计算出来。<br>而按 j 外层循环，由于 <span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span> ，f<span class="hljs-selector-attr">[100011]</span><span class="hljs-selector-attr">[5]</span> 根本就没有被计算过，所以不可行。<br></code></pre></td></tr></table></figure><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>, M = <span class="hljs-number">1</span> &lt;&lt; N;<br><span class="hljs-type">int</span> w[N][N];<br><span class="hljs-type">int</span> f[M][N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i][j]);<br>    <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 从起点出发，路径长度为0</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++) <span class="hljs-comment">// 枚举当前终点j</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>) <span class="hljs-comment">// 路径经过j才合法</span><br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k ++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (i - (<span class="hljs-number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="hljs-number">1</span>) <span class="hljs-comment">// 路径经过k</span><br>                    &#123;<br>                        f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - (<span class="hljs-number">1</span> &lt;&lt; j)][k] + w[k][j]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    <br>    cout &lt;&lt; f[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] &lt;&lt; endl; <span class="hljs-comment">// 经过了所有点，且最终停在终点</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式24-职责链模式</title>
    <link href="/2023/10/30/design-pattern/24.%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/30/design-pattern/24.%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>职责链模式（Chain of Responsibility）：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/30/365cXGqiPFpfLoW.jpg" alt="职责链模式结构图.jpg"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Handler</code> 类：定义一个处理请求的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br>  <span class="hljs-keyword">protected</span> Handler successor;<br>  <br>  <span class="hljs-comment">// 设置后继者</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(Handler successor)</span> &#123;<br>    <span class="hljs-built_in">this</span>.successor = successor;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteHandler</code> 类：具体处理者类，处理它负责的请求，可访问它的后继者，如果可处理该请求，就处理之，否则就将该请求转发给它的后继者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConcreteHandler1: 当请求数为0~10时有权处理，否则转发给后继</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandler1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span> &#123;<br>    <span class="hljs-keyword">if</span> (request &gt;= <span class="hljs-number">0</span> &amp;&amp; request &lt; <span class="hljs-number">10</span>) &#123;<br>      System.out.println(<span class="hljs-built_in">this</span>.getClass().getSimpleName() + <span class="hljs-string">&quot;处理请求&quot;</span> + request);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) &#123;<br>      successor.handleRequest(request);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// ConcreteHandler2: 当请求数为10~20时有权处理，否则转发给后继</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandler2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span> &#123;<br>    <span class="hljs-keyword">if</span> (request &gt;= <span class="hljs-number">10</span> &amp;&amp; request &lt; <span class="hljs-number">20</span>) &#123;<br>      System.out.println(<span class="hljs-built_in">this</span>.getClass().getSimpleName() + <span class="hljs-string">&quot;处理请求&quot;</span> + request);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) &#123;<br>      successor.handleRequest(request);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Handler</span> <span class="hljs-variable">h1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteHandler1</span>();<br><span class="hljs-type">Handler</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteHandler2</span>();<br><br>h1.setSuccessor(h2);<br><br><span class="hljs-type">int</span>[] requests = &#123; <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">14</span> &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> request : requests) &#123;<br>h1.handleRequest(request);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用，大大降低了耦合度。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理。需要事先考虑全面。</p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-5.DP-数位统计DP</title>
    <link href="/2023/10/29/algorithm/template/4-5.%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP/"/>
    <url>/2023/10/29/algorithm/template/4-5.%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1DP/</url>
    
    <content type="html"><![CDATA[<h1 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h1><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>分情况讨论。</p><h2 id="模板题：计数问题"><a href="#模板题：计数问题" class="headerlink" title="模板题：计数问题"></a>模板题：计数问题</h2><p>求数a～b中，0～9出现的次数。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>类似前缀和的思想。构造一个函数<code>count(n, x)</code>，表示1～n中x出现的次数</p><p><code>ans = count(b, x) - count(a - 1, x)</code></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>遍历位数，分别求出x在每一位上出现的次数。</p><p>设<code>n=abcdefg</code>，求<code>x</code>在第4位上出现的次数：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs llvm">将第<span class="hljs-number">3</span>位确定为<span class="hljs-keyword">x</span><br><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> yyxzzz &lt;<span class="hljs-operator">=</span> abcdef<br><br>分情况：<br>(<span class="hljs-number">1</span>) yy <span class="hljs-operator">=</span> <span class="hljs-number">00</span> ~ ab - <span class="hljs-number">1</span>: zzz可取<span class="hljs-number">000</span>~<span class="hljs-number">999</span>. 总次数为ab * <span class="hljs-number">1000</span><br>(<span class="hljs-number">2</span>) yy <span class="hljs-operator">=</span> ab:<br>(<span class="hljs-number">2.1</span>) <span class="hljs-keyword">c</span> &lt; <span class="hljs-keyword">x</span>: abxzzz &gt; abcdef，总次数为<span class="hljs-number">0</span><br>(<span class="hljs-number">2.2</span>) <span class="hljs-keyword">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>: zzz可取<span class="hljs-number">000</span>~def，总次数为def + <span class="hljs-number">1</span><br>(<span class="hljs-number">2.3</span>) <span class="hljs-keyword">c</span> &gt; <span class="hljs-keyword">x</span>: zzz可取<span class="hljs-number">000</span>~<span class="hljs-number">999</span>，总次数为<span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-4.DP-计数类DP</title>
    <link href="/2023/10/29/algorithm/template/4-4.%E8%AE%A1%E6%95%B0%E7%B1%BBDP/"/>
    <url>/2023/10/29/algorithm/template/4-4.%E8%AE%A1%E6%95%B0%E7%B1%BBDP/</url>
    
    <content type="html"><![CDATA[<h1 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h1><h2 id="模板题：整数划分"><a href="#模板题：整数划分" class="headerlink" title="模板题：整数划分"></a>模板题：整数划分</h2><h3 id="解法一：完全背包问题"><a href="#解法一：完全背包问题" class="headerlink" title="解法一：完全背包问题"></a>解法一：完全背包问题</h3><p>看作从权重为1～n的物品中选总权重不超过n的物品的完全背包问题，属性为总选法的个数cnt。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">f[i][j] = f[i - <span class="hljs-number">1</span>][j] + f[i - <span class="hljs-number">1</span>][j - i] + f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span>i] + ... + f[i - <span class="hljs-number">1</span>][j - si]<br>f[i][j - i] = f[i - <span class="hljs-number">1</span>][j - i] + f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span>i] + ... + f[i - <span class="hljs-number">1</span>][j - si]<br><br>=&gt;f[i][j] = f[i - <span class="hljs-number">1</span>][j] + f[i][j - i]<br></code></pre></td></tr></table></figure><h3 id="解法二：计数DP"><a href="#解法二：计数DP" class="headerlink" title="解法二：计数DP"></a>解法二：计数DP</h3><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p>集合：<code>f(i, j)</code>表示所有总和是<code>i</code>，并且恰好表示成<code>j</code>个数的和的方案。</p><p>属性：方案数量</p><h4 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h4><p>集合划分为：<code>方案中的最小值为1</code> 和 <code>方案中的最小值大于1</code> 两个集合。</p><p><code>f[i][j] = f[i - 1][j - 1] + f[i - j][j]</code>，等式右边的两项分别对应上述两个集合的方案数。</p><blockquote><p><code>f[i - 1][j - 1]</code>表示把集合中等于1的那个数去掉的选法数量，之后加上1选法数量不变</p><p><code>f[i - j][j]</code>表示把方案中所有数都减去1的选法数量，总共减了<code>j</code>，数的个数还是<code>j</code></p></blockquote><p><code>ans = f[n][1] + f[n][2] + ... + f[n][n]</code></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式23-命令模式</title>
    <link href="/2023/10/29/design-pattern/23.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/29/design-pattern/23.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>命令模式（Command），将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/29/DhKeTdnJQt6GuxX.jpg" alt="命令模式结构图.jpg"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Command</code> 类：用来声明执行操作的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> &#123;<br>  <br>  <span class="hljs-keyword">protected</span> Receiver receiver;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Command</span><span class="hljs-params">(Receiver receiver)</span> &#123;<br>    <span class="hljs-built_in">this</span>.receiver = receiver;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 执行命令</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeCommand</span><span class="hljs-params">()</span>;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteCommand</code> 类：将一个 <code>Receiver</code> 对象绑定于一个动作，调用 <code>Receiver</code> 相应的操作，以实现 <code>executeCommand</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Command</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteCommand</span><span class="hljs-params">(Receiver receiver)</span> &#123;<br>    <span class="hljs-built_in">super</span>(receiver);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeCommand</span><span class="hljs-params">()</span> &#123;<br>    receiver.action();<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>Invoker</code> 类：要求 <code>Command</code> 执行请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> Command command;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command command)</span> &#123;<br>    <span class="hljs-built_in">this</span>.command = command;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeCommand</span><span class="hljs-params">()</span> &#123;<br>    command.executeCommand();<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>Receiver</code> 类：知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;执行请求&quot;</span>);<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Receiver</span> <span class="hljs-variable">receiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Receiver</span>();<br><span class="hljs-type">Command</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteCommand</span>(receiver);<br><span class="hljs-type">Invoker</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Invoker</span>();<br><br>invoker.setCommand(command);<br>invoker.executeCommand();<br></code></pre></td></tr></table></figure><h2 id="进一步改进代码"><a href="#进一步改进代码" class="headerlink" title="进一步改进代码"></a>进一步改进代码</h2><p><code>Invoker</code> 类中的 <code>Command</code> 属性可以修改成 <code>List</code>，以实现执行命令的批处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> ArrayList&lt;Command&gt; commands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Command&gt;();<br>  <br>  <span class="hljs-comment">// 设置命令</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command command)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> command.getClass().getSimpleName();<br>    <br>    <span class="hljs-keyword">if</span> (className.equals(<span class="hljs-string">&quot;xxx&quot;</span>))&#123; <span class="hljs-comment">// 对无法完成的请求给予回绝</span><br>      <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>.commands.add(command);<br>      System.out.println(<span class="hljs-string">&quot;增加请求：&quot;</span> + className + <span class="hljs-string">&quot;，时间：&quot;</span> + getNowTime());<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 取消命令</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelCommand</span><span class="hljs-params">(Command command)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> command.getClass().getSimpleName();<br>    commands.remove(command);<br>    System.out.println(<span class="hljs-string">&quot;取消请求：&quot;</span> + className + <span class="hljs-string">&quot;，时间：&quot;</span> + getNowTime());<br>  &#125;<br>  <br>  <span class="hljs-comment">// 通知执行</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyCommand</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (Command command : commands)<br>      command.executeCommand();<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getNowTime</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SimpleDataFormat</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>);<br>    <span class="hljs-keyword">return</span> formatter.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).toString();<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Receiver</span> <span class="hljs-variable">receiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Receiver</span>();<br><span class="hljs-type">Command</span> <span class="hljs-variable">command1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteCommand1</span>(receiver);<br><span class="hljs-type">Command</span> <span class="hljs-variable">command2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteCommand2</span>(receiver);<br><span class="hljs-type">Invoker</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Invoker</span>();<br><br>invoker.setCommand(command1);<br>invoker.setCommand(command2);<br>invoker.setCommand(command1);<br>invoker.setCommand(command1);<br><br>invoker.cancelCommand(command1);<br><br>invoker.setCommand(command2);<br><br>invoker.notifyCommand(); <span class="hljs-comment">// 执行所有命令</span><br></code></pre></td></tr></table></figure><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>它能较容易地设计一个命令队列</li><li>在需要的情况下，可以较容易地将命令记录进日志</li><li>允许接受请求的一方决定是否要否决请求</li><li>可以容易地实现对请求的撤销与重做</li><li>由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易</li><li>把<strong>请求一个操作</strong>的对象与<strong>知道怎么执行一个操作</strong>的对象分隔开</li></ul><blockquote><p>敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销／恢复操作等功能时，把原来的代码重构为命令模式才有意义。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>码出高效读书笔记2-面向对象</title>
    <link href="/2023/10/26/Java/OOP/%E7%A0%81%E5%87%BA%E9%AB%98%E6%95%88%E7%AC%94%E8%AE%B02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/10/26/Java/OOP/%E7%A0%81%E5%87%BA%E9%AB%98%E6%95%88%E7%AC%94%E8%AE%B02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p><img src="https://s2.loli.net/2023/10/26/hlvCdauSt7I6NMA.png" alt="访问权限控制及可见范围.png"></p><ul><li>如果不允许外部直接通过 new 创建对象，构造方法必须是 private。</li><li>工具类不允许有 public 或 default 构造方法。</li></ul><h3 id="this和super"><a href="#this和super" class="headerlink" title="this和super"></a>this和super</h3><p><img src="https://s2.loli.net/2023/10/26/Fx2lKfmdSgryw8X.png" alt="this和super的异同点.png"></p><ul><li><p>在一个构造方法中， this 和 super 只能出现一个，且只能出现一次，否则在实例化对象时，会因子类调用到多个父类构造方法而造成混乱。</p></li><li><p>由于 this 和 super都在实例化阶段调用，所以不能在<strong>静态方法</strong>和<strong>静态代码块</strong>申使用 this 和 super 关键字。</p></li></ul><h3 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h3><p>类与类之间的关系可分成两种·有关系与没关系，难点在于确定类与类之间是否存在相互作用。证明类之间没关系是一个涉及业务、架构、模块边界的问 题，往往由于业务模型的抽象角度不同而不同，是一件非常棘手的事情。如果找到了 没有关系的点，就可以如庖丁解牛一样，进行架构隔离、模块解耦等工作。</p><p>类与类有关系的情况，包括以下5种类型：</p><ul><li>【继承】 extends (is-a)。</li><li>【实现】 implements (can-do)。</li><li>【组合】 类是成员变量 (contains-a)。</li><li>【聚合】 类是成员变量(has-a)。</li><li>【依赖】 import类(use-a)。</li></ul><p>随着业务和架构的发展，类与类的关系是会发生变化的，必须用发展的眼光看待类图。</p><p>在业务重构过程中，往往会把原来强组合的关系拆开来，供其他模块调用，这就是类图的一种演变。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>常见的序列化方式有三种：</p><ol><li><strong>Java 原生序列化。</strong>Java类通过实现 Serializable接口来实现该类对象的序列化，这个接口非常特殊，没有任何方法，只起标识作用。<ul><li>实现 Serializable 接口的类要显式设置 serialVersionUID 字段值，否则类源码修改后该值会发生变化。<ul><li>如果是兼容升级，请不要修改 seria!VersionUID 字段 ， 避免反序列化失败。</li><li>如果是不兼容升级，需要修改 serialVersionUID 值，避免反序列化混乱。</li></ul></li><li>Java 反序列化时不会调用类的无参构造方法，而 是调用 native 方法将成员变量赋值为对应类型的初始值。基于性能及兼容性考虑，不 推荐使用 Java 原生序列化。</li></ul></li><li><strong>Hessian 序列化。</strong>压缩编码，比Java原生序列化二进制流小且耗时短。特性：<ul><li>自描述序列化类型。不依赖外部描述文件或接口定义 ， 用一个字节表示常用 基础类型 ， 极大缩短二进制流。</li><li>语言无关，支持脚本语言。</li><li>协议简单，比 Java 原生序列化高效。</li></ul></li><li><strong>JSON 序列化。</strong>JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。JSON 序列化就是将数据对象转换为 JSON 字符串。在序列化过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确地反序列化。相比前两种方式， JSON 可读性比较好，方便调试。</li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="参数预处理"><a href="#参数预处理" class="headerlink" title="参数预处理"></a>参数预处理</h4><h5 id="1-入参保护"><a href="#1-入参保护" class="headerlink" title="1. 入参保护"></a>1. 入参保护</h5><p>人参保护实质上是对服务提供方的保护，常见于批量接口。</p><p>虽然批量接口能处理批数据，但其处理能力并不是无限的，因此需要<strong>对入参的数据量进行判断和控制</strong>，如果超出处理能力，可以直接返回错误给客户端。</p><h5 id="2-参数校验"><a href="#2-参数校验" class="headerlink" title="2. 参数校验"></a>2. 参数校验</h5><p>需要进行参数校验的场景：</p><ul><li>调用频度低的方法。</li><li>执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退或者错误，则得不偿失。</li><li>需要极高稳定性和可用性的方法。 </li><li>对外提供的开放接口。</li><li>敏感权限入口。</li></ul><p>不需要进行参数校验的场景：</p><ul><li>极有可能被<strong>循环调用</strong>的方法。但在方法说明里必须注明外部参数检查。</li><li><strong>底层调用频度较高</strong>的方法。参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同个应用中，部署在同一台服务器中，所以可以省略 DAO 的参数校验。</li><li>声明成 <strong>private</strong> 只会被自己代码调用的方法。如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>单一职责</strong>对于构造方法同样适用，构造方法的使命就是在构造对象时进行传参操作，所以不应该在构造方法中引入业务逻辑。</p><p>如果在一个对象生产中 ，需要完成初始化上下游对象、分配内存、执行静态方法、赋值句柄等繁重的工作，其中某个步骤出错，导致没有完成对象初始化，再将希望寄托于业务逻辑部分来处理异常就是一件不受控制的事情了。故推荐将初始化业务逻辑放在某个方法中，比如<code>init()</code>， 当对象确认完成所有初始化工作之后，再显式调用。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>OOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Easy Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-3.DP-区间DP</title>
    <link href="/2023/10/26/algorithm/template/4-3.%E5%8C%BA%E9%97%B4DP/"/>
    <url>/2023/10/26/algorithm/template/4-3.%E5%8C%BA%E9%97%B4DP/</url>
    
    <content type="html"><![CDATA[<h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><h2 id="状态分析"><a href="#状态分析" class="headerlink" title="状态分析"></a>状态分析</h2><h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f(i, j)</code>一般表示从i到j这个区间中的方案。</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>要保证每次枚举的时候等式右侧的状态已经被更新过了。</p><p>所以按照区间长度从小到大来枚举。</p><p>三重循环：</p><ol><li>区间长度从小到大</li><li>区间左端点（右端点可以通过左端点和长度算出来）</li><li>左右端点之间的分界点</li></ol><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><p>时间复杂度：<code>O(n^3)</code>，状态表示2维<code>O(n^2)</code> * 状态计算枚举分界线<code>O(n)</code></p><h4 id="状态分析-1"><a href="#状态分析-1" class="headerlink" title="状态分析"></a>状态分析</h4><h5 id="状态表示-1"><a href="#状态表示-1" class="headerlink" title="状态表示"></a>状态表示</h5><ul><li>集合：所有将第i堆石子到第j堆石子合并成一堆石子的合并方式</li><li>属性：代价的min</li></ul><h5 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h5><p>以最后一次合并的分界线的位置来分类：枚举i到j中的任何一个点x，把x左边和右边的石子合并</p><p>转移方程：<code>f[i][j] = min&#123;f[i][k] + f[k + 1][j] + s[j] - s[i - 1]&#125;, k = i ~ j-1</code></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-2.DP-线性DP</title>
    <link href="/2023/10/26/algorithm/template/4-2.%E7%BA%BF%E6%80%A7DP/"/>
    <url>/2023/10/26/algorithm/template/4-2.%E7%BA%BF%E6%80%A7DP/</url>
    
    <content type="html"><![CDATA[<h1 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h1><p>DP的递推顺序是线性的。</p><blockquote><p>比如：<code>f(i, j)</code>中i和j是从小到大递增。</p><p>背包问题就是线性DP。</p></blockquote><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p><code>f(i, j)</code>表示走到第i行第j列时的最大路径</p><p>方程：<code>f(i, j) = max(f[i - 1][j], f[i - 1][j - 1]) + a[i][j]</code></p><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><p><code>f[i]</code>表示所有以第i个数结尾的上升子序列长度的最大值</p><p>从0到i-1枚举倒数第二位j，找到最长的<code>f[j]</code></p><p>方程：<code>f[i] = max(f[j] + 1), j = 0,1,2,...,i-1 &amp;&amp; a[j] &lt; a[i]</code></p><p>记录方案：用一个g数组记录第i个数对应的最长子序列中倒数第二位j：<code>g[i] = j</code>，最后就可以把路径倒序输出</p><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p><code>f(i, j)</code> 表示所有在第一个序列的前i个字母中出现，且在第二个序列的前j个字母中出现的子序列的长度的最大值</p><p>集合划分：</p><ul><li><p>以<code>a[i]</code>和<code>b[j]</code>是否出现在子序列中划分（4种情况）</p><ul><li>00：<code>f(i - 1, j - 1)</code>（不用写，已经包含在01和10情况内了）</li><li>01：<code>f(i - 1, j)</code></li><li>10：<code>f(i, j - 1)</code></li><li>11：<code>f(i - 1, j - 1) + 1</code>, 且需要满足<code>a[i] == b[j]</code></li></ul><blockquote><p>注意：</p><p>01情况：<code>f(i - 1, j)</code>和01又区别，前者表示在第二个的前j个字母中出现的子序列（第j个字母不一定包含在子序列内），而后者表示第j个字母一定在子序列内。前者包含后者。但由于<code>f(i, j)</code>包含<code>f(i - 1, j)</code>这种状态，属性又为Max（集合划分适当重叠不影响结果的正确性，只要不漏掉某些情况），所以可以这样表示。</p><p>10情况同理。</p><p>不懂再去复习一下题解。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式22-桥接模式</title>
    <link href="/2023/10/26/design-pattern/22.%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/26/design-pattern/22.%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="合成-聚合复用原则-CARP"><a href="#合成-聚合复用原则-CARP" class="headerlink" title="合成&#x2F;聚合复用原则 (CARP)"></a>合成&#x2F;聚合复用原则 (CARP)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>合成／聚合复用原则（CARP），尽量使用合成 (Composition)／聚合 (Aggregation)，尽量不要使用类继承。</p><h2 id="合成和聚合"><a href="#合成和聚合" class="headerlink" title="合成和聚合"></a>合成和聚合</h2><ul><li><p>聚合表示一种弱的’拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。</p><ul><li>如：大雁是群居动物，所以每只大雁都是属于一个雁群，一个雁群可以有多只大雁，所以大雁和雁群是聚合关系。</li></ul></li><li><p>合成则是一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</p><ul><li>如：大雁有两个翅膀，翅膀与大雁是部分和整体的关系，并且它们的生命周期是相同的，于是大雁和翅膀就是合成关系。</li></ul></li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>优先使用对象的合成／聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>桥接模式（Bridge），将抽象部分（如手机品牌）与它的实现部分（如手机软件）分离，使它们都可以独立地变化。</p><blockquote><p>什么叫抽象与它的实现分离？这并不是说，让抽象类与其派生类分离，因为这没有任何意义。实现指的是抽象类和它的派生类用来实现自己的对象。</p><p>实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。</p></blockquote><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/26/pstFy3v7dxHa481.png" alt="桥接模式结构图.png"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Implementor</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Implementor</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteImplementorA</code>和<code>ConcreteImplementorB</code>等派生类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteImplementorA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Implementor</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;具体实现A的方法执行&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteImplementorB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Implementor</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;具体实现B的方法执行&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Abstraction</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Abstraction</span> &#123;<br>  <br>  <span class="hljs-keyword">protected</span> Implementor implementor;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setImplementor</span><span class="hljs-params">(Implementor implementor)</span> &#123;<br>    <span class="hljs-built_in">this</span>.implementor = implementor;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RefinedAbstraction</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefinedAbstraction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Abstraction</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>    System.out.print(<span class="hljs-string">&quot;具体的Abstraction&quot;</span>);<br>    implementor.operation();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Abstraction ab;<br>ab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefinedAbstraction</span>();<br><br>ab.setImplementor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteImplementorA</span>());<br>ab.operation();<br><br>ab.setImplementor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteImplementorB</span>());<br>ab.operation();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-1.DP-背包问题</title>
    <link href="/2023/10/22/algorithm/template/4-1.DP-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2023/10/22/algorithm/template/4-1.DP-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h1 id="通用问题描述"><a href="#通用问题描述" class="headerlink" title="通用问题描述"></a>通用问题描述</h1><p>给定 <code>N</code> 个物品和容量是为 <code>V</code> 的背包。每一个物品 <code>i</code> 有两个属性：体积 <code>vi</code> 和价值 <code>wi</code> 。</p><p>求：在 <code>总体积&lt;=V</code>的情况下，选出一些物品，它们的<code>最大价值之和</code>是多少。</p><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定 <code>N</code> 个物品和容量是为 <code>V</code> 的背包。每一个物品 <code>i</code> 有两个属性：体积 <code>vi</code> 和价值 <code>wi</code> 。</p><p>求：在 <code>总体积&lt;=V</code>的情况下，选出一些物品，它们的<code>最大价值之和</code>是多少。</p><p><strong>每件物品只能用一次或者不用。</strong></p><h3 id="状态分析"><a href="#状态分析" class="headerlink" title="状态分析"></a>状态分析</h3><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f(i, j)</code></p><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>所有选法的集合。</p><p>满足条件：</p><ol><li>只从前 <code>i</code> 个物品中选</li><li>选出来的物品的 <code>总体积 &lt;= j</code></li></ol><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p><code>f(i, j)</code> 表示所有选法集合里的价值的最大值。</p><h4 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h4><p>集合划分：<code>f(i, j)</code> 分成不含 <code>i</code> （一定存在）和含 <code>i</code>（不一定存在，只有j &gt;&#x3D; vi才存在） 两种情况的集合。</p><p>得出状态转移方程：</p><p><code>f(i, j) = max(f(i - 1, j), f(i - 1, j - vi) + wi)</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="朴素：二维"><a href="#朴素：二维" class="headerlink" title="朴素：二维"></a>朴素：二维</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m; <span class="hljs-comment">// n: N, m: V</span><br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++)<br>  &#123;<br>    f[i][j] = f[i - <span class="hljs-number">1</span>][j]; <span class="hljs-comment">// 不含i，一定存在</span><br>    <span class="hljs-keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]); <span class="hljs-comment">// 含i，需要判断条件</span><br>  &#125;<br><br>cout &lt;&lt; f[n][m] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h4 id="优化：一维"><a href="#优化：一维" class="headerlink" title="优化：一维"></a>优化：一维</h4><p>思路：</p><p>由于 <code>f[i]</code> 这一层只需要用到 <code>f[i - 1]</code> 层，所以可以优化成两层的滚动数组。</p><p>又两种情况：j和j-v[i]都是小于等于j的，说明不会同时用到当前列两边的数据，所以可以进一步优化成一层数组，即优化成一维数组。</p><p>需要注意：由于j-v[i]在j的左边，需要保证第i-1层循环中的<code>f[j - v[i]]</code>在被用到的时候没有被第i层更新过，所以内层循环j应从大到小枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j --)<br>  &#123;<br>    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定 <code>N</code> 个物品和容量是为 <code>V</code> 的背包。每一个物品 <code>i</code> 有两个属性：体积 <code>vi</code> 和价值 <code>wi</code> 。</p><p>求：在 <code>总体积&lt;=V</code>的情况下，选出一些物品，它们的<code>最大价值之和</code>是多少。</p><p><strong>每件物品有无限个。</strong></p><h3 id="状态分析-1"><a href="#状态分析-1" class="headerlink" title="状态分析"></a>状态分析</h3><h4 id="状态表示-1"><a href="#状态表示-1" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f(i, j)</code></p><h5 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h5><p>所有选法的集合。</p><p>满足条件：</p><ol><li>只从前 <code>i</code> 个物品中选</li><li>选出来的物品的 <code>总体积 &lt;= j</code></li></ol><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><p><code>f(i, j)</code> 表示所有选法集合里的价值的最大值。</p><h4 id="状态计算-1"><a href="#状态计算-1" class="headerlink" title="状态计算"></a>状态计算</h4><p>集合划分：<code>f(i, j)</code> 分成含<code>0~k</code> 个 <code>i</code> 的集合，其中<code>k</code>满足<code>j &gt;= k*v[i]</code>。</p><p>得出状态转移方程：</p><p><code>f(i, j) = max(f(i - 1, j), f(i - 1, j - k * vi) + k * wi), j &gt;= k*v[i]</code></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="朴素：二维，三重循环"><a href="#朴素：二维，三重循环" class="headerlink" title="朴素：二维，三重循环"></a>朴素：二维，三重循环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m; <span class="hljs-comment">// n: N, m: V</span><br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j; k ++)<br>      f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - k * v[i]] + k * w[i]);<br></code></pre></td></tr></table></figure><h4 id="优化：一维，两重循环"><a href="#优化：一维，两重循环" class="headerlink" title="优化：一维，两重循环"></a>优化：一维，两重循环</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f<span class="hljs-selector-attr">[i, j]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span>, f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - v]</span> + w, f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - 2v]</span> + <span class="hljs-number">2</span>w, f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - 3v]</span> + <span class="hljs-number">3</span>w, ...)<br>=&gt;f<span class="hljs-selector-attr">[i, j - v]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - v]</span>, f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - 2v]</span> + w, f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - 3v]</span> + <span class="hljs-number">2</span>w, ...)<br>可以推出：<br>f<span class="hljs-selector-attr">[i, j]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span>, f<span class="hljs-selector-attr">[i, j - v]</span> + w)<br></code></pre></td></tr></table></figure><p><code>f[i, j - v]</code>用的是第<code>i</code>层的<code>f[j - v[i]]</code> 所以内层循环j从小到大枚举，这样<code>f[j - v[i]]</code> 刚好是被第<code>i</code>层更新过的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = v[i]; j &lt;= m; j ++)<br>      f[i][j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br></code></pre></td></tr></table></figure><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定 <code>N</code> 个物品和容量是为 <code>V</code> 的背包。每一个物品 <code>i</code> 有两个属性：体积 <code>vi</code> 和价值 <code>wi</code> 。</p><p>求：在 <code>总体积&lt;=V</code>的情况下，选出一些物品，它们的<code>最大价值之和</code>是多少。</p><p><strong>每件物品有 <code>si</code> 个。</strong></p><h3 id="状态分析-2"><a href="#状态分析-2" class="headerlink" title="状态分析"></a>状态分析</h3><h4 id="状态表示-2"><a href="#状态表示-2" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f(i, j)</code></p><h5 id="集合-2"><a href="#集合-2" class="headerlink" title="集合"></a>集合</h5><p>所有选法的集合。</p><p>满足条件：</p><ol><li>只从前 <code>i</code> 个物品中选</li><li>选出来的物品的 <code>总体积 &lt;= j</code></li></ol><h5 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h5><p><code>f(i, j)</code> 表示所有选法集合里的价值的最大值。</p><h4 id="状态计算-2"><a href="#状态计算-2" class="headerlink" title="状态计算"></a>状态计算</h4><p>集合划分：<code>f(i, j)</code> 分成含<code>0~s[i]</code> 个 <code>i</code> 的集合。</p><p>得出状态转移方程（和完全背包类似，只是k变成了s[i]）：</p><p><code>f(i, j) = max(f(i - 1, j - k * vi) + k * wi), k=0, 1, ..., si</code></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="朴素"><a href="#朴素" class="headerlink" title="朴素"></a>朴素</h4><p>时间复杂度：<code>N * V * S</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++)<br>      f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - k * v[i]] + k * w[i]);<br></code></pre></td></tr></table></figure><h4 id="优化：二进制优化"><a href="#优化：二进制优化" class="headerlink" title="优化：二进制优化"></a>优化：二进制优化</h4><p>能不能像完全背包一样优化呢？</p><p>不能，它们是有区别的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 完全背包</span><br>f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j - v] + w, f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span>v] + <span class="hljs-number">2</span>w, f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">3</span>v] + <span class="hljs-number">3</span>w, ...)<br>=&gt;f[i][j - v] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j - v], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span>v] + w, f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">3</span>v] + <span class="hljs-number">2</span>w, ...)<br><span class="hljs-comment">// 两个省略号是完全可以对齐的，因为只要满足第二维下标j-kv&gt;=0即可</span><br>可以推出：<br>f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - v] + w)<br>  <br><span class="hljs-comment">// 多重背包</span><br>f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j - v] + w, f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span>v] + <span class="hljs-number">2</span>w, f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">3</span>v] + <span class="hljs-number">3</span>w, ..., f[i - <span class="hljs-number">1</span>][j - sv] + sw)<br>=&gt;f[i][j - v] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j - v], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span>v] + w, f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">3</span>v] + <span class="hljs-number">2</span>w, ..., f[i - <span class="hljs-number">1</span>][j - (s+<span class="hljs-number">1</span>)v] + sw)<br><span class="hljs-comment">// 两个省略号不一定是完全可以对齐的，因为有可能j-(s+1)v&gt;=0，那么j-sv&gt;=0也成立，但没有(s+1)那么多个物品，相当于提前结束了，此时第一个等式中没有一项与f[i - 1][j-(s+1)v]对齐</span><br><span class="hljs-comment">// 无法通过第二个等式来得出第一个等式中f[i][j]的最大值</span><br></code></pre></td></tr></table></figure><p>优化方式：<strong>二进制优化</strong>，看成若干个01背包问题</p><p>时间复杂度：<code>N * V * logS</code></p><p>对于一个一般的s（即物品个数），把它分成若干个组，其中前k+1组中第i组中有<code>2^i</code>个物品（<code>i=0~k</code>），最后一组中有<code>c</code>个物品（<code>c=(s-前k+1组中物品之和) &amp;&amp; c &lt; 2^(k+1)</code>），这样通过选或不选各个组，可以拼凑出取<code>0～s</code> 个物品的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = n * logs, M = v;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N];<br><br><span class="hljs-comment">// 预处理物品</span><br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>&#123;<br>  <span class="hljs-type">int</span> a, b, s; <span class="hljs-comment">// 分别为当前物品的体积，价值和个数</span><br>  cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>  <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (k &lt;= s)<br>  &#123;<br>    cnt ++;<br>    v[cnt] = a * k;<br>    w[cnt] = b * k;<br>    s -= k;<br>    k &lt;&lt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 还剩下c个物品</span><br>  &#123;<br>    cnt ++;<br>    v[cnt] = a * s;<br>    w[cnt] = b * s;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 转化成01背包求解</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; cnt; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j --)<br>    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br><br>cout &lt;&lt; f[m] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定 <code>N</code> 组物品和容量是为 <code>V</code> 的背包，每组物品里有若干件物品。每一个物品 <code>i</code> 有两个属性：体积 <code>vi</code> 和价值 <code>wi</code> 。</p><p>求：在 <code>总体积&lt;=V</code>的情况下，选出一些物品，它们的<code>最大价值之和</code>是多少。</p><p><strong>每组物品中只能选1件。</strong></p><h3 id="状态分析-3"><a href="#状态分析-3" class="headerlink" title="状态分析"></a>状态分析</h3><h4 id="状态表示-3"><a href="#状态表示-3" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f(i, j)</code></p><h5 id="集合-3"><a href="#集合-3" class="headerlink" title="集合"></a>集合</h5><p>所有选法的集合。</p><p>满足条件：</p><ol><li>只从前 <code>i</code> 组物品中选</li><li>选出来的物品的 <code>总体积 &lt;= j</code></li></ol><h5 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h5><p><code>f(i, j)</code> 表示所有选法集合里的价值的最大值。</p><h4 id="状态计算-3"><a href="#状态计算-3" class="headerlink" title="状态计算"></a>状态计算</h4><p>集合划分：<code>f(i, j)</code> 枚举：选第<code>i</code>组物品中的哪一个或者不选。</p><p>状态转移方程：<code>f(i, j) = max(f(i - 1, j), f(i - 1, j - v[i][k]) + w[i][k])</code></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j --) <span class="hljs-comment">// 这里 j &gt;= 0 而不是 j &gt;= v[i] 是因为一组有多种物品，无法确定一个v[i]，放到循环内部去判断了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; s[i]; k ++) <span class="hljs-comment">// s[i]为该组物品个数</span><br>      <span class="hljs-keyword">if</span> (j &gt;= v[i][k]) f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-0.DP理解方式</title>
    <link href="/2023/10/22/algorithm/template/4-0.DP%E7%90%86%E8%A7%A3%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/10/22/algorithm/template/4-0.DP%E7%90%86%E8%A7%A3%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="DP理解"><a href="#DP理解" class="headerlink" title="DP理解"></a>DP理解</h1><h2 id="DP求解过程"><a href="#DP求解过程" class="headerlink" title="DP求解过程"></a>DP求解过程</h2><p>DP求解过程可以分为两步：状态表示</p><h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p>思考：问题需要用几维的状态来表示？</p><blockquote><p>背包问题有两维。</p></blockquote><p><code>f(i, j)</code></p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p><code>f(i, j)</code>表示的是什么集合？</p><blockquote><p>如背包问题：<code>f(i, j)</code>表示所有选法的集合。</p></blockquote><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><code>f(i, j)</code>这个数存的是这个集合的什么属性？min, max, cnt?</p><blockquote><p>如背包问题：<code>f(i, j)</code>表示集合选法对应的价值的最大值。</p></blockquote><h3 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h3><p>思考：如何一步一步地把每个状态算出来？</p><p>对应集合划分。如何将当前的集合<strong>不重不漏</strong>地划分成若干更小的子集，使得每一个子集都能够被前面的状态表示出来。</p><h2 id="DP优化"><a href="#DP优化" class="headerlink" title="DP优化"></a>DP优化</h2><p>DP优化一般是对代码&#x2F;状态方程做等价变形。</p><p>先把朴素算法写出来，再变形。</p><h1 id="DP时间复杂度分析"><a href="#DP时间复杂度分析" class="headerlink" title="DP时间复杂度分析"></a>DP时间复杂度分析</h1><p>状态数量 * 转移计算量</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板3-6.二分图</title>
    <link href="/2023/10/20/algorithm/template/3-6.%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2023/10/20/algorithm/template/3-6.%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p>通俗定义：一个图可以分成两个集合，每个集合内部没有边。</p><h2 id="染色法-DFS"><a href="#染色法-DFS" class="headerlink" title="染色法 (DFS)"></a>染色法 (DFS)</h2><p>时间复杂度：<code>O(n + m)</code></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>判别一个图是否为二分图。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>一个图是二分图（等价于这个图可以被2染色），当且仅当图中不含奇数环。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><ul><li><p>必要性（二分图-&gt;不含奇数环）：反证法</p><p>假设有奇数环：把环中每个点依次标记为1, 2, 1, 2, … 标记到最后一个点的时候，应该为1。而它后一个点（也就是第一个点）也为1，矛盾。</p></li><li><p>充分性（不含奇数环-&gt;二分图）：</p><p>先任意标记一个点为1，之后与它连通的所有点的数字都被确定。在不与它连通的点中，又任选一个点标记为1。</p><p>由于图中不含奇数环，所以染色过程中一定没有矛盾。</p><blockquote><p>证明：反证法</p><p>如果染色过程中出现了矛盾，那么一定是1, 2, 1, 2, …, 1, 1这种形式，最后两个1和1一定头尾相接（否则最后一个1可以被标记为2），那么环中点的数量一定为奇数，即图中一定含有奇数环</p></blockquote></li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">if</span> (i未被染色)<br>    <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">1</span>) <span class="hljs-comment">// 1表示染的颜色</span><br>    <br><span class="hljs-comment">// dfs过程</span><br>递归将所有相邻的点染成相反的颜色，并且判断能不能成功并返回<br></code></pre></td></tr></table></figure><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> color[N]; <span class="hljs-comment">// 表示每个点的颜色，-1表示为染色，0表示白色，1表示黑色</span><br><br><span class="hljs-comment">// 参数：u表示当前节点，c表示当前点的颜色</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>  color[u] = c;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) <span class="hljs-comment">// 遍历所有相邻点</span><br>  &#123;<br>    <span class="hljs-type">int</span> j = e[i];<br>    <span class="hljs-keyword">if</span> (color[j] == <span class="hljs-number">-1</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(j, !c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果相邻点还没有染色，递归染色，传递的颜色是与当前点相反的颜色</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>  <span class="hljs-built_in">memset</span>(color, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> color);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    <span class="hljs-keyword">if</span> (color[i] == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>时间复杂度：理论最坏<code>O(mn)</code>，实际远小于 <code>O(mn)</code>（可能接近线性）</p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>求二分图的成功匹配的情况下，最大的匹配数量。</p><p>匹配：指的是边的数量。</p><p>匹配成功：不存在两条边共用一个点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">设左边集合为S1，右边集合为S2.<br>依次遍历S1中的每个点i，看能否匹配S2中的点：<br>  <span class="hljs-number">1.</span> 如果有S2中的点没有被匹配，或者它匹配的S1中的点可以换一个点匹配，返回<span class="hljs-literal">true</span><br>  <span class="hljs-number">2.</span> 如果i指向的所有点都不能被匹配，返回<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n1, n2; <span class="hljs-comment">// n1表示S1中的点数，n2表示S2中的点数</span><br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx; <span class="hljs-comment">// 邻接表存储所有边，匈牙利算法中只会用到从S1指向S2的边</span><br><span class="hljs-type">int</span> match[N]; <span class="hljs-comment">// 存储S2中的每一个点当前匹配的S1中的点是哪个</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 表示S2中的每个点是否已经被遍历过</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; ~i; i = ne[i]) <span class="hljs-comment">// 遍历x结点指向S2集合的所有边</span><br>  &#123;<br>    <span class="hljs-type">int</span> j = e[i];<br>    <span class="hljs-keyword">if</span> (!st[j])<br>    &#123;<br>      st[j] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j])) <span class="hljs-comment">// S2中的j结点还没有被匹配，或者能够让j结点当前匹配的S1中的点换一个点匹配</span><br>      &#123;<br>        match[j] = x;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 求最大匹配数量，依次枚举S1中的每一个点能否匹配S2中的点</span><br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>&#123;<br>  <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st); <span class="hljs-comment">// 在枚举S1中每个点的时候都要把S2中所有点的状态置0，每个点都只需要考虑一次</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i)) res ++;<br>&#125;<br></code></pre></td></tr></table></figure><p>练习：372</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式21-单例模式</title>
    <link href="/2023/10/20/design-pattern/21.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/20/design-pattern/21.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单例模式（Singleton），保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/23/7qNvY9VbhWHPit2.png" alt="单例模式结构图.png"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>Singleton类，定义一个GetInstance操作，允许客户访问它的唯一实例。GetInstance是一个静态方法，主要负责创建自己的唯一实例。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>调用getInstance的时候再来创建instance。</p><h4 id="V1-线程不安全"><a href="#V1-线程不安全" class="headerlink" title="V1 线程不安全"></a>V1 线程不安全</h4><p>在多线程的情况下有可能创建多个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>  <br>  <span class="hljs-comment">// 构造方法private化，堵死了外部代码利用new创建此类实例的可能</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>  <br>  <span class="hljs-comment">// 得到Singleton的实例（唯一途径）</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> instance; <span class="hljs-comment">// 当instance为null时创建一个返回，否则直接返回原有实例</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="V2-synchronized锁方法"><a href="#V2-synchronized锁方法" class="headerlink" title="V2 synchronized锁方法"></a>V2 synchronized锁方法</h4><p>每次调用 <code>getInstance</code> 时都需要锁。写起来简单，但比较影响性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>  <br>  <span class="hljs-comment">// 构造方法private化</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>  <br>  <span class="hljs-comment">// 得到Singleton的实例（唯一途径）</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="V3-Double-Check-Locking"><a href="#V3-Double-Check-Locking" class="headerlink" title="V3 Double-Check Locking"></a>V3 Double-Check Locking</h4><p>不用让线程每次都加锁，而只是在实例未被创建的时候再加锁处理。同时也能保证多线程的安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance; <span class="hljs-comment">// volatile作用是使得所有线程能够及时得知instance是否被实例化的状态</span><br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 保证所有线程用的是同一把锁</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>          instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要两次判断instance是否为null？</p><p>对于instance存在的情况，就直接返回，这没有问题。当instance为null并且同时有两个线程调用getInstance（）方法时，它们将都可以通过第一重instance&#x3D;&#x3D;null的判断。然后由于’锁’机制，这两个线程则只有一个进入，另一个在外排队等候，必须要其中的一个进入并出来后，另一个才能进入。而此时如果没有了第二重的instance是否为null的判断，则第一个线程创建了实例，而第二个线程还是可以继续再创建新的实例，这就没有达到单例的目的。</p><h3 id="饿汉式（静态初始化）"><a href="#饿汉式（静态初始化）" class="headerlink" title="饿汉式（静态初始化）"></a>饿汉式（静态初始化）</h3><p>不管有没有调用getInstance，先在自己被加载时就把instance创建出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="客户端代码："><a href="#客户端代码：" class="headerlink" title="客户端代码："></a>客户端代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Singleton s0 = new Singleton();</span><br><span class="hljs-type">Singleton</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br><span class="hljs-type">Singleton</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br><br><span class="hljs-keyword">if</span> (s1 == s2) &#123;<br>  System.out.println(<span class="hljs-string">&quot;两个对象是相同的实例&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单例模式好处"><a href="#单例模式好处" class="headerlink" title="单例模式好处"></a>单例模式好处</h2><ol><li>可以保证唯一的实例。</li><li>因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。</li></ol><h2 id="饿汉式和懒汉式对比"><a href="#饿汉式和懒汉式对比" class="headerlink" title="饿汉式和懒汉式对比"></a>饿汉式和懒汉式对比</h2><p>饿汉式，即静态初始化的方式，它是类一加载就实例化的对象，所以要提前占用系统资源。</p><p>然而懒汉式，又会面临着多线程访问的安全性问题，需要做双重锁定这样的处理才可以保证安全。</p><p>到底使用哪一种方式，取决于实际的需求。从Java语言角度来讲，饿汉式的单例类已经足够满足我们的需求了。</p><h2 id="单例模式-vs-实用类静态方法"><a href="#单例模式-vs-实用类静态方法" class="headerlink" title="单例模式 vs 实用类静态方法"></a>单例模式 vs 实用类静态方法</h2><p>和单例模式类似，实用类通常也会采用私有化的构造方法来避免其有实例。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>实用类不保存状态，只提供静态方法或静态属性使用；而单例类有状态。</li><li>实用类不能用于继承多态；而单例类虽然实例唯一，但可以有子类来继承。</li><li>实用类是一些方法属性的集合；单例类有唯一的对象实例。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式20-迭代器模式</title>
    <link href="/2023/10/20/design-pattern/20.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/20/design-pattern/20.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>迭代器模式（Iterator），提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/19/mKfRk7ElDi4Os1p.jpg" alt="迭代器模式结构图.jpg"></p><p>需要有 <code>Iterator</code> 抽象类的原因：遍历方式可能有很多种，需要对不同方式做不同具体实现。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Aggregate</code> 聚集抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>  <br>  <span class="hljs-comment">// 创建迭代器</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteAggregate</code> 具体聚集类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteAggregate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>  <br>  <span class="hljs-comment">// 声明一个ArrayList泛型变量，用于存放聚合对象</span><br>  <span class="hljs-keyword">private</span> ArrayList&lt;Object&gt; items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>  <br>  <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteIterator</span>(<span class="hljs-built_in">this</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 返回聚集总个数</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> items.size();<br>  &#125;<br>  <br>  <span class="hljs-comment">// 增加新对象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object object)</span> &#123;<br>    items.add(object);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 得到指定索引对象</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getCurrentItem</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> items.get(index);<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>Iterator</code> 迭代器抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">first</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 第一个</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 下一个</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 是否到结尾</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 当前对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteIterator</code> 具体迭代器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterator</span> &#123;<br>  <span class="hljs-keyword">private</span> ConcreteAggregate aggregate;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">// 初始化时将具体的聚集对象传入</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteIterator</span><span class="hljs-params">(ConcreteAggregate aggregate)</span> &#123;<br>    <span class="hljs-built_in">this</span>.aggregate = aggregate;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 得到第一个对象</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">first</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> aggregate.getCurrentItem(<span class="hljs-number">0</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 得到下一个对象</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    current ++;<br>    <span class="hljs-keyword">if</span> (current &lt; aggregate.getCount()) &#123;<br>      ret = aggregate.getCurrentItem(current);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 判断当前是否遍历到结尾，到结尾返回true</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> current &gt;= aggregate.getCount() ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 返回当前的聚集对象</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> aggregate.getCurrentItem(current);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ConcreteAggregate</span> <span class="hljs-variable">ca</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteAggregate</span>();<br>ca.add(<span class="hljs-number">1</span>);<br>ca.add(<span class="hljs-number">2</span>);<br>ca.add(<span class="hljs-number">3</span>);<br><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteIterator</span>(ca);<br><br>i.first();<br><span class="hljs-keyword">while</span> (!i.isDone()) &#123;<br>  System.out.println(i.currentItem());<br>  i.next();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Java的迭代器实现"><a href="#Java的迭代器实现" class="headerlink" title="Java的迭代器实现"></a>Java的迭代器实现</h2><p>java.util.Iterator支持对集合的简单迭代接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 如果还有下一个元素，返回true</span><br>  <br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 返回迭代中的下一个元素</span><br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>java.util.ListIterator支持对集合的任意方向上迭代接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ListIterator</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPrevious</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">previous</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>迭代器（Iterator）模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责。</p><p>这样既可以做到<strong>不暴露集合的内部结构</strong>，又可以让外部代码<strong>透明地访问集合内部的数据</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式19-组合模式</title>
    <link href="/2023/10/19/design-pattern/19.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/19/design-pattern/19.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>组合模式（Composite），将对象组合成树形结构以表示’部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/18/qbGU8Fy4LRCzDvO.jpg" alt="组合模式结构图.jpg"></p><p><code>Component</code> 接口&#x2F;抽象类：为组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理 <code>Component</code> 的子部件。</p><p><code>Leaf</code> 类：在组合中表示叶节点，无子节点。</p><p><code>Composite</code> 类：定义非叶节点的行为。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Component</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>  <br>  <span class="hljs-keyword">protected</span> String name;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Component</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">int</span> depth)</span>;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>Leaf</code> 类：add和remove方法没有意义，但好处是可以消除叶节点和非叶节点在抽象层次的区别，它们具备完全一致的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Leaf</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Cannot add to a leaf.&quot;</span>); <span class="hljs-comment">// 叶子无法增加子节点</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Cannot remove from a leaf.&quot;</span>); <span class="hljs-comment">// 叶子无法移除子节点</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">int</span> depth)</span> &#123;<br>    <span class="hljs-comment">// 叶节点的具体显示方法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; depth; i ++)<br>      System.out.println(<span class="hljs-string">&quot;-&quot;</span>);<br>    System.out.println(name);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Composite</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> ArrayList&lt;Component&gt; children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 存储其下属的非叶节点和叶节点</span><br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Composite</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span> &#123;<br>    children.add(component);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span> &#123;<br>    children.remove(component);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">int</span> depth)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; depth; i ++)<br>      System.out.println(<span class="hljs-string">&quot;-&quot;</span>);<br>    System.out.println(name);<br>    <span class="hljs-comment">// 对下一层进行遍历</span><br>    <span class="hljs-keyword">for</span> (Component item : children) &#123;<br>      item.display(depth + <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Composite</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>(<span class="hljs-string">&quot;root&quot;</span>);<br>root.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf A&quot;</span>));<br>root.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf B&quot;</span>));<br><br><span class="hljs-type">Composite</span> <span class="hljs-variable">comp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>(<span class="hljs-string">&quot;Composite X&quot;</span>);<br>comp.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf XA&quot;</span>));<br>comp.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf XB&quot;</span>));<br>root.add(comp);<br><br><span class="hljs-type">Composite</span> <span class="hljs-variable">comp2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>(<span class="hljs-string">&quot;Composite XY&quot;</span>);<br>comp2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf XYA&quot;</span>));<br>comp2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf XYB&quot;</span>));<br>comp.add(comp2);<br><br><span class="hljs-type">Leaf</span> <span class="hljs-variable">leaf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf C&quot;</span>);<br>root.add(leaf);<br><br><span class="hljs-type">Leaf</span> <span class="hljs-variable">leaf2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf D&quot;</span>);<br>root.add(leaf2);<br>root.remove(leaf2);<br><br>root.display(<span class="hljs-number">1</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">展示结果：</span><br><span class="hljs-comment">-root</span><br><span class="hljs-comment">--Leaf A</span><br><span class="hljs-comment">--Leaf B</span><br><span class="hljs-comment">--Composite X</span><br><span class="hljs-comment">---Leaf XA</span><br><span class="hljs-comment">---Leaf XB</span><br><span class="hljs-comment">---Composite XY</span><br><span class="hljs-comment">----LeafXYA</span><br><span class="hljs-comment">----LeafXYB</span><br><span class="hljs-comment">--Leaf C</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="透明方式与安全方式"><a href="#透明方式与安全方式" class="headerlink" title="透明方式与安全方式"></a>透明方式与安全方式</h2><h3 id="透明方式"><a href="#透明方式" class="headerlink" title="透明方式"></a>透明方式</h3><p>在Component中声明所有用来管理子对象的方法，其中包括add、remove等。这样实现Component接口的所有子类都具备了add和remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。但问题也很明显，因为Leaf类本身不具备add()、remove()方法的功能，所以实现它是没有意义的。</p><h3 id="安全方式"><a href="#安全方式" class="headerlink" title="安全方式"></a>安全方式</h3><p>安全方式，也就是在Component接口中不去声明add和remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite中声明所有用来管理子类对象的方法，这样做就不会出现Leaf类也需要实现add()、remove()方法的问题，不过由于不够透明，所以树叶和树枝类将不具有相同的接口，客户端的调用需要做相应的判断，带来了不便。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>发现需求中是体现<strong>部分与整体层次的结构</strong>时，以及希望用户可以忽略组合对象与单个对象的不同，<strong>统一地使用组合结构中的所有对象</strong>时，就应该考虑用组合模式了。</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>组合模式定义了包含基本对象和组合对象的类层次结构。基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象了。</p><p>并且，用户不用关心到底是处理一个叶节点还是处理一个组合组件，也就不用为定义组合而写一些选择判断语句了。组合模式让客户可以一致地使用组合结构和单个对象。</p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式18-备忘录模式</title>
    <link href="/2023/10/18/design-pattern/18.%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/18/design-pattern/18.%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>备忘录（Memento）：在<strong>不破坏封装性</strong>的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p><blockquote><p>如：游戏中的存档。不破坏封装性即不把过多的细节暴露给客户端</p></blockquote><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/17/Af2uqHx4KsjVtWz.jpg" alt="备忘录模式结构图.jpg"></p><p><code>Originator</code>（发起人）：负责创建一个备忘录 <code>Memento</code>，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。<code>Originator</code> 可根据需要决定 <code>Memento</code> 存储 <code>Originator</code> 的哪些内部状态。</p><p> <code>Memento</code> （备忘录）：负责存储 <code>Originator</code> 对象的内部状态，并可防止 <code>Originator</code> 以外的其他对象访问备忘录 <code>Memento</code> 。备忘录有两个接口：<code>Caretaker</code> 只能看到备忘录的窄接口，它只能将备忘录传递给其他对象；<code>Originator</code> 能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。</p><p><code>CareTaker</code> （管理者）：负责保存好备忘录<code>Memento</code>，不能对备忘录的内容进行操作或检查。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>发起人 <code>Originator</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span> &#123;<br>  <br>  <span class="hljs-comment">// 需要保存的状态，可能有多个</span><br>  <span class="hljs-keyword">private</span> String state;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.state;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(String value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.state = value;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 显示数据</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;State: &quot;</span> + <span class="hljs-built_in">this</span>.state);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 创建备忘录，将当前需要保存的信息（也许不是全部状态）导入，并实例化出一个Memento对象</span><br>  <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">createMemento</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(<span class="hljs-built_in">this</span>.state);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 恢复备忘录，将Memento导入并将相关数据恢复</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoveryMemento</span><span class="hljs-params">(Memento memento)</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(memento.getState());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>备忘录 <code>Memento</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> String state;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Memento</span><span class="hljs-params">(String state)</span> &#123;<br>    <span class="hljs-built_in">this</span>.state = state;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.state;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(String value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.state = value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>管理者 <code>Caretaker</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Caretaker</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> Memento memento;<br>  <br>  <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">getMemento</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.memento;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemento</span><span class="hljs-params">(Memento value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.memento = value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Originator初始状态：例如状态属性为&quot;On&quot;</span><br><span class="hljs-type">Originator</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Originator</span>();<br>o.setState(<span class="hljs-string">&quot;On&quot;</span>);<br>o.show();<br><br><span class="hljs-type">Caretaker</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Caretaker</span>();<br><span class="hljs-comment">// 保存状态时，由于有了很好的封装，可以隐藏Originator的实现细节</span><br>c.setMemento(o.createMMento());<br><br><span class="hljs-comment">// Originator改变了状态属性，变为&quot;Off&quot;</span><br>o.setState(<span class="hljs-string">&quot;Off&quot;</span>);<br>o.show();<br><br><span class="hljs-comment">// 恢复原来的初始状态</span><br>o.recoveryMemento(c.getMemento());<br>o.show();<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>要保存的细节给封装在了Memento中了，要更改保存的细节也不用影响客户端了。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>状态需要完整存储到备忘录对象中，如果状态数据很大很多，那么在资源消耗上，备忘录对象会非常耗内存。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>Memento模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，Originator可以根据保存的Memento信息还原到前一状态。</p><p>有时一些对象的内部信息必须保存在对象以外的地方，但是必须要由对象自己读取，这时，使用备忘录可以把复杂的对象内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。</p><blockquote><p>管理类是有必要的。其实管理类主要得做两件事，一个是保存快照信息，这个快照信息可以保存多份的（用啥容器都行，栈、列表啥的），游戏状态这个例子里只保存了一份，所以会觉得没有必要；第二个是undo操作（即取出某个快照并恢复原发器状态的操作），该操作最好也要由管理者来提供，这样原发器的职责会更单一。</p><p>还有一个很致命的缺陷，快照Memento的getState是public的，不够安全。应该由Memento持有原发器的引用，且由Memento对象提供方法进行原发器对象的状态恢复，这样就不会有Memento.state的信息泄漏的危险了；当然，还有另一种做法，将Memento设计为原发器的私有内部类。</p></blockquote><blockquote><p>拓展：命令模式也有实现类似撤销的作用，如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式17-适配器模式</title>
    <link href="/2023/10/15/design-pattern/17.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/15/design-pattern/17.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>适配器模式（Adapter），将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><blockquote><p>类似于国标转英标的转接头。</p></blockquote><h2 id="适用场景和时机"><a href="#适用场景和时机" class="headerlink" title="适用场景和时机"></a>适用场景和时机</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>系统的数据和行为都相同或类似，但接口不统一时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。客户代码可以统一调用同一接口就行了，更简单、更直接、更紧凑。</p><p>适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况，比如在需要对早期代码复用一些功能等应用上很有实际价值。</p><h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><p>在设计阶段，应该把类似的功能类的接口按照规范设计得相同。</p><blockquote><p>设计之初就需要考虑用适配器模式的场景：公司设计一系统时考虑使用第三方开发组件，而这个组件的接口与我们自己的系统接口是不相同的，而我们也没有必要为了迎合它而改动自己的接口</p></blockquote><p>在软件开发后期或维护期，通常应优先考虑通过重构统一接口，其次在双方都不太容易修改的时候再使用适配器模式适配。</p><blockquote><p>用适配器模式是无奈之举，有点’亡羊补牢’的感觉</p></blockquote><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>GoF的设计模式介绍了适配器模式的两种类型：</p><h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>类适配器模式通过多重继承对一个接口与另一个接口进行匹配，而Java不支持多重继承，故略。</p><h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p>对象适配器模式结构图：</p><p><img src="https://s2.loli.net/2023/10/15/Zv51cel4BIWzA2q.jpg" alt="适配器模式结构图.jpg"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Target</code> 接口：客户所期待的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;普通请求&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Adaptee</code> 类：需要适配的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">specificRequest</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;特殊请求&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Adapter</code> 接口：通过在内部包装一个 <code>Adaptee</code> 对象，把源接口转换成目标接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Target</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-type">Adaptee</span> <span class="hljs-variable">adaptee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adaptee</span>(); <span class="hljs-comment">// 建立一个私有的Adaptee对象</span><br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>    adaptee.specificRequest(); <span class="hljs-comment">// 把表面上调用request()方法转换成实际调用specificRequest()方法</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Target</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adapter</span>();<br><br>target.request();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板3-5.最小生成树</title>
    <link href="/2023/10/14/algorithm/template/3-5.%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2023/10/14/algorithm/template/3-5.%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>定义：一个<strong>连通加权无向图</strong>中，一棵没有环的、权值最小的生成树。</p><p>注：权重的正负对最小生成树问题没有影响。</p><blockquote><p>应用举例：已知若干个城市的坐标，要在城市间铺设公路，使得各个城市能够连通，且公路长度最小。</p></blockquote><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><blockquote><p>和Dijkstra算法的形式非常类似。</p></blockquote><h3 id="朴素版Prim算法"><a href="#朴素版Prim算法" class="headerlink" title="朴素版Prim算法"></a>朴素版Prim算法</h3><p>时间复杂度：<code>O(n^2 + m)</code> ，适合稠密图</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">集合S: 存储当前已经在连通块中的所有点<br>    <br>dist[i] &lt;- +<span class="hljs-function">INF</span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-title">for</span> <span class="hljs-params">(i: <span class="hljs-number">0</span>~n)</span></span><br><span class="hljs-function">  t &lt;- 不在S中的距离S最近的点</span><br><span class="hljs-function">  用t更新其他点到**集合S**的距离，即所有连向集合S的边中权重最小的边 <span class="hljs-comment">// 注意：Dijkstra中是到起点的距离</span></span><br><span class="hljs-function">  st[t] </span>= <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">// 稠密图，用邻接矩阵存边权</span><br><span class="hljs-type">int</span> dist[N]; <span class="hljs-comment">// 存储其他点到集合S中的距离</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 记录每个点是否在S中</span><br><br><span class="hljs-comment">// 如果图不连通，则返回INF；否则返回最小生成树的边权之和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>  <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>  &#123;<br>    <span class="hljs-comment">// 找到不在S中的距离S最近的点</span><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>      <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t])) t = j;<br><br>    <span class="hljs-keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF; <span class="hljs-comment">// 表示图不连通</span><br><br>    <span class="hljs-keyword">if</span> (i) res += dist[t]; <span class="hljs-comment">// 从第二个点开始累加边权。注意这一步要写在更新距离前，以防负自环把自己的dist更新了</span><br><br>    st[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 把该点加入S</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++) dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]); <span class="hljs-comment">// 更新其他点到S的距离</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化版Prim算法（略）"><a href="#堆优化版Prim算法（略）" class="headerlink" title="堆优化版Prim算法（略）"></a>堆优化版Prim算法（略）</h3><p>时间复杂度：<code>O(mlogn)</code> ，适合稀疏图</p><p>稀疏图一般用Kruskal算法，堆优化Prim算法不常用，因为Kruskal代码短很多，思路也更清晰。</p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>时间复杂度：<code>O(mlogm)</code>（瓶颈是对边做排序的步骤），适合稀疏图</p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">集合S：存储最小生成树中的边<br><br><span class="hljs-comment">// O(mlogm)</span><br><span class="hljs-number">1.</span> 将所有边按权重从小到大排序<br><br><span class="hljs-comment">// O(m), 因为并查集是O(1)的，一共m条边</span><br><span class="hljs-number">2.</span> 枚举每条边a-b，权重c<br>  <span class="hljs-keyword">if</span> a,b不连通<br>    将这条边加入集合S中 <span class="hljs-comment">// 并查集的应用</span><br></code></pre></td></tr></table></figure><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> p[N]; <span class="hljs-comment">// 并查集中父节点数组</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> <span class="hljs-comment">// 由于只需要枚举所有边，可以用结构体来存储所有边</span><br>&#123;<br>  <span class="hljs-type">int</span> a, b, w;<br>  <br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;W)<span class="hljs-type">const</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> w &lt; W.w;<br>  &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 并查集</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>  <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">sort</span>(edges, edges + m);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) p[i] = i;<br>  <br>  <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// res是最小生成树中的边权之和，cnt是最小生成树中的边的数量</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>  &#123;<br>    <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br>    <br>    a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b); <span class="hljs-comment">// 查找a和b所在的连通块</span><br>    <span class="hljs-keyword">if</span> (a != b) <span class="hljs-comment">// 如果两个连通块不连通，则合并两个连通块</span><br>    &#123;<br>      p[a] = b;<br>      res += w;<br>      cnt ++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板3-4.最短路</title>
    <link href="/2023/10/14/algorithm/template/3-4.%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <url>/2023/10/14/algorithm/template/3-4.%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><p>源点：起点，汇点：终点</p><p>n: 点数，m: 边数</p><p>稠密图：m ~ n^2^，稀疏图：m ~ n</p><blockquote><p>难点：建图，如何把原问题抽象成最短路问题，如何把原模型抽象成图，如何定义点和边</p></blockquote><blockquote><p>最短路问题只需要考虑有向图。无向图只需要连两条对称的边就可以。</p></blockquote><h2 id="边权为1的最短路"><a href="#边权为1的最短路" class="headerlink" title="边权为1的最短路"></a>边权为1的最短路</h2><p>比较特殊，可以用BFS来求。单源和多源都可以。</p><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><p>求从一个点到其他所有点的最短路。</p><h3 id="所有边权都是正数"><a href="#所有边权都是正数" class="headerlink" title="所有边权都是正数"></a>所有边权都是正数</h3><h4 id="朴素Dijkstra算法"><a href="#朴素Dijkstra算法" class="headerlink" title="朴素Dijkstra算法"></a>朴素Dijkstra算法</h4><p>时间复杂度：<code>O(n^2 + m)</code> ，适合稠密图</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>贪心</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">S集合：存储当前已确定最短距离的点<br><br><span class="hljs-number">1</span>. dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, dist[i] = +inf<br><span class="hljs-number">2</span>. for i <span class="hljs-symbol">:</span> <span class="hljs-number">0</span>~<span class="hljs-built_in">n</span> // 每次循环都能确定<span class="hljs-number">1</span>个点的最短距离，循环<span class="hljs-built_in">n</span>次结束<br><span class="hljs-built_in">t</span> &lt;- 不在S中的，距离最近的点<br>S &lt;- <span class="hljs-built_in">t</span> (<span class="hljs-built_in">t</span>放入S中)<br>dist[x] = <span class="hljs-built_in">min</span>(dist[x], dist[<span class="hljs-built_in">t</span>] + w(<span class="hljs-built_in">t</span>, x)) (用<span class="hljs-built_in">t</span>更新其他点x的距离)<br></code></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol><li><p>处理重边和自环。</p><ul><li>由于边权都是正数，自环直接忽略即可。</li><li>重边保留最小值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) g[i][i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 也可以不写，因为边权都为正，最短路不会走自环</span><br><br>对每条边：g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c);<br></code></pre></td></tr></table></figure></li></ol><h5 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 稠密图用邻接矩阵存</span><br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">// 存储每条边</span><br><span class="hljs-type">int</span> dist[N]; <span class="hljs-comment">// 存储1号点到每个点到最短距离</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 存储每个点到最短路是否已经确定，即步骤里的S集合</span><br><br><span class="hljs-comment">// 求1号点到n号点到最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>  dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++)<br>  &#123;<br>    <span class="hljs-comment">// 在还未确定的最短路的点中，寻找距离最小的点</span><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>      <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t])) t = j;<br><br>    <span class="hljs-comment">// 点t放入S集合</span><br>    st[t] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-comment">// 用t更新其他点的距离</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>      dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>    <br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="堆优化版Dijkstra算法"><a href="#堆优化版Dijkstra算法" class="headerlink" title="堆优化版Dijkstra算法"></a>堆优化版Dijkstra算法</h4><p>时间复杂度：<code>O(mlogn)</code> ，适合稀疏图（当图为稠密图，也就是 <code>m和n^2一个级别</code> 时，时间复杂度比朴素版高些）</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>先看看在稀疏图中，朴素Dijkstra算法循环内部每一步<strong>总共</strong>（循环n次之后）的执行次数</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">S集合：存储当前已确定最短距离的点<br><br><span class="hljs-number">1</span>. dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, dist[i] = +inf<br><span class="hljs-number">2</span>. for i <span class="hljs-symbol">:</span> <span class="hljs-number">0</span>~<span class="hljs-built_in">n</span><br>(<span class="hljs-number">1</span>) <span class="hljs-built_in">t</span> &lt;- 不在S中的，距离最近的点 总共执行<span class="hljs-built_in">n</span>^<span class="hljs-number">2</span>次（瓶颈）<br>(<span class="hljs-number">2</span>) S &lt;- <span class="hljs-built_in">t</span> 总共执行<span class="hljs-built_in">n</span>次<br>(<span class="hljs-number">3</span>) dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[<span class="hljs-built_in">t</span>] + w(<span class="hljs-built_in">t</span>, j)) 总共执行m次，因为图是用邻接表存，只有<span class="hljs-built_in">t</span>和j之间有边才有可能更新<br></code></pre></td></tr></table></figure><p>每次找离1号点最近的点这一步是算法瓶颈。由于是找最小值，可以<code>用堆来存储dist</code>，来优化到每次循环为O(1)，总复杂度为O(n)。但(3)在每次循环中的复杂度会从O(1)变到O(logn)，因为是对堆做更新操作。(3)总共执行m次，所以总的时间复杂度是O(mlogn)。</p><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">S集合：存储当前已确定最短距离的点<br><br><span class="hljs-number">1</span>. dist<span class="hljs-selector-attr">[1]</span> = <span class="hljs-number">0</span>, dist<span class="hljs-selector-attr">[i]</span> = +inf, heap<span class="hljs-selector-class">.push</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;) <span class="hljs-comment">// first: i号点到1号点到距离, second: 点编号i</span><br><span class="hljs-number">2</span>. <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> : <span class="hljs-number">1</span>~n<br>(<span class="hljs-number">1</span>) t &lt;- dist<span class="hljs-selector-class">.top</span>() 记得要判断t.second是不是已经S里<br>(<span class="hljs-number">2</span>) S &lt;- t<span class="hljs-selector-class">.second</span><br>(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> (t的所有边对应点j和权重w)<br><span class="hljs-keyword">if</span> (dist<span class="hljs-selector-attr">[j]</span> &gt; t<span class="hljs-selector-class">.first</span> + w) dist<span class="hljs-selector-class">.push</span>(&#123;t<span class="hljs-selector-class">.first</span> + w, j&#125;) 这里由于STL堆不支持修改任意位置的值，所以只能冗余，插入新的dist，反正小的dist先出来<br></code></pre></td></tr></table></figure><h5 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">int</span> n; <span class="hljs-comment">// 点的数量</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="hljs-comment">// 稀疏图用邻接表存</span><br><span class="hljs-type">int</span> dist[N]; <span class="hljs-comment">// 所有点到1号点的距离</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 即S集合</span><br><br><span class="hljs-comment">// 求1号点到n号点到最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>  dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; <span class="hljs-comment">// 小根堆</span><br>  heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// first存储距离，second存储点的编号</span><br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++)<br>  &#123;<br>    <span class="hljs-comment">// 在还未确定的最短路的点中，寻找距离最小的点</span><br>    <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>    heap.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br>    <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 因为堆存储有冗余，该节点的距离可能已经被确定了，此时跳过</span><br><br>    <span class="hljs-comment">// 点t放入S集合</span><br>    st[t] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-comment">// 用t更新与其有边连接的其他点的距离</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; ~i; i)<br>    &#123;<br>      <span class="hljs-type">int</span> j = e[i];<br>      <span class="hljs-keyword">if</span> (dist[j] &gt; distance + w[i]) <span class="hljs-comment">// 需要更新dist[j]</span><br>      &#123;<br>        dist[j] = distance + w[i];<br>        heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="存在负权边"><a href="#存在负权边" class="headerlink" title="存在负权边"></a>存在负权边</h3><p>SPFA是BF算法的优化。但如果限制经过的边数（如&lt;&#x3D;k）的话，只能用Bellman-Ford。</p><h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h4><p>时间复杂度：<code>O(nm)</code></p><blockquote><p>注意：如果有负权回路存在，最短路就<strong>不一定</strong>存在。不一定的原因：只有这个负环1号点到某个点x的路径上，1-&gt;x到最短路才不存在。没在路径上就没有影响。</p></blockquote><h5 id="存边方式"><a href="#存边方式" class="headerlink" title="存边方式"></a>存边方式</h5><p>由于是遍历所有边，所以BF算法存边方式不一定要用邻接表。可以定义struct存边</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>  <span class="hljs-type">int</span> a, b, w;<br>&#125; edge[M];<br></code></pre></td></tr></table></figure><h5 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> n次循环<br><span class="hljs-keyword">for</span> 所有边a, b, w<br>dist[b] = <span class="hljs-built_in">min</span>(dist[b], dist[a] + w); <span class="hljs-comment">// 松弛操作</span><br></code></pre></td></tr></table></figure><h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><p><strong>三角不等式：</strong>在循环n*m次之后，对每条边，都有 <code>dist[b] &lt;= dist[a] + w</code>。</p><p><strong>n重循环中迭代k次的含义：</strong>从1号点经过不超过k条边，走到每一个点的最短距离。</p><h5 id="如何判断是否有负环？"><a href="#如何判断是否有负环？" class="headerlink" title="如何判断是否有负环？"></a>如何判断是否有负环？</h5><p>BF算法可以判断是否有负环。但时间复杂度较高，一般用SPFA来做。</p><p>如果第n次迭代时，dist[x]有更新：说明从1号点到x号点，存在一条有n条边的路。但一条路有n条边，说明有n+1个点，即路径上有环。又由于dist[x]更新了，所以这个环一定是负环（因为不包含环的那条路之前已经走过了）。</p><h5 id="代码模板-2"><a href="#代码模板-2" class="headerlink" title="代码模板"></a>代码模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dist[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>  <span class="hljs-type">int</span> a, b, w;<br>&#125; edges[M];<br><br><span class="hljs-comment">// 求1到n到最短路距离，如果无法从1走到n，则返回-1。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>  dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>    &#123;<br>      <span class="hljs-type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>      <span class="hljs-keyword">if</span> (dist[b] &gt; dist[a] + w)<br>      dist[b] = dist[a] + w;<br>    &#125; <br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 不直接写 == 0x3f3f3f3f 的原因是，可能有负权边更新距离，使得dist小于0x3f3f3f3f</span><br>  <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="例题：有边数k限制的最短路"><a href="#例题：有边数k限制的最短路" class="headerlink" title="例题：有边数k限制的最短路"></a>例题：有边数k限制的最短路</h5><p>需要加上backup数组，保存上一次循环中所有边更新的结果，保证这一次循环只用上一次循环的结果，以免用到本次循环更新过的距离，这样经过的边实际可能&gt;k，不符合要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 每重循环复制dist数组到backup数组</span><br><span class="hljs-built_in">memcpy</span>(backup, dist, <span class="hljs-keyword">sizeof</span> dist);<br></code></pre></td></tr></table></figure><h4 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h4><p>一般时间复杂度：<code>O(m)</code>, 最坏时间复杂度：<code>O(nm)</code></p><h5 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h5><p>图中不含负环。</p><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>类似BFS的思想。</p><p>对于 <code>dist[b] = min(dist[b], dist[a] + w);</code> ，只有 <code>dist[a]</code> 变小了，<code>dist[b]</code> 才有可能被更新。所以用一个队列来存 更新过的点<code>a</code>。</p><blockquote><p>SPFA长得很Dijkstra算法很像。不过前者外循环是通过判断queue不空，后者是循环n次（n个点）。</p></blockquote><h5 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">st[]数组：记录队列里有没有某个节点<br>  <br>queue &lt;- 1<br><br><span class="hljs-keyword">while</span> queue不空<br>  1. t &lt;- q.front, q.pop(), st[t] = <span class="hljs-literal">false</span>;<br>2. 更新t的所有出边 t-w-&gt;<span class="hljs-function">b</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(dist[b] 被更新 &amp;&amp; !st[b])</span> queue &lt;- b, st[b] </span>= <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h5 id="代码模板-3"><a href="#代码模板-3" class="headerlink" title="代码模板"></a>代码模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n; <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 记录某个点是否在队列中</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>  dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <br>  queue&lt;<span class="hljs-type">int</span>&gt; q;<br>  q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>  st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>  <br>  <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>  &#123;<br>    <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    st[t] = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])<br>    &#123;<br>      <span class="hljs-type">int</span> j = e[i];<br>      <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>      &#123;<br>        dist[j] = dist[t] + w[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>          q.<span class="hljs-built_in">push</span>(j);<br>          st[j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 这里不用/2的原因是，只有它的前置节点被更新（变成非无穷的数）时，它才会被更新，它也一定是非无穷的数+w[i]；而BF算法是暴力更新所有边，可能是INF+w[i]</span><br>  <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="SPFA如何判负环？"><a href="#SPFA如何判负环？" class="headerlink" title="SPFA如何判负环？"></a>SPFA如何判负环？</h5><p>增加一个cnt[]数组，cnt[x]表示当前这个最短路边的数量。</p><p>在更新dist[x]的同时，也更新cnt[x]。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dist<span class="hljs-comment">[x]</span> = dist<span class="hljs-comment">[t]</span> + w<span class="hljs-comment">[i]</span>;<br>cnt<span class="hljs-comment">[x]</span> = cnt<span class="hljs-comment">[t]</span> + 1;<br></code></pre></td></tr></table></figure><p>当 <code>cnt[x] &gt;= n</code> 时，即最短路上的边数 &gt;&#x3D; n，即路上存在环，这个环一定是负环。</p><h6 id="代码模板-4"><a href="#代码模板-4" class="headerlink" title="代码模板"></a>代码模板</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n; <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">int</span> cnt[N]; <span class="hljs-comment">// cnt[x]存储</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 记录某个点是否在队列中</span><br><br><span class="hljs-comment">// 求整个图中是否有负环</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 不需要初始化dist数组，不需要距离的绝对值，有相对值的大小作为比较就行</span><br>  <span class="hljs-comment">// memset(dist, 0x3f, sizeof dist);</span><br>  <span class="hljs-comment">// dist[1] = 0;</span><br>  <br>  queue&lt;<span class="hljs-type">int</span>&gt; q;<br>  <span class="hljs-comment">// 要求整个图上是否有负环，而不是从1开始的负环，所以把所有的点都加进队列</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  &#123;<br>    q.<span class="hljs-built_in">push</span>(i);<br>    st[i] = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>  &#123;<br>    <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    st[t] = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])<br>    &#123;<br>      <span class="hljs-type">int</span> j = e[i];<br>      <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>      &#123;<br>        dist[j] = dist[t] + w[i];<br>        cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>          q.<span class="hljs-built_in">push</span>(j);<br>          st[j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>      <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以这样理解：</p><ol><li>构造一个虚拟节点 O，单向指向所有的节点，且到所有节点距离为0；</li><li>新图是否有负环等价于原始的图。</li><li>dist[]一开始为0,没有违背算法过程，可以理解为根据算法已经从 O 更新到了各个节点，接下来的代码就是顺理成章。所以dist数组从所有为0的状态开始是有对应意义的。就是先走一步。</li><li>cnt[x]可以认为是从节点O到节点x的最短路中边的数量，由于O和所有其他节点都连通，所以能够判断<strong>整个</strong>图中是否有负环。</li></ol><h2 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h2><p>会有多个query，求不同的源点到不同的汇点的最短路。</p><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>时间复杂度： <code>O(n^3)</code></p><h4 id="原理：DP"><a href="#原理：DP" class="headerlink" title="原理：DP"></a>原理：DP</h4><h5 id="状态表示："><a href="#状态表示：" class="headerlink" title="状态表示："></a>状态表示：</h5><p><code>d[k, i, j]</code> 的含义：从节点i，只经过1~k这些节点，到达节点j，所有路径中最短路的距离。</p><h5 id="状态转移："><a href="#状态转移：" class="headerlink" title="状态转移："></a>状态转移：</h5><p><code>d[k, i, j] = d[k - 1, i, k] + d[k - 1, k, j]</code></p><p>表示只经过1~k-1这些节点，从i到k再从k到j的最短距离。</p><p>发现第一维无需记录，在循环中自然就是这么算的，所以可以改写为：</p><p><code>d[i, j] = d[i, k] + d[k, j]</code></p><h4 id="代码模板-5"><a href="#代码模板-5" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> d[N][N]; <span class="hljs-comment">// 邻接矩阵</span><br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>    <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> d[i][j] = INF;<br><br><span class="hljs-comment">// 然后加入所有边。。。</span><br><br><span class="hljs-comment">// 算法结束后，d[a][b]表示a到b的最短距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>        d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br><br><span class="hljs-comment">// 判断是否有最短路</span><br><span class="hljs-keyword">if</span> (d[a][b] &gt; INF / <span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>); <span class="hljs-comment">// /2的原因与BF相同</span><br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, d[a][b]);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式16-状态模式</title>
    <link href="/2023/10/12/design-pattern/16.%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/12/design-pattern/16.%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>状态模式（State），当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p><blockquote><p>状态模式主要解决的是当控制一个对象<strong>状态转换的条件表达式过于复杂</strong>时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。</p></blockquote><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/12/MP5HFstNdQUkrT1.png" alt="状态模式结构图.png"></p><p><code>State</code> 类：抽象状态类，定义一个接口以封装与 <code>Context</code> 的一个特定状态相关的行为。</p><p><code>ConcreteState</code> 类：具体状态，每一个子类实现一个与 <code>Context</code> 的一个状态相关的行为。</p><p><code>Context</code> 类：维护一个 <code>ConcreteState</code> 类的实例，这个实例定义当前的状态（可以修改 <code>State</code> 的类型）。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>State</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Context context)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteState</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体状态类A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Context context)</span> &#123;<br>    <span class="hljs-comment">//可以在方法里做一些事情</span><br>    <br>    context.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStateB</span>()); <span class="hljs-comment">// 设置 ConcreteStateA 的下一状态是 ConcreteStateB</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体状态类B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Context context)</span> &#123;<br>    <span class="hljs-comment">//可以在方法里做一些事情</span><br>    <br>    context.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStateA</span>()); <span class="hljs-comment">// 设置 ConcreteStateB 的下一状态是 ConcreteStateA</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Context</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> State state;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Context</span><span class="hljs-params">(State state)</span> &#123;<br>    <span class="hljs-built_in">this</span>.state = state; <span class="hljs-comment">// 设置 Context 的初始状态</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// 可读写的状态属性，用于读取当前状态和设置新状态</span><br>  <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.state;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(State value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.state = value;<br>    System.out.println(<span class="hljs-string">&quot;当前状态：&quot;</span> + <span class="hljs-built_in">this</span>.state.getClass().getName());<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.state.handle(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Context</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStateA</span>()); <span class="hljs-comment">// 设置c的初始状态为 ConcreteStateA</span><br><br><span class="hljs-comment">// 不断请求，不断更改状态</span><br>c.request();<br>c.request();<br>c.request();<br>c.request();<br></code></pre></td></tr></table></figure><h2 id="好处与使用场景"><a href="#好处与使用场景" class="headerlink" title="好处与使用场景"></a>好处与使用场景</h2><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p><blockquote><p>将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换。</p></blockquote><p>这样做可以消除 <code>Long Method</code> 中庞大的条件分支语句。大的分支判断会使得它们难以修改和扩展。</p><p>状态模式通过把各种状态转移逻辑分布到 <code>State</code> 的子类之间，来减少相互间的依赖，这样就容易维护和扩展了。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式。</p><blockquote><p>如果业务需求某项业务有多个状态，通常都是一些枚举常量。</p><p>状态的变化都是依靠大量的多分支判断语句来实现，此时应该考虑<strong>将每一种业务状态定义为一个State的子类</strong>，于是这些对象就可以不依赖于其他对象而独立变化了。</p><p>某一天客户需要更改需求，增加或减少业务状态或改变状态流程，就变得不困难了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板3-1.DFS和BFS</title>
    <link href="/2023/10/11/algorithm/template/3-1.DFS%E5%92%8CBFS/"/>
    <url>/2023/10/11/algorithm/template/3-1.DFS%E5%92%8CBFS/</url>
    
    <content type="html"><![CDATA[<h1 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历 (DFS)"></a>深度优先遍历 (DFS)</h1><p>一条路走到底，无路可走了之后往回退<strong>一步</strong>，继续找一条其他的路一直往下走。</p><p>形势一般为递归。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>走到底了，返回的过程叫做回溯。</p><p>回来的时候要<strong>恢复现场</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 恢复现场的代码与修改状态的代码一般是对称的，例：</span><br>path[u] = i;<br>st[i] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>); <span class="hljs-comment">// 下一层递归返回之后恢复</span><br>st[i] = <span class="hljs-literal">false</span>;<br>path[u] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>剪枝可以提高效率。</p><h4 id="可行性剪枝"><a href="#可行性剪枝" class="headerlink" title="可行性剪枝"></a>可行性剪枝</h4><p>在搜索的过程中判断，如果这个节点不合法，那么它的子树上的所有节点也都不合法，直接停止搜索。</p><h4 id="最优性剪枝"><a href="#最优性剪枝" class="headerlink" title="最优性剪枝"></a>最优性剪枝</h4><p>当前路径一定不如最优解，停止搜索。</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>递归结束条件的选择+状态标记+递归后的恢复</p><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="字典序输出"><a href="#字典序输出" class="headerlink" title="字典序输出"></a>字典序输出</h3><p>每一种输出都是一个叶子节点，第x位的遍历对应第x层的节点。整个搜索过程就是一棵搜索树（当然不需要自己存这棵树，系统栈会帮我们做这件事）。</p><p>path数组下标为当前遍历到的位数，存储的值为这一位填的数字。</p><h3 id="n-皇后"><a href="#n-皇后" class="headerlink" title="n-皇后"></a>n-皇后</h3><h4 id="进阶解法-以行作为一层来搜索"><a href="#进阶解法-以行作为一层来搜索" class="headerlink" title="进阶解法 - 以行作为一层来搜索"></a>进阶解法 - 以<strong>行</strong>作为一层来搜索</h4><p>col数组记录该列是否有皇后。</p><p>额外开两个数组存储对角线和反对角线上是否有皇后，如果有代表不合法，剪枝。</p><p>对角线数组的长度是 <code>2n - 1</code>。</p><p>判断一个点在哪一条对角线&#x2F;反对角线上：用截距。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">x, y分别是行号和列号，b为对角线号。<br><br><span class="hljs-attribute">y</span>=x+b/ -&gt; <span class="hljs-attribute">b</span>=y-x+n (+n是因为数组下标要为正数)<br><br><span class="hljs-attribute">y</span>=-x+b -&gt; <span class="hljs-attribute">b</span>=y+x<br></code></pre></td></tr></table></figure><p>时间复杂度：<code>O(n*n!)</code></p><h4 id="原始解法-以格子作为一层来搜索"><a href="#原始解法-以格子作为一层来搜索" class="headerlink" title="原始解法 - 以格子作为一层来搜索"></a>原始解法 - 以<strong>格子</strong>作为一层来搜索</h4><p>每一层dfs都往下拓展两种可能：一种是该格子放皇后；一种是该格子不放皇后。</p><blockquote><p>row数组记录该行是否有皇后。</p><p>col数组记录该列是否有皇后。</p><p>额外开两个数组存储对角线和反对角线上是否有皇后，如果有代表不合法，剪枝。</p></blockquote><p>时间复杂度：<code>O(2^(n^2))</code></p><h1 id="宽度优先遍历-BFS"><a href="#宽度优先遍历-BFS" class="headerlink" title="宽度优先遍历 (BFS)"></a>宽度优先遍历 (BFS)</h1><p>一层一层遍历，某一层全部遍历完，再遍历该层第一个节点的第一个子节点，以此类推。</p><p>形势一般为迭代。</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl">模拟队列 <span class="hljs-string">q[N]</span>, d[N] 使用d数组标记状态<br><br>queue &lt;- 初始状态<br><span class="hljs-keyword">while</span> queue不空<br>&#123;<br>t &lt;- 队头<br>拓展t<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="往上下左右四个方向拓展的小技巧"><a href="#往上下左右四个方向拓展的小技巧" class="headerlink" title="往上下左右四个方向拓展的小技巧"></a>往上下左右四个方向拓展的小技巧</h2><p>用向量数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>  <span class="hljs-type">int</span> x = a + dx[i], y = b + dy[i];<br></code></pre></td></tr></table></figure><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h3><p>以离起点距离为x的点为第x层</p><h3 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h3><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><table><thead><tr><th>算法</th><th>数据结构</th><th>空间复杂度</th><th>性质</th></tr></thead><tbody><tr><td>DFS</td><td>stack</td><td>O(h)</td><td></td></tr><tr><td>BFS</td><td>queue</td><td>O(2^h^)</td><td>最短路（第一次搜到时）</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>DFS在空间上占优势；</p><p>但BFS具有“最短路”的性质（前提：边的权重为1）。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板3-3.树与图的遍历</title>
    <link href="/2023/10/11/algorithm/template/3-3.%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2023/10/11/algorithm/template/3-3.%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h1><p>时间复杂度：<code>O(n + m)</code>，其中 <code>n</code> 表示点数， <code>m</code> 表示边数。</p><p>树是特殊的图，同样只需要考虑图的遍历即可。</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>一般树和图的遍历，每个点只需要遍历一次。</p><p>需要一个状态数组 <code>st[]</code>，表示该点是否被遍历过。</p><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>  <br>  st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// st[u] 表示点u已经遍历过</span><br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>    <span class="hljs-type">int</span> j = e[i]; <span class="hljs-comment">// 取到该边对应的点</span><br>    <span class="hljs-keyword">if</span> (!st[j]) <span class="hljs-built_in">dfs</span>(j);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h4><p>重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>在dfs的过程中从下往上算出以各个节点为根节点的子树节点的数量。</p><p>对每个节点n：求出<code>以其子节点为根节点的所有子树节点数量</code>和 <code>总节点数量减去以n为根节点的子树节点数量</code> （即剩余连通块点数）的最大值。再求所有最大值的最小值。</p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; q;<br>st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示1号点已经被遍历过</span><br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>  <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>  q.<span class="hljs-built_in">pop</span>();<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>    <span class="hljs-type">int</span> j = e[i];<br>    <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>      st[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 把j号点标记为已经被遍历过</span><br>      q.<span class="hljs-built_in">push</span>(j);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="图中点的层次"><a href="#图中点的层次" class="headerlink" title="图中点的层次"></a>图中点的层次</h4><p>即从1号点开始一层层搜，计算每个点到1号点的最短距离。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h5 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h5><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。</p><p>其实也就是把点排成拓扑序列之后，满足所有的边都是从前面的点指向后面的点的。</p><blockquote><p>只有<strong>有向图</strong>有拓扑序列。</p></blockquote><h6 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h6><p>可以证明，一个有向无环图一定存在拓扑序列。</p><blockquote><p>有向无环图也被称为拓扑图。</p><p>一个有向无环图，一定至少存在一个入度为0的点。</p></blockquote><h5 id="拓扑排序-1"><a href="#拓扑排序-1" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><p>所有入度为0的点都可以作为起点。（所以对于有环的图，这个环上的点永远不会入队，因为入度都不为0）</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs elm">用bfs框架：<br><span class="hljs-title">queue</span> &lt;- 所有入度为<span class="hljs-number">0</span>的点<br><br><span class="hljs-title">while</span> queue 不空<br>&#123;<br>t &lt;- 队头<br>枚举t的所有出边t-&gt;j<br>删掉t-&gt;j 即j号点的入度<span class="hljs-comment">--：d[j] --;</span><br><span class="hljs-keyword">if</span> (!d[j]) queue &lt;- j<br>&#125;<br></code></pre></td></tr></table></figure><p>queue里的次序即为拓扑序。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板3-2.树与图的存储</title>
    <link href="/2023/10/11/algorithm/template/3-2.%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    <url>/2023/10/11/algorithm/template/3-2.%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="树和图的存储"><a href="#树和图的存储" class="headerlink" title="树和图的存储"></a>树和图的存储</h1><p>树是一种特殊的图：无环连通图。与图的存储方式相同。</p><p>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。</p><p>因此我们可以只考虑有向图的存储。</p><h2 id="存储方法一：邻接矩阵"><a href="#存储方法一：邻接矩阵" class="headerlink" title="存储方法一：邻接矩阵"></a>存储方法一：邻接矩阵</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">g<span class="hljs-selector-attr">[a]</span><span class="hljs-selector-attr">[b]</span> 存储边<span class="hljs-selector-tag">a</span>-&gt;<span class="hljs-selector-tag">b</span>的权重(int)/有无(bool)<br></code></pre></td></tr></table></figure><p>邻接矩阵不能存重边，不过一般存最短的就行。</p><h2 id="存储方法二：邻接表"><a href="#存储方法二：邻接表" class="headerlink" title="存储方法二：邻接表"></a>存储方法二：邻接表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = N * <span class="hljs-number">2</span>; <span class="hljs-comment">// N：点的数量，M：边的数量</span><br><br><span class="hljs-comment">// h[]对应点：对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头节点</span><br><span class="hljs-comment">// w[], e[], ne[]对应边：它们的下标都是边的编号，w[]值是边的权重，e[]值是指向的节点；ne[]存储某个节点的出边链表中，某条边的下一条边的编号</span><br><span class="hljs-type">int</span> h[N], w[M], e[M], ne[M], idx;<br><br><span class="hljs-comment">// 添加一条边a-&gt;b</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>  e[idx] = b, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br><span class="hljs-comment">// 初始化</span><br>idx = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h); <span class="hljs-comment">// 让n个头节点都指向-1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式15-抽象工厂模式</title>
    <link href="/2023/10/11/design-pattern/15.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/11/design-pattern/15.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>抽象工厂模式（Abstract Factory），提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p><blockquote><p>与工厂方法模式的区别：</p><p>以操作不同数据库为例：只有一个User类和User操作类的时候，是只需要工厂方法模式的，但现在显然你数据库中有很多的表，而SQL Server与Access又是两大不同的分类，所以解决这种涉及<strong>多个产品系列</strong>的问题，有一个专门的工厂模式叫抽象工厂模式。</p></blockquote><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/11/RILujqhdlvWVsQF.png" alt="抽象工厂模式结构图.png"></p><p>AbstractProductA和AbstractProductB是两个抽象产品，之所以为抽象，是因为它们都有可能有两种不同的实现，比如对两种数据库中某一张表的操作。</p><p>ProductA1、ProductA2和ProductB1、ProductB2就是对两个抽象产品的具体分类的实现。</p><p>IFactory是一个抽象工厂接口，它里面应该包含所有的产品创建的抽象方法。</p><p>而ConcreteFactory1和ConcreteFactory2就是具体的工厂了，就像SqlserverFactory和AccessFactory一样。</p><blockquote><p>通常是在<strong>运行时刻</strong>再创建一个ConcreteFactory类的实例，这个具体的工厂再创建具有特定实现的产品对象，也就是说，为创建不同的产品对象，客户端应使用不同的具体工厂。</p></blockquote><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p><strong>易于交换产品系列</strong>。由于具体工厂类，例如 <code>IFactory factory = new AccessFactory()</code>，在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易（只在初始化的地方改一行就行），它只需要改变具体工厂即可使用不同的产品配置。</p><blockquote><p>我们的设计不能去防止需求的更改，那么我们的理想便是让改动变得最小，现在如果你要更改数据库访问，我们只需要更改具体工厂就可以做到。</p></blockquote></li><li><p><strong>让具体的创建实例过程与客户端分离</strong>。客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。</p><blockquote><p>比如换数据库的例子，客户端所认识的只有IUser和IDepartment，至于它是用SQL Server来实现还是Access来实现就不知道了。</p></blockquote></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>如果需求来自添加功能（比如添加数据库中的一张表），需要增加三个类： IProject、SqlserverProject、AccessProject ，还需要更改三个类：IFactory 、SqlserverFactory 和AccessFactory才可以完全实现。</li><li>客户端程序类很多的情况下，还是需要改很多行 <code>IFactory factory = new AccessFactory()</code>这样的代码。</li></ul><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="1-用简单工厂来改进抽象工厂"><a href="#1-用简单工厂来改进抽象工厂" class="headerlink" title="1. 用简单工厂来改进抽象工厂"></a>1. 用简单工厂来改进抽象工厂</h3><p>去除IFactory 、SqlserverFactory和AccessFactory三个工厂类，取而代之的是DataAccess类，用一个简单工厂模式来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataAccess</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Sqlserver&quot;</span>; <span class="hljs-comment">// 数据库预设名称，可换成其他</span><br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IUser <span class="hljs-title function_">createUser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">IUser</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-keyword">switch</span>(db) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Sqlserver&quot;</span>:<br>        result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlserverUser</span>();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Access&quot;</span>:<br>        result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccessUser</span>();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样当新增一个表时，只需要修改DataAccess一个类，而不是IFactory 、SqlserverFactory 和AccessFactory这三个类。</p><p>但当新增Oracle数据库时，抽象工厂只需要增加一个OracleFactory，而简单工厂需要在DataAccess类中的每个方法的switch语句中加对应的case。</p><h3 id="2-反射-抽象工厂"><a href="#2-反射-抽象工厂" class="headerlink" title="2. 反射+抽象工厂"></a>2. 反射+抽象工厂</h3><p>使用一种编程方式：依赖注入（Dependency Injection）。</p><p>方式：</p><ol><li><p>专门的IoC容器提供，比如Spring</p></li><li><p>Java反射技术</p><p>将程序由编译时转为运行时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 常规的写法</span><br><span class="hljs-type">IUser</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlserverUser</span>();<br><br><span class="hljs-comment">// 反射的写法</span><br><span class="hljs-type">IUser</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (IUser)Class.forName(<span class="hljs-string">&quot;pathxxx.xxx.abstractfactory.SqlserverUser&quot;</span>).getDeclaredConstructor().newInstance();<br></code></pre></td></tr></table></figure><p>由于forName传参是字符串，所以可以用变量来处理，根据需要来更换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DataAccess类，用反射技术，取代IFactory、SqlserverFactory和AccessFactory</span><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataAccess</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">assemblyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pathxxx.xxx.abstractfactory.&quot;</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Sqlserver&quot;</span>; <span class="hljs-comment">// 数据库预设名称，可换成其他</span><br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IUser <span class="hljs-title function_">createUser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (IUser)getInstance(assemblyName + db + <span class="hljs-string">&quot;User&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getInstance</span><span class="hljs-params">(String className)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      result = Class.forName(className).getDeclaredConstructor().newInstance();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IvocationTargetException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>现在如果我们增加了Oracle数据访问，相关类的增加（如OracleUser, OracleDepartment）是不可避免的，这点无论我们用任何办法都解决不了，不过这叫扩展，<strong>开放-封闭原则</strong>告诉我们，<strong>对于扩展，我们开放。但对于修改，我们应该要尽量关闭。</strong></p><p>现在如果需要增加Oracle数据库的访问，只需要更改 <code>private static String db =&quot;Sqlserver&quot;;</code> 为<code>private static String db = &quot;Oracle&quot;;</code></p><p>如果要增加Project表产品，只需要增加三个与Project相关的类 IProject、SqlserverProject、AccessProject，再修改DataAccesss，在其中增加一个public static IProject createProject()方法即可。</p><h3 id="3-反射-配置文件-抽象工厂"><a href="#3-反射-配置文件-抽象工厂" class="headerlink" title="3. 反射+配置文件+抽象工厂"></a>3. 反射+配置文件+抽象工厂</h3><p>反射+抽象工厂问题：</p><p>在更换数据库访问时，我还是需要去改程序（改db这个字符串的值）重编译，如果可以不改程序，那才是真正地符合开放-封闭原则。</p><p>解决：</p><p>利用配置文件来解决更改DataAccess的问题。读文件来给DB字符串赋值，在配置文件中写明是Sqlserver还是Access，这样就连DataAccess类也不用更改了。</p><ol><li><p>添加一个db.properties文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">db=Sqlserver<br></code></pre></td></tr></table></figure></li><li><p>再更改DataAccess类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加与读取文件内容相关的包</span><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataAccess</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">assemblyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pathxxx.xxx.abstractfactory.&quot;</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getDb</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>      <span class="hljs-comment">// 需要将db.properties文件放到要编译的class目录中，并确保下面path路径与实际db.properties文件路径一致。否则会报No such file or directory错误</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;/pathxxx/xxx/abstractfactory/db.properties&quot;</span>;<br>      System.out.println(<span class="hljs-string">&quot;path: &quot;</span> + path);<br>      <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path));<br>      properties.load(bufferedReader);<br>      result = properties.getProperty(<span class="hljs-string">&quot;db&quot;</span>); <span class="hljs-comment">// 读取db.properties配置文件中db的内容</span><br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOExceprtion e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IUser <span class="hljs-title function_">createUser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> getDb();<br>    <span class="hljs-keyword">return</span> (IUser)getInstance(assemblyName + db + <span class="hljs-string">&quot;User&quot;</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><p>将来要更换数据库，根本无须重新编译任何代码，只需要更改配置文件就好了。应用了反射+配置文件+抽象工厂模式解决了数据库访问时的可维护、可扩展的问题。</p><blockquote><p>所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合，解决它们难以应对变化，难以维护和扩展的诟病。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>STL总结</title>
    <link href="/2023/10/10/algorithm/STL%E6%80%BB%E7%BB%93/"/>
    <url>/2023/10/10/algorithm/STL%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="vector-变长数组，倍增的思想"><a href="#vector-变长数组，倍增的思想" class="headerlink" title="vector, 变长数组，倍增的思想"></a>vector, 变长数组，倍增的思想</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>  返回元素个数<br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span>  返回是否为空<br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span>  清空<br><span class="hljs-function"><span class="hljs-title">front</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">back</span>()<br><span class="hljs-function"><span class="hljs-title">push_back</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">pop_back</span>()<br><span class="hljs-function"><span class="hljs-title">begin</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">end</span>()<br><span class="hljs-selector-attr">[]</span><br>支持比较运算，按字典序<br></code></pre></td></tr></table></figure><h3 id="pair"><a href="#pair" class="headerlink" title="pair&lt;int, int&gt;"></a>pair&lt;int, int&gt;</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">first</span>, 第一个元素<br><span class="hljs-keyword">second</span>, 第二个元素<br>支持比较运算，以<span class="hljs-keyword">first</span>为第一关键字，以<span class="hljs-keyword">second</span>为第二关键字（字典序）<br></code></pre></td></tr></table></figure><h3 id="string，字符串"><a href="#string，字符串" class="headerlink" title="string，字符串"></a>string，字符串</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">length</span>()  返回字符串长度<br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">substr</span><span class="hljs-params">(起始下标，(子串长度)</span></span>)  返回子串<br><span class="hljs-function"><span class="hljs-title">c_str</span><span class="hljs-params">()</span></span>  返回字符串所在字符数组的起始地址<br></code></pre></td></tr></table></figure><h3 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue, 队列"></a>queue, 队列</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">()</span></span>  向队尾插入一个元素<br><span class="hljs-function"><span class="hljs-title">front</span><span class="hljs-params">()</span></span>  返回队头元素<br><span class="hljs-function"><span class="hljs-title">back</span><span class="hljs-params">()</span></span>  返回队尾元素<br><span class="hljs-function"><span class="hljs-title">pop</span><span class="hljs-params">()</span></span>  弹出队头元素<br></code></pre></td></tr></table></figure><h3 id="priority-queue-优先队列，默认是大根堆"><a href="#priority-queue-优先队列，默认是大根堆" class="headerlink" title="priority_queue, 优先队列，默认是大根堆"></a>priority_queue, 优先队列，默认是大根堆</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">size</span>()<br><span class="hljs-built_in">empty</span>()<br><span class="hljs-built_in">push</span>()  插入一个元素<br><span class="hljs-attribute">top</span>()  返回堆顶元素<br><span class="hljs-built_in">pop</span>()  弹出堆顶元素<br>定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; <span class="hljs-selector-tag">q</span>;<br></code></pre></td></tr></table></figure><h3 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack, 栈"></a>stack, 栈</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">()</span></span>  向栈顶插入一个元素<br><span class="hljs-function"><span class="hljs-title">top</span><span class="hljs-params">()</span></span>  返回栈顶元素<br><span class="hljs-function"><span class="hljs-title">pop</span><span class="hljs-params">()</span></span>  弹出栈顶元素<br></code></pre></td></tr></table></figure><h3 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque, 双端队列"></a>deque, 双端队列</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">front</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">back</span>()<br><span class="hljs-function"><span class="hljs-title">push_back</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">pop_back</span>()<br><span class="hljs-function"><span class="hljs-title">push_front</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">pop_front</span>()<br><span class="hljs-function"><span class="hljs-title">begin</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">end</span>()<br><span class="hljs-selector-attr">[]</span><br></code></pre></td></tr></table></figure><h3 id="set-map-multiset-multimap-基于平衡二叉树（红黑树），动态维护有序序列"><a href="#set-map-multiset-multimap-基于平衡二叉树（红黑树），动态维护有序序列" class="headerlink" title="set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列"></a>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</h3><pre><code class="hljs">size()empty()clear()begin()/end()++, -- 返回前驱和后继，时间复杂度 O(logn)</code></pre><h4 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">insert</span><span class="hljs-params">()</span></span>  插入一个数<br><span class="hljs-function"><span class="hljs-title">find</span><span class="hljs-params">()</span></span>  查找一个数<br><span class="hljs-function"><span class="hljs-title">count</span><span class="hljs-params">()</span></span>  返回某一个数的个数<br><span class="hljs-function"><span class="hljs-title">erase</span><span class="hljs-params">()</span></span><br>    (<span class="hljs-number">1</span>) 输入是一个数x，删除所有x   <span class="hljs-built_in">O</span>(k + logn)<br>    (<span class="hljs-number">2</span>) 输入一个迭代器，删除这个迭代器<br><span class="hljs-function"><span class="hljs-title">lower_bound</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">upper_bound</span>()<br>    <span class="hljs-built_in">lower_bound</span>(x)  返回大于等于x的最小的数的迭代器<br>    <span class="hljs-built_in">upper_bound</span>(x)  返回大于x的最小的数的迭代器<br></code></pre></td></tr></table></figure><h4 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">insert</span><span class="hljs-params">()</span></span>  插入的数是一个pair<br><span class="hljs-function"><span class="hljs-title">erase</span><span class="hljs-params">()</span></span>  输入的参数是pair或者迭代器<br><span class="hljs-function"><span class="hljs-title">find</span><span class="hljs-params">()</span></span><br><span class="hljs-selector-attr">[]</span>  注意multimap不支持此操作。 时间复杂度是 <span class="hljs-built_in">O</span>(logn)<br><span class="hljs-function"><span class="hljs-title">lower_bound</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">upper_bound</span>()<br></code></pre></td></tr></table></figure><h3 id="unordered-set-unordered-map-unordered-multiset-unordered-multimap-哈希表"><a href="#unordered-set-unordered-map-unordered-multiset-unordered-multimap-哈希表" class="headerlink" title="unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表"></a>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</h3><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl">和上面类似，增删改查的时间复杂度是 <span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-number">1</span>)</span><br>不支持 <span class="hljs-function"><span class="hljs-title">lower_bound</span>()/<span class="hljs-title">upper_bound</span>()， 迭代器的++，--</span><br></code></pre></td></tr></table></figure><h3 id="bitset-圧位"><a href="#bitset-圧位" class="headerlink" title="bitset, 圧位"></a>bitset, 圧位</h3><pre><code class="hljs">bitset&lt;10000&gt; s;~, &amp;, |, ^&gt;&gt;, &lt;&lt;==, !=[]count()  返回有多少个1any()  判断是否至少有一个1none()  判断是否全为0set()  把所有位置成1set(k, v)  将第k位变成vreset()  把所有位变成0flip()  等价于~flip(k) 把第k位取反</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-8.字符串哈希</title>
    <link href="/2023/10/10/algorithm/template/2-8.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <url>/2023/10/10/algorithm/template/2-8.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>快速判断一个字符串中两个区间对应的子串是否完全相同。</p><blockquote><p>除了求一个字符串的循环节只能用KMP之外，大部分时候字符串哈希都能代替KMP。</p></blockquote><h2 id="字符串前缀哈希法"><a href="#字符串前缀哈希法" class="headerlink" title="字符串前缀哈希法"></a>字符串前缀哈希法</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ABCABCDE&quot;</span><br><br>把每一个前缀的哈希值算出来：<br>h[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>h[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A&quot;</span>的哈希值<br>h[<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AB&quot;</span>的哈希值<br>h[<span class="hljs-number">3</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ABC&quot;</span>的哈希值<br>...<br></code></pre></td></tr></table></figure><p><strong>结果：</strong>可以通过这些前缀的哈希值，算出 <strong><code>str</code> 任何一个子串</strong>的哈希值。</p><h2 id="如何定义某一前缀的哈希值？"><a href="#如何定义某一前缀的哈希值？" class="headerlink" title="如何定义某一前缀的哈希值？"></a>如何定义某一前缀的哈希值？</h2><p>把字符串str看成一个p进制的数。str中<strong>每一个字符（的ASCII码）</strong>对应这个<strong>p进制数的每一位数字</strong>。最后一个字符对应最低位。</p><blockquote><p>例：hash(“ABC”) &#x3D; (A * p^2 + B * p^1 + C * p^0)</p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><strong>目标：</strong>将str映射到0～Q-1的范围内。</p><p><strong>经验值：</strong> <code> p=131或13331</code>, <code>Q = 2^64</code>。用 <code>unsigned long long</code> 来存储哈希值，当它溢出时，刚好等价于取模。</p><h4 id="1-算出这个p进制数x"><a href="#1-算出这个p进制数x" class="headerlink" title="1. 算出这个p进制数x"></a>1. 算出这个p进制数x</h4><h5 id="2-x-mod-Q"><a href="#2-x-mod-Q" class="headerlink" title="2. x mod Q"></a>2. x mod Q</h5><p>由于str的长度可能比较长，x可能为一个很大的数字，不好存。所以算出x之后，需要mod一个比较小的数Q。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>不能把某一个字母映射成0。例：”A”-&gt;0, “AA”-&gt;0，将不同的字符串映射成了同一个数。</li><li>假定无冲突。这个算法没有考虑冲突情况。p和Q取经验值的情况下，起冲突的可能性很小。</li></ol><h2 id="如何算出任意子串的哈希值？"><a href="#如何算出任意子串的哈希值？" class="headerlink" title="如何算出任意子串的哈希值？"></a>如何算出任意子串的哈希值？</h2><p>假设我们要算 <code>str</code> 第 <code>L</code> 位和第<code>R</code> 位之间这个子串的哈希值。</p><p>已知 <code>h[R]</code> 和 <code>h[L-1]</code> ：</p><p><code>h[R] - h[L - 1] * p^(R - L + 1)</code> 即为子串的哈希值。</p><blockquote><p><code>h[R]</code> 中第R个字符对应x的第0位，第1个字符对应x的第R-1位</p><p><code>h[L-1]</code>  中第L-1个字符对应x的第0位，第1个字符对应x的第L-2位</p><p>h[L-1] * p^(R - L + 1)是为了将 <code>h[L-1]</code> 往左移，与 <code>h[R]</code> 对齐。</p></blockquote><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, <span class="hljs-type">int</span> P = <span class="hljs-number">13331</span>;<br><span class="hljs-type">char</span> str[N];<br>ULL h[N], p[N]; <span class="hljs-comment">// h[k]存储字符串前k个字母的哈希值，p[k]存储 P^k mod 2^64（提前预处理减少重复计算）</span><br><br><span class="hljs-comment">// 初始化：注意str字符串是从1开始的，scanf(&quot;%s&quot;, str + 1)</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>  h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>  p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>&#125;<br><br><span class="hljs-comment">// 计算子串 str[l ~ r] 的哈希值</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-7.哈希</title>
    <link href="/2023/10/10/algorithm/template/2-7.%E5%93%88%E5%B8%8C/"/>
    <url>/2023/10/10/algorithm/template/2-7.%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="一般哈希"><a href="#一般哈希" class="headerlink" title="一般哈希"></a>一般哈希</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>把庞大的值域映射到一个比较小的空间。</p><p>如 <code>0~10^9 -&gt; 0~10^5</code>。</p><blockquote><p>与离散化的关系：离散化是需要保序的，可以看作一种特殊的哈希方式</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-x-mod-n"><a href="#1-x-mod-n" class="headerlink" title="1. x mod n"></a>1. x mod n</h3><p><code>n</code> 即数组长度，它是一个质数，并且这个质数要离2的整数次幂尽可能远。</p><blockquote><p>这样取可以使冲突的概率最小。数学证明待补充</p></blockquote><h3 id="2-解决冲突"><a href="#2-解决冲突" class="headerlink" title="2. 解决冲突"></a>2. 解决冲突</h3><p>有两种方法</p><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>数组的长度即为<code>n</code>，其中每个元素都是一个链表，取模之后结果相同的数存在链表里</p><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>只开一个一维数组，但长度应取为题给数据范围的2～3倍（经验值）。</p><p>取模之后存在数组对应的位置，如已有元素存在，则依次向后面的位置找，直到找到空位存下来。</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><h3 id="拉链法-1"><a href="#拉链法-1" class="headerlink" title="拉链法"></a>拉链法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-comment">// h[]是数组（槽），数组中的每个元素是一个链表，其中有e[]（存值）和ne[]（存下一个节点的下标），idx为当前新插入节点编号</span><br><br><span class="hljs-comment">// 需要先初始化h数组元素为-1，代表空链表</span><br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h)); <span class="hljs-comment">// -1二进制为11111111，刚好可以按字节设置</span><br><br><span class="hljs-comment">// 向哈希表中插入一个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-comment">// k即为哈希值</span><br>  <span class="hljs-type">int</span> k = (x % N + N) % N; <span class="hljs-comment">// 目的：让k在0～N范围内。cpp取模：原数是负数的话取模之后还是负数，所以要+N；但正数+N之后又大于N了，所以需要再取一次模</span><br>  <br>  <span class="hljs-comment">// 以下代码实现了将新节点插入h[k]，作为新的头节点</span><br>  e[idx] = x;<br>  ne[idx] = h[k];<br>  h[k] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-type">int</span> k = (x % N + N) % N;<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[k]; ~i; i = ne[i]) <span class="hljs-comment">// 从头节点往后找</span><br>    <span class="hljs-keyword">if</span> (e[i] == x) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="开放寻址法-1"><a href="#开放寻址法-1" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200003</span>, null = <span class="hljs-number">0x3f3f3f3f</span>; <span class="hljs-comment">// null的值近似无穷大，代表数组该位置为空</span><br><br><span class="hljs-type">int</span> h[N];<br><br><span class="hljs-comment">// 需要先初始化h数组元素为0x3f3f3f3f，代表所有位置都空</span><br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(h)); <span class="hljs-comment">// memset按字节来设置</span><br><br><span class="hljs-comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-type">int</span> t = (x % N + N) % N;<br>  <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x) &#123;<br>    t ++;<br>    <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-comment">// 插入操作：</span><br><span class="hljs-type">int</span> k = <span class="hljs-built_in">find</span>(x);<br>h[k] = x;<br><br><span class="hljs-comment">// 查找操作：</span><br><span class="hljs-type">int</span> k = <span class="hljs-built_in">find</span>(x);<br><span class="hljs-keyword">if</span> (h[k] == null) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>一般不需要删除元素。如果需要考虑删除，一般是另开一个布尔数组，来标记对应元素是否已删除。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式14-观察者模式</title>
    <link href="/2023/10/10/design-pattern/14.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/10/design-pattern/14.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式又叫作发布-订阅（Publish&#x2F;Subscribe）模式。</p><p>观察者模式（Observer）定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/10/LCoseQJmfYubWig.jpg" alt="观察者模式结构图.jpg"></p><h3 id="Subject类"><a href="#Subject类" class="headerlink" title="Subject类"></a>Subject类</h3><p>即主题或抽象通知者，一般用一个抽象类或者一个接口实现。</p><p>它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</p><h3 id="Observer类"><a href="#Observer类" class="headerlink" title="Observer类"></a>Observer类</h3><p>抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫作更新接口。更新接口通常包含一个update()方法，这个方法叫作更新方法。</p><p>抽象观察者一般用一个抽象类或者一个接口实现。</p><h3 id="ConcreteSubject类"><a href="#ConcreteSubject类" class="headerlink" title="ConcreteSubject类"></a>ConcreteSubject类</h3><p>具体主题或具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。</p><p>具体主题角色通常用一个具体子类实现。</p><h3 id="ConcreteObserver类"><a href="#ConcreteObserver类" class="headerlink" title="ConcreteObserver类"></a>ConcreteObserver类</h3><p>具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。具体观察者角色可以保存一个<strong>指向具体主题对象的引用</strong>。</p><p>具体观察者角色通常用一个具体子类实现。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>Subject类：通知者抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>  <span class="hljs-keyword">private</span> ArrayList&lt;Observer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;(); <span class="hljs-comment">// 针对抽象的Observer编程</span><br>  <br>  <span class="hljs-comment">// 增加观察者</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span> &#123;<br>    list.add(observer);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 减少观察者</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span> &#123;<br>    list.remove(observer);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 通知观察者</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObserver</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (Observer item : list) &#123;<br>      item.update();<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">protected</span> String subjectState;<br>  <br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSubjectState</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.subjectState;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSubjectState</span><span class="hljs-params">(String value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.subjectState = value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Observer类：抽象观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ConcreteSubject类：具体通知者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span> &#123;<br>  <span class="hljs-comment">// 具体通知者的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ConcreteObserver类：具体观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> Subject sub;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteObserver</span><span class="hljs-params">(String name, Subject sub)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.sub = sub;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;观察者&quot;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;的新状态是&quot;</span> + <span class="hljs-built_in">this</span>.sub.getSubjectState());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Subject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteSubject</span>();<br>subject.attach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserver</span>(<span class="hljs-string">&quot;NameX&quot;</span>, subject));<br>subject.attach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserver</span>(<span class="hljs-string">&quot;NameY&quot;</span>, subject));<br>subject.attach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserver</span>(<span class="hljs-string">&quot;NameZ&quot;</span>, subject));<br><br>subject <span class="hljs-title function_">setSubjectState</span><span class="hljs-params">(<span class="hljs-string">&quot;ABC&quot;</span>)</span>;<br>subject.notifyObserver();<br></code></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。</p><h3 id="何时使用观察者模式？"><a href="#何时使用观察者模式？" class="headerlink" title="何时使用观察者模式？"></a>何时使用观察者模式？</h3><ol><li>当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象有待改变时</li><li>当一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。</p><h2 id="Java内置接口实现"><a href="#Java内置接口实现" class="headerlink" title="Java内置接口实现"></a>Java内置接口实现</h2><p>现实编程中，具体的观察者完全有可能是风马牛不相及的类，但它们都需要根据通知者的通知来做出update()的操作，此时不适合使用继承，要用接口来实现。</p><p>Java已经为观察者模式准备好了相关的接口和抽象类了：<strong>观察者接口java.util.Observer</strong> 和 <strong>通知者类java.util.Observable</strong> 。</p><p>Java内置的Observable是一个类，这样设计是有问题的。一个类，就只能继承它，但我们自己的类可能本身就需要继承其他抽象类，这就产生了麻烦。Java不支持多重继承，这就严重限制了Observable的复用潜力。所以，当你这段代码用javac编译时，会给出提示： <code>警告：［deprecation］ java.util中的Observable已过时。</code> 系统其实是建议你不要复用这样的方法。所以真实编程中，我们也要考虑怎么取舍，如何修改的问题。</p><h3 id="示例版本一"><a href="#示例版本一" class="headerlink" title="示例版本一"></a>示例版本一</h3><h3 id="示例版本二"><a href="#示例版本二" class="headerlink" title="示例版本二"></a>示例版本二</h3>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式13-建造者模式</title>
    <link href="/2023/10/10/design-pattern/13.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/10/design-pattern/13.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>建造者模式（Builder），将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者模式可以将一个产品的<strong>内部表象</strong>与产品的<strong>生成过程</strong>分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。</p><p>用户只需指定需要建造的类型即可，不需要知道具体建造的过程和细节。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/10/9L64AUgXlocTGOB.jpg" alt="建造者模式结构图.jpg"></p><h3 id="Director"><a href="#Director" class="headerlink" title="Director"></a>Director</h3><p>构建一个使用 <code>Builder</code> 接口的对象。</p><p>用于控制建造过程，隔离用户与建造过程的关联。</p><h3 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h3><p>为创建一个 <code>Product</code> 对象的各个部件指定的抽象接口。</p><h3 id="ConcreteBuilder"><a href="#ConcreteBuilder" class="headerlink" title="ConcreteBuilder"></a>ConcreteBuilder</h3><p>具体建造者，实现 <code>Builder</code> 接口，构造和装配各个部件。</p><h3 id="Product"><a href="#Product" class="headerlink" title="Product"></a>Product</h3><p><code>Builder</code> 建造出来的具体产品。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Product</code> 类：产品类，由多个部件组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>  <br>  ArrayList&lt;String&gt; parts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>  <br>  <span class="hljs-comment">// 添加新的产品部件</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String part)</span> &#123;<br>    parts.add(part);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 列举所有产品部件</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (String part : parts) &#123;<br>      System.out.println(part);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Builder</code> 类：抽象建造者类，确定产品由两个部件 <code>PartA</code> 和 <code>PartB</code> 组成，并声明一个得到产品建造后结果的方法 <code>GetResult</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartA</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartB</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Product <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteBuilder</code> 类：具体建造者类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体建造者类1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteBuilder1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Builder</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartA</span><span class="hljs-params">()</span> &#123;<br>    product.add(<span class="hljs-string">&quot;部件A-1&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartB</span><span class="hljs-params">()</span> &#123;<br>    product.add(<span class="hljs-string">&quot;部件B-1&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> product;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体建造者类2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteBuilder2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Builder</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartA</span><span class="hljs-params">()</span> &#123;<br>    product.add(<span class="hljs-string">&quot;部件A-2&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartB</span><span class="hljs-params">()</span> &#123;<br>    product.add(<span class="hljs-string">&quot;部件B-2&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> product;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Director</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">construct</span><span class="hljs-params">(Builder builder)</span> &#123;<br>    builder.buildPartA();<br>    builder.buildPartB();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：客户不需要知道具体的建造过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Director</span> <span class="hljs-variable">director</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Director</span>();<br><span class="hljs-type">Builder</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteBuilder1</span>();<br><span class="hljs-type">Builder</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteBuilder2</span>();<br><br><span class="hljs-comment">// 指挥者用ConcreteBuilder1的方法来建造产品</span><br>director.construct(b1);<br><span class="hljs-type">Product</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> b1.getResult();<br>p1.show();<br><br><span class="hljs-comment">// 指挥者用ConcreteBuilder2的方法来建造产品</span><br>director.construct(b2);<br><span class="hljs-type">Product</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> b2.getResult();<br>p2.show();<br><br><span class="hljs-comment">// p1, p2结果不同</span><br></code></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>建造者模式主要用于创建一些复杂的对象，这些对象内部子对象的建造顺序通常是稳定的，但每个子对象的构建通常面临复杂的变化。</p><p>建造者模式是在当<strong>创建复杂对象的算法</strong>应该独立于<strong>该对象的组成部分</strong>以及<strong>它们的装配方式</strong>时适用的模式。</p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-6.堆</title>
    <link href="/2023/10/09/algorithm/template/2-6.%E5%A0%86/"/>
    <url>/2023/10/09/algorithm/template/2-6.%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>以小根堆为例：</p><p>堆中的每一个点都是小于等于左右儿子的。</p><p>所以根节点就是整个堆的最小值。</p><h2 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h2><ol><li><p>插入一个数</p><p><code>heap[++ size] = x; up(size);</code></p></li><li><p>求集合当中的最小值</p><p><code>heap[1]</code></p></li><li><p>删除最小值</p><p>用整个堆的最后一个元素覆盖堆顶元素：</p><p><code>heap[1] = heap[size --]; down(1);</code></p></li><li><p>删除任意一个元素</p><p>与删除最小值类似，用最后一个元素覆盖下标为k的元素：</p><p><code>heap[k] = heap[size --]; up(k); down(k);</code></p><p>理论上是需要判断heap[k]的值变大还是变小再决定是up还是down。为了方便，可以直接up和down一遍</p></li><li><p>修改任意一个元素</p><p><code>heap[k] = x; up(k); down(k);</code></p></li></ol><p>其中，插入和删除元素都是 <code>O(logn)</code> 的，求最小值是 <code>O(1)</code> 的。</p><blockquote><p>后两种是手写堆特有的操作，STL无法直接实现。</p></blockquote><p>以上所有操作都可以由两个操作组合实现：</p><h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><p><code>down(x)</code>: 把下标为x的节点的值变大了</p><p>递归：与左右儿子相比，和最小的那个交换位置</p><h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><p><code>up(x)</code>: 把下标为x的节点的值变小了</p><p>递归：与父节点相比，如果比父节点小，则交换位置</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>堆是一个完全二叉树。</p><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p>用一个一位数组来存。下标为x的元素的左儿子下标是2x，右儿子的下标是2x + 1。</p><p>注：下标从1开始 </p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><p>带映射数组版本的模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// h[N]存储堆中的值，h[1]是堆顶，x的左儿子是2x，右儿子是2x + 1</span><br><span class="hljs-comment">// ph[k]存储第k个插入的点在堆中的位置，p是下标，h是堆，ph的意思是插入顺序的下标映射到堆</span><br><span class="hljs-comment">// hp[k]存储堆中下标是k的点是第几个插入的</span><br><span class="hljs-type">int</span> h[N], ph[N], hp[N], size;<br><br><span class="hljs-comment">// 交换两个点，及其映射关系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>  <span class="hljs-built_in">swap</span>(ph[hp[a]], ph[hp[b]]);<br>  <span class="hljs-built_in">swap</span>(hp[a], hp[b]);<br>  <span class="hljs-built_in">swap</span>(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>  <span class="hljs-type">int</span> t = u;<br>  <span class="hljs-comment">// t设为u及其左右儿子里值最小的那一个</span><br>  <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (u != t) &#123;<br>    <span class="hljs-built_in">heap_swap</span>(u, t);<br>    <span class="hljs-built_in">down</span>(t);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>]) &#123;<br>    <span class="hljs-built_in">heap_swap</span>(u, u / <span class="hljs-number">2</span>);<br>    u &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// O(n)建堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i --) <span class="hljs-built_in">down</span>(i);<br></code></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>先把数组建成堆，再依次输出堆顶元素</p><p>时间复杂度： <code>O(nlogn)</code>。</p><h4 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h4><p>如果一个一个元素插入，时间复杂度是 <code>O(nlogn)</code> 的。</p><p><code>O(n)</code> 的建堆方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i --) <span class="hljs-built_in">down</span>(i);<br></code></pre></td></tr></table></figure><p>从 n&#x2F;2 开始往上的所有元素 down，其实就是从树的倒数第二层开始down。</p><p>时间复杂度证明：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span>/<span class="hljs-number">4</span> * <span class="hljs-number">1</span> + <span class="hljs-built_in">n</span>/<span class="hljs-number">8</span> * <span class="hljs-number">2</span> + <span class="hljs-built_in">n</span>/<span class="hljs-number">16</span> * <span class="hljs-number">3</span> + ...<br>= <span class="hljs-built_in">n</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>^<span class="hljs-number">2</span> + <span class="hljs-number">2</span>/<span class="hljs-number">2</span>^<span class="hljs-number">3</span> + <span class="hljs-number">3</span>/<span class="hljs-number">2</span>^<span class="hljs-number">4</span> + ...)<br><br>S = <span class="hljs-number">1</span>/<span class="hljs-number">2</span>^<span class="hljs-number">2</span> + <span class="hljs-number">2</span>/<span class="hljs-number">2</span>^<span class="hljs-number">3</span> + <span class="hljs-number">3</span>/<span class="hljs-number">2</span>^<span class="hljs-number">4</span> + ...<br><span class="hljs-number">2</span>S = <span class="hljs-number">1</span>/<span class="hljs-number">2</span> + <span class="hljs-number">2</span>/<span class="hljs-number">2</span>^<span class="hljs-number">2</span> + <span class="hljs-number">3</span>/<span class="hljs-number">2</span>^<span class="hljs-number">3</span> + ...<br><span class="hljs-number">2</span>S - S = S = <span class="hljs-number">1</span>/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>/<span class="hljs-number">2</span>^<span class="hljs-number">2</span> + <span class="hljs-number">1</span>/<span class="hljs-number">2</span>^<span class="hljs-number">3</span> + ... &lt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="Dijkstra堆优化"><a href="#Dijkstra堆优化" class="headerlink" title="Dijkstra堆优化"></a>Dijkstra堆优化</h3><p>需要用到hp, ph映射数组</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-5.并查集</title>
    <link href="/2023/10/09/algorithm/template/2-5.%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/10/09/algorithm/template/2-5.%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h2><p>在近乎 <code>O(1)</code> 的时间复杂度内支持以下两种操作：</p><ol><li>将两个集合合并</li><li>询问两个元素是否在一个集合当中</li></ol><p>注：有时也用于处理图论相关的问题。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>每个集合用一棵树来表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，<code>p[x]</code> 表示 <code>x</code> 的父节点。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="问题1-如何判断树根？"><a href="#问题1-如何判断树根？" class="headerlink" title="问题1: 如何判断树根？"></a>问题1: 如何判断树根？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (p[x] == x) 则为树根<br></code></pre></td></tr></table></figure><h3 id="问题2-如何求x的集合编号？"><a href="#问题2-如何求x的集合编号？" class="headerlink" title="问题2: 如何求x的集合编号？"></a>问题2: 如何求x的集合编号？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (p[x] != x) x = p[x];<br></code></pre></td></tr></table></figure><h3 id="问题3-如何合并两个集合？"><a href="#问题3-如何合并两个集合？" class="headerlink" title="问题3: 如何合并两个集合？"></a>问题3: 如何合并两个集合？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">px是x的集合编号，py是y的集合编号<br>令p[px] = py即可<br></code></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="1-路径压缩"><a href="#1-路径压缩" class="headerlink" title="1. 路径压缩"></a>1. 路径压缩</h3><p>在 <code>find</code> 函数中通过 <code> if (p[x] != x) p[x] = find(p[x]);</code> 实现把路径上所有点都直接指向祖宗节点</p><h3 id="2-按秩合并（待补充）"><a href="#2-按秩合并（待补充）" class="headerlink" title="2. 按秩合并（待补充）"></a>2. 按秩合并（待补充）</h3><p>大致意思就是倾向于把短的树接到长的树上面</p><p>用得较少，一般不在代码中实现</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><h3 id="朴素并查集"><a href="#朴素并查集" class="headerlink" title="朴素并查集"></a>朴素并查集</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> p[N]; <span class="hljs-comment">// 存储每个点的祖宗节点</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]); <span class="hljs-comment">// 顺手做了路径压缩</span><br>  <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1～n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) p[i] = i;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b); <span class="hljs-comment">// 让a的祖宗节点的父亲指向b的祖宗节点</span><br></code></pre></td></tr></table></figure><h3 id="维护size的并查集"><a href="#维护size的并查集" class="headerlink" title="维护size的并查集"></a>维护size的并查集</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> p[N], size[N];<br><span class="hljs-comment">// p[]存储每个点的祖宗节点，size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>  <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1～n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>  p[i] = i;<br>  size[i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合</span><br>size[<span class="hljs-built_in">find</span>(b)] += size[<span class="hljs-built_in">find</span>(a)];<br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><h3 id="维护到祖宗节点距离的并查集"><a href="#维护到祖宗节点距离的并查集" class="headerlink" title="维护到祖宗节点距离的并查集"></a>维护到祖宗节点距离的并查集</h3><p>例题：食物链</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> p[N], d[N];<br><span class="hljs-comment">// p[]存储每个点的祖宗节点，d[x]存储x到p[x]的距离</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (p[x] != x) &#123;<br>    <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>    d[x] += d[p[x]];<br>    p[x] = u;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1～n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) &#123;<br>  p[i] = i;<br>  d[i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b); <span class="hljs-comment">// 让a的祖宗节点的父亲指向b的祖宗节点</span><br>d[<span class="hljs-built_in">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-4.Trie树</title>
    <link href="/2023/10/09/algorithm/template/2-4.Trie%E6%A0%91/"/>
    <url>/2023/10/09/algorithm/template/2-4.Trie%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>是用于高效<strong>存储</strong>和<strong>查找</strong>字符串集合中各字符串出现次数的数据结构。</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-comment">// 0号点既是根节点，又是空节点（一个点如果没有子节点，它的son就指向0）</span><br><span class="hljs-comment">// son[][]存储树中每个节点的子节点</span><br><span class="hljs-comment">// cnt[]存储以每个节点结尾的单词数量</span><br><br><span class="hljs-comment">// 插入一个字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span> </span>&#123;<br>  <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++) &#123;<br>    <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx; <span class="hljs-comment">// 如果没有子节点，创建一个新节点继续走</span><br>    p = son[p][u];<br>  &#125;<br>  cnt[p] ++;<br>&#125;<br><br><span class="hljs-comment">// 查询字符串出现的次数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span> </span>&#123;<br>  <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++) &#123;<br>    <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    p = son[p][u];<br>  &#125;<br>  <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-3.KMP</title>
    <link href="/2023/10/07/algorithm/template/2-3.KMP/"/>
    <url>/2023/10/07/algorithm/template/2-3.KMP/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>有两个字符串 <code>S</code> 和 <code>p</code>，其中 <code>S</code> 是原串（长），<code>p</code>是模板串（短）。</p><p>KMP用于字符串匹配：找到 <code>S</code> 中所有与 <code>p</code> 相同的子串，并返回每个子串开头字符的下标。</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span><br><br><span class="hljs-comment">// 求模式串的next数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++) &#123; <span class="hljs-comment">// i从2开始的原因：ne[1]不用算，ne[1]=0，第一个字母失败了只能从头开始</span><br>  <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>  <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++;<br>  ne[i] = j; <span class="hljs-comment">// 记录当前i对应的ne[i]</span><br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++) &#123;<br>  <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j]; <span class="hljs-comment">// j没有回到第一个字符且s[i]和p[j + 1]不能匹配：一直往后移动p串使得p[j + 1]之前的子串是匹配的</span><br>  <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++; <span class="hljs-comment">// 如果匹配了，j往后移动</span><br>  <span class="hljs-keyword">if</span> (j == m) &#123; <span class="hljs-comment">// 整个p串都匹配成功</span><br>    j = ne[j]; <span class="hljs-comment">// j还得退一步（试了下如果不加也能ac，因为在下一次循环的while中如果不匹配的话，反正也会执行j=ne[j]的？）</span><br>    <span class="hljs-comment">// 匹配成功之后的逻辑</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想不清楚的话拿个例子模拟一下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">s</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;abababc&quot;</span><br><span class="hljs-attribute">p</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;abababab&quot;</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h3><h4 id="时间复杂度-O-n-2"><a href="#时间复杂度-O-n-2" class="headerlink" title="时间复杂度 O(n^2)"></a>时间复杂度 <code>O(n^2)</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S[N], p[M]<br><br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>  <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>  <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>    <span class="hljs-keyword">if</span> (S[i + j - <span class="hljs-number">1</span>] != p[j]) &#123;<br>      flag = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  <span class="hljs-keyword">if</span> (flag) res.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="时间复杂度-O-n"><a href="#时间复杂度-O-n" class="headerlink" title="时间复杂度 O(n)"></a>时间复杂度 <code>O(n)</code></h4><p>分析：在 <code>i</code> 循环 <code>n</code> 次的过程中，每次循环 <code>j</code> 最多会+1，<code>j</code> 总共最多会+n，因此 <code>j=ne[j]</code> 再怎么减都最多减n</p><p>故总的时间复杂度是 <code>2n</code>，是 <code>O(n)</code> 的。</p><h4 id="next-数组"><a href="#next-数组" class="headerlink" title="next 数组"></a><code>next</code> 数组</h4><p>对于模板串 <code>p</code> 中的每一个字符 <code>p[i]</code>，都进行一个预处理：求出一个最大长度 <code>x</code>，使得以 <code>p[i]</code> 为结尾的长度为 <code>x</code> 的子串和 <code>p</code> 开头的长度为 <code>x</code> 的子串相等。</p><p><code>next[i] = j</code> 含义：<code>p[1, ..., j] = p[i - j + 1, ..., i]</code></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>模板中两个字符串的下标都是从1开始。</p><p><code>p</code> 中每次和<code>S[i]</code> 匹配的是 <code>p[j + 1]</code>，可以理解为 <code>j</code> 比 <code>i</code> 往前错一位，每次都只是试探一下 <code>p[j+1]</code> 能不能和 <code>S[i]</code> 匹配。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-2.栈和队列</title>
    <link href="/2023/10/07/algorithm/template/2-2.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2023/10/07/algorithm/template/2-2.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>LIFO</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// tt表示栈顶</span><br><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[++ tt] = x;<br><br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt --;<br><br><span class="hljs-comment">// 获得栈顶的值</span><br>stk[tt];<br><br><span class="hljs-comment">// 判断栈是否为空，如果 tt &gt; 0，则表示不为空</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>FIFO</p><h2 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h2><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// hh 表示队头， tt 表示队尾</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[++ tt] = x;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><h3 id="代码模板-2"><a href="#代码模板-2" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// hh 表示队头，tt 表示队尾的后一个位置</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[tt ++] = x;<br><span class="hljs-keyword">if</span> (tt == N) tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++;<br><span class="hljs-keyword">if</span> (hh == N) hh = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span><br><span class="hljs-keyword">if</span> (hh != tt) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="代码模板-3"><a href="#代码模板-3" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>    <span class="hljs-keyword">while</span> (tt &amp;&amp; <span class="hljs-built_in">check</span>(stk[tt], a[i])) tt --; <span class="hljs-comment">// 栈不空且栈顶元素满足某种性质时，一直弹出栈顶元素</span><br>    stk[++ tt] = a[i]; <span class="hljs-comment">// 当前元素压入栈中</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h2><p>找出每个数左边离它最近的比它大&#x2F;小的数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先想出暴力思路，再观察有没有单调性</p><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>两重循环 <code>O(n^2)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j --)<br>        <span class="hljs-keyword">if</span> (a[j] &lt; a[i]) &#123;<br>            cout &lt;&lt; a[j] &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h4><p><strong>性质</strong>：如果 <code>a[x] &gt;= a[y] &amp;&amp; x &lt; y</code>，那么 <code>a[x]</code> 一定不会被 <code>y</code> 及 <code>y</code> 后面的元素用到，它可以被删掉</p><p>一重循环 <code>O(n)</code>，每个元素最多入栈一次、出栈一次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>    <span class="hljs-comment">// 弹出不符合条件的元素</span><br>    <span class="hljs-keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= a[i]) tt --;<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (tt) cout &lt;&lt; stk[tt] &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 新元素入栈</span><br>    stk[++ tt] = a[i];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><h2 id="代码模板-4"><a href="#代码模板-4" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check_out</span>(q[hh])) hh ++; <span class="hljs-comment">// 判断队头是否滑出窗口</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check</span>(q[tt], i)) tt --;<br>    q[++ tt] = i; <span class="hljs-comment">// 注意：此处队列里存的是下标，不是值</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常见模型-1"><a href="#常见模型-1" class="headerlink" title="常见模型"></a>常见模型</h2><p>找出滑动窗口中的最大值&#x2F;最小值</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h4><p>从头到尾遍历元素，维护滑动窗口，每次遍历窗口内的所有元素找出最小值</p><p>时间复杂度 <code>O(nk)</code>，<code>k</code> 为窗口大小</p><h4 id="单调队列（双端队列）"><a href="#单调队列（双端队列）" class="headerlink" title="单调队列（双端队列）"></a>单调队列（双端队列）</h4><p>时间复杂度 <code>O(n)</code></p><p><strong>性质</strong>：如果 <code>a[x] &gt;= a[y] &amp;&amp; x &lt; y</code>，那么 <code>a[x]</code> 一定不会被用到，可以从队尾移除</p><p>额外维护一个严格单调递增的单调队列，取最小值时从队头取即可（记得判断队头元素是否已经在当前维护的滑动窗口之前了）</p><p>注意：队列里存的是下标，不是值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="hljs-number">1</span>) hh ++; <span class="hljs-comment">// 把滑动窗口之外的元素出队</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt --; <span class="hljs-comment">// 把队尾比a[i]大或相等的元素出队</span><br><br>    q[++ tt] = i; <span class="hljs-comment">// 当前元素入队</span><br><br>    <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[hh]]); <span class="hljs-comment">// 窗口完全进来了，输出队头元素（此时元素一定在滑动窗口范围内）</span><br>&#125;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-1.链表</title>
    <link href="/2023/10/07/algorithm/template/2-1.%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/10/07/algorithm/template/2-1.%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><h2 id="结构体-指针"><a href="#结构体-指针" class="headerlink" title="结构体+指针"></a>结构体+指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    Node *next;<br>&#125;;<br><br><span class="hljs-keyword">auto</span> n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(); <span class="hljs-comment">// 非常慢</span><br></code></pre></td></tr></table></figure><p>即动态链表。</p><p>一般面试中用得较多，笔试不常用，因为<code>new</code>操作效率低。</p><h2 id="数组模拟（常用）"><a href="#数组模拟（常用）" class="headerlink" title="数组模拟（常用）"></a>数组模拟（常用）</h2><p>即静态链表。</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>主要用途：邻接表。</p><p>邻接表应用：存储树和图。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><code>e[N]</code>: 存储每个点的 <code>val</code>。<code>ne[N]</code>：存储每个点的 <code>next</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// head存储链表头，e[]存储结点的值，ne[]存储结点的next指针，idx表示当前用到了哪个结点</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表头插入一个数a (80%的情况都是插到头结点的位置)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_to_head</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx ++;<br>&#125;<br><br><span class="hljs-comment">// 一般的插入操作：将a插入下标是k的结点后面</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> a)</span> </span>&#123;<br>    e[idx] = a, ne[idx] = ne[k], ne[k] = idx ++;<br>&#125;<br><br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_head</span><span class="hljs-params">()</span> </span>&#123;<br>    head = ne[head];<br>&#125;<br><br><span class="hljs-comment">// 一般的删除操作：将下标是k的点后面的点删掉</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    ne[k] = ne[ne[k]];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>主要用途：优化某些问题。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>让下标为0的点为<code>head</code>，下标为1的点为<code>tail</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// e[]表示结点的值，l[]表示结点的左指针，r[]表示结点的右指针，idx表示当前用到了哪个结点</span><br><span class="hljs-type">int</span> e[N], l[N], r[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 0是左端点，1是右端点</span><br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 在结点k的右边插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> a)</span> </span>&#123;<br>    e[idx] = a;<br>    l[idx] = k, r[idx] = r[k];<br>    l[r[k]] = idx, r[k] = idx;<br>    idx ++;<br>&#125;<br><span class="hljs-comment">// 注：如果想在结点k的左边插入a，调用insert(l[k], a)即可</span><br><br><span class="hljs-comment">// 删除结点k</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    l[r[k]] = l[k];<br>    r[l[k]] = r[k];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式12-外观模式</title>
    <link href="/2023/10/07/design-pattern/12.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/07/design-pattern/12.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个<strong>高层接口</strong>，这个接口使得这一子系统更加容易使用。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/07/LyeOAYqbGIl1nKp.jpg" alt="外观模式结构图.jpg"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>四个子系统的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 子系统1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemOne</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodOne</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子系统方法一&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 子系统2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemTwo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodTwo</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子系统方法二&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 子系统3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemThree</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodThree</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子系统方法三&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 子系统4</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemFour</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodFour</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子系统方法四&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>外观类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 外观类，需要了解所有子系统的方法或属性，进行组合以备外界调用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;<br>    SubSystemOne one;<br>    SubSystemTwo two;<br>    SubSystemThree three;<br>    SubSystemFour four;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Facade</span><span class="hljs-params">()</span> &#123;<br>        one = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemOne</span>();<br>        two = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemTwo</span>();<br>        three = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemThree</span>();<br>        four = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemFour</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        one.methodOne();<br>        two.methodTwo();<br>        three.methodThree();<br>        four.methodFour();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        two.methodTwo();<br>        three.methodThree();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 由于Facade的作用，客户端可以根本不知道四个子系统类的存在</span><br><span class="hljs-type">Facade</span> <span class="hljs-variable">facade</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Facade</span>();<br><br>facade.methodA();<br>facade.methodB();<br></code></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>对于面向对象有一定基础的朋友，即使没有听说过外观模式，也完全有可能在很多时候使用它，因为它完美地体现了依赖倒转原则和迪米特法则的思想，所以是非常常用的模式之一。</p><h3 id="何时使用？"><a href="#何时使用？" class="headerlink" title="何时使用？"></a>何时使用？</h3><ol><li>在设计初期阶段，应该要有意识地<strong>将不同的两个层分离</strong>，比如经典的三层架构，就需要考虑在数据访问层和业务逻辑层、业务逻辑层和表示层的<strong>层与层之间建立外观Facade</strong>，这样可以<strong>为复杂的子系统提供一个简单的接口，使得耦合大大降低。</strong></li><li>在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，大多数的模式使用时也都会产生很多很小的类，这本是好事，但也给外部调用它们的用户程序带来了使用上的困难，增加外观Facade可以<strong>提供一个简单的接口，减少它们之间的依赖。</strong></li><li>在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，但因为它包含非常重要的功能，新的需求开发必须要依赖于它。此时用外观模式Facade也是非常合适的。你可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让<strong>新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。</strong></li></ol><p><img src="https://s2.loli.net/2023/10/07/jCbN9tF6UzOJE1R.jpg" alt="外观模式使用场景.jpg"></p><h2 id="例：投资"><a href="#例：投资" class="headerlink" title="例：投资"></a>例：投资</h2><h3 id="v1股民直接炒股"><a href="#v1股民直接炒股" class="headerlink" title="v1股民直接炒股"></a>v1股民直接炒股</h3><p><img src="https://s2.loli.net/2023/10/07/y6CFScxOXlfApq5.jpg" alt="外观模式v1.jpg"></p><h3 id="v2股民投资基金"><a href="#v2股民投资基金" class="headerlink" title="v2股民投资基金"></a>v2股民投资基金</h3><p><img src="https://s2.loli.net/2023/10/07/X42AszLPjbJZhHd.jpg" alt="外观模式v2.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板1-7.区间合并模板</title>
    <link href="/2023/10/06/algorithm/template/1-7.%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/10/06/algorithm/template/1-7.%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><p><strong>快速地</strong>将有交集的区间合并。</p><p>跟区间有关的问题，大概率会用到贪心。按照端点排序。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>有若干个区间，若其中某些区间有交集，则将它们合并。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>类似贪心。</p><ol><li>按区间左端点从小到大排序</li><li>当前维护的区间，左端点 <code>st</code>，右端点 <code>ed</code>。第<code>i</code>个区间（左端点 <code>l</code>，右端点 <code>r</code>）与当前维护区间的关系：<ol><li><code>st</code> &lt;&#x3D; <code>l</code> &lt;&#x3D; <code>r</code> &lt;&#x3D; <code>ed</code> &#x3D;&gt; 当前维护区间不变</li><li><code>st</code> &lt;&#x3D; <code>l</code> &lt;&#x3D; <code>ed</code> &lt; <code>r</code> &#x3D;&gt; <code>ed</code> 延长到 <code>r</code></li><li><code>st</code> &lt;&#x3D; <code>ed</code> &lt; <code>l</code> &lt;&#x3D; <code>r</code>  &#x3D;&gt; 当前维护区间放入答案，不会再更改；第 <code>i</code> 个区间作为新的当前维护区间</li></ol></li></ol><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回合并后的区间数组</span><br><span class="hljs-function">vector&lt;PII&gt; <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span> </span>&#123;<br>    vector&lt;PII&gt; res;<br>    <br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>; <span class="hljs-comment">// 初始区间设为负无穷</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs) &#123;<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first) &#123; <span class="hljs-comment">// 新区间左端点大于当前维护区间右端点，开始维护新区间</span><br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ed = <span class="hljs-built_in">max</span>(ed, seg.second); <span class="hljs-comment">// 合并情况1, 2</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;); <span class="hljs-comment">// 最后的区间也要加入答案，并且它不能为初始区间（segs为空的情况下答案也应为空）</span><br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板1-1.排序模板</title>
    <link href="/2023/10/06/algorithm/template/1-1.%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/10/06/algorithm/template/1-1.%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均，最好：<code>O(nlogn)</code></p><p>最坏：<code>O(n^2)</code></p><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><p>从小到大：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i ++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j --; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均，最好，最坏：<code>O(nlogn)</code></p><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><p>从小到大：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> tmp[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q, tmp, l, mid), <span class="hljs-built_in">merge_sort</span>(q, tmp, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++] = q[i ++];<br>        <span class="hljs-keyword">else</span> tmp[k ++] = q[j ++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++] = q[i ++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++] = q[j ++];<br>    <br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://s2.loli.net/2023/09/19/aIySX8EKsdhnu4B.png" alt="排序复杂度总结.png"></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板1-2.二分模板</title>
    <link href="/2023/10/06/algorithm/template/1-2.%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/10/06/algorithm/template/1-2.%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h1><p><code>check</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">// 检查arr[x]是否满足某种性质</span><br>&#125;<br></code></pre></td></tr></table></figure><p>区间<code>[l, r]</code>被划分成<code>[l, mid]</code>和<code>[mid + 1, r]</code>时使用（要找的是右半段的最左边那个点）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p>区间<code>[l, r]</code>被划分成<code>[l, mid - 1]</code>和<code>[mid, r]</code>时使用（要找的是左半段的最右边那个点）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br>    <span class="hljs-keyword">while</span> (r - l &gt; eps) &#123;  <span class="hljs-comment">// eps表示精度，取决于题目对精度的要求</span><br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板1-3.前缀和与差分模板</title>
    <link href="/2023/10/06/algorithm/template/1-3.%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/10/06/algorithm/template/1-3.%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>给定a数组，需要构造S数组，使得：<code>S[i] = a[1] + a[2] + ... a[i] (i = 1, 2, ...), S[0] = 0</code></p><blockquote><p>注：a数组下标从1开始，S[i]也从1算起，且S[0]必须赋值0（当l&#x3D;1时会用到，S[l - 1] &#x3D; S[0]）</p></blockquote><h3 id="如何构造-S-i"><a href="#如何构造-S-i" class="headerlink" title="如何构造 S[i] ?"></a>如何构造 <code>S[i]</code> ?</h3><p>从前往后推：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    S[i] = S[i - <span class="hljs-number">1</span>] + a[i];<br></code></pre></td></tr></table></figure><h3 id="作用？"><a href="#作用？" class="headerlink" title="作用？"></a>作用？</h3><p>求a数组[l, r]的和 <code>a[l] + ... + a[r]</code></p><ul><li><p>如果没有S数组：时间复杂度<code>O(n)</code>，需要累加 <code>a[l] + a[l + 1] + ... + a[r]</code>；</p></li><li><p>有了S数组：时间复杂度 <code>O(1)</code>，直接 <code>S[r] - S[l - 1]</code>。</p></li></ul><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">S[i<span class="hljs-punctuation">,</span> j] <span class="hljs-operator">=</span> 第i行j列格子左上部分所有元素的和<br>以(<span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">1</span>)为左上角，(<span class="hljs-keyword">x</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">2</span>)为右下角的子矩阵的和为：<br>S[<span class="hljs-keyword">x</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">2</span>] - S[<span class="hljs-keyword">x</span><span class="hljs-number">1</span> - <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">2</span>] - S[<span class="hljs-keyword">x</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">1</span> - <span class="hljs-number">1</span>] + S[<span class="hljs-keyword">x</span><span class="hljs-number">1</span> - <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">1</span> - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="如何构造-S-i-j"><a href="#如何构造-S-i-j" class="headerlink" title="如何构造 S[i, j] ?"></a>如何构造 <code>S[i, j]</code> ?</h3><p>二重循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>    S[i, j] = S[i - <span class="hljs-number">1</span>, j] + S[i, j - <span class="hljs-number">1</span>] - S[i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>] + a[i, j];<br></code></pre></td></tr></table></figure><h3 id="作用？-1"><a href="#作用？-1" class="headerlink" title="作用？"></a>作用？</h3><p>求a矩阵中：以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和</p><ul><li><p>如果没有S矩阵：时间复杂度<code>O(n^2)</code>，需要二重循环累加；</p></li><li><p>有了S矩阵：时间复杂度 <code>O(1)</code>，直接 <code>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</code>。</p></li></ul><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>前缀和的逆运算</p><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><h3 id="问题？"><a href="#问题？" class="headerlink" title="问题？"></a>问题？</h3><p>给定a数组，需要构造b数组，使得：<code>a[i] = b[1] + b[2] + ... + b[i]</code></p><blockquote><p>满足上述条件的b数组称为a的差分</p></blockquote><h3 id="作用？-2"><a href="#作用？-2" class="headerlink" title="作用？"></a>作用？</h3><p>给a数组区间[l, r]中的每个数加上c</p><ul><li>如果没有b数组：时间复杂度<code>O(n)</code>，需要遍历a数组</li><li>有了b数组：时间复杂度<code>O(1)</code>，<code>b[l] += c, b[r + 1] -= c</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何构造-b-i"><a href="#如何构造-b-i" class="headerlink" title="如何构造 b[i] ?"></a>如何构造 <code>b[i]</code> ?</h3><p>首先假定a, b数组所有元素都是0，此时满足前缀和与差分关系。</p><p>然后其实a数组是有初始值的，这里等价于做n次操作：<code>给a数组区间[i, i]中的每个数都加上a[i]</code>，构造b数组：<code>b[i] += a[i], b[i + 1] -= a[i]</code> 即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    <span class="hljs-built_in">insert</span>(i, i, a[i]);<br></code></pre></td></tr></table></figure><h3 id="最后用前缀和算法求操作后的a数组"><a href="#最后用前缀和算法求操作后的a数组" class="headerlink" title="最后用前缀和算法求操作后的a数组"></a>最后用前缀和算法求操作后的a数组</h3><p>做完若干+c操作后，用前缀和算法求最终答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>    b[i] += b[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, b[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">给以(<span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">1</span>)为左上角，(<span class="hljs-keyword">x</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">2</span>)为右下角的子矩阵中的所有元素加上<span class="hljs-keyword">c</span>：<br>b[<span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">1</span>] +<span class="hljs-operator">=</span> <span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> b[<span class="hljs-keyword">x</span><span class="hljs-number">2</span> + <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">1</span>] -<span class="hljs-operator">=</span> <span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> b[<span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">2</span> + <span class="hljs-number">1</span>] -<span class="hljs-operator">=</span> <span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> b[<span class="hljs-keyword">x</span><span class="hljs-number">2</span> + <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">2</span> + <span class="hljs-number">1</span>] +<span class="hljs-operator">=</span> <span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><h3 id="问题？-1"><a href="#问题？-1" class="headerlink" title="问题？"></a>问题？</h3><p>给定a矩阵，需要构造b矩阵，使得：<code>a[i, j] = b矩阵第i行j列格子左上部分所有元素的和</code></p><blockquote><p>也就是构造b矩阵，使得a矩阵是b矩阵的前缀和</p></blockquote><h3 id="作用？-3"><a href="#作用？-3" class="headerlink" title="作用？"></a>作用？</h3><p>给a矩阵以(x1, y1)为左上角，(x2, y2)为右下角的的子矩阵中的每个数加上c</p><ul><li>如果没有b矩阵：时间复杂度<code>O(n^2)</code>，需要遍历a矩阵</li><li>有了b矩阵：时间复杂度<code>O(1)</code>，<code>b[x1, y1] += c, b[x2 + 1, y1] -= c, b[x1, y2 + 1] -= c, b[x2 + 1, y2 + 1] += c</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    b[x1][y1] += c;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何构造-b-i-j"><a href="#如何构造-b-i-j" class="headerlink" title="如何构造 b[i][j] ?"></a>如何构造 <code>b[i][j]</code> ?</h3><p>与一维差分同理</p><p>其实具体构造不用管，就当作进行了n*m次修改操作即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>    <span class="hljs-built_in">insert</span>(i, j, i, j, a[i][j]);<br></code></pre></td></tr></table></figure><h3 id="最后用前缀和算法求操作后的a矩阵"><a href="#最后用前缀和算法求操作后的a矩阵" class="headerlink" title="最后用前缀和算法求操作后的a矩阵"></a>最后用前缀和算法求操作后的a矩阵</h3><p>做完若干+c操作后，用前缀和算法求最终答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>        b[i][j] += b[i][j - <span class="hljs-number">1</span>] + b[i - <span class="hljs-number">1</span>][j] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, b[i][j]);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板1-4.双指针模板</title>
    <link href="/2023/10/06/algorithm/template/1-4.%E5%8F%8C%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/10/06/algorithm/template/1-4.%E5%8F%8C%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>    <span class="hljs-keyword">while</span> (j &lt;=  i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++; <span class="hljs-comment">// j在合法范围内且满足特定条件，继续往后走</span><br>    <br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常见问题分类"><a href="#常见问题分类" class="headerlink" title="常见问题分类"></a>常见问题分类</h2><ol><li>对于一个序列，用两个指针维护一段区间</li><li>对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</li></ol><h2 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a>核心作用</h2><p>运用某些单调性质（如i, j都只能往后移动），把 <code>O(n^2)</code> 复杂度的暴力枚举优化为 <code>O(n)</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板1-5.位运算模板</title>
    <link href="/2023/10/06/algorithm/template/1-5.%E4%BD%8D%E8%BF%90%E7%AE%97%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/10/06/algorithm/template/1-5.%E4%BD%8D%E8%BF%90%E7%AE%97%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">求n的第k位数字: n &gt;&gt; k &amp; <span class="hljs-number">1</span><br>返回n的最后一位<span class="hljs-number">1</span>：<span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板1-6.离散化模板</title>
    <link href="/2023/10/06/algorithm/template/1-6.%E7%A6%BB%E6%95%A3%E5%8C%96%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/10/06/algorithm/template/1-6.%E7%A6%BB%E6%95%A3%E5%8C%96%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="整数保序离散化"><a href="#整数保序离散化" class="headerlink" title="整数保序离散化"></a>整数保序离散化</h1><h2 id="适用情景"><a href="#适用情景" class="headerlink" title="适用情景"></a>适用情景</h2><p>值域跨度大，但数非常稀疏。即数的范围比较大，但个数比较少。</p><blockquote><p>如：值域0~10^9^，个数10^5^。</p></blockquote><p>需要以数的值作为数组下标。这时需要用一个数组a[]对它们做映射。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>数组a[]中可能有重复元素 -&gt; <strong>需要去重</strong>，用cpp库函数erase()</li><li>如何算出某个数x离散化后的值（在a[]中的下标）是多少？ -&gt; <strong>二分</strong></li></ol><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><br><span class="hljs-comment">// 两行代码实现排序+去重</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//去掉重复元素（unique把所有不重复元素放到数组最前面，并返回这一段元素的尾端点的后一个端点，然后就可以用erase把这个端点到整个数组的尾端点这一段，即多余的重复元素删掉）</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>  </span>&#123; <span class="hljs-comment">// 找到第一个大于等于x的值对应的下标</span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 为了方便建立前缀和数组，映射到1, 2, ..., n （如果需要映射到0, 1, ..., n - 1，return r即可）</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例子：区间和"><a href="#例子：区间和" class="headerlink" title="例子：区间和"></a>例子：区间和</h2><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。</p><p>现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。</p><p>接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p><p>接下来 n 行，每行包含两个整数 x 和 c。</p><p>再接下来 m 行，每行包含两个整数 l 和 r。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 m 行，每行输出一个询问中所求的区间内数字和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>−10^9^≤ x ≤10^9^<br>1≤ n,m ≤10^5^<br>−10^9^≤ l ≤ r ≤10^9^<br>−10000≤ c ≤10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">8<br>0<br>5<br></code></pre></td></tr></table></figure><p>x, l和r都需要离散化存到a[]中，共3×10^5^的空间复杂度</p><p>最后query的区间和用离散化之后的数组求前缀和得出。</p><blockquote><p>注：如果值域跨度小，也可以直接用前缀和来做。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式11-迪米特法则</title>
    <link href="/2023/10/06/design-pattern/11.%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/"/>
    <url>/2023/10/06/design-pattern/11.%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="迪米特法则-LoD"><a href="#迪米特法则-LoD" class="headerlink" title="迪米特法则 (LoD)"></a>迪米特法则 (LoD)</h1><p>迪米特法则，也叫最少知识原则。</p><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><h2 id="根本思想"><a href="#根本思想" class="headerlink" title="根本思想"></a>根本思想</h2><p>强调类之间的松耦合。</p><p>在程序设计时，类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>在类的结构设计上，每一个类都应当尽量<strong>降低成员的访问权限</strong>。也就是说，一个类包装好自己的private状态，不需要让别的类知道的字段或行为就不要公开。</p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式10-模板方法模式</title>
    <link href="/2023/10/06/design-pattern/10.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/06/design-pattern/10.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>模板方法（Template Method）模式，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。</p><p>模板方法使得子类可以在不改变一个算法的结构的情况下，重定义该算法的某些特定步骤。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/06/cXdaetYSGvgoiw8.jpg" alt="模板方法模式结构图.jpg"></p><h3 id="AbstractClass"><a href="#AbstractClass" class="headerlink" title="AbstractClass"></a>AbstractClass</h3><p>AbstractClass是抽象类，其实也就是一个抽象模板，定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</p><h3 id="ConcreteClass"><a href="#ConcreteClass" class="headerlink" title="ConcreteClass"></a>ConcreteClass</h3><p>ConcreteClass ， 实现父类所定义的一个或多个抽象方法。每一个AbstractClass 都可以有任意多个ConcreteClass 与之对应， 而每一个ConcreteClass都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>模板方法抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <br>    <span class="hljs-comment">// 模板方法，给出逻辑骨架，而逻辑组成是一些相应的抽象操作，都推迟到子类实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">templateMethod</span><span class="hljs-params">()</span> &#123;<br>        <br>        <span class="hljs-comment">// 写一些可以被子类共享的代码</span><br>        <br>        <span class="hljs-built_in">this</span>.primitiveOperation1();<br>        <span class="hljs-built_in">this</span>.primitiveOperation2();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 子类个性的行为，放到子类去实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation2</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板方法具体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体类A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClassA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;具体类A方法1实现&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;具体类A方法2实现&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体类B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClassB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;具体类B方法1实现&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;具体类B方法2实现&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势。</p><p>当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。</p><p>模板方法模式是很常用的模式，对继承和多态玩得好的人几乎都会在继承体系中多多少少用到它。比如在Java类库的设计中，通常都会利用模板方法模式提取类库中的公共行为到抽象类中。</p><h2 id="例：试卷抄题与作答"><a href="#例：试卷抄题与作答" class="headerlink" title="例：试卷抄题与作答"></a>例：试卷抄题与作答</h2><h3 id="v1学生抄题"><a href="#v1学生抄题" class="headerlink" title="v1学生抄题"></a>v1学生抄题</h3><p>试卷内容和答案都放到具体某个学生类中实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPaperA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TestPaper</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQuestion1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;问题xxxx。a. xxx b. xxx c. xxx&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;答案：b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="v2打印试卷"><a href="#v2打印试卷" class="headerlink" title="v2打印试卷"></a>v2打印试卷</h3><p>考题试卷类作为父类，试卷内容在试卷类中实现。</p><p>学生答卷类继承试卷类，答案在学生答卷类中实现。</p><h4 id="v2-1-试题方法在子类调用"><a href="#v2-1-试题方法在子类调用" class="headerlink" title="v2.1 试题方法在子类调用"></a>v2.1 试题方法在子类调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPaperA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TestPaper</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQuestion1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.testQuestion1();<br>        System.out.println(<span class="hljs-string">&quot;答案：b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="v2-2-只有具体答案在子类实现"><a href="#v2-2-只有具体答案在子类实现" class="headerlink" title="v2.2 只有具体答案在子类实现"></a>v2.2 只有具体答案在子类实现</h4><p>所有重复的代码都应该要上升到父类去，而不是让每个子类都去重复。</p><p>增加answer1()抽象方法，在子类重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 考题试卷</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPaper</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQuestion1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;问题xxxx。a. xxx b. xxx c. xxx&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;答案：&quot;</span> + <span class="hljs-built_in">this</span>.answer1()); <span class="hljs-comment">// 改成调用抽象方法answer1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">answer1</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 让继承的子类重写，因为每个人的答案不同</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 学生答卷</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPaperA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TestPaper</span> &#123;<br>    <br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">answer1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;b&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp算法相关写法总结</title>
    <link href="/2023/10/06/algorithm/cpp%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%86%99%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2023/10/06/algorithm/cpp%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%86%99%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="输入一行字符串到一个字符数组"><a href="#输入一行字符串到一个字符数组" class="headerlink" title="输入一行字符串到一个字符数组"></a>输入一行字符串到一个字符数组</h3><p>例：</p><p><code>abc def ghi</code> 到 <code>char str[1000]</code></p><p>写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> str[<span class="hljs-number">1000</span>];<br><span class="hljs-built_in">gets</span>(str);<br></code></pre></td></tr></table></figure><p><a href="https://www.programiz.com/cpp-programming/library-function/cstdio/gets">https://www.programiz.com/cpp-programming/library-function/cstdio/gets</a></p><h3 id="用scanf读入一个字母-推荐读成字符串的形式"><a href="#用scanf读入一个字母-推荐读成字符串的形式" class="headerlink" title="用scanf读入一个字母 - 推荐读成字符串的形式"></a>用scanf读入一个字母 - 推荐读成字符串的形式</h3><p>例：</p><p><code>Q 2 3</code></p><p>写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> op[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> a, b;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);<br><span class="hljs-comment">// op[0]即为所需字母</span><br></code></pre></td></tr></table></figure><p>原因：</p><p>如果用 <code>%c</code> 读op，容易读到空格回车等其他字符，很麻烦</p><p>但用 <code>%s</code> 会自动过滤空格回车（读到空格回车就停了）</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="比较字符串是否相等"><a href="#比较字符串是否相等" class="headerlink" title="比较字符串是否相等"></a>比较字符串是否相等</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><br>相等：!<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;PM&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><p>头文件：cstring</p><h4 id="0"><a href="#0" class="headerlink" title="0"></a>0</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">memset</span><span class="hljs-params">(array, <span class="hljs-number">0</span>, sizeof(array)</span></span>)<br></code></pre></td></tr></table></figure><h4 id="1"><a href="#1" class="headerlink" title="-1"></a>-1</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">memset</span><span class="hljs-params">(array, -<span class="hljs-number">1</span>, sizeof(array)</span></span>)<br></code></pre></td></tr></table></figure><h4 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span>类型：常采用<span class="hljs-number">0x3f3f3f3f</span>来作为无穷大<br><br>memset(array, <span class="hljs-number">0x3f</span>, sizeof(array))<br>为数组设初值为<span class="hljs-number">0x3f3f3f3f</span>，因为这个数的每个字节都是<span class="hljs-number">0x3f</span><br></code></pre></td></tr></table></figure><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><ol><li>cout</li><li>Segment Fault的时候一段一段删代码</li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式9-原型模式</title>
    <link href="/2023/10/05/design-pattern/9.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/10/05/design-pattern/9.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>原型模式（Prototype），用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</p><h2 id="原型模式结构图"><a href="#原型模式结构图" class="headerlink" title="原型模式结构图"></a>原型模式结构图</h2><p><img src="https://s2.loli.net/2023/10/05/MWng9htBKl2oAVD.jpg" alt="原型模式结构图.jpg"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>原型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Prototype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Prototype</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getID</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.id;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 原型模式关键：clone方法</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            object = <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Clone异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体原型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcretePrototype</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Prototype</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcretePrototype</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-built_in">super</span>(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ConcretePrototype</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcretePrototype</span>(<span class="hljs-string">&quot;123456&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;原ID: &quot;</span> + p1.getID());<br><br><span class="hljs-type">ConcretePrototype</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> (ConcretePrototype)p1.clone();<br>System.out.println(<span class="hljs-string">&quot;克隆ID: &quot;</span> + c1.getID());<br></code></pre></td></tr></table></figure><blockquote><p>对于Java而言，那个原型抽象类Prototype是用不着的，因为克隆实在是太常用了，所以Java提供了Cloneable接口，其中就是唯一的一个方法clone()，这样就只需要实现这个接口就可以完成原型模式了。</p></blockquote><h2 id="clone的好处"><a href="#clone的好处" class="headerlink" title="clone的好处"></a>clone的好处</h2><p>一般在初始化的信息不发生变化的情况下，克隆是最好的办法</p><ul><li>隐藏对象创建的细节，且修改时可以对特定对象修改，相同的部分也无需重复</li><li>提高性能：不用重新初始化对象，而是动态地获得对象运行时的状态</li></ul><h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><p>super.clone()方法是这样：</p><ul><li>如果字段是值类型的，则对该字段执行逐位复制</li><li>如果字段是引用类型，则复制引用但不复制引用的对象</li></ul><p>因此，原始对象及其副本引用同一对象。</p><h2 id="例：简历"><a href="#例：简历" class="headerlink" title="例：简历"></a>例：简历</h2><p>招聘时投递的简历，可以手抄也可以复印</p><h3 id="v1初步实现"><a href="#v1初步实现" class="headerlink" title="v1初步实现"></a>v1初步实现</h3><p>每生成一份简历，就要实例化一个Resume类的对象。类似于手写，信息需要填写多次，容易出错。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>简历类 <code>Resume</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resume</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> String age;<br>    <span class="hljs-keyword">private</span> String timeArea;<br>    <span class="hljs-keyword">private</span> String company;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Resume</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置个人信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPersonalInfo</span><span class="hljs-params">(String sex, String age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置工作经历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWorkExperience</span><span class="hljs-params">(String timeArea, String company)</span> &#123;<br>        <span class="hljs-built_in">this</span>.timeArea = timeArea;<br>        <span class="hljs-built_in">this</span>.company = company;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 展示简历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.sex + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.age);<br>        System.out.println(<span class="hljs-string">&quot;工作经历 &quot;</span> + <span class="hljs-built_in">this</span>.timeArea + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.company);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Resume</span> <span class="hljs-variable">resume1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>resume1.setPersonalInfo(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>resume1.setWorkExperience(<span class="hljs-string">&quot;2022-2023&quot;</span>, <span class="hljs-string">&quot;xx company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>resume2.setPersonalInfo(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>resume2.setWorkExperience(<span class="hljs-string">&quot;2022-2023&quot;</span>, <span class="hljs-string">&quot;xx company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>resume3.setPersonalInfo(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>resume3.setWorkExperience(<span class="hljs-string">&quot;2022-2023&quot;</span>, <span class="hljs-string">&quot;xx company&quot;</span>);<br><br>resume1.display();<br>resume2.display();<br>resume3.display();<br><br><span class="hljs-comment">// 错误的代码：引用传递 - 实际上指向的是同一个对象</span><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>resume1.setPersonalInfo(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>resume1.setWorkExperience(<span class="hljs-string">&quot;2022-2023&quot;</span>, <span class="hljs-string">&quot;xx company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume2</span> <span class="hljs-operator">=</span> resume1;<br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume3</span> <span class="hljs-operator">=</span> resume1;<br></code></pre></td></tr></table></figure><h3 id="v2原型实现"><a href="#v2原型实现" class="headerlink" title="v2原型实现"></a>v2原型实现</h3><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>简历类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resume</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> String age;<br>    <span class="hljs-keyword">private</span> String timeArea;<br>    <span class="hljs-keyword">private</span> String company;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Resume</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>    ... <span class="hljs-comment">// set方法</span><br>        <br>    <span class="hljs-comment">// 重写clone()方法</span><br>    <span class="hljs-keyword">public</span> Resume <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Resume</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            object = (Resume)<span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Clone异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Resume</span> <span class="hljs-variable">resume1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>resume1.setPersonalInfo(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>resume1.setWorkExperience(<span class="hljs-string">&quot;2022-2023&quot;</span>, <span class="hljs-string">&quot;xx company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume2</span> <span class="hljs-operator">=</span> resume1.clone();<br>resume2.setWorkExperience(<span class="hljs-string">&quot;2021-2022&quot;</span>, <span class="hljs-string">&quot;yy company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume3</span> <span class="hljs-operator">=</span> resume1.clone();<br>resume3.setPersonalInfo(<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;23&quot;</span>);<br><br>resume1.display();<br>resume2.display();<br>resume3.display();<br></code></pre></td></tr></table></figure><h3 id="v3浅拷贝与深拷贝实现"><a href="#v3浅拷贝与深拷贝实现" class="headerlink" title="v3浅拷贝与深拷贝实现"></a>v3浅拷贝与深拷贝实现</h3><p>将 <code>workExperience</code> 单独作为一个类，其中有时间区间和公司名称属性</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>不同resume对象指向的workExperience实际上是同一个</p><h5 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h5><p><img src="https://s2.loli.net/2023/10/05/p7GNTdRsmej3yWL.jpg" alt="原型模式v3浅拷贝.jpg"></p><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><p>工作经历类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkExperience</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String timeArea;<br>    <span class="hljs-keyword">private</span> String company;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTimeArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.timeArea;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTimeArea</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.timeArea = value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCompany</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.company;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCompany</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.company = vaule;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简历类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resume</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> String age;<br>    <span class="hljs-keyword">private</span> WorkExperience work; <span class="hljs-comment">// 声明一个工作经历的对象</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Resume</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.work = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkExperience</span>(); <span class="hljs-comment">// 对这个工作经历对象实例化</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置个人信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPersonalInfo</span><span class="hljs-params">(String sex, String age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置工作经历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWorkExperience</span><span class="hljs-params">(String timeArea, String company)</span> &#123;<br>        <span class="hljs-built_in">this</span>.work.setTimeArea(timeArea); <span class="hljs-comment">// 给工作经历实例的时间赋值</span><br>        <span class="hljs-built_in">this</span>.work.setCompany(company); <span class="hljs-comment">// 给工作经历实例的公司赋值</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 展示简历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.sex + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.age);<br>        System.out.println(<span class="hljs-string">&quot;工作经历 &quot;</span> + <span class="hljs-built_in">this</span>.work.getTimeArea() + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.work.getCompany());<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Resume <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Resume</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            object = (Resume)<span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span>(CloneNotSupportedException e) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Clone异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Resume</span> <span class="hljs-variable">resume1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>resume1.setPersonalInfo(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>resume1.setWorkExperience(<span class="hljs-string">&quot;2022-2023&quot;</span>, <span class="hljs-string">&quot;xx company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume2</span> <span class="hljs-operator">=</span> resume1.clone();<br>resume2.setWorkExperience(<span class="hljs-string">&quot;2021-2022&quot;</span>, <span class="hljs-string">&quot;yy company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume3</span> <span class="hljs-operator">=</span> resume1.clone();<br>resume3.setPersonalInfo(<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;23&quot;</span>);<br>resume2.setWorkExperience(<span class="hljs-string">&quot;2020-2021&quot;</span>, <span class="hljs-string">&quot;zz company&quot;</span>);<br><br>resume1.display();<br>resume2.display();<br>resume3.display();<br></code></pre></td></tr></table></figure><h6 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h6><p>实际结果与期望结果并不符合，前两次的工作经历数据被最后一次数据给覆盖了。</p><h6 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h6><p>这种拷贝方式是<strong>浅拷贝</strong>。对于值类型，没什么问题；对引用类型，就只是复制了引用，对引用的对象还是指向了原来的对象。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>我们希望是resume1、resume2、resume3三个引用的对象是不同的，复制时就一变二，二变三，此时，我们就叫这种方式为 <code>深拷贝</code>，深拷贝把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。</p><p>深复制要深入到多少层，需要事先就考虑好，而且要当心出现循环引用的问题，需要小心处理，这里比较复杂，可以慢慢研究。</p><h5 id="结构图-1"><a href="#结构图-1" class="headerlink" title="结构图"></a>结构图</h5><p><img src="https://s2.loli.net/2023/10/05/yRPYeD53NJKVduL.jpg" alt="原型模式v3深拷贝.jpg"></p><h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><p>工作经历类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkExperience</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String timeArea;<br>    <span class="hljs-keyword">private</span> String company;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTimeArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.timeArea;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTimeArea</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.timeArea = value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCompany</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.company;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCompany</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.company = vaule;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 重写clone方法</span><br>    <span class="hljs-keyword">public</span> WorkExperience <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">WorkExperience</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            object = (WorkExperience)<span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Clone异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简历类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resume</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> String age;<br>    <span class="hljs-keyword">private</span> WorkExperience work; <span class="hljs-comment">// 声明一个工作经历的对象</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Resume</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.work = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkExperience</span>(); <span class="hljs-comment">// 对这个工作经历对象实例化</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置个人信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPersonalInfo</span><span class="hljs-params">(String sex, String age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置工作经历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWorkExperience</span><span class="hljs-params">(String timeArea, String company)</span> &#123;<br>        <span class="hljs-built_in">this</span>.work.setTimeArea(timeArea); <span class="hljs-comment">// 给工作经历实例的时间赋值</span><br>        <span class="hljs-built_in">this</span>.work.setCompany(company); <span class="hljs-comment">// 给工作经历实例的公司赋值</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 展示简历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.sex + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.age);<br>        System.out.println(<span class="hljs-string">&quot;工作经历 &quot;</span> + <span class="hljs-built_in">this</span>.work.getTimeArea() + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.work.getCompany());<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Resume <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Resume</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            object = (Resume)<span class="hljs-built_in">super</span>.clone();<br>            object.work = <span class="hljs-built_in">this</span>.work.clone(); <span class="hljs-comment">// 新增该条语句，对work进行深拷贝</span><br>        &#125; <span class="hljs-keyword">catch</span>(CloneNotSupportedException e) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Clone异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Resume</span> <span class="hljs-variable">resume1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>resume1.setPersonalInfo(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>resume1.setWorkExperience(<span class="hljs-string">&quot;2022-2023&quot;</span>, <span class="hljs-string">&quot;xx company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume2</span> <span class="hljs-operator">=</span> resume1.clone();<br>resume2.setWorkExperience(<span class="hljs-string">&quot;2021-2022&quot;</span>, <span class="hljs-string">&quot;yy company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume3</span> <span class="hljs-operator">=</span> resume1.clone();<br>resume3.setPersonalInfo(<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;23&quot;</span>);<br>resume2.setWorkExperience(<span class="hljs-string">&quot;2020-2021&quot;</span>, <span class="hljs-string">&quot;zz company&quot;</span>);<br><br>resume1.display();<br>resume2.display();<br>resume3.display();<br></code></pre></td></tr></table></figure><h6 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h6><p>这时客户端输出结果达到预期效果。</p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式8-工厂方法模式</title>
    <link href="/2023/09/25/design-pattern/8.%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/25/design-pattern/8.%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>工厂方法模式（Factory Method），定义一个用于创建对象的接口，让子类决定实例化哪一个类。</p><p>工厂方法使一个类的实例化<strong>延迟到其子类</strong>。</p><h2 id="工厂方法模式结构图"><a href="#工厂方法模式结构图" class="headerlink" title="工厂方法模式结构图"></a>工厂方法模式结构图</h2><p><img src="https://s2.loli.net/2023/09/25/ECs5PaBurW7kmyZ.jpg" alt="工厂方法模式结构图.jpg"></p><p>相比于简单工厂（工厂类只有一个），工厂方法模式中有<strong>多个工厂类</strong>继承于工厂抽象类&#x2F;实现工厂接口，增加新工厂不会影响原有工厂。此外，产品的实例化延迟到工厂子类中，而不是最外层的工厂类（如计算器中的 <code>OperationFactory</code>）。</p><h1 id="例1：计算器"><a href="#例1：计算器" class="headerlink" title="例1：计算器"></a>例1：计算器</h1><h2 id="计算器V1"><a href="#计算器V1" class="headerlink" title="计算器V1"></a>计算器V1</h2><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://s2.loli.net/2023/09/25/5gty3FUwSMIWdv9.jpg" alt="工厂方法结构图.jpg"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>工厂接口 <code>IFactory</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>每种运算各建立一个具体工厂实现 <code>IFactory</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 加法工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Add</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 其余运算类似</span><br></code></pre></td></tr></table></figure><p>运算工厂类 <code>OperationFactory</code> ：根据用户输入的运算符号，决定返回哪一个运算子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperate</span><span class="hljs-params">(String operate)</span> &#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">IFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (operate) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddFactory</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubFactory</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulFactory</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DivFactory</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        oper = factory.createOperation();<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> OperationFactory.createOperate(strOperate);<br><span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> oper.getResult(numberA, numberB);<br></code></pre></td></tr></table></figure><h3 id="简单工厂vs工厂方法"><a href="#简单工厂vs工厂方法" class="headerlink" title="简单工厂vs工厂方法"></a>简单工厂vs工厂方法</h3><h4 id="假如要增加一个指数运算？"><a href="#假如要增加一个指数运算？" class="headerlink" title="假如要增加一个指数运算？"></a>假如要增加一个指数运算？</h4><h5 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h5><p>先增加指数运算的运算类，再更改 <code>OperationFactory</code> 类的 <code>switch</code> 语句。</p><h5 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h5><p>先增加指数运算的运算类，再更改 <code>OperationFactory</code> 类的 <code>switch</code> 语句，还要额外增加一个指数运算工厂类实现 <code>IFacotry</code> 接口。增加了复杂性。</p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><ul><li><p><strong>简单工厂模式</strong>：最大优点在于工厂类中包含必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</p><ul><li>例如计算器，客户端不用管该用哪个类的实例，只需要把’+’给工厂，工厂自动就给出了相应的实例，客户端只要去做运算就可以了，不同的实例会实现不同的运算。但问题也就在这里，如你所说，如果要加一个’求x的n次方（x^n）’的功能，我们需要给OperationFactory类的方法里加’Case’的分支条件。目前来看，这个OperationFactory类，承载了太多功能，这可不是好办法。这就等于说，我们不但对扩展开放了，对修改也开放了，违背了开放-封闭原则。</li></ul></li><li><p><strong>工厂方法模式</strong>：将长的代码切割成小段，再将每一小段’封装’起来，减少每段代码之间的耦合，这样风险就分散了，需要修改或扩展的难度就降低了。</p><ul><li>比如计算器：加减乘除运算统一设计成 <code>基础运算工厂</code> 的产品。增加指数、对数运算类，新开一个工厂 <code>高级运算工厂</code> 类，不需要对 <code>基础运算工厂</code> 做改动。</li></ul></li></ul><h2 id="计算器V2"><a href="#计算器V2" class="headerlink" title="计算器V2"></a>计算器V2</h2><h3 id="结构图-1"><a href="#结构图-1" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://s2.loli.net/2023/09/25/pij2CroZTRvWfIQ.jpg" alt="工厂方法结构图2.jpg"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>增加指数运算类，继承 <code>Operation</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> numberA, <span class="hljs-type">double</span> numberB)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.pow(numberA, numberB);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将加减乘除运算封装到基础运算工厂类 <code>FactoryBasic</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryBasic</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">(String operateType)</span> &#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (operateType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Add</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mul</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Div</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将新运算封装到高级运算工厂类 <code>FactoryAdvanced</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryAdvanced</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">(String operateType)</span> &#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (operateType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pow&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pow</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;log&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 还可扩展其他高级运算类的实例化，但修改当前工厂类不会影响到基础运算工厂类</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>新的 <code>OperationFactory</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperate</span><span class="hljs-params">(String operate)</span> &#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">IFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (operate) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                <span class="hljs-comment">// 基础运算工厂实例</span><br>                factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FactoryBasic</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pow&quot;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;log&quot;</span>:<br>                <span class="hljs-comment">// 高级运算工厂实例</span><br>                factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FactoryAdvanced</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 利用多态返回实际的运算类实例</span><br>        oper = factory.createOperation(operate);<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对比简单工厂模式中的 <code>OperationFactory</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperate</span><span class="hljs-params">(String operate)</span> &#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (operate) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Add</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mul</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Div</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，新的 <code>OperationFactory</code> 类已经不存在运算子类实例化的代码了。也就是说，在这个代码里，全部是接口与具体工厂类，并不存在具体的实现，与原来的 <code>OperationFactory</code> 类对比，实例化的过程延迟到了工厂子类中。</p><p>遵循<code>依赖倒置原则</code>：针对接口（<code>IFactory</code>）编程，而不是针对实现（<code>Operation</code>）编程。</p><h1 id="例2：再升级商场收银程序"><a href="#例2：再升级商场收银程序" class="headerlink" title="例2：再升级商场收银程序"></a>例2：再升级商场收银程序</h1><blockquote><p>简单工厂+策略+装饰+工厂方法</p></blockquote><p>之前的<code>简单工厂+策略+装饰</code> 版本中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashContext</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> ISale cs;<br>    <br>    <span class="hljs-comment">// 在构造函数中传入type，根据type来实例化具体的收费策略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashContext</span><span class="hljs-params">(<span class="hljs-type">int</span> cashType)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (cashType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-built_in">this</span>.cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>();<br>                <span class="hljs-keyword">break</span>;<br>            ...<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                <span class="hljs-comment">// 先打8折，再满300返100</span><br>                <span class="hljs-type">CashNormal</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>();<br>                <span class="hljs-type">CashReturn</span> <span class="hljs-variable">crt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashReturn</span>(<span class="hljs-number">300d</span>, <span class="hljs-number">100d</span>);<br>                <span class="hljs-type">CashRebate</span> <span class="hljs-variable">crb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.8d</span>);<br>                <br>                crt.decorate(cn); <span class="hljs-comment">// 用 满300返100算法 包装原价算法</span><br>                crb.decorate(crt); <span class="hljs-comment">// 用 打8折算法 装饰 满300返100算法</span><br>                <span class="hljs-built_in">this</span>.cs = crb;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 根据收费策略的不同，获得计算结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.cs.acceptCash(price, num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>case 5</code>中new的对象太多，应该将其封装成一个工厂。</p><p>所有的case可以抽象成两个工厂类：<code>先打折后满减</code>和<code>先满减后打折</code>。有<code>先打折后满减</code>类存在，那它应该有三个初始化参数：<em>折扣值、满减条件、满减返利值</em>，那么：</p><ul><li>打折类：其实就是满减返利值条件为0的情况</li><li>满减类：就相当于折扣参数为1的情况</li></ul><h2 id="结构图-2"><a href="#结构图-2" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/09/25/uPfSU2R5J7bxM39.jpg" alt="工厂方法结构图3.jpg"></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><p>增加 <code>IFactory</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> ISale <span class="hljs-title function_">createSalesModel</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 创建销售模式</span><br>&#125;<br></code></pre></td></tr></table></figure><p>增加实现 <code>IFactory</code> 接口的两个类：<code>先打折后满减</code>和<code>先满减后打折</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先打折后满减类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashRebateReturnFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyRebate</span> <span class="hljs-operator">=</span> <span class="hljs-number">1d</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyCondition</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyReturn</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashRebateReturnFactory</span><span class="hljs-params">(<span class="hljs-type">double</span> moneyRebate, <span class="hljs-type">double</span> moneyCondition, <span class="hljs-type">double</span> moneyReturn)</span> &#123;<br>        <span class="hljs-built_in">this</span>.moneyRebate = moneyRebate;<br>        <span class="hljs-built_in">this</span>.moneyCondition = moneyCondition;<br>        <span class="hljs-built_in">this</span>.moneyReturn = moneyReturn;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 重写接口方法，先打折后满减</span><br>    <span class="hljs-keyword">public</span> ISale <span class="hljs-title function_">createSalesModel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CashNormal</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>();<br>        <span class="hljs-type">CashReturn</span> <span class="hljs-variable">cr1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashReturn</span>(<span class="hljs-built_in">this</span>.moneyCondition, <span class="hljs-built_in">this</span>.moneyReturn);<br>        <span class="hljs-type">CashRebate</span> <span class="hljs-variable">cr2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-built_in">this</span>.moneyRebate);<br>        <br>        cr1.decorate(cn);<br>        cr2.decorate(cr1);<br>        <span class="hljs-keyword">return</span> cr2;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 先满减后打折类类似。。</span><br></code></pre></td></tr></table></figure><p><code>CashContext</code> 类：针对 <code>ISale</code> 和 <code>IFactory</code> 接口和两个工厂类编程， 对于各个打折满减算法CashSuper、CashNormal、CashReturn、CashRebate等具体类一无所知。实现了松耦合的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashContext</span> &#123;<br>    <span class="hljs-keyword">private</span> ISale cs;<br>    <br>    <span class="hljs-comment">// 构造函数传入收费策略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashContext</span><span class="hljs-params">(<span class="hljs-type">int</span> cashType)</span> &#123;<br>        <span class="hljs-type">IFactory</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (cashType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// 原价</span><br>                fs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebateReturnFactory</span>(<span class="hljs-number">1d</span>, <span class="hljs-number">0d</span>, <span class="hljs-number">0d</span>); <span class="hljs-comment">// 不打折，不满减</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// 打8折</span><br>                fs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebateReturnFactory</span>(<span class="hljs-number">0.8d</span>, <span class="hljs-number">0d</span>, <span class="hljs-number">0d</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-comment">// 满300返100</span><br>                fs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebateReturnFactory</span>(<span class="hljs-number">1d</span>, <span class="hljs-number">300d</span>, <span class="hljs-number">100d</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-comment">// 先打8折，再满300返100</span><br>                fs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebateReturnFactory</span>(<span class="hljs-number">0.8d</span>, <span class="hljs-number">300d</span>, <span class="hljs-number">100d</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-comment">// 先满200返50，再打7折</span><br>                fs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashReturnRebateFactory</span>(<span class="hljs-number">0.7d</span>, <span class="hljs-number">200d</span>, <span class="hljs-number">50d</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.cs = fs.createSalesModel();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.cs.acceptCash(price, num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>工厂方法模式是简单工厂模式的进一步抽象和推广：当只有一个工厂时，就是简单工厂模式；当有多个工厂时，就是工厂方法模式（当然外层还有一个总的工厂来决定具体选择哪一个工厂）。类似由一维进化成了二维。</p><p>工厂方法本质就是对获取对象过程的抽象，它克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。</p><h2 id="工厂方法模式的好处"><a href="#工厂方法模式的好处" class="headerlink" title="工厂方法模式的好处"></a>工厂方法模式的好处</h2><ul><li><strong>对于复杂的参数的构造对象，可以很好地对外层屏蔽代码的复杂性</strong>，注意是指创建新实例的构造对象。比如说我们用了’先打折再满减’类工厂，其实就屏蔽了装饰模式的一部分代码，让CashContext不再需要了解装饰的过程。</li><li><strong>有很好的解耦能力。</strong>也就是针对接口在编程。当我们要修改具体实现层的代码时，上层代码完全不了解实现层的情况，因此并不会影响到上层代码的调用，这就达到了解耦的目的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式2-策略模式</title>
    <link href="/2023/09/25/design-pattern/2.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/25/design-pattern/2.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p><h3 id="策略模式结构图"><a href="#策略模式结构图" class="headerlink" title="策略模式结构图"></a>策略模式结构图</h3><p><img src="https://s2.loli.net/2023/09/25/3FbYVIzrKk2hLA5.jpg" alt="策略模式结构图.jpg"></p><h3 id="策略模式基本代码"><a href="#策略模式基本代码" class="headerlink" title="策略模式基本代码"></a>策略模式基本代码</h3><p>Strategy类，定义所有支持的算法的公共接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象算法类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-comment">// 算法方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ConcreteStrategy类，封装了具体的算法或行为，继承于Strategy：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体算法A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-comment">// 算法A实现方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;算法A实现&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体算法B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-comment">// 算法B实现方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;算法B实现&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体算法C</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-comment">// 算法C实现方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;算法C实现&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Context类，用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上下文</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    Strategy strategy;<br>    <br>    <span class="hljs-comment">// 初始化时，传入具体的策略对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Context</span><span class="hljs-params">(Strategy strategy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.strategy = strategy;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 上下文接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextInterface</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 根据具体的策略对象，调用其算法的方法</span><br>        strategy.algorithmInterface();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Context context;<br><br><span class="hljs-comment">// 实例化不同的策略</span><br>context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyA</span>());<br>context.contextInterface();<br><br>context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyB</span>());<br>context.contextInterface();<br><br>context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyC</span>());<br>context.contextInterface();<br></code></pre></td></tr></table></figure><h1 id="例：商场收银软件"><a href="#例：商场收银软件" class="headerlink" title="例：商场收银软件"></a>例：商场收银软件</h1><h2 id="原始版本"><a href="#原始版本" class="headerlink" title="原始版本"></a>原始版本</h2><p>所有内容都写在一个程序中，如要需要修改任意代码，都需要重新安装在商场所有机器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>; <span class="hljs-comment">// 商品单价</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 商品数量</span><br><span class="hljs-type">double</span> <span class="hljs-variable">totalPrices</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>; <span class="hljs-comment">// 当前商品合计费用</span><br><span class="hljs-type">double</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>; <span class="hljs-comment">// 总计所有商品费用</span><br><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br><span class="hljs-keyword">do</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;请输入商品单价：&quot;</span>);<br>    price = Double.parseDouble(sc.nextLine());<br>    System.out.println(<span class="hljs-string">&quot;请输入商品数量：&quot;</span>);<br>    num = Integer.parseInt(sc.nextLine());<br>    System.out.println();<br>    <br>    <span class="hljs-keyword">if</span> (price &gt; <span class="hljs-number">0</span> &amp;&amp; num &gt; <span class="hljs-number">0</span>) &#123;<br>        totalPrices = price * num;<br>        total += totalPrices;<br>        <br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;单价：&quot;</span> + price + <span class="hljs-string">&quot;元，数量：&quot;</span> + num + <span class="hljs-string">&quot;，合计：&quot;</span> + totalPrices + <span class="hljs-string">&quot;元&quot;</span>);<br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;总计：&quot;</span> + total + <span class="hljs-string">&quot;元&quot;</span>);<br>        System.out.println();<br>    &#125;<br>&#125; <span class="hljs-keyword">while</span> (price &gt; <span class="hljs-number">0</span> &amp;&amp; num &gt; <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="增加打折"><a href="#增加打折" class="headerlink" title="增加打折"></a>增加打折</h2><p>新增打折&#x2F;返利功能</p><h3 id="硬编码实现版本"><a href="#硬编码实现版本" class="headerlink" title="硬编码实现版本"></a>硬编码实现版本</h3><p>写在客户端程序中。每新增打x折都要重新安装。用下拉框选择销售模式实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">discount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 商品销售模式：1.原价 2.八折 3.七折</span><br>...<br><span class="hljs-keyword">switch</span> (discount) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        totalPrices = price * num;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        totalPrices = price * num * <span class="hljs-number">0.8</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        totalPrices = price * num * <span class="hljs-number">0.7</span>;<br>&#125;<br><br>total += totalPrices;<br></code></pre></td></tr></table></figure><h3 id="简单工厂实现版本"><a href="#简单工厂实现版本" class="headerlink" title="简单工厂实现版本"></a>简单工厂实现版本</h3><p>用收费抽象类，让打折&#x2F;返利继承抽象类，传入对应需要的参数灵活实现具体打几折、满多少返多少，需要新增时在工厂类中添加模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 收费抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashSuper</span> &#123;<br>    <br>    <span class="hljs-comment">// 收费抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span>;<br>&#125;<br><br><span class="hljs-comment">// 正常收费</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashNormal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CashSuper</span> &#123;<br>    <br>    <span class="hljs-comment">// 原价返回</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">return</span> price * num;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 打折收费</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashRebate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CashSuper</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyRebate</span> <span class="hljs-operator">=</span> <span class="hljs-number">1d</span>;<br>    <br>    <span class="hljs-comment">// 初始化时输入折扣率</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashRebate</span><span class="hljs-params">(<span class="hljs-type">double</span> moneyRebate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.moneyRebate = moneyRebate;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 返回乘上折扣率的总价</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">return</span> price * num * <span class="hljs-built_in">this</span>.moneyRebate;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 返利收费</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashReturn</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CashSuper</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyCondition</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>; <span class="hljs-comment">// 返利条件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyReturn</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>; <span class="hljs-comment">// 返利值</span><br>    <br>    <span class="hljs-comment">// 初始化时输入返利条件和返利值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashReturn</span><span class="hljs-params">(<span class="hljs-type">double</span> moneyCondition, <span class="hljs-type">double</span> moneyReturn)</span> &#123;<br>        <span class="hljs-built_in">this</span>.moneyCondition = moneyCondition;<br>        <span class="hljs-built_in">this</span>.moneyReturn = moneyReturn;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 返回返利后的总价</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> price * num;<br>        <span class="hljs-keyword">if</span> (moneyCondition &gt; <span class="hljs-number">0</span> &amp;&amp; result &gt;= moneyCondition) &#123;<br>            result -= Math.floor(result / moneyCondition) * moneyReturn;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>收费工厂代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CashSuper <span class="hljs-title function_">createCashAccept</span><span class="hljs-params">(<span class="hljs-type">int</span> cashType)</span> &#123;<br>        <span class="hljs-type">CashSuper</span> <span class="hljs-variable">cs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (cashType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.8d</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.7d</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashReturn</span>(<span class="hljs-number">300d</span>, <span class="hljs-number">100d</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cs;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端程序主要部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CashSuper</span> <span class="hljs-variable">cashSuper</span> <span class="hljs-operator">=</span> CashFactory.createCashAccept(cashType);<br>totalPrices = cashSuper.acceptCash(price, num);<br>total += totalPrices;<br></code></pre></td></tr></table></figure><h3 id="策略模式实现版本"><a href="#策略模式实现版本" class="headerlink" title="策略模式实现版本"></a>策略模式实现版本</h3><p>跟简单工厂很像，只要加一个CashContext类，改写一下客户端代码即可。</p><p>CashContext类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashContext</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> CashSuper cs;<br>    <br>    <span class="hljs-comment">// 构造方法传入具体的收费策略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashContext</span><span class="hljs-params">(CashSuper csuper)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cs = csuper;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 根据收费策略的不同，获得计算结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.cs.acceptCash(price, num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端主要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CashContext</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">switch</span> (cashType) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        cc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashContext</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>());<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        cc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashContext</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.8d</span>));<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        cc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashContext</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.7d</span>));<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>        cc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashContext</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CashReturn</span>(<span class="hljs-number">300d</span>, <span class="hljs-number">100d</span>));<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 通过Context的getResult方法调用，得到收费结果</span><br><span class="hljs-comment">// 让具体算法与客户完全隔离</span><br>totalPrices = cc.getResult(price, num);<br>total += totalPrices;<br></code></pre></td></tr></table></figure><p>但这样是在客户端判断使用哪种算法，客户能看到具体的收费策略，可以将策略模式与简单工厂模式结合，把判断转移到工厂中。</p><h3 id="策略与简单工厂结合版本"><a href="#策略与简单工厂结合版本" class="headerlink" title="策略与简单工厂结合版本"></a>策略与简单工厂结合版本</h3><p>改进CashContext类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashContext</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> CashSuper cs;<br>    <br>    <span class="hljs-comment">// 在构造函数中传入type，根据type来实例化具体的收费策略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashContext</span><span class="hljs-params">(<span class="hljs-type">int</span> cashType)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (cashType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-built_in">this</span>.cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-built_in">this</span>.cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.8d</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                <span class="hljs-built_in">this</span>.cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.7d</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                <span class="hljs-built_in">this</span>.cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashReturn</span>(<span class="hljs-number">300d</span>, <span class="hljs-number">100d</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 根据收费策略的不同，获得计算结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.cs.acceptCash(price, num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CashContext</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashContext</span>(cashType);<br>totalPrices = cc.getResult(price, num);<br>total += totalPrices;<br></code></pre></td></tr></table></figure><h4 id="与纯简单工厂模式对比"><a href="#与纯简单工厂模式对比" class="headerlink" title="与纯简单工厂模式对比"></a>与纯简单工厂模式对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 简单工厂模式用法</span><br><span class="hljs-type">CashSuper</span> <span class="hljs-variable">cs</span> <span class="hljs-operator">=</span> CashFactory.createCashAccept(cashType);<br>totalPrices = cs.acceptCash(price, num);<br><br><span class="hljs-comment">// 策略模式与简单工厂模式结合的用法</span><br><span class="hljs-type">CashContext</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashContext</span>(cashType);<br>totalPrices = cc.getResult(price, num);<br></code></pre></td></tr></table></figure><p>简单工厂模式我需要让客户端认识两个类，CashSuper和CashFactory，而策略模式与简单工厂结合的用法，客户端就只需要认识一个类CashContext就可以了。耦合更加降低。</p><p>在客户端实例化的是CashContext的对象，调用的是CashContext的方法GetResult，这使得具体的收费算法彻底地与客户端分离。连算法的父类CashSuper都不让客户端认识了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="策略模式优点"><a href="#策略模式优点" class="headerlink" title="策略模式优点"></a>策略模式优点</h2><ul><li>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种<strong>算法类</strong>与<strong>使用算法类</strong>之间的耦合。<strong>策略模式封装了变化。</strong></li><li>策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于<strong>析取</strong>出这些算法中的<strong>公共功能</strong>。如：收费算法公共的功能就是获得计算费用的结果GetResult，这使得算法间有了抽象的父类CashSuper.</li><li>简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口<strong>单独测试</strong>。</li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>收银系统中如果要新增折扣，还是需要修改CashContext中的switch语句，可以通过<code>反射技术</code>（抽象工厂模式章节）来解决这个问题。</p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式7-代理模式</title>
    <link href="/2023/09/22/design-pattern/7.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/22/design-pattern/7.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。</p><h2 id="代理模式结构图"><a href="#代理模式结构图" class="headerlink" title="代理模式结构图"></a>代理模式结构图</h2><p><img src="https://s2.loli.net/2023/09/21/PAE9T4Ht7ku6MFY.jpg" alt="代理模式结构图.jpg"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><code>ISubject</code> 接口：定义了 <code>RealSubject</code> 和 <code>Proxy</code> 的共用接口，这样就可以在任何使用 <code>RealSubject</code> 的地方都可以使用 <code>Proxy</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISubject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RealSubject</code> 类：定义 <code>Proxy</code> 所代表的真实实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISubject</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;真实的请求。&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Proxy</code> 类：保存一个 <code>RealSubject</code> 的引用使得 <code>Proxy</code> 可以访问实体，并提供一个与 <code>RealSubject</code> 相同的方法，以替代实体执行方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISubject</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> RealSubject rs;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>(); <span class="hljs-comment">// 为什么不是传入参数rs?</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.rs.request();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="应用场合"><a href="#应用场合" class="headerlink" title="应用场合"></a>应用场合</h2><h3 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h3><p>为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。</p><p>例：WebService在Java中的应用。在项目中加入一个WebService，此时会在项目中生成一个wsdl文件和一些相关文件，其实它们就是代理，这就使得客户端程序调用代理就可以解决远程访问的问题。</p><h3 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h3><p>是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。</p><p>例：比如说你打开一个很大的HTML网页时，里面可能有很多的文字和图片，但你还是可以很快打开它，此时你所看到的是所有的文字，但图片却是一张一张地下载后才能看到。那些未打开的图片框，就是通过虚拟代理来替代了真实的图片，此时代理存储了真实图片的路径和尺寸。</p><h3 id="安全代理"><a href="#安全代理" class="headerlink" title="安全代理"></a>安全代理</h3><p>用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候。</p><h3 id="智能指引"><a href="#智能指引" class="headerlink" title="智能指引"></a>智能指引</h3><p>当调用真实的对象时，代理处理另外一些事。</p><p>例：计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它；或当第一次引用一个持久对象时，将它装入内存；或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。</p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合使用注意事项</title>
    <link href="/2023/09/20/Java/collection/Java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2023/09/20/Java/collection/Java%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="集合判空"><a href="#集合判空" class="headerlink" title="集合判空"></a>集合判空</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</strong></p></blockquote><p>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 O(1)。</p><p>绝大部分我们使用的集合的 <code>size()</code> 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 <code>java.util.concurrent</code> 包下的某些集合（<code>ConcurrentLinkedQueue</code>、<code>ConcurrentHashMap</code>…）。</p><p>下面是 <code>ConcurrentHashMap</code> 的 <code>size()</code> 方法和 <code>isEmpty()</code> 方法的源码。（时间复杂度都是O(1)啊）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sumCount();<br>    <span class="hljs-keyword">return</span> ((n &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0</span> :<br>            (n &gt; (<span class="hljs-type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :<br>            (<span class="hljs-type">int</span>)n);<br>&#125;<br><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sumCount</span><span class="hljs-params">()</span> &#123;<br>    CounterCell[] as = counterCells; CounterCell a;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> baseCount;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> sumCount() &lt;= <span class="hljs-number">0L</span>; <span class="hljs-comment">// ignore transient negative values</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="集合转-Map"><a href="#集合转-Map" class="headerlink" title="集合转 Map"></a>集合转 Map</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String phoneNumber;<br>     <span class="hljs-comment">// getters and setters</span><br>&#125;<br><br>List&lt;Person&gt; bookList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-string">&quot;18163138123&quot;</span>));<br>bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;martin&quot;</span>,<span class="hljs-literal">null</span>));<br><span class="hljs-comment">// 空指针异常</span><br>bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));<br></code></pre></td></tr></table></figure><h1 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</strong></p></blockquote><p>通过反编译你会发现 foreach 语法底层其实还是依赖 <code>Iterator</code> 。不过， <code>remove/add</code> 操作直接调用的是集合自己的方法，而不是 <code>Iterator</code> 的 <code>remove/add</code>方法。</p><p>这就导致 <code>Iterator</code> 莫名其妙地发现自己有元素被 <code>remove/add</code> ，然后，它就会抛出一个 <code>ConcurrentModificationException</code> 来提示用户发生了并发修改异常。这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p><blockquote><p><strong>fail-fast 机制</strong>：多个线程对 fail-fast 集合进行修改的时候，可能会抛出<code>ConcurrentModificationException</code>。 即使是单线程下也有可能会出现这种情况，上面已经提到过。</p></blockquote><p>Java8 开始，可以使用 <code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br>    list.add(i);<br>&#125;<br>list.removeIf(filter -&gt; filter % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">/* 删除list中的所有偶数 */</span><br>System.out.println(list); <span class="hljs-comment">/* [1, 3, 5, 7, 9] */</span><br></code></pre></td></tr></table></figure><p>除了上面介绍的直接使用 <code>Iterator</code> 进行遍历操作之外，还可以：</p><ul><li>使用<strong>普通的 for 循环</strong></li><li>使用 <strong>fail-safe 的集合类</strong>。<code>java.util</code>包下面的所有的集合类都是 fail-fast 的，而<code>java.util.concurrent</code>包下面的所有的类都是 fail-safe 的。</li></ul><h1 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>可以利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</strong></p></blockquote><p>以 <code>HashSet</code> 和 <code>ArrayList</code> 为例说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Set 去重代码示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="hljs-title function_">removeDuplicateBySet</span><span class="hljs-params">(List&lt;T&gt; data)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(data)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(data);<br>&#125;<br><br><span class="hljs-comment">// List 去重代码示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">removeDuplicateByList</span><span class="hljs-params">(List&lt;T&gt; data)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(data)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    &#125;<br>    List&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(data.size());<br>    <span class="hljs-keyword">for</span> (T current : data) &#123;<br>        <span class="hljs-keyword">if</span> (!result.contains(current)) &#123;<br>            result.add(current);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>两者的核心差别在于 <code>contains()</code> 方法的实现。</p><p><code>HashSet</code> 的 <code>contains()</code> 方法底部依赖的 <code>HashMap</code> 的 <code>containsKey()</code> 方法，时间复杂度接近<code>O(1)</code>（没有出现哈希冲突的时候为 <code>O(1)</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">return</span> map.containsKey(o);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们有 N 个元素插入进 Set 中，时间复杂度为 <code>O(n)</code>。</p><p><code>ArrayList</code> 的 <code>contains()</code> 方法是通过遍历所有元素的方法来做的，时间复杂度为 <code>O(n)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>List</code> 中有 N 个元素，时间复杂度为 <code>O (n^2)</code>。</p><h1 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。</strong></p></blockquote><p><code>toArray(T[] array)</code> 方法的参数是一个泛型数组，如果 <code>toArray</code> 方法中没有传递任何参数的话返回的是 <code>Object</code>类 型数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String [] s= <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<br>    <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;lazy&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;over&quot;</span>, <span class="hljs-string">&quot;jumps&quot;</span>, <span class="hljs-string">&quot;fox&quot;</span>, <span class="hljs-string">&quot;brown&quot;</span>, <span class="hljs-string">&quot;quick&quot;</span>, <span class="hljs-string">&quot;A&quot;</span><br>&#125;;<br>List&lt;String&gt; list = Arrays.asList(s);<br>Collections.reverse(list);<br><span class="hljs-comment">//没有指定类型的话会报错</span><br>s=list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p>由于 JVM 优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。</p><h1 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</strong></p></blockquote><p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个 <code>List</code> 集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] myArray = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>&#125;;<br>List&lt;String&gt; myList = Arrays.asList(myArray);<br><span class="hljs-comment">//上面两个语句等价于下面一条语句</span><br>List&lt;String&gt; myList = Arrays.asList(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>);<br></code></pre></td></tr></table></figure><p>JDK 源码对于这个方法的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，</span><br><span class="hljs-comment">  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">asList</span><span class="hljs-params">(T... a)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(a);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Array-asList-使用注意事项"><a href="#Array-asList-使用注意事项" class="headerlink" title="Array.asList()使用注意事项"></a><code>Array.asList()</code>使用注意事项</h2><p><strong>1、<code>Arrays.asList()</code>是泛型方法，传递的数组的类型必须是对象（如Integer），而不是基本类型（如int）。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] myArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> Arrays.asList(myArray);<br>System.out.println(myList.size());<span class="hljs-comment">//1</span><br>System.out.println(myList.get(<span class="hljs-number">0</span>));<span class="hljs-comment">//数组地址值</span><br>System.out.println(myList.get(<span class="hljs-number">1</span>));<span class="hljs-comment">//报错：ArrayIndexOutOfBoundsException</span><br><span class="hljs-type">int</span>[] array = (<span class="hljs-type">int</span>[]) myList.get(<span class="hljs-number">0</span>);<br>System.out.println(array[<span class="hljs-number">0</span>]);<span class="hljs-comment">//1</span><br><br><span class="hljs-comment">// 要使用包装类型数组</span><br>Integer[] myArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身。此时 <code>List</code> 的唯一元素就是这个数组。</p><p><strong>2、使用集合的修改方法: <code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>myList.add(<span class="hljs-number">4</span>);<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br>myList.remove(<span class="hljs-number">1</span>);<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br>myList.clear();<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br></code></pre></td></tr></table></figure><p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类 <code>java.util.Arrays$ArrayList</code> ,这个内部类并没有实现集合的修改方法（并没有重写这些方法）。</p><h2 id="如何正确的将数组转换为-ArrayList"><a href="#如何正确的将数组转换为-ArrayList" class="headerlink" title="如何正确的将数组转换为 ArrayList ?"></a><strong>如何正确的将数组转换为 <code>ArrayList</code> ?</strong></h2><p>使用 Java8 的 <code>Stream</code> (推荐)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer [] myArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());<br><span class="hljs-comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span><br><span class="hljs-type">int</span> [] myArray2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode15. 三数之和</title>
    <link href="/2023/09/20/algorithm/leetcode/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2023/09/20/algorithm/leetcode/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>CodeTop字节高频题。</p><p><a href="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><h1 id="考察知识点"><a href="#考察知识点" class="headerlink" title="考察知识点"></a>考察知识点</h1><ul><li>双指针</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>时间复杂度：<code>O(n^2)</code>，i从头到尾：<code>O(n)</code>，对每个i：j和k加起来<code>O(n)</code>。<ul><li>暴力：<code>O(n^3)</code></li></ul></li></ul><p>首先将数组排序（<code>O(nlogn)</code>）。使用双指针算法需要数组有序。</p><p>三个指针i, j, k，首先固定i，然后让j从i+1往后遍历。对于每个i, j：k从最后一个数往左移，直到找到最小的k，使得<code>nums[i] + nums[j] + nums[k] &gt;= 0</code>。此时若三数之和为0，加入res。</p><p>去重方法：判断<code>i</code>和<code>i-1</code>、<code>j</code>和<code>j-1</code>(还得j不为第一个数即<code>j != i + 1</code>)下标对应的值是否相同，相同则代表这种情况已经考虑过了，直接continue。</p><h3 id="自己写的非常不优雅的版本"><a href="#自己写的非常不优雅的版本" class="headerlink" title="自己写的非常不优雅的版本"></a>自己写的非常不优雅的版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 去除重复情况</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &lt; k; j ++) &#123;<br>                <span class="hljs-keyword">while</span> (nums[j - <span class="hljs-number">1</span>] == nums[j] &amp;&amp; i != j - <span class="hljs-number">1</span> &amp;&amp; j != k) j ++;<br>                <span class="hljs-keyword">while</span> (j &lt; k - <span class="hljs-number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>) k --; <span class="hljs-comment">// 获得当前i, j满足条件的k的最小坐标</span><br>                <span class="hljs-keyword">if</span> (j != k &amp;&amp; nums[i] + nums[j] + nums[k] == <span class="hljs-number">0</span>) res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="优雅版本"><a href="#优雅版本" class="headerlink" title="优雅版本"></a>优雅版本</h3><p><code>while (nums[j - 1] == nums[j] &amp;&amp; i != j - 1 &amp;&amp; j != k) j ++;</code> 这一步可以用<code>continue</code>语句代替，之后的<code>j != k</code>也不需要判断了（只要在循环里没跳出，就一定满足<code>j &lt; k</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 去除重复情况</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &lt; k; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j - <span class="hljs-number">1</span>] == nums[j]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 去除重复情况</span><br>                <span class="hljs-keyword">while</span> (j &lt; k - <span class="hljs-number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>) k --; <span class="hljs-comment">// 获得当前i, j满足条件的k的最小坐标</span><br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="hljs-number">0</span>) res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式6-装饰模式</title>
    <link href="/2023/09/20/design-pattern/6.%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/20/design-pattern/6.%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>需求：需要把所需的功能按正确的顺序串联起来进行控制</p><h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>装饰模式（Decorator），动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p><h2 id="装饰模式结构图"><a href="#装饰模式结构图" class="headerlink" title="装饰模式结构图"></a>装饰模式结构图</h2><p><img src="https://s2.loli.net/2023/09/20/YdCDAhkco9ETLF6.jpg" alt="装饰模式结构图.jpg"></p><ul><li><p>Component是定义一个对象接口，可以给这些对象动态地添加职责。</p></li><li><p>ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。</p></li><li><p>Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无须知道Decorator的存在的。</p></li><li><p>ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。</p></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Component类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ConcreteComponent类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;具体对象的实际操作&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Decorator类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>    <br>    <span class="hljs-keyword">protected</span> Component component;<br>    <br>    <span class="hljs-comment">// 装饰一个Component对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setComponent</span><span class="hljs-params">(Component component)</span> &#123;<br>        <span class="hljs-built_in">this</span>.component = component;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 重写operation()，实际调用component的operation方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (component != <span class="hljs-literal">null</span>) &#123;<br>            component.operation();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ConcreteDecorator类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConcreteDecoratorA类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreateDecoratorA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> String addedState;  <span class="hljs-comment">// 本类独有属性</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.operation();  <span class="hljs-comment">// 首先执行原有Component的operation()</span><br>        <br>        <span class="hljs-built_in">this</span>.addedState = <span class="hljs-string">&quot;具体装饰对象A的独有操作&quot;</span>;  <span class="hljs-comment">// 再执行本类独有功能</span><br>        System.out.println(<span class="hljs-built_in">this</span>.addedState);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ConcreteDecoratorB类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecoratorB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.operation();  <span class="hljs-comment">// 首先执行原有Component的operation()</span><br>        <span class="hljs-built_in">this</span>.addedBehavior(); <span class="hljs-comment">// 再执行本类独有功能</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addedBehavior</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;具体装饰对象B的独有操作&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ConcreteComponent</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteComponent</span>();<br><span class="hljs-type">ConcreteDecoratorA</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteDecoratorA</span>();<br><span class="hljs-type">ConcreteDecoratorB</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteDecoratorB</span>();<br><br>d1.setComponent(c); <span class="hljs-comment">// 首先用d1来包装c</span><br>d2.setComponent(d1); <span class="hljs-comment">// 再用d2来包装d1</span><br>d2.operation(); <span class="hljs-comment">// 最终执行d2的operation()</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/09/20/Gx6ynzCtlqogS5F.jpg" alt="装饰模式对象链.jpg"></p><p>装饰模式是利用<code>setComponent</code>来对对象进行包装的。<br>这样每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。</p><h2 id="例1：穿不同的服饰"><a href="#例1：穿不同的服饰" class="headerlink" title="例1：穿不同的服饰"></a>例1：穿不同的服饰</h2><p><img src="https://s2.loli.net/2023/09/20/U2GwI9iXWxH3mTJ.jpg" alt="装饰模式例子.jpg"></p><p><code>ICharacter</code>人物形象接口（<code>Component</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICharacter</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Person</code>类（<code>ConcreteComponent</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICharacter</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;装扮的&quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Finery</code>类（<code>Decorater</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Q: Finery不是一个实际存在的事物，为什么不设计成抽象类？</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">abstract</span><span class="hljs-params">(?)</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Finery</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICharacter</span> &#123;<br>    <br>    <span class="hljs-keyword">protected</span> ICharacter component;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decorate</span><span class="hljs-params">(ICharacter component)</span> &#123;<br>        <span class="hljs-built_in">this</span>.component = component;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.component != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.component.show();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体服饰类（<code>ConcreteDecorator</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tshirt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Finery</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;T恤&quot;</span>);<br>        <br>        <span class="hljs-built_in">super</span>.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他服饰同理。</p><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br><br><span class="hljs-type">Sneakers</span> <span class="hljs-variable">sneakers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sneakers</span>();<br>sneakers.decorate(p);<br><br><span class="hljs-type">Trousers</span> <span class="hljs-variable">trousers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trousers</span>();<br>trousers.decorate(sneakers);<br><br><span class="hljs-type">Tshirt</span> <span class="hljs-variable">tshirt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tshirt</span>();<br>tshirt.decorate(trousers);<br><br>tshirt.show(); <span class="hljs-comment">// 打印:&quot;T恤裤子运动鞋装扮的Alice&quot;</span><br></code></pre></td></tr></table></figure><h2 id="例2：升级商场收银程序"><a href="#例2：升级商场收银程序" class="headerlink" title="例2：升级商场收银程序"></a>例2：升级商场收银程序</h2><p>如果需要在打折基础上又返现，不需要添加新的<code>CashReturnRebate</code>子类，依然是<code>CashNormal </code>、<code>CashReturn</code>、<code>CashRebate</code>三种基本算法子类。增加一个接口<code>ISale</code>，用作装饰模式里的<code>Component</code>。</p><p><img src="https://s2.loli.net/2023/09/20/HthTDI9Zpz61acq.jpg" alt="装饰模式例子2.jpg"></p><p>装饰模式有一个重要的优点，把类中的装饰功能从类中搬移去除，这样可以简化原有的类。</p><p><code>CashNormal</code>是最基础的类，可以把它作为<code>ConcreteComponent</code>。</p><p><img src="https://s2.loli.net/2023/09/20/Oq4yoQVPExWRgeD.jpg" alt="装饰模式例子2-改进.jpg"></p><p><code>ISale </code>接口（<code>Component</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISale</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CashSuper</code> 实现 <code>ISale </code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">abstract</span><span class="hljs-params">(?)</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashSuper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISale</span> &#123;<br>    <br>    <span class="hljs-keyword">protected</span> ISale component;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decorate</span><span class="hljs-params">(ISale component)</span> &#123;<br>        <span class="hljs-built_in">this</span>.component = component;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.component != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 若装饰对象存在，则执行装饰的算法运算</span><br>            result = <span class="hljs-built_in">this</span>.component.acceptCash(price, num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CashNormal</code> 类（<code>ConcreteComponent</code>），最基本的原价算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashNormal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISale</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">return</span> price * num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打折和返现的算法都继承自 <code>CashSuper</code> ，都为 <code>ConcreteDecorator</code>。</p><p>从外层向里层依次执行 <code>acceptCash</code> 方法。先执行自己的<code>acceptCash</code>方法，再调用 <code>super(CashSuper).acceptCash()</code> ，会执行 <code>this.component</code> （里层的装饰器）的 <code>acceptCash</code> ，将计算结果 <code>result</code> 传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashRebate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CashSuper</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyRebate</span> <span class="hljs-operator">=</span> <span class="hljs-number">1d</span>; <span class="hljs-comment">// 折扣率</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashRebate</span><span class="hljs-params">(<span class="hljs-type">double</span> moneyRebate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.moneyRebate = moneyRebate;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> price * num * <span class="hljs-built_in">this</span>.moneyRebate;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.acceptCash(result, <span class="hljs-number">1</span>); <span class="hljs-comment">// result作为price传入，数量为1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashReturn</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CashSuper</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyCondition</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>; <span class="hljs-comment">// 返利条件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyReturn</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>; <span class="hljs-comment">// 返利值</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashReturn</span><span class="hljs-params">(<span class="hljs-type">double</span> moneyCondition, <span class="hljs-type">double</span> moneyReturn)</span> &#123;<br>        <span class="hljs-built_in">this</span>.moneyCondition = moneyCondition;<br>        <span class="hljs-built_in">this</span>.moneyReturn = moneyReturn;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> price * num;<br>        <span class="hljs-keyword">if</span> (moneyCondition &gt; <span class="hljs-number">0</span> &amp;&amp; result &gt;= moneyCondition) &#123;<br>            result -= Math.floor(result / moneyCondition) * moneyReturn;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.acceptCash(result, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点在 <code>CashContext</code> 类，因为涉及组合算法，所以用装饰模式的方式进行包装，这里需要注意包装的顺序，先打折后满多少返多少，与先满多少返多少，再打折会得到完全不同的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashContext</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> ISale cs;<br>    <br>    <span class="hljs-comment">// 在构造函数中传入type，根据type来实例化具体的收费策略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashContext</span><span class="hljs-params">(<span class="hljs-type">int</span> cashType)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (cashType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-built_in">this</span>.cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>();<br>                <span class="hljs-keyword">break</span>;<br>            ...<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                <span class="hljs-comment">// 先打8折，再满300返100</span><br>                <span class="hljs-type">CashNormal</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>();<br>                <span class="hljs-type">CashReturn</span> <span class="hljs-variable">crt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashReturn</span>(<span class="hljs-number">300d</span>, <span class="hljs-number">100d</span>);<br>                <span class="hljs-type">CashRebate</span> <span class="hljs-variable">crb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.8d</span>);<br>                <br>                crt.decorate(cn); <span class="hljs-comment">// 用 满300返100算法 包装原价算法</span><br>                crb.decorate(crt); <span class="hljs-comment">// 用 打8折算法 装饰 满300返100算法</span><br>                <span class="hljs-built_in">this</span>.cs = crb;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 根据收费策略的不同，获得计算结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.cs.acceptCash(price, num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在无论如何组合算法，哪怕是先打折再返现，再打折再返现，都只需要更改<code>CashContext</code>类，很好地做到了开放封闭。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>装饰模式是为已有功能<strong>动态地添加更多功能</strong>的一种方式。</p><h3 id="用装饰模式前"><a href="#用装饰模式前" class="headerlink" title="用装饰模式前"></a>用装饰模式前</h3><p>当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为（如：给Person添加新服饰）。</p><p><strong>问题</strong>：它们在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度。而这些新加入的东西仅仅是为了满足一些只在某种<strong>特定情况</strong>下才会执行的特殊行为的需要。</p><h3 id="用装饰模式后"><a href="#用装饰模式后" class="headerlink" title="用装饰模式后"></a>用装饰模式后</h3><p>它把每个要装饰的功能放在<strong>单独的类</strong>中，并让这个类<strong>包装</strong>它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。</p><p><strong>优点</strong>：</p><ul><li>把类中的装饰功能从类中搬移去除，这样可以简化原有的类（如：原价算法）。</li><li>有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑（如：无需重复编写 先打折后返现 &amp; 先返现后打折）。对于装饰模式来说，只是多几种组合而已。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>装饰顺序很重要。</strong></p><p>比如加密数据和过滤词汇都可以是数据持久化前的装饰功能，但若先加密了数据再用过滤功能就会出问题了。</p><p>最理想的情况，是保证装饰类之间彼此独立，这样它们就可以以任意的顺序进行组合了。</p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式0-OOP Basic</title>
    <link href="/2023/09/20/design-pattern/0.OOP_basic/"/>
    <url>/2023/09/20/design-pattern/0.OOP_basic/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程基础"><a href="#面向对象编程基础" class="headerlink" title="面向对象编程基础"></a>面向对象编程基础</h1><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h4 id="1-封装"><a href="#1-封装" class="headerlink" title="1. 封装"></a>1. 封装</h4><p>每个对象都包含<strong>它能进行操作所需要的所有信息</strong>，这个特性称为封装，因此对象不必依赖其他对象来完成自己的操作。</p><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><ul><li>良好的封装能够减少耦合（让某类和调用该类方法的其他类分离）</li><li>类内部的实现可以自由地修改（不影响其他的类）</li><li>类具有清晰的对外接口（其他类只需要关心这些接口，不用管内部实现）</li></ul><h4 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h4><p>继承定义了类如何<strong>相互关联，共享特性</strong>（is-a, not has-a）。继承的工作方式是，定义父类和子类，或叫作基类和派生类，其中子类继承父类的所有特性。子类不但继承了父类的所有特性，还可以定义新的特性。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>子类拥有父类非private的属性和功能</li><li>子类具有自己的属性和功能，即子类可以扩展父类没有的属性和功能</li><li>子类还可以以自己的方式实现父类的功能（方法重写）</li></ul><p>protected表示继承时子类可以对基类有完全访问权。</p><p>不用继承的话，如果要修改功能，就必须在<strong>所有重复的方法中修改</strong>（枚举类同理），代码越多，出错的可能就越大，而继承的优点是，继承使得所有子类公共的部分都放在了父类，使得代码得到了共享，这就避免了重复，另外，继承可使得修改或扩展继承而来的实现都较为容易。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>父类变，则子类不得不变</li><li>继承会破坏包装，父类实现细节暴露给子类，这其实是增大了两个类之间的耦合性（继承是一种类与类之间<strong>强耦合</strong>的关系）</li></ul><h4 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h4><p>多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行。</p><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul><li>子类以父类的身份出现</li><li>子类在工作时以<strong>自己的方式</strong>来实现（子类可以选择使用override关键字，将父类实现替换为它自己的实现，这就是方法重写Override）</li><li>子类以父类的身份出现时，子类<strong>特有的属性和方法不可以使用</strong></li></ul><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h4 id="抽象类-方法"><a href="#抽象类-方法" class="headerlink" title="抽象类&#x2F;方法"></a>抽象类&#x2F;方法</h4><p>考虑把实例化没有任何意义的父类改成抽象类；把方法体没有意义的方法改成抽象方法。</p><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><ul><li>抽象类不能被实例化（没有意义）</li><li>抽象方法是必须被子类重写的方法（重写之前肯定没有意义）</li><li>如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法</li></ul><h5 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h5><ul><li>应该考虑让抽象类拥有<strong>尽可能多的共同代码</strong>，拥有<strong>尽可能少的数据</strong></li></ul><h5 id="什么时候应该用抽象类？"><a href="#什么时候应该用抽象类？" class="headerlink" title="什么时候应该用抽象类？"></a>什么时候应该用抽象类？</h5><p>抽象类通常代表一个抽象概念，它提供一个<strong>继承的出发点</strong>，当设计一个新的抽象类时，一定是用来继承的。所以，在一个以继承关系形成的等级结构里面，<strong>树叶节点</strong>应当是<strong>具体类</strong>，而<strong>树枝节点</strong>均应当是<strong>抽象类</strong></p><img src="https://s2.loli.net/2023/09/13/VhwuR9FrsnI1SdE.jpg" alt="抽象类和具体类.jpg" style="zoom:40%;" /><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口是把隐式公共方法和属性组合起来，以封装特定功能的一个集合。一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。</p><p>声明接口在语法上与声明抽象类完全相同，但不允许提供接口中任何成员的执行方式。</p><p>实现接口的类就必须要实现接口中的所有方法和属性。</p><p>一个类可以支持多个接口，多个类也可以支持相同的接口。</p><p>接口中的方法或属性前面不能有修饰符、方法没有方法体。</p><h4 id="抽象类vs接口"><a href="#抽象类vs接口" class="headerlink" title="抽象类vs接口"></a>抽象类vs接口</h4><ol><li>抽象类可以给出一些成员的实现，接口却不包含成员的实现</li><li>抽象类的抽象成员可被子类<strong>部分实现</strong>，接口的成员需要实现类<strong>完全实现</strong></li><li>一个类只能继承<strong>一个抽象类</strong>，但可以实现<strong>多个接口</strong></li><li>类是对对象的抽象，<strong>抽象类</strong>是对<strong>类</strong>的抽象，接口是对<strong>行为</strong>的抽象</li><li>如果行为跨越<strong>不同类的对象</strong>，可使用接口；对于一些<strong>相似的类对象</strong>，用继承抽象类<ul><li>接口类似一个功能（如：飞行），实现某接口的不同类之间也许并没有什么关系；而继承抽象类的不同类之间一般关系紧密</li></ul></li><li>从设计角度讲，抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类；而接口是根本不知子类的存在，方法如何实现还不确认，预先定义</li></ol><h2 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h2><p>SOLID 原则是面向对象 class 设计的五条原则。它们是设计 class 结构时应该遵守的准则和最佳实践。</p><h4 id="1-Single-Responsibility-Principle，单一职责原则"><a href="#1-Single-Responsibility-Principle，单一职责原则" class="headerlink" title="1. Single Responsibility Principle，单一职责原则"></a>1. <strong>S</strong>ingle Responsibility Principle，单一职责原则</h4><p>一个 class 应该只做一件事，一个 class 应该只有一个变化的原因。</p><p>应该只有一个软件定义的潜在改变（数据库逻辑、日志逻辑等）能够影响 class 的定义。</p><p>单一职责适用于<strong>接口、类</strong>，同时也适用于<strong>方法</strong>。例如我们需要修改用户密码，有两种方式可以实现，一种是用「修改用户信息接口」实现修改密码，一种是新起一个接口来实现修改密码功能。在单一职责原则的指导下，一个方法只承担一个职能，所以我们应该新起一个接口来实现修改密码的功能。</p><p>在设计一个类的时候，可以先从粗粒度的类开始设计，等到业务发展到一定规模，我们发现这个粗粒度的类方法和属性太多，且经常修改的时候，我们就可以对这个类进行重构了，将这个类拆分成粒度更细的类，这就是所谓的持续重构。</p><h4 id="2-Open-Close-Principle，开闭原则"><a href="#2-Open-Close-Principle，开闭原则" class="headerlink" title="2. Open Close Principle，开闭原则"></a>2. <strong>O</strong>pen Close Principle，开闭原则</h4><p>一个软件实体，如类、模块和函数应该<strong>对扩展开放</strong>，<strong>对修改关闭</strong>。</p><p>当别人要修改软件功能的时候，使他不能修改我们原有代码，只能新增代码实现软件功能修改的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/*反例*/</span><br><span class="hljs-keyword">if</span>(type == apple)&#123;<br>    <span class="hljs-comment">//deal with apple </span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == banana)&#123;<br>    <span class="hljs-comment">//deal with banana</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == ......)&#123;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*正例*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PeelOff</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">peelOff</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplePeelOff</span> implement PeelOff&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">peelOff</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">//deal with apple</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BananaPeelOff</span> implement PeelOff&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">peelOff</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">//deal with banan</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PeelOffFactory</span>&#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String, PeelOff&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//init all the Class that implements PeelOff interface </span><br>   &#125;<br>&#125;<br><br>.....<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;apple&quot;</span>;<br>    <span class="hljs-type">PeelOff</span> <span class="hljs-variable">peelOff</span> <span class="hljs-operator">=</span> PeelOffFactory.getPeelOff(type);  <span class="hljs-comment">//get ApplePeelOff Class Instance.</span><br>    peelOff.pealOff();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-Liskov-Substitution-Principle，里氏替换原则"><a href="#3-Liskov-Substitution-Principle，里氏替换原则" class="headerlink" title="3. Liskov Substitution Principle，里氏替换原则"></a>3. <strong>L</strong>iskov Substitution Principle，里氏替换原则</h4><p>所有引用基类的地方必须能透明地使用其子类的对象。</p><p>所有父类能出现的地方，子类就可以出现，并且替换了也不会出现任何错误。对使用者来说，能够使用父类的地方，一定可以使用其子类，并且预期结果是一致的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Parent</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-type">Son</span> <span class="hljs-variable">son</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br></code></pre></td></tr></table></figure><p>父类的约定，不仅仅指的是语法层面上的约定，还包括实现上的约定。有时候父类会在类注释、方法注释里做了相关约定的说明，当你要覆写父类的方法时，需要弄懂这些约定，否则可能会出现问题。例如子类违背父类声明要实现的功能。比如父类某个排序方法是从小到大来排序，你子类的方法竟然写成了从大到小来排序。</p><h4 id="4-Interface-Segregation-Principle，接口隔离原则"><a href="#4-Interface-Segregation-Principle，接口隔离原则" class="headerlink" title="4. Interface Segregation Principle，接口隔离原则"></a>4. <strong>I</strong>nterface Segregation Principle，接口隔离原则</h4><p>类间的依赖关系应该建立在最小的接口上。简单地说：<strong>接口的内容一定要尽可能地小，能有多小就多小。</strong></p><p>很多客户端特定的接口优于一个多用途接口。客户端不应该强制实现他们不需要的函数。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>减少改动导致的变化风险</li><li>减少无用功能的理解成本</li></ul><h4 id="5-Dependency-Inversion-Principle，依赖倒置原则"><a href="#5-Dependency-Inversion-Principle，依赖倒置原则" class="headerlink" title="5. Dependency Inversion Principle，依赖倒置原则"></a>5. <strong>D</strong>ependency Inversion Principle，依赖倒置原则</h4><p>高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节，即接口或抽象类不依赖于实现类。细节应该依赖抽象，即实现类不应该依赖于接口或抽象类。<strong>简单地说，我们应该面向接口编程。通过抽象成接口，使各个类的实现彼此独立，实现类之间的松耦合。</strong></p><h4 id="各原则间的联系"><a href="#各原则间的联系" class="headerlink" title="各原则间的联系"></a>各原则间的联系</h4><ul><li>单一职责是所有设计原则的基础，开闭原则是设计的终极目标。</li><li>里氏替换原则强调的是子类替换父类后程序运行时的正确性，它用来帮助实现开闭原则。</li><li>而接口隔离原则用来帮助实现里氏替换原则，同时它也体现了单一职责。</li><li>依赖倒置原则是过程式编程与面向对象编程的分水岭，同时它也被用来指导接口隔离原则。</li></ul><p>依赖倒置原则告诉我们要面向接口编程。当我们面向接口编程之后，接口隔离原则和单一职责原则又告诉我们要注意职责的划分，不要什么东西都塞在一起。当我们职责捋得差不多的时候，里氏替换原则告诉我们在使用继承的时候，要注意遵守父类的约定。而上面说的这四个原则，它们的最终目标都是为了实现开闭原则。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li><a href="https://www.freecodecamp.org/chinese/news/solid-principles/">https://www.freecodecamp.org/chinese/news/solid-principles/</a></li><li><a href="https://zhuanlan.zhihu.com/p/350291336">https://zhuanlan.zhihu.com/p/350291336</a></li><li><a href="https://insights.thoughtworks.cn/understand-solid-principles/">https://insights.thoughtworks.cn/understand-solid-principles/</a></li></ol><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="1-识别应用中变化的方面，把它们和不变的方面分开。"><a href="#1-识别应用中变化的方面，把它们和不变的方面分开。" class="headerlink" title="1. 识别应用中变化的方面，把它们和不变的方面分开。"></a>1. 识别应用中变化的方面，把它们和不变的方面分开。</h3><p>如果每次有新需求，某方面的代码就要变，那么这个行为需要抽出来，与其他不变的代码分离。</p><p>把会变化的部分取出并封装，这样以后就可以修改或扩展这个部分，而不会影响其他不需要变化的部分。</p><h3 id="2-针对接口编程，而不是针对实现编程。"><a href="#2-针对接口编程，而不是针对实现编程。" class="headerlink" title="2. 针对接口编程，而不是针对实现编程。"></a>2. 针对接口编程，而不是针对实现编程。</h3><p>这里的接口指的是广义的超类型，包括接口和抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> getAnimal(); <span class="hljs-comment">// 抽象类</span><br>a.makeSound(); <span class="hljs-comment">// 抽象方法</span><br></code></pre></td></tr></table></figure><h3 id="3-优先使用组合而非继承。"><a href="#3-优先使用组合而非继承。" class="headerlink" title="3. 优先使用组合而非继承。"></a>3. 优先使用组合而非继承。</h3><p>例：策略模式</p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="https://s2.loli.net/2023/09/14/lLdVpOa35Z1YWDm.jpg" alt="UML类图图示样例.jpg"></p><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><h4 id="矩形框表示"><a href="#矩形框表示" class="headerlink" title="矩形框表示"></a>矩形框表示</h4><ul><li>第一层：类的名称<ul><li>抽象类用斜体显示</li></ul></li><li>第二层：类的特性（字段和属性）</li><li>第三层：类的操作（方法和行为）<ul><li>+表示public</li><li>-表示private</li><li>#表示protected</li></ul></li></ul><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><h4 id="矩形框表示-1"><a href="#矩形框表示-1" class="headerlink" title="矩形框表示"></a>矩形框表示</h4><p>顶端有&lt;&lt;interface&gt;&gt;显示</p><ul><li>第一层：接口名称</li><li>第二层：接口方法</li></ul><h4 id="棒棒糖表示"><a href="#棒棒糖表示" class="headerlink" title="棒棒糖表示"></a>棒棒糖表示</h4><p>如图中唐老鸭类实现“讲人话”接口</p><h3 id="类与类、类与接口的关系"><a href="#类与类、类与接口的关系" class="headerlink" title="类与类、类与接口的关系"></a>类与类、类与接口的关系</h3><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><ul><li>用<strong>空心三角形+实线</strong>表示</li></ul><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><ul><li>用<strong>空心三角形+虚线</strong>表示</li></ul><h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><ul><li>用<strong>实线箭头</strong>表示</li><li>表示一个类<em>知道</em>另一个类（如企鹅需要知道气候的变化）</li><li>可以有基数</li></ul><h4 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h4><ul><li>用<strong>空心菱形+实线箭头</strong>表示</li><li>表示一种弱的<em>拥有</em>关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分（如雁群拥有大雁）</li><li>可以有基数</li></ul><h4 id="合成关系"><a href="#合成关系" class="headerlink" title="合成关系"></a>合成关系</h4><ul><li><p>用<strong>实心菱形+实线箭头</strong>表示</p></li><li><p>表示一种强的<em>拥有</em>关系，体现了严格的部分和整体的关系（如鸟拥有翅膀）</p></li><li><p>部分和整体的生命周期一样</p></li><li><p>合成关系的连线两端还有一个数字’1’和数字’2’，这被称为基数</p></li></ul><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><ul><li>用<strong>虚线箭头</strong>表示</li><li>比如动物依赖氧气和水</li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式1-简单工厂模式</title>
    <link href="/2023/09/20/design-pattern/1.%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/20/design-pattern/1.%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="业务的封装"><a href="#业务的封装" class="headerlink" title="业务的封装"></a>业务的封装</h1><p>让业务逻辑与界面逻辑分开，让它们之间的耦合度下降。只有分离开，才可以达到容易维护或扩展，且可复用。</p><p>封装业务逻辑，开放特定外部接口，让界面逻辑使用。</p><p>封装业务逻辑前，与界面逻辑糅合在一起，不易维护：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    System.out.println(<span class="hljs-string">&quot;请输入数字A:&quot;</span>);<br>    <span class="hljs-type">double</span> <span class="hljs-variable">numberA</span> <span class="hljs-operator">=</span> Double.parseDouble(sc.nextLine());<br>    System.out.println(<span class="hljs-string">&quot;请选择运算符号:&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">strOperate</span> <span class="hljs-operator">=</span> sc.nextLine();<br>    System.out.println(<span class="hljs-string">&quot;请输入数字B:&quot;</span>);<br>    <span class="hljs-type">double</span> <span class="hljs-variable">numberB</span> <span class="hljs-operator">=</span> Double.parseDouble(sc.nextLine());<br>    <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>;<br>    <br>    <span class="hljs-keyword">switch</span> (strOperate) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>            result = numberA + numberB;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>            result = numberA - numberB;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>            result = numberA * numberB;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>            result = numberA / numberB;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <br>    System.out.println(<span class="hljs-string">&quot;result: &quot;</span> + result);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;wrong input: &quot;</span> + e.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>将业务逻辑（计算）封装在Operation类中，与界面逻辑（输出）分离：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Operation类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> numberA, <span class="hljs-type">double</span> numberB, String operate)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>;<br>        <span class="hljs-keyword">switch</span> (operate) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                result = numberA + numberB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                result = numberA - numberB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                result = numberA * numberB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                result = numberA / numberB;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    System.out.println(<span class="hljs-string">&quot;请输入数字A:&quot;</span>);<br>    <span class="hljs-type">double</span> <span class="hljs-variable">numberA</span> <span class="hljs-operator">=</span> Double.parseDouble(sc.nextLine());<br>    System.out.println(<span class="hljs-string">&quot;请选择运算符号:&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">strOperate</span> <span class="hljs-operator">=</span> sc.nextLine();<br>    System.out.println(<span class="hljs-string">&quot;请输入数字B:&quot;</span>);<br>    <span class="hljs-type">double</span> <span class="hljs-variable">numberB</span> <span class="hljs-operator">=</span> Double.parseDouble(sc.nextLine());<br>    <br>    <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Operation.getResult(numberA, numberB, strOperate);<br>    <br>    System.out.println(<span class="hljs-string">&quot;result: &quot;</span> + result);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;wrong input: &quot;</span> + e.toString());<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="紧耦合vs松耦合"><a href="#紧耦合vs松耦合" class="headerlink" title="紧耦合vs松耦合"></a>紧耦合vs松耦合</h1><p>按照上一节的写法，如果需要增加一个新的运算方式，加减乘除运算都会暴露。</p><p>可以将Operation类变为抽象类，各个运算方式继承这个类。这样新增运算方式只需要创建新类继承Operation不影响其他几个运算。</p><p>Operation类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> numberA, <span class="hljs-type">double</span> numberB)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0d</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>加减乘除类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Add</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> numberA, <span class="hljs-type">double</span> numberB)</span> &#123;<br>        <span class="hljs-keyword">return</span> numberA + numberB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> numberA, <span class="hljs-type">double</span> numberB)</span> &#123;<br>        <span class="hljs-keyword">return</span> numberA - numberB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mul</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> numberA, <span class="hljs-type">double</span> numberB)</span> &#123;<br>        <span class="hljs-keyword">return</span> numberA * numberB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Div</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> numberA, <span class="hljs-type">double</span> numberB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (numberB == <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;除数不能为0&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticException</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> numberA / numberB;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>解决<code>实例化哪个类的对象</code>的问题。</p><p>简单运算工厂类：根据用户输入的运算符号，决定返回哪一个运算子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperate</span><span class="hljs-params">(String operate)</span> &#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (operate) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Add</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mul</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Div</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> OperationFactory.createOperate(strOperate);<br><span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> oper.getResult(numberA, numberB);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/09/14/uDzxwSonvHCfRrj.jpg" alt="简单工厂类图.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合-Map</title>
    <link href="/2023/09/19/Java/collection/Java%E9%9B%86%E5%90%88-Map/"/>
    <url>/2023/09/19/Java/collection/Java%E9%9B%86%E5%90%88-Map/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h2><h3 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h3><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过<strong>拉链法</strong>解决冲突。</p><h4 id="扰动函数"><a href="#扰动函数" class="headerlink" title="扰动函数"></a><strong>扰动函数</strong></h4><p>指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法。换句话说使用扰动函数之后可以减少碰撞。</p><h5 id="JDK-1-8-HashMap-的-hash-方法源码"><a href="#JDK-1-8-HashMap-的-hash-方法源码" class="headerlink" title="JDK 1.8 HashMap 的 hash 方法源码:"></a><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></h5><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="对比一下-JDK1-7-的-HashMap-的-hash-方法源码"><a href="#对比一下-JDK1-7-的-HashMap-的-hash-方法源码" class="headerlink" title="对比一下 JDK1.7 的 HashMap 的 hash 方法源码:"></a>对比一下 JDK1.7 的 HashMap 的 hash 方法源码:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> &#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a><strong>拉链法</strong></h4><p>将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><h3 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h3><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><blockquote><p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="1、-putVal-方法中执行链表转红黑树的判断逻辑。"><a href="#1、-putVal-方法中执行链表转红黑树的判断逻辑。" class="headerlink" title="1、 putVal 方法中执行链表转红黑树的判断逻辑。"></a><strong>1、 <code>putVal</code> 方法中执行链表转红黑树的判断逻辑。</strong></h5><p>链表的长度大于 8 的时候，就执行 <code>treeifyBin</code> （转换红黑树）的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历链表</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>    <span class="hljs-comment">// 遍历到链表最后一个节点</span><br>    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）</span><br>        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>            <span class="hljs-comment">// 红黑树转换（并不会直接转换成红黑树）</span><br>            treeifyBin(tab, hash);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>        <span class="hljs-keyword">break</span>;<br>    p = e;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、treeifyBin-方法中判断是否真的转换为红黑树。"><a href="#2、treeifyBin-方法中判断是否真的转换为红黑树。" class="headerlink" title="2、treeifyBin 方法中判断是否真的转换为红黑树。"></a><strong>2、<code>treeifyBin</code> 方法中判断是否真的转换为红黑树。</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">// 判断当前数组的长度是否小于 64</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        <span class="hljs-comment">// 如果当前数组的长度小于 64，那么会选择先进行数组扩容</span><br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 否则才将列表转换为红黑树</span><br><br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>                hd = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)<br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树。</p><h2 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h2><ul><li><p><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p></li><li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p></li><li><p><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p></li><li><p><strong>初始容量大小和每次扩充容量大小的不同：</strong> </p><ul><li>创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li><li>创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 <strong>2 的幂次方</strong>大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li></ul></li><li><p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</p></li></ul><p><strong><code>HashMap</code> 中带有初始容量的构造函数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tableSizeFor</code>，保证了 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Returns a power of two size for the given target capacity.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span>;<br>       n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>       n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>       n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>       n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>       n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>       <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h2><p><code>HashSet</code> 底层是基于 <code>HashMap</code> 实现的。</p><table><thead><tr><th align="center"><code>HashMap</code></th><th align="center"><code>HashSet</code></th></tr></thead><tbody><tr><td align="center">实现了 <code>Map</code> 接口</td><td align="center">实现 <code>Set</code> 接口</td></tr><tr><td align="center">存储键值对</td><td align="center">仅存储对象</td></tr><tr><td align="center">调用 <code>put()</code>向 map 中添加元素</td><td align="center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr><tr><td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td><td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><h2 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h2><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p><img src="https://s2.loli.net/2023/09/19/BhjL4qe3pPAUDyu.png" alt="TreeMap继承关系图.png"></p><ul><li><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p></li><li><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p></li></ul><h2 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h2><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用<code>%</code>取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p><h2 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h2><p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在<strong>死循环</strong>问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p><p>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在<strong>数据覆盖</strong>的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h2><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong><ul><li><strong><code>ConcurrentHashMap</code></strong>:<ul><li>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li><li>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li></ul></li><li><strong><code>Hashtable</code>(同一把锁)</strong> :<ul><li>s使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul></li></ul></li></ul><h2 id="不同版本ConcurrentHashMap底层实现"><a href="#不同版本ConcurrentHashMap底层实现" class="headerlink" title="不同版本ConcurrentHashMap底层实现"></a>不同版本ConcurrentHashMap底层实现</h2><h3 id="JDK1-7-的-ConcurrentHashMap"><a href="#JDK1-7-的-ConcurrentHashMap" class="headerlink" title="JDK1.7 的 ConcurrentHashMap"></a><strong>JDK1.7 的 ConcurrentHashMap</strong></h3><p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</p><p><code>Segment</code> 数组中的每个元素包含一个 <code>HashEntry</code> 数组， <code>HashEntry</code> 数组中的元素是链表结构。</p><p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p><p><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p><h3 id="JDK1-8-的-ConcurrentHashMap"><a href="#JDK1-8-的-ConcurrentHashMap" class="headerlink" title="JDK1.8 的 ConcurrentHashMap"></a><strong>JDK1.8 的 ConcurrentHashMap</strong></h3><p>JDK1.8 的 <code>ConcurrentHashMap</code> 不再是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 **<code>TreeNode</code>**。当冲突链表达到一定长度时，链表会转换成红黑树。</p><p><code>TreeNode</code>是存储红黑树节点，被<code>TreeBin</code>包装。<code>TreeBin</code>通过<code>root</code>属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 <code>ConcurrentHashMap</code> 中<code>TreeBin</code>通过<code>waiter</code>属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>        TreeNode&lt;K,V&gt; root;<br>        <span class="hljs-keyword">volatile</span> TreeNode&lt;K,V&gt; first;<br>        <span class="hljs-keyword">volatile</span> Thread waiter;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> lockState;<br>        <span class="hljs-comment">// values for lockState</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WRITER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// set while holding write lock</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WAITER</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// set when waiting for write lock</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">READER</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// increment value for setting read lock</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p><p>Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p><h3 id="总结：JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？"><a href="#总结：JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？" class="headerlink" title="总结：JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"></a>总结：JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h3><ul><li><p><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p></li><li><p><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p></li><li><p><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p></li></ul><h2 id="ConcurrentHashMap-为什么-key-和-value-不能为-null？"><a href="#ConcurrentHashMap-为什么-key-和-value-不能为-null？" class="headerlink" title="ConcurrentHashMap 为什么 key 和 value 不能为 null？"></a>ConcurrentHashMap 为什么 key 和 value 不能为 null？</h2><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 <code>ConcurrentHashMap</code> 中，还是根本没有这个键。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 <code>ConcurrentHashMap</code> 中的，还是因为找不到对应的键而返回的。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>这也就是二义性的由来。</p><p>多线程环境下，存在一个线程操作该 <code>ConcurrentHashMap</code> 时，其他的线程将该 <code>ConcurrentHashMap</code> 修改的情况，所以无法通过 <code>containsKey(key)</code> 来判断否存在这个键值对，也就没办法解决二义性问题了。</p><p>与此形成对比的是，<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 <code>HashMap</code> 修改的情况，所以可以通过 <code>contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p><p>也就是说，多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。</p><p>如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">NULL</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-能保证复合操作的原子性吗？"><a href="#ConcurrentHashMap-能保证复合操作的原子性吗？" class="headerlink" title="ConcurrentHashMap 能保证复合操作的原子性吗？"></a>ConcurrentHashMap 能保证复合操作的原子性吗？</h2><p>不能。</p><p><code>ConcurrentHashMap</code> 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的。</p><p>复合操作是指由多个基本操作(如<code>put</code>、<code>get</code>、<code>remove</code>、<code>containsKey</code>等)组成的操作，例如先判断某个键是否存在<code>containsKey(key)</code>，然后根据结果进行插入或更新<code>put(key, value)</code>。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。</p><p>例如，有两个线程 A 和 B 同时对 <code>ConcurrentHashMap</code> 进行复合操作，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A</span><br><span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>map.put(key, value);<br>&#125;<br><span class="hljs-comment">// 线程 B</span><br><span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>map.put(key, anotherValue);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果线程 A 和 B 的执行顺序是这样：</p><ol><li>线程 A 判断 map 中不存在 key</li><li>线程 B 判断 map 中不存在 key</li><li>线程 B 将 (key, anotherValue) 插入 map</li><li>线程 A 将 (key, value) 插入 map</li></ol><p>那么最终的结果是 (key, value)，而不是预期的 (key, anotherValue)。这就是复合操作的非原子性导致的问题。</p><h3 id="那如何保证-ConcurrentHashMap-复合操作的原子性呢？"><a href="#那如何保证-ConcurrentHashMap-复合操作的原子性呢？" class="headerlink" title="那如何保证 ConcurrentHashMap 复合操作的原子性呢？"></a><strong>那如何保证 <code>ConcurrentHashMap</code> 复合操作的原子性呢？</strong></h3><p><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。</p><p>上面的代码可以改写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A</span><br>map.putIfAbsent(key, value);<br><span class="hljs-comment">// 线程 B</span><br>map.putIfAbsent(key, anotherValue);<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A</span><br>map.computeIfAbsent(key, k -&gt; value);<br><span class="hljs-comment">// 线程 B</span><br>map.computeIfAbsent(key, k -&gt; anotherValue);<br></code></pre></td></tr></table></figure><p>很多同学可能会说了，这种情况也能加锁同步呀！确实可以，但不建议使用加锁的同步机制，违背了使用 <code>ConcurrentHashMap</code> 的初衷。在使用 <code>ConcurrentHashMap</code> 的时候，尽量使用这些原子性的复合操作方法来保证原子性。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合-Set</title>
    <link href="/2023/09/19/Java/collection/Java%E9%9B%86%E5%90%88-Set/"/>
    <url>/2023/09/19/Java/collection/Java%E9%9B%86%E5%90%88-Set/</url>
    
    <content type="html"><![CDATA[<h2 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul><li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都<strong>不是线程安全的</strong>。</p></li><li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。</p><ul><li><code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。</li><li><code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li><li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li></ul></li><li><p>底层数据结构不同又导致这三者的应用场景不同。</p><ul><li><code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景。</li><li><code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景。</li><li><code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul></li></ul><h2 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h2><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p><ul><li><code>Comparable</code> 接口出自<code>java.lang</code>包，它有一个 <code>compareTo(Object obj)</code>方法用来排序（拿自己和其他对象比较）</li><li><code>Comparator</code>接口出自 <code>java.util</code> 包，它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序（传入两个对象比较）</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要<strong>重写<code>compareTo()</code>方法或<code>compare()</code>方法</strong>。</p><ul><li>当我们需要对某一个集合实现两种排序方式，比如一个 <code>song</code> 对象中的歌名和歌手名分别采用一种排序方法的话：<ul><li>我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法来实现歌名排序和歌星名排序</li><li>或者以两个 <code>Comparator</code> 来实现歌名排序和歌星名排序，我们只能使用两个参数版的 <code>Collections.sort(collection, comparator)</code>.</li></ul></li></ul><h2 id="无序性和不可重复性的含义"><a href="#无序性和不可重复性的含义" class="headerlink" title="无序性和不可重复性的含义"></a>无序性和不可重复性的含义</h2><ul><li><p>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p></li><li><p>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</p></li></ul><h2 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复?"></a>HashSet 如何检查重复?</h2><p>先检查<code>hashcode</code>，如果有重复的再调用<code>equals()</code>。</p><blockquote><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p></blockquote><p>在 JDK1.8 中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。直接看一下<code>HashSet</code>中的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Returns: true if this set did not already contain the specified element</span><br><span class="hljs-comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而在<code>HashMap</code>的<code>putVal()</code>方法中也能看到如下说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Returns : previous value, or null if none</span><br><span class="hljs-comment">// 返回值：如果插入位置没有元素返回null，否则返回上一个元素</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，在 JDK1.8 中，实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式5-依赖倒转原则</title>
    <link href="/2023/09/19/design-pattern/5.%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/"/>
    <url>/2023/09/19/design-pattern/5.%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h1><p>SOLID原则中的D: <strong>D</strong>ependency Inversion Principle</p><h2 id="准确解释"><a href="#准确解释" class="headerlink" title="准确解释"></a>准确解释</h2><ul><li>高层模块不应该依赖低层模块。两个都应该依赖抽象。<ul><li>解释：<ul><li>面向过程的开发时，为了使得常用代码可以复用，一般都会把这些常用代码写成许许多多函数的程序库，这样我们在做新项目时，去调用这些低层的函数就可以了。比如我们做的项目大多要访问数据库，所以我们就把访问数据库的代码写成了函数，每次做新项目时就去调用这些函数。这也就叫作高层模块依赖低层模块。</li><li>而如果不管高层模块还是低层模块，它们都依赖于抽象，具体一点就是接口或抽象类，只要接口是稳定的，那么任何一个更改都不用担心其他受到影响，这就使得无论高层模块还是低层模块都可以很容易地被复用。</li></ul></li></ul></li><li>抽象不应该依赖细节，细节应该依赖于抽象，即：要针对接口编程，不要对实现编程。<ul><li>例：主板、CPU、内存、硬盘都是针对接口设计的，如果针对实现来设计，内存就要对应到具体的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即<strong>程序中所有的依赖关系都是终止于抽象类或者接口</strong>，那就是面向对象的设计，反之那就是过程化的设计了。</p><h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h1><p>SOLID原则中的L: <strong>L</strong>iskov Substitution Principle</p><h2 id="准确解释-1"><a href="#准确解释-1" class="headerlink" title="准确解释"></a>准确解释</h2><p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。</p><p>正因为有了这个原则，使得继承复用成为可能，只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。</p><h2 id="与其他原则的关系"><a href="#与其他原则的关系" class="headerlink" title="与其他原则的关系"></a>与其他原则的关系</h2><p><strong>有里氏代换原则，才使得开放-封闭成为可能。</strong></p><p>正是由于<strong>子类型的可替换性</strong>才使得使用父类类型的模块在无须修改的情况下就可以扩展。</p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode215. 数组中的第K个最大元素</title>
    <link href="/2023/09/19/algorithm/leetcode/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <url>/2023/09/19/algorithm/leetcode/215.%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>CodeTop字节高频题。</p><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">https://leetcode.cn/problems/kth-largest-element-in-an-array/description/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,5,6,4], k = 2</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">3,2,3,1</span>,<span class="hljs-number">2,4,5,5</span>,<span class="hljs-number">6</span>], k = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h1 id="考察知识点"><a href="#考察知识点" class="headerlink" title="考察知识点"></a>考察知识点</h1><ul><li>快速选择算法</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>套快排模板，区别是只需要递归左区间&#x2F;右区间，时间复杂度为<code>O(n)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_select</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> nums[l];<br>        <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = nums[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i ++; <span class="hljs-keyword">while</span> (nums[i] &gt; x);<br>            <span class="hljs-keyword">do</span> j --; <span class="hljs-keyword">while</span> (nums[j] &lt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-type">int</span> cnt_l = j - l + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k &lt;= cnt_l) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_select</span>(nums, l, j, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_select</span>(nums, j + <span class="hljs-number">1</span>, r, k - cnt_l);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_select</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合-Queue</title>
    <link href="/2023/09/18/Java/collection/Java%E9%9B%86%E5%90%88-Queue/"/>
    <url>/2023/09/18/Java/collection/Java%E9%9B%86%E5%90%88-Queue/</url>
    
    <content type="html"><![CDATA[<h1 id="Queue-和-Deque-的区别"><a href="#Queue-和-Deque-的区别" class="headerlink" title="Queue 和 Deque 的区别"></a>Queue 和 Deque 的区别</h1><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: </p><ul><li>一种在操作失败后会抛出异常（如add）</li><li>另一种则会返回特殊值（如offer）</li></ul><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p><h1 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h1><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能。</p><p>区别：</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li>关于插入性能<ul><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。</li><li>虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul></li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。</p><p>此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是<strong>优先级最高的元素先出队</strong>。（二叉堆是优先队列的一种实现方式。最小堆即元素越小，优先级最高）</p><p>这里列举其相关的一些要点：</p><ul><li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><p><code>BlockingQueue</code> （阻塞队列）是一个接口，继承自 <code>Queue</code>。</p><p><code>BlockingQueue</code>支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p><h2 id="BlockingQueue-的实现类有哪些？"><a href="#BlockingQueue-的实现类有哪些？" class="headerlink" title="BlockingQueue 的实现类有哪些？"></a>BlockingQueue 的实现类有哪些？</h2><p><img src="https://s2.loli.net/2023/09/18/WRSBpaoAXiZzkq4.png" alt="BlockingQueue 的实现类.png"></p><p>Java 中常用的阻塞队列实现类有以下几种：</p><ol><li><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</li><li><code>LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为<code>Integer.MAX_VALUE</code>。和<code>ArrayBlockingQueue</code>类似， 它也支持公平和非公平的锁访问机制。</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</li><li><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</li><li><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li><li>……</li></ol><p>日常开发中，这些队列使用的其实都不多，了解即可。</p><h2 id="ArrayBlockingQueue-和-LinkedBlockingQueue-有什么区别？"><a href="#ArrayBlockingQueue-和-LinkedBlockingQueue-有什么区别？" class="headerlink" title="ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？"></a>ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？</h2><p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 是 Java 并发包中常用的两种阻塞队列实现，它们都是线程安全的。不过，不过它们之间也存在下面这些区别：</p><ul><li>底层实现：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>LinkedBlockingQueue</code> 基于链表实现。</li><li>是否有界：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code>Integer.MAX_VALUE</code>，也就是无界的。但也可以指定队列大小，从而成为有界的。</li><li>锁是否分离： <code>ArrayBlockingQueue</code>中的锁是没有分离的，即生产和消费用的是同一个锁；<code>LinkedBlockingQueue</code>中的锁是分离的，即生产用的是<code>putLock</code>，消费是<code>takeLock</code>，这样可以防止生产者和消费者线程之间的锁争夺。</li><li>内存占用：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。这意味着，<code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而<code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合概览</title>
    <link href="/2023/09/18/Java/collection/Java%E9%9B%86%E5%90%88%E6%A6%82%E8%A7%88/"/>
    <url>/2023/09/18/Java/collection/Java%E9%9B%86%E5%90%88%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/18/NSXU8CnfhvgZopd.png" alt="Java集合框架.png"></p><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：</p><ul><li><code>Collection</code>接口，主要用于存放单一元素</li><li><code>List</code>接口(对付顺序的好帮手): 存储的元素是有序的、可重复的。<ul><li><code>ArrayList</code>：<code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul></li><li><code>Set</code>接口(注重独一无二的性质): 存储的元素不可重复的。<ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul></li><li><code>Queue</code>接口(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。<ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li><li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul></li><li><code>Map</code> 接口(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li><li><code>HashMap</code>：JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）</li></ul><h2 id="如何选用集合？"><a href="#如何选用集合？" class="headerlink" title="如何选用集合？"></a>如何选用集合？</h2><p>根据集合的特点来选择合适的集合。比如：</p><ul><li>我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</li><li>我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</li></ul><h2 id="为什么要选用集合？"><a href="#为什么要选用集合？" class="headerlink" title="为什么要选用集合？"></a>为什么要选用集合？</h2><p>相较于数组，Java 集合的优势在于它们的<strong>大小可变、支持泛型、具有内建算法</strong>等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合-List</title>
    <link href="/2023/09/18/Java/collection/Java%E9%9B%86%E5%90%88-List/"/>
    <url>/2023/09/18/Java/collection/Java%E9%9B%86%E5%90%88-List/</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="ArrayList-和-Array（数组）的区别？"><a href="#ArrayList-和-Array（数组）的区别？" class="headerlink" title="ArrayList 和 Array（数组）的区别？"></a>ArrayList 和 Array（数组）的区别？</h2><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><h3 id="使用对比"><a href="#使用对比" class="headerlink" title="使用对比"></a>使用对比</h3><p><code>Array</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化一个 String 类型的数组</span><br>String[] stringArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>&#125;;<br><span class="hljs-comment">// 修改数组元素的值</span><br>stringArr[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;goodbye&quot;</span>;<br>System.out.println(Arrays.toString(stringArr));<span class="hljs-comment">// [goodbye, world, !]</span><br><span class="hljs-comment">// 删除数组中的元素，需要手动移动后面的元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stringArr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    stringArr[i] = stringArr[i + <span class="hljs-number">1</span>];<br>&#125;<br>stringArr[stringArr.length - <span class="hljs-number">1</span>] = <span class="hljs-literal">null</span>;<br>System.out.println(Arrays.toString(stringArr));<span class="hljs-comment">// [world, !, null]</span><br></code></pre></td></tr></table></figure><p><code>ArrayList</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化一个 String 类型的 ArrayList</span><br> ArrayList&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// 添加元素到 ArrayList 中</span><br> stringList.add(<span class="hljs-string">&quot;goodbye&quot;</span>);<br> System.out.println(stringList);<span class="hljs-comment">// [hello, world, !, goodbye]</span><br> <span class="hljs-comment">// 修改 ArrayList 中的元素</span><br> stringList.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hi&quot;</span>);<br> System.out.println(stringList);<span class="hljs-comment">// [hi, world, !, goodbye]</span><br> <span class="hljs-comment">// 删除 ArrayList 中的元素</span><br> stringList.remove(<span class="hljs-number">0</span>);<br> System.out.println(stringList); <span class="hljs-comment">// [world, !, goodbye]</span><br></code></pre></td></tr></table></figure><h2 id="ArrayList-插入和删除元素的时间复杂度？"><a href="#ArrayList-插入和删除元素的时间复杂度？" class="headerlink" title="ArrayList 插入和删除元素的时间复杂度？"></a>ArrayList 插入和删除元素的时间复杂度？</h2><p>对于插入：</p><ul><li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li></ul><p>对于删除：</p><ul><li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li><li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li></ul><h1 id="Vector-Stack"><a href="#Vector-Stack" class="headerlink" title="Vector &amp; Stack"></a>Vector &amp; Stack</h1><h2 id="ArrayList-和-Vector-的区别-（了解即可）"><a href="#ArrayList-和-Vector-的区别-（了解即可）" class="headerlink" title="ArrayList 和 Vector 的区别?（了解即可）"></a>ArrayList 和 Vector 的区别?（了解即可）</h2><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 。</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全。</li></ul><h2 id="Vector-和-Stack-的区别-（了解即可）"><a href="#Vector-和-Stack-的区别-（了解即可）" class="headerlink" title="Vector 和 Stack 的区别?（了解即可）"></a>Vector 和 Stack 的区别?（了解即可）</h2><ul><li><code>Vector</code> 和 <code>Stack</code> 两者都是线程安全的，都是使用 <code>synchronized</code> 关键字进行同步处理。</li><li><code>Stack</code> 继承自 <code>Vector</code>，是一个后进先出的栈，而 <code>Vector</code> 是一个列表。</li></ul><p>随着 Java 并发编程的发展，<code>Vector</code> 和 <code>Stack</code> 已经被淘汰，推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</p><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><h2 id="LinkedList-插入和删除元素的时间复杂度？"><a href="#LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="LinkedList 插入和删除元素的时间复杂度？"></a>LinkedList 插入和删除元素的时间复杂度？</h2><ul><li><p>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</p></li><li><p>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</p></li><li><p>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</p></li></ul><h2 id="LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="LinkedList 为什么不能实现 RandomAccess 接口？"></a>LinkedList 为什么不能实现 RandomAccess 接口？</h2><p><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口。</p><p><code>ArrayList</code>可以。</p><h3 id="补充：RandomAccess接口"><a href="#补充：RandomAccess接口" class="headerlink" title="补充：RandomAccess接口"></a>补充：RandomAccess接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RandomAccess</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RandomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt;<br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(List&lt;? extends Comparable&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; list, T key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (list <span class="hljs-keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)<br>        <span class="hljs-keyword">return</span> Collections.indexedBinarySearch(list, key);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> Collections.iteratorBinarySearch(list, key);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。</p><p> <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的。</p><h2 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h2><ul><li><p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p></li><li><p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p></li><li><p><strong>插入和删除是否受元素位置的影响：</strong></p><ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。</li></ul></li><li><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p></li><li><p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ul><p>我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！就连 <code>LinkedList</code> 的作者约书亚 · 布洛克（Joshua Bloch）自己都说从来不会使用 <code>LinkedList</code> 。</p><p>不要下意识地认为 <code>LinkedList</code> 作为链表就最适合元素增删的场景。<code>LinkedList</code> 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式4-开放封闭原则</title>
    <link href="/2023/09/18/design-pattern/4.%E5%BC%80%E6%94%BE-%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    <url>/2023/09/18/design-pattern/4.%E5%BC%80%E6%94%BE-%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>SOLID原则中的O: <strong>O</strong>pen-Close Principle</p><h1 id="准确解释"><a href="#准确解释" class="headerlink" title="准确解释"></a>准确解释</h1><p>开放-封闭原则，是说软件实体（类、模块、函数等）应该可以扩展，但是不可修改。</p><h2 id="两个特征"><a href="#两个特征" class="headerlink" title="两个特征"></a>两个特征</h2><ul><li>Open for extension 对扩展开放</li><li>Close for modification 对修改封闭</li></ul><h2 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h2><p>面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本，而不会把整个程序推倒重来。</p><p>设计的时候，时刻要考虑，尽量让这个类足够好，写好了就不要去修改了，如果新需求来，我们增加一些类就完事了，原来的代码能不动则不动。</p><p>绝对的对修改关闭是不可能的。无论模块是多么的’封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块<strong>应该对哪种变化封闭</strong>做出选择。他必须先猜测出最有可能发生的变化种类，然后<strong>构造抽象</strong>来隔离那些变化。</p><p>我们是很难预先猜测，但我们却可以在发生小变化时，就及早去想办法应对发生更大变化的可能。也就是说，<strong>等到变化发生时立即采取行动</strong>。在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>简单工厂模式中的计算器。</p><ol><li>首先加法程序写在client类中。</li><li>然后增加减法功能，发现需要修改原来类，违背OCP -&gt; 考虑重构程序，增加抽象的运算类 -&gt; 能够满足需求，并能应对变化</li><li>增加乘除法功能，无需修改client类，只需增加乘法和除法的子类。</li></ol><p>面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。</p><p>我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。（如：加减运算在很多地方应用了，再考虑抽象、考虑分离，就很困难）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是<strong>可维护、可扩展、可复用、灵活性好</strong>。</p><p>开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。<strong>拒绝不成熟的抽象和抽象本身一样重要</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis常用标签</title>
    <link href="/2023/09/16/backend/MyBatis/MyBatis%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
    <url>/2023/09/16/backend/MyBatis/MyBatis%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="顶级元素"><a href="#顶级元素" class="headerlink" title="顶级元素"></a>顶级元素</h1><p><strong>文档</strong>：<a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html">https://mybatis.org/mybatis-3/zh/sqlmap-xml.html</a></p><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li>cache：该命名空间的缓存配置</li><li>cache-ref：引用其它命名空间的缓存配置</li><li>resultMap：描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素</li><li><del>parameterMap：老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。</del></li><li>sql：可被其它语句引用的可重用语句块</li><li>insert：映射插入语句</li><li>update：映射更新语句</li><li>delete：映射删除语句</li><li>select：映射查询语句</li></ul><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>查询语句是 MyBatis 中最常用的元素之一，光能把数据存到数据库中价值并不大，还要能重新取出来才有用，多数应用也都是查询比修改要频繁。</p><p> MyBatis 的基本原则之一是： 在每个插入、更新或删除操作之间，通常会执行多个查询操作。因此，MyBatis 在查询和结果映射做了相当多的改进。select 元素允许你配置很多属性来配置每条语句的行为细节。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;hashmap&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;personResultMap&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;10&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">fetchSize</span>=<span class="hljs-string">&quot;256&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">resultSetType</span>=<span class="hljs-string">&quot;FORWARD_ONLY&quot;</span>&gt;</span>  <br>  //此处是你的sql语句 例如：<br>  select * from t_user where id = #&#123;id&#125;  <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 与java对象对应的列不是数据库中表的列名，而是查询后结果集的列名</p><h2 id="insert-update-和-delete"><a href="#insert-update-和-delete" class="headerlink" title="insert, update 和 delete"></a>insert, update 和 delete</h2><p>数据变更语句 insert，update 和 delete 的实现非常接近：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAuthor&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;domain.blog.Author&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateAuthor&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;domain.blog.Author&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteAuthor&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;domain.blog.Author&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 带条件的删除语句，不要对表使用别名，否则会报错</p><h3 id="insert，update-和-delete-语句的示例"><a href="#insert，update-和-delete-语句的示例" class="headerlink" title="insert，update 和 delete 语句的示例"></a>insert，update 和 delete 语句的示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAuthor&quot;</span>&gt;</span><br>  insert into Author (id,username,password,email,bio)<br>  values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateAuthor&quot;</span>&gt;</span><br>  update Author set<br>    username = #&#123;username&#125;,<br>    password = #&#123;password&#125;,<br>    email = #&#123;email&#125;,<br>    bio = #&#123;bio&#125;<br>  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteAuthor&quot;</span>&gt;</span><br>  delete from Author where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="insert语句额外的属性和子元素"><a href="#insert语句额外的属性和子元素" class="headerlink" title="insert语句额外的属性和子元素"></a>insert语句额外的属性和子元素</h3><p>如前所述，插入语句的配置规则更加丰富，在插入语句里面有一些额外的属性和子元素用来处理主键的生成，并且提供了多种生成方式。</p><h4 id="自动生成主键"><a href="#自动生成主键" class="headerlink" title="自动生成主键"></a>自动生成主键</h4><p>首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 <code>useGeneratedKeys=”true”</code>，然后再把 <code>keyProperty</code> 设置为目标属性就 OK 了。例如，如果上面的 Author 表已经在 id 列上使用了自动生成，那么语句可以修改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAuthor&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>  insert into Author (username,password,email,bio)<br>  values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="多行插入"><a href="#多行插入" class="headerlink" title="多行插入"></a>多行插入</h4><p>如果你的数据库还支持多行插入, 你也可以传入一个 <code>Author</code> 数组或集合，并返回自动生成的主键。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAuthor&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>  insert into Author (username, password, email, bio) values<br>  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>    (#&#123;item.username&#125;, #&#123;item.password&#125;, #&#123;item.email&#125;, #&#123;item.bio&#125;)<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="另外一种方法来生成主键"><a href="#另外一种方法来生成主键" class="headerlink" title="另外一种方法来生成主键"></a>另外一种方法来生成主键</h4><p>对于不支持自动生成主键列的数据库和可能不支持自动生成主键的 JDBC 驱动，MyBatis 有另外一种方法来生成主键。</p><p>这里有一个简单（也很傻）的示例，它可以生成一个随机 ID（不建议实际使用，这里只是为了展示 MyBatis 处理问题的灵活性和宽容度）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAuthor&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span>&gt;</span><br>    select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.SYSDUMMY1<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>  insert into Author<br>    (id, username, password, email, bio, favourite_section)<br>  values<br>    (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;, #&#123;bio&#125;, #&#123;favouriteSection,jdbcType=VARCHAR&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，首先会运行 selectKey 元素中的语句，并设置 Author 的 id，然后才会调用插入语句。这样就实现了数据库自动生成主键类似的行为，同时保持了 Java 代码的简洁。</p><p>selectKey 元素描述如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span></span><br><span class="hljs-tag">  <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>As an irregular case, some databases allow INSERT, UPDATE or DELETE statement to return result set (e.g. <code>RETURNING</code> clause of <em>PostgreSQL</em> and <em>MariaDB</em> or <code>OUTPUT</code> clause of MS SQL Server). This type of statement must be written as <code>&lt;select&gt;</code> to map the returned data.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAndGetAuthor&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;domain.blog.Author&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">affectData</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>  insert into Author (username, password, email, bio)<br>  values (#&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;, #&#123;bio&#125;)<br>  returning id, username, password, email, bio<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><p>这个元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 <code>include</code> 元素中定义不同的参数值。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userColumns&quot;</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个 SQL 片段可以在其它语句中使用，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsers&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>  select<br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;userColumns&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;alias&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;t1&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>,<br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;userColumns&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;alias&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;t2&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>  from some_table t1<br>    cross join some_table t2<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以在 <code>include</code> 元素的 <code>refid</code> 属性或内部语句中使用属性值，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sometable&quot;</span>&gt;</span><br>  $&#123;prefix&#125;Table<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;someinclude&quot;</span>&gt;</span><br>  from<br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;$&#123;include_target&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>  select<br>    field1, field2, field3<br>  <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;someinclude&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Some&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;include_target&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sometable&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>之前见到的所有语句都使用了简单的参数形式。但实际上，参数是 MyBatis 非常强大的元素。对于大多数简单的使用场景，你都不需要使用复杂的参数，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsers&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>  select id, username, password<br>  from users<br>  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的这个示例说明了一个非常简单的命名参数映射。鉴于参数类型（parameterType）会被自动设置为 <code>int</code>，这个参数可以随意命名。原始类型或简单数据类型（比如 <code>Integer</code> 和 <code>String</code>）因为没有其它属性，会用它们的值来作为参数。 然而，如果传入一个复杂的对象，行为就会有点不一样了。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>  insert into users (id, username, password)<br>  values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果 User 类型的参数对象传递到了语句中，会查找 id、username 和 password 属性，然后将它们的值传入预处理语句的参数中。</p><p>大多时候，你只须简单指定属性名，顶多要为可能为空的列指定 <code>jdbcType</code>，其他的事情交给 MyBatis 自己去推断就行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#&#123;firstName&#125;</span><br><span class="hljs-comment">#&#123;middleInitial,jdbcType=VARCHAR&#125;</span><br><span class="hljs-comment">#&#123;lastName&#125;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong> JDBC 要求，如果一个列允许使用 null 值，并且会使用值为 null 的参数，就必须要指定 JDBC 类型（jdbcType）。阅读 <code>PreparedStatement.setNull()</code>的 JavaDoc 来获取更多信息。</p><h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><p><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC <code>ResultSets</code> 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 <code>resultMap</code> 能够代替实现同等功能的数千行代码。ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</p><h3 id="自动创建resultMap"><a href="#自动创建resultMap" class="headerlink" title="自动创建resultMap"></a>自动创建resultMap</h3><p>你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为领域模型。MyBatis 对两者都提供了支持。看看下面这个 JavaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.someapp.model;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>  <span class="hljs-keyword">private</span> String username;<br>  <span class="hljs-keyword">private</span> String hashedPassword;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> id;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>    <span class="hljs-built_in">this</span>.id = id;<br>  &#125;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> username;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span> &#123;<br>    <span class="hljs-built_in">this</span>.username = username;<br>  &#125;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHashedPassword</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> hashedPassword;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHashedPassword</span><span class="hljs-params">(String hashedPassword)</span> &#123;<br>    <span class="hljs-built_in">this</span>.hashedPassword = hashedPassword;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于 JavaBean 的规范，上面这个类有 3 个属性：id，username 和 hashedPassword。这些属性会对应到 select 语句中的列名。</p><p>这样的一个 JavaBean 可以被映射到 <code>ResultSet</code>，就像映射到 <code>HashMap</code> 一样简单。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsers&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.someapp.model.User&quot;</span>&gt;</span><br>  select id, username, hashedPassword<br>  from some_table<br>  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这些情况下，MyBatis 会在幕后自动创建一个 <code>ResultMap</code>，再根据属性名来映射列到 JavaBean 的属性上。如果列名和属性名不能匹配上，可以在 SELECT 语句中设置列别名（这是一个基本的 SQL 特性）来完成匹配。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsers&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>  select<br>    user_id             as &quot;id&quot;,<br>    user_name           as &quot;userName&quot;,<br>    hashed_password     as &quot;hashedPassword&quot;<br>  from some_table<br>  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="显示配置resultMap"><a href="#显示配置resultMap" class="headerlink" title="显示配置resultMap"></a>显示配置resultMap</h3><p>我们来看看如果在刚刚的示例中，显式使用外部的 <code>resultMap</code> 会怎样，这也是解决列名不匹配的另外一种方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.someapp.model.User&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;hashed_password&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在引用它的语句中设置 <code>resultMap</code> 属性就行了（注意我们去掉了 <code>resultType</code> 属性）。比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsers&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userResultMap&quot;</span>&gt;</span><br>  select user_id, user_name, hashed_password<br>  from some_table<br>  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="resultMap-元素的概念视图"><a href="#resultMap-元素的概念视图" class="headerlink" title="resultMap 元素的概念视图"></a><code>resultMap</code> 元素的概念视图</h3><ul><li><code>constructor</code>- 用于在实例化类时，注入结果到构造方法中<ul><li><code>idArg</code> - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能</li><li><code>arg</code> - 将被注入到构造方法的一个普通结果</li></ul></li><li><code>id</code> – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能</li><li><code>result</code> – 注入到字段或 JavaBean 属性的普通结果</li><li><code>association</code>– 一个复杂类型的关联；许多结果将包装成这种类型<ul><li>嵌套结果映射 – 关联可以是 <code>resultMap</code> 元素，或是对其它结果映射的引用</li></ul></li><li><code>collection</code>– 一个复杂类型的集合<ul><li>嵌套结果映射 – 集合可以是 <code>resultMap</code> 元素，或是对其它结果映射的引用</li></ul></li><li><code>discriminator</code>– 使用结果值来决定使用哪个<code>resultMap</code><ul><li><code>case</code> – 基于某些值的结果映射<ul><li>嵌套结果映射 – <code>case</code> 也是一个结果映射，因此具有相同的结构和元素；或者引用其它的结果映射</li></ul></li></ul></li></ul><p><strong>最佳实践：</strong> 最好逐步建立结果映射。单元测试可以在这个过程中起到很大帮助。 如果你尝试一次性创建像上面示例那么巨大的结果映射，不仅容易出错，难度也会直线上升。 所以，从最简单的形态开始，逐步迭代。而且别忘了单元测试！ 有时候，框架的行为像是一个黑盒子（无论是否开源）。因此，为了确保实现的行为与你的期望相一致，最好编写单元测试。 并且单元测试在提交 bug 时也能起到很大的作用。</p><h4 id="id-result"><a href="#id-result" class="headerlink" title="id &amp; result"></a>id &amp; result</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;post_id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;subject&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;post_subject&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这些元素是结果映射的基础。<em>id</em> 和 <em>result</em> 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段。</p><p>这两者之间的唯一不同是，<em>id</em> 元素对应的属性会被标记为对象的标识符，在比较对象实例时使用。 这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>通过修改对象属性的方式，可以满足大多数的数据传输对象（Data Transfer Object, DTO）以及绝大部分领域模型的要求。但有些情况下你想使用不可变类。 一般来说，很少改变或基本不变的包含引用或数据的表，很适合使用不可变类。 构造方法注入允许你在初始化时为类设置属性的值，而不用暴露出公有方法。MyBatis 也支持私有属性和私有 JavaBean 属性来完成注入，但有一些人更青睐于通过构造方法进行注入。 <em>constructor</em> 元素就是为此而生的。</p><p>看看下面这个构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>   <span class="hljs-comment">//...</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(Integer id, String username, <span class="hljs-type">int</span> age)</span> &#123;<br>     <span class="hljs-comment">//...</span><br>  &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了将结果注入构造方法，MyBatis 需要通过某种方式定位相应的构造方法。 在下面的例子中，MyBatis 搜索一个声明了三个形参的构造方法，参数类型以 <code>java.lang.Integer</code>, <code>java.lang.String</code> 和 <code>int</code> 的顺序给出。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">constructor</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">idArg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;int&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;String&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;_int&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">constructor</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;blog_author_id&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Author&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_username&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br></code></pre></td></tr></table></figure><p>关联（association）元素处理<strong>“有一个”</strong>类型的关系。 比如，在我们的示例中，一个博客有一个用户。</p><p>关联结果映射和其它类型的映射工作方式差不多。 你需要指定目标属性名以及属性的<code>javaType</code>（很多时候 MyBatis 可以自己推断出来），在必要的情况下你还可以设置 JDBC 类型，如果你想覆盖获取结果值的过程，还可以设置类型处理器。</p><p>关联的不同之处是，你需要告诉 MyBatis 如何加载关联。MyBatis 有两种不同的方式加载关联：</p><ul><li>嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。</li><li>嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。</li></ul><h5 id="关联的嵌套-Select-查询"><a href="#关联的嵌套-Select-查询" class="headerlink" title="关联的嵌套 Select 查询"></a>关联的嵌套 Select 查询</h5><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blogResult&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_id&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Author&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;selectAuthor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBlog&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;blogResult&quot;</span>&gt;</span><br>  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAuthor&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Author&quot;</span>&gt;</span><br>  SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>就是这么简单。我们有两个 select 查询语句：一个用来加载博客（Blog），另外一个用来加载作者（Author），而且博客的结果映射描述了应该使用 <code>selectAuthor</code> 语句加载它的 author 属性。</p><p>其它所有的属性将会被自动加载，只要它们的列名和属性名相匹配。</p><p>这种方式虽然很简单，但在大型数据集或大型数据表上表现不佳。这个问题被称为<strong>“N+1 查询问题”</strong>。 概括地讲，N+1 查询问题是这样子的：</p><ul><li>你执行了一个单独的 SQL 语句来获取结果的一个列表（就是“+1”）。</li><li>对列表返回的每条记录，你执行一个 select 查询语句来为每条记录加载详细信息（就是“N”）。</li></ul><p>这个问题会导致成百上千的 SQL 语句被执行。有时候，我们不希望产生这样的后果。</p><p>好消息是，MyBatis 能够对这样的查询进行延迟加载，因此可以将大量语句同时运行的开销分散开来。 然而，如果你加载记录列表之后立刻就遍历列表以获取嵌套的数据，就会触发所有的延迟加载查询，性能可能会变得很糟糕。</p><h5 id="关联的嵌套结果映射"><a href="#关联的嵌套结果映射" class="headerlink" title="关联的嵌套结果映射"></a>关联的嵌套结果映射</h5><p>下面的例子则是一个非常简单的例子，用于演示嵌套结果映射如何工作。 现在我们将博客表和作者表连接在一起，而不是执行一个独立的查询语句，就像这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBlog&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;blogResult&quot;</span>&gt;</span><br>  select<br>    B.id            as blog_id,<br>    B.title         as blog_title,<br>    B.author_id     as blog_author_id,<br>    A.id            as author_id,<br>    A.username      as author_username,<br>    A.password      as author_password,<br>    A.email         as author_email,<br>    A.bio           as author_bio<br>  from Blog B left outer join Author A on B.author_id = A.id<br>  where B.id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意查询中的连接，以及为确保结果能够拥有唯一且清晰的名字，我们设置的别名。 这使得进行映射非常简单。现在我们可以映射这个结果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blogResult&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;blog_id&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;blog_title&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;blog_author_id&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Author&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;authorResult&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;authorResult&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Author&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_username&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_password&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_email&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;bio&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_bio&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，你可以看到，博客（Blog）作者（author）的关联元素委托名为 “authorResult” 的结果映射来加载作者对象的实例。</p><p><strong>非常重要</strong>： id 元素在嵌套结果映射中扮演着非常重要的角色。你应该总是指定一个或多个可以唯一标识结果的属性。 虽然，即使不指定这个属性，MyBatis 仍然可以工作，但是会产生严重的性能问题。 只需要指定可以唯一标识结果的最少属性。显然，你可以选择主键（复合主键也可以）。</p><h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><p>MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 为了使它更加强大而且易于配置，我们对 MyBatis 3 中的缓存实现进行了许多改进。</p><p>默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>基本上就是这样。这个简单语句的效果如下:</p><ul><li>映射语句文件中的所有 <strong>select</strong> 语句的结果将会被缓存。</li><li>映射语句文件中的所有 <strong>insert、update 和 delete</strong> 语句会刷新缓存。</li><li>缓存会使用最近最少使用算法（<strong>LRU</strong>, Least Recently Used）算法来清除不需要的缓存。</li><li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li><li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li><li>缓存会被视为读&#x2F;写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li></ul><h2 id="cache-ref"><a href="#cache-ref" class="headerlink" title="cache-ref"></a>cache-ref</h2><p>回想一下上一节的内容，对某一命名空间的语句，只会使用该命名空间的缓存进行缓存或刷新。 但你可能会想要在多个命名空间中共享相同的缓存配置和实例。要实现这种需求，你可以使用 cache-ref 元素来引用另一个缓存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache-ref</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.someone.application.data.SomeMapper&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><h3 id="一个条件"><a href="#一个条件" class="headerlink" title="一个条件"></a>一个条件</h3><p>使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogWithTitleLike&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  SELECT * FROM BLOG<br>  WHERE state = ‘ACTIVE’<br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>    AND title like #&#123;title&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果（细心的读者可能会发现，“title” 的参数值需要包含查找掩码或通配符字符）。</p><p>这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果（细心的读者可能会发现，“title” 的参数值需要包含查找掩码或通配符字符）。</p><h3 id="多个条件"><a href="#多个条件" class="headerlink" title="多个条件"></a>多个条件</h3><p>如果希望通过 “title” 和 “author” 两个参数进行可选搜索该怎么办呢？首先，我想先将语句名称修改成更名副其实的名称；接下来，只需要加入另一个条件即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  SELECT * FROM BLOG WHERE state = ‘ACTIVE’<br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>    AND title like #&#123;title&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>    AND author_name like #&#123;author.name&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose, when, otherwise"></a>choose, when, otherwise</h2><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><p>还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员精选的 Blog）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  SELECT * FROM BLOG WHERE state = ‘ACTIVE’<br>  <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>      AND title like #&#123;title&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>      AND author_name like #&#123;author.name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>      AND featured = 1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim, where, set"></a>trim, where, set</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>前面几个例子已经方便地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，这次我们将 “state &#x3D; ‘ACTIVE’” 设置成动态条件，看看会发生什么。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  SELECT * FROM BLOG<br>  WHERE<br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;state != null&quot;</span>&gt;</span><br>    state = #&#123;state&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>    AND title like #&#123;title&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>    AND author_name like #&#123;author.name&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> BLOG<br><span class="hljs-keyword">WHERE</span><br></code></pre></td></tr></table></figure><p>这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> BLOG<br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">AND</span> title <span class="hljs-keyword">like</span> ‘someTitle’<br></code></pre></td></tr></table></figure><p>这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。</p><p>MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  SELECT * FROM BLOG<br>  <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;state != null&quot;</span>&gt;</span><br>         state = #&#123;state&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>        AND title like #&#123;title&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>        AND author_name like #&#123;author.name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。</p><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>如果 <em>where</em> 元素与你期望的不太一样，你也可以通过<strong>自定义 trim 元素</strong>来定制 <em>where</em> 元素的功能。比如，和 <em>where</em> 元素等价的自定义 trim 元素为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;WHERE&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;AND |OR &quot;</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>prefixOverrides</em> 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 <em>prefixOverrides</em> 属性中指定的内容，并且插入 <em>prefix</em> 属性中指定的内容。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>用于动态<code>update</code>语句的类似解决方案叫做 <em>set</em>。<em>set</em> 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span><br>  update Author<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>  where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个例子中，<em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p><p>或者，你可以通过使用<em>trim</em>元素来达到同样的效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;SET&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意，我们覆盖了后缀值设置，并且自定义了前缀值。</p><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPostIn&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;domain.blog.Post&quot;</span>&gt;</span><br>  SELECT *<br>  FROM POST P<br>  <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;ID in (&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">nullable</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>          #&#123;item&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>foreach</em> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！</p><p><strong>提示：</strong>你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p><h2 id="script"><a href="#script" class="headerlink" title="script"></a>script</h2><p>要在带注解的映射器接口类中使用动态 SQL，可以使用 <em>script</em> 元素。比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Update(&#123;&quot;&lt;script&gt;&quot;,</span><br><span class="hljs-meta">  &quot;update Author&quot;,</span><br><span class="hljs-meta">  &quot;  &lt;set&gt;&quot;,</span><br><span class="hljs-meta">  &quot;    &lt;if test=&#x27;username != null&#x27;&gt;username=#&#123;username&#125;,&lt;/if&gt;&quot;,</span><br><span class="hljs-meta">  &quot;    &lt;if test=&#x27;password != null&#x27;&gt;password=#&#123;password&#125;,&lt;/if&gt;&quot;,</span><br><span class="hljs-meta">  &quot;    &lt;if test=&#x27;email != null&#x27;&gt;email=#&#123;email&#125;,&lt;/if&gt;&quot;,</span><br><span class="hljs-meta">  &quot;    &lt;if test=&#x27;bio != null&#x27;&gt;bio=#&#123;bio&#125;&lt;/if&gt;&quot;,</span><br><span class="hljs-meta">  &quot;  &lt;/set&gt;&quot;,</span><br><span class="hljs-meta">  &quot;where id=#&#123;id&#125;&quot;,</span><br><span class="hljs-meta">  &quot;&lt;/script&gt;&quot;&#125;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">updateAuthorValues</span><span class="hljs-params">(Author author)</span>;<br></code></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><code>bind</code> 元素允许你在 OGNL (Object Graph Navigation Language) 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBlogsLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#x27;%&#x27; + _parameter.getTitle() + &#x27;%&#x27;&quot;</span> /&gt;</span><br>  SELECT * FROM BLOG<br>  WHERE title LIKE #&#123;pattern&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Backend</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode206. 反转链表</title>
    <link href="/2023/09/16/algorithm/leetcode/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/09/16/algorithm/leetcode/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>CodeTop字节高频题。</p><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>双指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> a = head, b = a-&gt;next;<br>        <span class="hljs-keyword">while</span> (b) &#123;<br>            <span class="hljs-keyword">auto</span> c = b-&gt;next;<br>            b-&gt;next = a;<br>            a = b, b = c;<br>        &#125;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>直接用给的函数<code>reverseList</code>本身递归。</p><p><code>reverseList</code>的参数是某节点<code>n</code>，返回值是<code>n指向的子链表</code>的尾结点<code>tail</code>。<code>n指向的子链表</code>是已经翻转完毕的链表，只需要将<code>n的下一个节点</code>的next指向n，n的next设置成nullptr即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> tail = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> tail;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式3-单一职责原则</title>
    <link href="/2023/09/16/design-pattern/3.%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <url>/2023/09/16/design-pattern/3.%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>SOLID原则中的S: <strong>S</strong>ingle Responsibility Principle</p><h1 id="准确解释"><a href="#准确解释" class="headerlink" title="准确解释"></a>准确解释</h1><p>就一个类而言，应该仅有一个引起它变化的原因。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。</p><p>如果你能够想到<strong>多于一个的动机去改变一个类</strong>，那么这个类就具有<strong>多于一个的职责</strong>，就应该考虑类的职责分离。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="俄罗斯方块开发"><a href="#俄罗斯方块开发" class="headerlink" title="俄罗斯方块开发"></a>俄罗斯方块开发</h2><p>将游戏界面和游戏逻辑分离开。界面的变化是和游戏本身没有关系的，界面是容易变化的，而游戏逻辑是不太容易变化的，将它们分离开有利于界面的改动。</p><h3 id="游戏界面"><a href="#游戏界面" class="headerlink" title="游戏界面"></a>游戏界面</h3><ul><li>Android</li><li>Web</li><li>Windows</li></ul><h3 id="游戏逻辑"><a href="#游戏逻辑" class="headerlink" title="游戏逻辑"></a>游戏逻辑</h3><ul><li>移动</li><li>旋转</li><li>消层</li><li>堆积</li></ul>]]></content>
    
    
    <categories>
      
      <category>Design Pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis中#{}和${}的区别是什么？</title>
    <link href="/2023/09/16/backend/MyBatis/MyBatis%E5%8F%82%E6%95%B0%E6%9B%BF%E6%8D%A2/"/>
    <url>/2023/09/16/backend/MyBatis/MyBatis%E5%8F%82%E6%95%B0%E6%9B%BF%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>动态 sql 是 MyBatis 的主要特性之一，在 mapper 中定义的参数传到 xml 中之后，在查询之前 MyBatis 会对其进行动态解析。MyBatis 为我们提供了两种支持动态 sql 的语法：#{} 以及 ${}。</p><h2 id="一句话回答"><a href="#一句话回答" class="headerlink" title="一句话回答"></a>一句话回答</h2><p>#{}是预编译处理，${}是字符串替换。</p><h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h2><ul><li><p>MyBatis在处理#{}时，会将SQL中的#{}替换为?号，使用PreparedStatement的set方法来赋值；</p></li><li><p>而MyBatis在处理${}时，直接把${}替换成变量的值。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPerson&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;hashmap&quot;</span>&gt;</span><br>  SELECT * FROM PERSON WHERE ID = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p><p>注意参数符号：#{id}</p><p>这就告诉 MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 近似的 JDBC 代码，非 MyBatis 代码...</span><br><span class="hljs-type">String</span> <span class="hljs-variable">selectPerson</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT * FROM PERSON WHERE ID = ?&quot;</span>;<br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> conn.prepareStatement(selectPerson);<br>ps.setInt(<span class="hljs-number">1</span>,id);<br></code></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="防止恶意SQL注入示例"><a href="#防止恶意SQL注入示例" class="headerlink" title="防止恶意SQL注入示例"></a>防止恶意SQL注入示例</h3><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from tb_name where name = &#x27;&quot;</span> + varname + <span class="hljs-string">&quot;&#x27; and passwd = &#x27;&quot;</span> + varpasswd + <span class="hljs-string">&quot;&#x27; &quot;</span>;<br></code></pre></td></tr></table></figure><p>如果我们把<code>[ &#39; or&#39;1&#39;=&#39;1&#39;]</code>作为<code>varpasswd</code>传入进来.用户名随意,看看会成为什么?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;随意&#x27;</span> <span class="hljs-keyword">and</span> passwd <span class="hljs-operator">=</span> <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span>;<br></code></pre></td></tr></table></figure><p>因为’1’&#x3D;’1’肯定成立,所以可以任何通过验证</p><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> $&#123;tableName&#125; <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> #&#123;name&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，如果${tableName}传入<code>user; delete user; --</code></p><p>则动态解析之后 sql 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>; <span class="hljs-keyword">delete</span> <span class="hljs-keyword">user</span>; <span class="hljs-comment">-- where name = ?;</span><br></code></pre></td></tr></table></figure><p>–之后的语句被注释掉，而原本查询用户的语句变成了查询所有用户信息+删除用户表的语句，会对数据库造成重大损伤，极大可能导致服务器宕机。</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>指的是数据库驱动在发送 sql 语句和参数给 DBMS 之前对 sql 语句进行编译，这样 DBMS 执行 sql 时，就不需要重新编译。</p><h5 id="为什么需要预编译"><a href="#为什么需要预编译" class="headerlink" title="为什么需要预编译?"></a>为什么需要预编译?</h5><p>预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作。而预编译机制则可以很好的防止SQL注入。</p><p>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。</p><ol><li><p><strong>预编译阶段可以优化 sql 的执行</strong>。</p><ul><li>预编译之后的 sql 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的sql，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。</li></ul></li><li><p><strong>预编译语句对象可以重复利用</strong>。</p><ul><li>把一个 sql 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个sql，可以直接使用这个缓存的 PreparedState 对象。</li></ul></li></ol><p>MyBatis 默认情况下，将对所有的 sql 进行预编译。</p><h3 id="MyBatis-sql-动态解析"><a href="#MyBatis-sql-动态解析" class="headerlink" title="MyBatis sql 动态解析"></a>MyBatis sql 动态解析</h3><p>MyBatis 在调用 connection 进行 sql 预编译之前，会对sql语句进行动态解析，动态解析主要包含如下的功能：</p><ul><li><p>占位符的处理</p></li><li><p>动态sql的处理</p></li><li><p>参数类型校验</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Backend</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode146. LRU 缓存</title>
    <link href="/2023/09/15/algorithm/leetcode/146.LRU%20%E7%BC%93%E5%AD%98/"/>
    <url>/2023/09/15/algorithm/leetcode/146.LRU%20%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>CodeTop字节高频题。</p><p><a href="https://leetcode.cn/problems/lru-cache/description/">https://leetcode.cn/problems/lru-cache/description/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 105</code></li><li>最多调用 <code>2 * 10^5</code> 次 <code>get</code> 和 <code>put</code></li></ul><h1 id="考察知识点"><a href="#考察知识点" class="headerlink" title="考察知识点"></a>考察知识点</h1><ul><li>哈希表</li><li>双向链表</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用哈希表和双向链表两个数据结构实现。</p><p>哈希表用来存储key对应的Node，双向链表用来记录每个Node最近使用时间的新旧顺序。</p><p>实现<code>insert</code>和<code>remove</code>两个函数可以在<code>get</code>和<code>put</code>方法中复用。</p><p>注意判断当前哈希表的size是否已经到达capacity，从而决定是否要移除最旧的Node。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> key, val;<br>        Node *left, *right;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _val): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>    &#125;*L, *R;<br><br>    <span class="hljs-type">int</span> capacity;<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; hash;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> _capacity) &#123;<br>        capacity = _capacity;<br>        L = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>), R = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);<br>        L-&gt;right = R, R-&gt;left = L;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node *n)</span> </span>&#123;<br>        n-&gt;left-&gt;right = n-&gt;right;<br>        n-&gt;right-&gt;left = n-&gt;left;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Node *n)</span> </span>&#123;<br>        L-&gt;right-&gt;left = n;<br>        n-&gt;right = L-&gt;right;<br>        L-&gt;right = n;<br>        n-&gt;left = L;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> n = hash[key];<br>            <span class="hljs-built_in">remove</span>(n);<br>            <span class="hljs-built_in">insert</span>(n);<br>            <span class="hljs-keyword">return</span> n-&gt;val;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> n = hash[key];<br>            n-&gt;val = value;<br>            <span class="hljs-built_in">remove</span>(n);<br>            <span class="hljs-built_in">insert</span>(n);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">auto</span> n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            <span class="hljs-built_in">insert</span>(n);<br>            hash[key] = n;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">size</span>() &gt; capacity) &#123;<br>                <span class="hljs-keyword">auto</span> n = R-&gt;left;<br>                <span class="hljs-built_in">remove</span>(n);<br>                hash.<span class="hljs-built_in">erase</span>(n-&gt;key);<br>                <span class="hljs-keyword">delete</span> n;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>学习结构体构造函数的简写方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> key, val;<br>    Node *left, *right;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _val): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;*L, *R;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode3. 无重复字符的最长子串</title>
    <link href="/2023/09/15/algorithm/leetcode/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2023/09/15/algorithm/leetcode/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>CodeTop字节高频题。</p><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h1 id="考察知识点"><a href="#考察知识点" class="headerlink" title="考察知识点"></a>考察知识点</h1><ul><li>哈希表</li><li>滑动窗口（双指针）</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="原始思路"><a href="#原始思路" class="headerlink" title="原始思路"></a>原始思路</h2><p>从头到尾遍历字符串s，hash存储每个字符最后出现的下标，p作为子串起始点，i为子串当前结束点。</p><p>i每次移动，更新对应字符下标。如果出现重复字符，将子串起点p更新到重复字符上一次出现位置的后一个位置（如果已经在它后面了就不动）。</p><p>i每次移动，都更新全局最大长度res。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">0</span>;<br>        s = <span class="hljs-string">&quot; &quot;</span> + s;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (!hash[s[i]]) &#123;<br>                hash[s[i]] = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 将子串起点p更新到重复字符上一次出现位置的后一个位置（如果已经在它后面了就不动）</span><br>                p = <span class="hljs-built_in">max</span>(p, hash[s[i]] + <span class="hljs-number">1</span>);<br>                hash[s[i]] = i;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, i - p + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以简写为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">0</span>;<br>        s = <span class="hljs-string">&quot; &quot;</span> + s;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (hash[s[i]]) p = <span class="hljs-built_in">max</span>(p, hash[s[i]] + <span class="hljs-number">1</span>);<br>            hash[s[i]] = i;<br>            res = <span class="hljs-built_in">max</span>(res, i - p + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="另一种思路"><a href="#另一种思路" class="headerlink" title="另一种思路"></a>另一种思路</h2><p>i和j为子串右端点和左端点，hash存储每个字符在i和j之间出现的次数，如果出现次数大于1了，把左端点j往右移，直到该字符出现次数为1为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            hash[s[i]] ++;<br>            <span class="hljs-keyword">while</span> (hash[s[i]] &gt; <span class="hljs-number">1</span>) hash[s[j ++]] --;<br>            res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AOP原理、术语和AspectJ示例</title>
    <link href="/2023/09/15/backend/Spring/Spring%20AOP/AOP-principle-and-tutorial-with-AspectJ-Examples/"/>
    <url>/2023/09/15/backend/Spring/Spring%20AOP/AOP-principle-and-tutorial-with-AspectJ-Examples/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h1><p>在Java平台上，对于AOP的织入，有3种方式：</p><ol><li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li><li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li><li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li></ol><p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理，应用了代理模式。</p><p>AOP让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。</p><blockquote><p>AOP对于解决特定问题，例如事务管理非常有用，这是因为分散在各处的事务代码几乎是完全相同的，并且它们需要的参数（JDBC的Connection）也是固定的。</p><p>另一些特定问题，如日志，就不那么容易实现，因为日志虽然简单，但打印日志的时候，经常需要捕获局部变量，如果使用AOP实现日志，我们只能输出固定格式的日志，</p><p>因此，使用AOP时，必须适合特定的场景。</p></blockquote><h1 id="Terminologies"><a href="#Terminologies" class="headerlink" title="Terminologies"></a>Terminologies</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ul><li>Aspect：切面，即一个横跨多个核心逻辑的功能，或者称之为系统关注点；</li><li>Joinpoint：连接点，即定义在应用程序流程的何处插入切面的执行；</li><li>Pointcut：切入点，即一组连接点的集合；</li><li>Advice：增强，指特定连接点上执行的动作；</li><li>Introduction：引介，指为一个已有的Java对象动态地增加新的接口；</li><li>Weaving：织入，指将切面整合到程序的执行流程中；</li><li>Interceptor：拦截器，是一种实现增强的方式；</li><li>Target Object：目标对象，即真正执行业务的核心逻辑对象；</li><li>AOP Proxy：AOP代理，是客户端持有的增强后的对象引用。</li></ul><h2 id="Static-Compile-Time"><a href="#Static-Compile-Time" class="headerlink" title="Static - Compile Time"></a>Static - Compile Time</h2><h3 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h3><p>Aspect is the concern that we are trying to implement generically.  The functionality you want to implement. What you want to achieve.</p><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><ul><li>Transaction Management</li><li>Logging (e.g. Every method of business layer called, log the input and output parameters)</li><li>Performance metrics (how much time a method took to execute)</li></ul><h3 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h3><p>A regular expression which determines what are the methods are to be intercepted.</p><p>e.g. execution(* com.example.spring.business.aop.HiByeService.*(..))</p><h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><p>Action taken by an aspect at a particular join point. What is to be done when the Pointcut is met.</p><h2 id="Dynamic-Runtime"><a href="#Dynamic-Runtime" class="headerlink" title="Dynamic - Runtime"></a>Dynamic - Runtime</h2><h3 id="Join-point"><a href="#Join-point" class="headerlink" title="Join point"></a>Join point</h3><p>A point during the execution of a program. Execution of a specific AOP method.</p><p>All the runtime information about the method call.</p><p>Input parameters of the Advice?</p><h3 id="Weaving"><a href="#Weaving" class="headerlink" title="Weaving"></a>Weaving</h3><p>The entire process of executing the Advice.</p><h1 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h1><h2 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h2><h3 id="Aspect类"><a href="#Aspect类" class="headerlink" title="Aspect类"></a>Aspect类</h3><ul><li>@Order(3)，值越小优先级越高</li><li>@Aspect</li></ul><h3 id="AspectJ-Advice-Types"><a href="#AspectJ-Advice-Types" class="headerlink" title="AspectJ Advice Types"></a>AspectJ Advice Types</h3><ul><li><p><strong>@Before</strong>（前置通知）：先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；</p></li><li><p><strong>@After</strong> （后置通知）：先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；</p></li><li><p><strong>@AfterReturning</strong>（返回通知）：和@After不同的是，只有当目标代码正常返回时，才执行拦截器代码；</p></li><li><p><strong>@AfterThrowing</strong>（异常通知）：和@After不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；</p><blockquote><p>AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</p></blockquote></li><li><p><strong>@Around</strong> （环绕通知）：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能</p></li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// AspectJ annotation</span><br><span class="hljs-meta">@Component</span> <span class="hljs-comment">// Managed by Spring</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(* com.example.spring.business.aop.HiByeService.*(..))&quot;)</span> <span class="hljs-comment">// 默认等价于pointcut=&quot;execution...&quot;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;Before &quot;</span>);<br>        System.out.println(joinPoint.getSignature().getName());<br>    &#125;<br>    <br>    <span class="hljs-meta">@AfterReturning(pointcut=&quot;execution(* com.example.spring.business.aop.HiByeService.*(..))&quot;, returning=&quot;result&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(JoinPoint joinPoint, Object result)</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;After &quot;</span>);<br>        System.out.print(joinPoint.getSignature().getName());<br>        System.out.println(<span class="hljs-string">&quot;, result is &quot;</span> + result);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(classes = SpringContextAOP.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AOPExampleTest</span> &#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> HiByeService service;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSomething</span><span class="hljs-params">()</span> &#123;<br>        service.sayHi();<br>        service.sayBye();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用注解装配AOP"><a href="#使用注解装配AOP" class="headerlink" title="使用注解装配AOP"></a>使用注解装配AOP</h3><p>例：监控应用程序的性能</p><h4 id="1-定义一个性能监控的注解"><a href="#1-定义一个性能监控的注解" class="headerlink" title="1. 定义一个性能监控的注解"></a>1. 定义一个性能监控的注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(METHOD)</span><br><span class="hljs-meta">@Retention(RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MetricTime &#123;<br>  String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-在需要被监控的关键方法上标注该注解"><a href="#2-在需要被监控的关键方法上标注该注解" class="headerlink" title="2. 在需要被监控的关键方法上标注该注解"></a>2. 在需要被监控的关键方法上标注该注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>  <span class="hljs-comment">// 监控register()方法性能</span><br>  <span class="hljs-meta">@MetricTime(&quot;register&quot;)</span><br>  <span class="hljs-keyword">public</span> User <span class="hljs-title function_">register</span><span class="hljs-params">(String email, String password, String name)</span> &#123;<br>    ...<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-定义MetricAspect"><a href="#3-定义MetricAspect" class="headerlink" title="3. 定义MetricAspect"></a>3. 定义<code>MetricAspect</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MetricAspect</span> &#123;<br>  <span class="hljs-meta">@Around(&quot;@annotation(metricTime)&quot;)</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">metric</span><span class="hljs-params">(ProceedingJoinPoint joinPoint, MetricTime metricTime)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> metricTime.value();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">return</span> joinPoint.proceed();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - start;<br>      System.err.println(<span class="hljs-string">&quot;[Metrics] &quot;</span> + name + <span class="hljs-string">&quot;: &quot;</span> + t + <span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>metric()</code>方法标注了<code>@Around(&quot;@annotation(metricTime)&quot;)</code>，它的意思是，符合条件的目标方法是带有<code>@MetricTime</code>注解的方法，因为<code>metric()</code>方法<strong>参数类型</strong>是<code>MetricTime</code>（注意参数名是<code>metricTime</code>不是<code>MetricTime</code>），我们通过它获取性能监控的名称。</p><blockquote><p>Aspect织入的地方取决于<code>metric</code>方法的第二个入参类型</p></blockquote><p>有了<code>@MetricTime</code>注解，再配合<code>MetricAspect</code>，任何Bean，只要方法标注了<code>@MetricTime</code>注解，就可以自动实现性能监控。运行代码，输出结果如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">Welcome, Bob!<br><span class="hljs-selector-attr">[Metrics]</span> register: <span class="hljs-number">16ms</span><br></code></pre></td></tr></table></figure><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>定义执行方法，并在方法上通过AspectJ的注解告诉Spring应该在何处调用此方法；</li><li>标记<code>@Component</code>和<code>@Aspect</code>；</li><li>在<code>@Configuration</code>类上标注<code>@EnableAspectJAutoProxy</code>。</li></ol><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><ol><li>访问被注入的Bean时，总是调用方法而非直接访问字段<ul><li>因为CGLIB代理类不会调用super()，也就是父类即原始类的构造函数，所以自己继承来的该字段不会被初始化</li><li>但调用方法会委托给<strong>引用的原始类的实例</strong>的该方法（跟父类就没关系了）</li></ul></li><li>编写Bean时，如果可能会被代理，就不要编写<code>public final</code>方法。</li></ol><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li>Spring doc for AspectJ: <a href="https://docs.spring.io/spring-framework/reference/core/aop/ataspectj.html">https://docs.spring.io/spring-framework/reference/core/aop/ataspectj.html</a></li><li>注解装配AOP：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1310052317134882">https://www.liaoxuefeng.com/wiki/1252599548343744/1310052317134882</a></li><li>AOP注意事项：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1339039378571298">https://www.liaoxuefeng.com/wiki/1252599548343744/1339039378571298</a></li><li>Spring AOP Tutorial - with AspectJ Examples: <a href="https://www.youtube.com/watch?v=Og9Fyew8ltQ">https://www.youtube.com/watch?v=Og9Fyew8ltQ</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Backend</category>
      
      <category>Spring</category>
      
      <category>Spring AOP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Doc</title>
    <link href="/2023/09/14/tips/Hexo-doc/"/>
    <url>/2023/09/14/tips/Hexo-doc/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Tips</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
