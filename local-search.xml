<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL知识总结</title>
    <link href="/posts/df19d329.html"/>
    <url>/posts/df19d329.html</url>
    
    <content type="html"><![CDATA[<h1 id="存储引擎：MyISAM-和-InnoDB-有什么区别？"><a href="#存储引擎：MyISAM-和-InnoDB-有什么区别？" class="headerlink" title="存储引擎：MyISAM 和 InnoDB 有什么区别？"></a>存储引擎：MyISAM 和 InnoDB 有什么区别？</h1><p><strong>总结</strong>：</p><ul><li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li><li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li><li>MyISAM 不支持外键，而 InnoDB 支持。</li><li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li><li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li><li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li><li>InnoDB 的性能比 MyISAM 更强大。</li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="并发事务导致的问题"><a href="#并发事务导致的问题" class="headerlink" title="并发事务导致的问题"></a>并发事务导致的问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据。</p><h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失了。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样。</p><blockquote><p>不可重复读和幻读有什么区别？</p><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul></blockquote><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><blockquote><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重复读）</strong>。</p></blockquote><h2 id="锁和MVCC"><a href="#锁和MVCC" class="headerlink" title="锁和MVCC"></a>锁和MVCC</h2><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>InnoDB支持表级锁和行级锁。</p><p><strong>行级锁的使用有什么注意事项？</strong><br>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。</p><p><strong>InnoDB 有哪几类行锁？</strong><br>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong>记录锁（Record Lock）</strong>：属于单个行记录上的锁。</li><li><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身。</li><li><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>意向锁是表级锁，共有两种：</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InnoDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p><p>意向锁之间是互相兼容的。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>IS 锁</td><td>兼容</td><td>兼容</td></tr><tr><td>IX 锁</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>S 锁</td><td>兼容</td><td>互斥</td></tr><tr><td>X 锁</td><td>互斥</td><td>互斥</td></tr></tbody></table><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。</p><p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改。</p><p>（待详细补充实现细节）</p><h3 id="当前读与快照读"><a href="#当前读与快照读" class="headerlink" title="当前读与快照读"></a>当前读与快照读</h3><p>InnoDB在隔离级别为可重复读的情况下，通过使用MVCC + Next-Key Lock，可以解决部分幻读的问题：</p><p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p><p><strong>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</strong></p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks">Next-key Lock</a> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>既然哈希表这么快，<strong>为什么 MySQL 没有使用哈希表作为索引的数据结构呢？</strong><br>主要是因为 Hash 索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>当二叉查找树是平衡的时候，也就是树的每个节点的左右子树深度相差不超过 1 的时候，查询的时间复杂度为 O(log2(N))，具有比较高的效率。然而，当二叉查找树不平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为斜树），导致查询效率急剧下降，时间复杂退化为 O(N)。<br><strong>二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。</strong></p><h3 id="B树-B-树"><a href="#B树-B-树" class="headerlink" title="B树 &amp; B+树"></a>B树 &amp; B+树</h3><p><strong>B 树&amp; B+ 树两者有何异同呢？</strong></p><ul><li>B 树的所有节点既存放键(key)也存放数据(data)，而 B+ 树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的；B+ 树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+ 树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+ 树的范围查询，只需要对链表进行遍历即可。</li></ul><p>B+ 树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p><h2 id="如何选择索引列的顺序"><a href="#如何选择索引列的顺序" class="headerlink" title="如何选择索引列的顺序"></a>如何选择索引列的顺序</h2><p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p><ul><li><strong>区分度最高的列放在联合索引的最左侧</strong>：这是最重要的原则。区分度越高，通过索引筛选出的数据就越少，I&#x2F;O 操作也就越少。计算区分度的方法是 <code>count(distinct column) / count(*)</code>。</li><li><strong>最频繁使用的列放在联合索引的左侧</strong>：这符合最左前缀匹配原则。将最常用的查询条件列放在最左侧，可以最大程度地利用索引。</li><li><strong>字段长度</strong>：字段长度对联合索引非叶子节点的影响很小，因为它存储了所有联合索引字段的值。字段长度主要影响主键和包含在其他索引中的字段的存储空间，以及这些索引的叶子节点的大小。因此，在选择联合索引列的顺序时，字段长度的优先级最低。对于主键和包含在其他索引中的字段，选择较短的字段长度可以节省存储空间和提高 I&#x2F;O 性能。</li></ul><h3 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h3><p>由于联合索引是按照从左到右排序的，所以查询时也是按照从左到右依次匹配查询条件中的字段。</p><blockquote><p>最左匹配原则会一直向右匹配，直到遇到范围查询（如 &gt;、&lt;）为止。对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配。</p></blockquote><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p><strong>索引下推（Index Condition Pushdown，简称 ICP）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 <code>WHERE</code> 字句的判断条件，直接过滤掉不满足条件的记录，从而减少回表次数，提高查询效率。</p><p><img src="https://s2.loli.net/2025/03/26/bX5p7KfAEc9tHmy.png" alt="image.png"></p><p>MySQL 可以简单分为 Server 层和存储引擎层这两层。Server 层处理查询解析、分析、优化、缓存以及与客户端的交互等操作，而存储引擎层负责数据的存储和读取，MySQL 支持 InnoDB、MyISAM、Memory 等多种存储引擎。</p><p>索引下推的 <strong>下推</strong> 其实就是指将部分上层（Server 层）负责的事情，交给了下层（存储引擎层）去处理。</p><p><strong>除了可以减少回表次数之外，索引下推还可以减少存储引擎层和 Server 层的数据传输量。</strong></p><h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><p><code>explain sql</code></p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>常见的几种类型具体含义如下：</p><ul><li><strong>system</strong>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</li><li><strong>const</strong>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li><li><strong>eq_ref</strong>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li><li><strong>ref</strong>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li><li><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li><li><strong>range</strong>：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</li><li><strong>index</strong>：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li><li><strong>ALL</strong>：全表扫描。</li></ul><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>key 列表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。</p><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p><ul><li><strong>Using filesort</strong>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li><li><strong>Using temporary</strong>：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</li><li><strong>Using index</strong>：表明查询使用了<strong>覆盖索引</strong>，不用回表，查询效率非常高。</li><li><strong>Using index condition</strong>：表示查询优化器选择使用了<strong>索引条件下推</strong>这个特性。</li><li><strong>Using where</strong>：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li><li>**Using join buffer (Block Nested Loop)**：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</li></ul><p>当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p>]]></content>
    
    
    <categories>
      
      <category>database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty in Action 7 - EventLoop and threading model</title>
    <link href="/posts/b7fae525.html"/>
    <url>/posts/b7fae525.html</url>
    
    <content type="html"><![CDATA[<p><strong>EventLoop</strong> 是框架实现高性能、异步事件驱动架构的核心组件之一。它负责处理网络 I&#x2F;O 事件、用户任务调度以及线程管理，是 Netty 实现高效并发的基础。</p><h1 id="1-线程模型"><a href="#1-线程模型" class="headerlink" title="1. 线程模型"></a>1. 线程模型</h1><p>基本的线程池化模式可以描述为：从池的空闲线程列表中选择一个Thread，并且指派它去运行一个已提交的任务（一个Runnable的实现）​；当任务完成时，将该Thread返回给该列表，使其可被重用。<br><img src="https://s2.loli.net/2025/03/14/LIMBfbu1CcAeR8W.png" alt="image.png"></p><p>虽然池化和重用线程相对于简单地为每个任务都创建和销毁线程是一种进步，但是它并不能消除由上下文切换所带来的开销，其将随着线程数量的增加很快变得明显，并且在高负载下愈演愈烈。此外，仅仅由于应用程序的整体复杂性或者并发需求，在项目的生命周期内也可能会出现其他和线程相关的问题。</p><p>Netty的线程模型帮助简化了这些问题。</p><h1 id="2-EventLoop接口"><a href="#2-EventLoop接口" class="headerlink" title="2. EventLoop接口"></a>2. EventLoop接口</h1><p>事件循环的基本思想，其中每个任务都是一个Runnable的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!terminated) &#123;<br>List&lt;Runnable&gt; readyEvents = blockUntilEventsReady();　<span class="hljs-comment">// 阻塞，直到有事件已经就绪可被运行 　</span><br><span class="hljs-keyword">for</span> (Runnable ev: readyEvents) &#123; 　　<br>ev.run();　 <span class="hljs-comment">// 循环遍历，并处理所有的事件 </span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个模型中，一个<code>EventLoop</code>将由一个永远都不会改变的<code>Thread</code>驱动，同时任务（<code>Runnable</code>或者<code>Callable</code>）可以直接提交给<code>EventLoop</code>实现，以立即执行或者调度执行。根据配置和可用核心的不同，可能会创建多个<code>EventLoop</code>实例用以优化资源的使用，并且单个<code>EventLoop</code>可能会被指派用于服务多个<code>Channel</code>。</p><blockquote><p>事件&#x2F;任务的执行顺序：事件和任务是以先进先出（FIFO）的顺序执行的。这样可以通过保证字节内容总是按正确的顺序被处理，消除潜在的数据损坏的可能性。</p></blockquote><h1 id="3-任务调度"><a href="#3-任务调度" class="headerlink" title="3. 任务调度"></a>3. 任务调度</h1><h2 id="JDK任务调度API"><a href="#JDK任务调度API" class="headerlink" title="JDK任务调度API"></a>JDK任务调度API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> 　<br>Executors.newScheduledThreadPool(<span class="hljs-number">10</span>);<span class="hljs-comment">// 创建一个其线程池具有10 个线程的ScheduledExecutorService</span><br>ScheduledFuture&lt;?&gt; future = executor.schedule( 　<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;　<span class="hljs-comment">// 创建一个R unnable，以供调度稍后执行 </span><br><span class="hljs-meta">@Override</span> 　<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>System.out.println(<span class="hljs-string">&quot;60 seconds later&quot;</span>);<span class="hljs-comment">// 该任务要打印的消息 　</span><br>&#125;<br>&#125;, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<span class="hljs-comment">// 调度任务在从现在开始的60 秒之后执行 </span><br>... <br>executor.shutdown();<span class="hljs-comment">// 一旦调度任务执行完成，就关闭ScheduledExecutorService 以释放资源</span><br></code></pre></td></tr></table></figure><p>虽然ScheduledExecutorServiceAPI是直截了当的，但是在高负载下它将带来性能上的负担。</p><h2 id="使用EventLoop调度任务"><a href="#使用EventLoop调度任务" class="headerlink" title="使用EventLoop调度任务"></a>使用EventLoop调度任务</h2><p>ScheduledExecutorService的实现具有局限性，例如，事实上作为线程池管理的一部分，将会有额外的线程创建。如果有大量任务被紧凑地调度，那么这将成为一个瓶颈。Netty通过Channel的EventLoop实现任务调度解决了这一问题。</p><p>使用EventLoop调度任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Channel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> ...<br>ScheduledFuture&lt;?&gt; future = ch.eventLoop().schedule( <span class="hljs-comment">// 创建一个Runnable以供调度稍后执行 　</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <br><span class="hljs-meta">@Override</span> 　<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 要执行的代码 　　</span><br>System.out.println(<span class="hljs-string">&quot;60 seconds later&quot;</span>);　 　<br>&#125; <br>&#125;, <span class="hljs-number">60</span>, TimeUnit.SECONDS);　 <span class="hljs-comment">// 调度任务在从现在开始的60 秒之后执行</span><br></code></pre></td></tr></table></figure><p>使用EventLoop调度周期性任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Channel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> ...<br>ScheduledFuture&lt;?&gt; future = ch.eventLoop().scheduleAtFixedRate( <span class="hljs-comment">// 创建一个Runnable，以供调度稍后执行 </span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; 　<br><span class="hljs-meta">@Override</span> 　<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; 　<br>System.out.println(<span class="hljs-string">&quot;Run every 60 seconds&quot;</span>);　 <span class="hljs-comment">// 这将一直运行，直到ScheduledFuture 被取消 　</span><br>&#125; <br>&#125;, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>, TimeUnit.Seconds);　 <span class="hljs-comment">// 调度在60 秒之后，并且以后每间隔60 秒运行</span><br></code></pre></td></tr></table></figure><p>使用ScheduledFuture取消任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFuture&lt;?&gt; future = ch.eventLoop().scheduleAtFixedRate(...); <span class="hljs-comment">// 调度任务，并获得所返回的ScheduledFuture </span><br><span class="hljs-comment">// Some other code that runs... </span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">mayInterruptIfRunning</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <br>future.cancel(mayInterruptIfRunning);　 <span class="hljs-comment">// 取消该任务，防止它再次运行</span><br></code></pre></td></tr></table></figure><h1 id="4-实现细节"><a href="#4-实现细节" class="headerlink" title="4. 实现细节"></a>4. 实现细节</h1><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><p>每个EventLoop都有它自已的任务队列，独立于任何其他的EventLoop。</p><p><img src="https://s2.loli.net/2025/03/15/xYCOK7vqPD5oTib.png" alt="image.png"></p><blockquote><p>永远不要将一个长时间运行的任务放入到执行队列中，因为它将阻塞需要在同一线程上执行的任何其他任务。如果必须要进行阻塞调用或者执行长时间运行的任务，我们建议使用一个专门的EventExecutor。​</p></blockquote><h2 id="EventLoop-线程的分配"><a href="#EventLoop-线程的分配" class="headerlink" title="EventLoop&#x2F;线程的分配"></a>EventLoop&#x2F;线程的分配</h2><p>服务于Channel的I&#x2F;O和事件的EventLoop包含在EventLoopGroup中。根据不同的传输实现，EventLoop的创建和分配方式也不同。</p><h3 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h3><p>异步传输实现只使用了少量的EventLoop（以及和它们相关联的Thread）​，而且在当前的线程模型中，它们可能会被多个Channel所共享。这使得可以通过尽可能少量的Thread来支撑大量的Channel，而不是每个Channel分配一个Thread。<br><img src="https://s2.loli.net/2025/03/18/LmuQ1rjyPTZWwEB.png" alt="image.png"></p><p>EventLoopGroup负责为每个新创建的Channel分配一个EventLoop。在当前实现中，使用顺序循环（round-robin）的方式进行分配以获取一个均衡的分布，并且<strong>相同的EventLoop可能会被分配给多个Channel</strong>。​<br><strong>一旦一个Channel被分配给一个EventLoop，它将在它的整个生命周期中都使用这个EventLoop（以及相关联的Thread）​。</strong>请牢记这一点，因为它可以使你从担忧你的Channel- Handler实现中的线程安全和同步问题中解脱出来。</p><blockquote><p>EventLoop的分配方式对ThreadLocal的使用的影响。因为一个EventLoop通常会被用于支撑多个Channel，所以对于所有相关联的Channel来说，ThreadLocal都将是一样的。这使得它对于实现状态追踪等功能来说是个糟糕的选择。然而，在一些无状态的上下文中，它仍然可以被用于在多个Channel之间共享一些重度的或者代价昂贵的对象，甚至是事件。</p></blockquote><h3 id="阻塞传输"><a href="#阻塞传输" class="headerlink" title="阻塞传输"></a>阻塞传输</h3><p><img src="https://s2.loli.net/2025/03/18/xGFgDv8w6E21HKR.png" alt="image.png"></p><p>这里每一个Channel都将被分配给一个EventLoop（以及它的Thread）​。</p><p>正如同之前一样，得到的保证是每个Channel的I&#x2F;O事件都将只会被一个Thread（用于支撑该Channel的EventLoop的那个Thread）处理。这也是另一个Netty设计一致性的例子，这种设计上的一致性对Netty的可靠性和易用性做出了巨大贡献。</p><h1 id="附：AI总结"><a href="#附：AI总结" class="headerlink" title="附：AI总结"></a>附：AI总结</h1><h3 id="1-EventLoop-的核心作用"><a href="#1-EventLoop-的核心作用" class="headerlink" title="1. EventLoop 的核心作用"></a><strong>1. EventLoop 的核心作用</strong></h3><p>EventLoop 的核心设计目标是通过<strong>单线程处理多个 Channel 的 I&#x2F;O 事件和任务</strong>，避免多线程竞争，同时减少上下文切换开销。其职责包括：</p><ol><li><p><strong>处理 I&#x2F;O 事件</strong>：如数据读取（<code>channelRead</code>）、连接建立（<code>channelActive</code>）、异常捕获（<code>exceptionCaught</code>）。</p></li><li><p><strong>执行用户任务</strong>：提交到 EventLoop 的普通任务（<code>Runnable</code>）或定时任务（<code>ScheduledFuture</code>）。</p></li><li><p><strong>管理 Channel 生命周期</strong>：将 Channel 注册到 EventLoop，并绑定到特定的线程。</p></li></ol><h3 id="2-EventLoop-的线程模型"><a href="#2-EventLoop-的线程模型" class="headerlink" title="2. EventLoop 的线程模型"></a><strong>2. EventLoop 的线程模型</strong></h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a><strong>基本结构</strong></h4><ul><li><p><strong>单线程单 EventLoop</strong>：<br>每个 EventLoop 绑定一个独立的线程（如 <code>NioEventLoop</code>），该线程负责处理所有绑定到该 EventLoop 的 Channel 的 I&#x2F;O 事件和任务。</p></li><li><p><strong>线程复用</strong>：<br>一个 EventLoop 可以管理多个 Channel（基于多路复用技术如 <code>Selector</code>），但每个 Channel 只会注册到一个 EventLoop，确保线程安全。</p></li></ul><h4 id="与-EventLoopGroup-的关系"><a href="#与-EventLoopGroup-的关系" class="headerlink" title="与 EventLoopGroup 的关系"></a><strong>与 EventLoopGroup 的关系</strong></h4><ul><li><strong>EventLoopGroup</strong>：<br>一组 EventLoop 的集合，用于分配和管理多个 EventLoop。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个包含 4 个 EventLoop 的 EventLoopGroup</span><br><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><ul><li><strong>Channel 分配规则</strong>：<br>新 Channel 会通过轮询（Round-Robin）方式分配到 EventLoopGroup 中的某个 EventLoop，确保负载均衡。</li></ul><h3 id="3-EventLoop-的工作流程"><a href="#3-EventLoop-的工作流程" class="headerlink" title="3. EventLoop 的工作流程"></a><strong>3. EventLoop 的工作流程</strong></h3><p>EventLoop 内部采用经典的 <strong>Reactor 模式</strong>，运行流程如下：</p><ol><li><p><strong>事件循环（Loop）</strong>：<br>线程持续轮询注册的 Channel 的 I&#x2F;O 事件（如 <code>OP_READ</code>、<code>OP_WRITE</code>）。</p></li><li><p><strong>事件分发</strong>：<br>当检测到事件时，触发对应的 <code>ChannelHandler</code> 处理（如 <code>channelRead()</code>）。</p></li><li><p><strong>任务执行</strong>：<br>处理完 I&#x2F;O 事件后，执行用户提交的任务队列中的任务（如 <code>Runnable</code>）。</p></li><li><p><strong>定时任务调度</strong>：<br>检查并执行到期的定时任务（如 <code>scheduleAtFixedRate()</code>）。</p></li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EventLoop</span> <span class="hljs-variable">eventLoop</span> <span class="hljs-operator">=</span> channel.eventLoop();<br><span class="hljs-comment">// 提交普通任务</span><br>eventLoop.execute(() -&gt; System.out.println(<span class="hljs-string">&quot;Task executed by EventLoop&quot;</span>));<br><span class="hljs-comment">// 提交定时任务（5秒后执行）</span><br>eventLoop.schedule(() -&gt; System.out.println(<span class="hljs-string">&quot;Delayed task&quot;</span>), <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><h3 id="4-EventLoop-的实现类"><a href="#4-EventLoop-的实现类" class="headerlink" title="4. EventLoop 的实现类"></a><strong>4. EventLoop 的实现类</strong></h3><p>Netty 提供了多种 EventLoop 实现，支持不同的 I&#x2F;O 模型：</p><ol><li><p><strong>NioEventLoop</strong>：<br>基于 Java NIO 的 <code>Selector</code> 实现，适用于大多数场景。</p></li><li><p><strong>EpollEventLoop</strong>：<br>基于 Linux 的 <code>epoll</code> 系统调用（需依赖 <code>netty-transport-native-epoll</code>），性能更高，适合 Linux 环境。</p></li><li><p><strong>KQueueEventLoop</strong>：<br>基于 BSD&#x2F;macOS 的 <code>kqueue</code> 系统调用，适用于 macOS 环境。</p></li></ol><h4 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a><strong>配置示例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 EpollEventLoopGroup（Linux 环境）</span><br><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EpollEventLoopGroup</span>();<br></code></pre></td></tr></table></figure><h3 id="5-EventLoop-的优势"><a href="#5-EventLoop-的优势" class="headerlink" title="5. EventLoop 的优势"></a><strong>5. EventLoop 的优势</strong></h3><ol><li><p><strong>高性能</strong>：单线程处理多个 Channel，减少线程切换和锁竞争。</p></li><li><p><strong>低延迟</strong>： I&#x2F;O 事件和任务在同一线程中顺序执行，避免多线程同步问题。</p></li><li><p><strong>资源高效</strong>： 少量线程即可支持高并发连接（如经典的 1 个 EventLoop 处理 10k+ 连接）。</p></li><li><p><strong>简化并发编程</strong>： 用户无需手动处理线程同步，所有绑定到同一 EventLoop 的操作都是线程安全的。</p></li></ol><h3 id="6-关键设计细节"><a href="#6-关键设计细节" class="headerlink" title="6. 关键设计细节"></a><strong>6. 关键设计细节</strong></h3><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a><strong>任务队列</strong></h4><ul><li><p>每个 EventLoop 维护一个任务队列（<code>Task Queue</code>），用于存放用户提交的 <code>Runnable</code> 任务。</p></li><li><p>任务按提交顺序执行，保证线程安全性。</p></li></ul><h4 id="Selector-空轮询-Bug-规避"><a href="#Selector-空轮询-Bug-规避" class="headerlink" title="Selector 空轮询 Bug 规避"></a><strong>Selector 空轮询 Bug 规避</strong></h4><ul><li>Netty 通过计数器和重建 Selector 的机制，规避了 Java NIO 中可能出现的 Selector 空轮询导致的 CPU 100% 问题。</li></ul><h4 id="线程绑定"><a href="#线程绑定" class="headerlink" title="线程绑定"></a><strong>线程绑定</strong></h4><ul><li><p>EventLoop 的线程在首次执行任务时才会启动（懒加载），且一旦启动不会更换线程。</p></li><li><p>所有与 Channel 相关的操作必须由绑定的 EventLoop 线程执行，否则 Netty 会将任务转发到正确的线程。</p></li></ul><h3 id="7-典型应用场景"><a href="#7-典型应用场景" class="headerlink" title="7. 典型应用场景"></a><strong>7. 典型应用场景</strong></h3><ol><li><p><strong>高并发服务器</strong>： 如 HTTP 服务器、游戏服务器，通过少量 EventLoop 线程处理海量连接。</p></li><li><p><strong>实时通信</strong>： WebSocket 或自定义协议，利用 EventLoop 的低延迟特性。</p></li><li><p><strong>任务调度</strong>： 替代 <code>ScheduledExecutorService</code>，统一管理定时任务和 I&#x2F;O 事件。</p></li></ol><h3 id="8-最佳实践"><a href="#8-最佳实践" class="headerlink" title="8. 最佳实践"></a><strong>8. 最佳实践</strong></h3><ol><li><p><strong>避免阻塞 EventLoop 线程</strong>： 不要在 <code>ChannelHandler</code> 中执行耗时操作（如数据库查询），否则会阻塞整个 EventLoop。</p></li><li><p><strong>合理配置线程数</strong>： EventLoopGroup 的线程数通常设置为 CPU 核心数 * 2（根据 I&#x2F;O 密集或计算密集调整）。</p></li><li><p><strong>使用业务线程池</strong>： 耗时任务应提交到独立的业务线程池，避免影响 EventLoop。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>backend</category>
      
      <category>Netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty in Action 6 - ChannelHandler &amp; ChannelPipeline</title>
    <link href="/posts/ab126a8f.html"/>
    <url>/posts/ab126a8f.html</url>
    
    <content type="html"><![CDATA[<h1 id="ChannelHandler家族"><a href="#ChannelHandler家族" class="headerlink" title="ChannelHandler家族"></a>ChannelHandler家族</h1><h2 id="The-Channel-lifecycle"><a href="#The-Channel-lifecycle" class="headerlink" title="The Channel lifecycle"></a>The Channel lifecycle</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelLifecycleHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRegistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        <span class="hljs-comment">// Channel 注册到 EventLoop</span><br>      <br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        <span class="hljs-comment">// Channel 激活，可以进行I/O操作</span><br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        <span class="hljs-comment">// Channel 不活跃，无法进行I/O操作</span><br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelUnregistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        <span class="hljs-comment">// Channel 从 EventLoop 中注销</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>As these state changes occur, corresponding events are generated. These are forwarded to ChannelHandlers in the ChannelPipeline, which can then act on them.</p><h2 id="The-ChannelHandler-lifecycle"><a href="#The-ChannelHandler-lifecycle" class="headerlink" title="The ChannelHandler lifecycle"></a>The ChannelHandler lifecycle</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LifecycleHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        <span class="hljs-comment">// Handler 被添加到 pipeline 时调用</span><br>        System.out.println(<span class="hljs-string">&quot;Handler added&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        <span class="hljs-comment">// Handler 从 pipeline 中移除时调用</span><br>        System.out.println(<span class="hljs-string">&quot;Handler removed&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;<br>        <span class="hljs-comment">// 处理过程中发生异常时调用</span><br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ChannelInboundHandler"><a href="#ChannelInboundHandler" class="headerlink" title="ChannelInboundHandler"></a>ChannelInboundHandler</h3><p>Processes inbound data and state changes of all kinds.</p><ul><li>从前到后执行</li><li>主要用于解码和业务处理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomInboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>    <span class="hljs-comment">// 读取数据</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 处理接收到的数据</span><br>            processInboundMessage(msg);<br>            <br>            <span class="hljs-comment">// 传递给下一个handler</span><br>            ctx.fireChannelRead(msg);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ReferenceCountUtil.release(msg);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 读取完成</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        ctx.flush();<br>        ctx.fireChannelReadComplete();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 连接建立</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Connection established&quot;</span>);<br>        ctx.fireChannelActive();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 连接断开</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Connection closed&quot;</span>);<br>        ctx.fireChannelInactive();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 异常处理</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>如果用<code>SimpleChannelInboundHandler</code>，它会自动完成资源的释放。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleDiscardHandler</span> <br>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;Object&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>        <span class="hljs-comment">// No need to do anything special</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="ChannelOutboundHandler"><a href="#ChannelOutboundHandler" class="headerlink" title="ChannelOutboundHandler"></a>ChannelOutboundHandler</h3><p>Processes outbound data and allows interception of all operations.</p><ul><li>从后到前执行</li><li>主要用于编码和发送前处理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomOutboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span> &#123;<br>    <span class="hljs-comment">// 写数据</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, </span><br><span class="hljs-params">                     ChannelPromise promise)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 处理要发送的数据</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">processedMsg</span> <span class="hljs-operator">=</span> processOutboundMessage(msg);<br>            <br>            <span class="hljs-comment">// 继续传递</span><br>            ctx.write(processedMsg, promise);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            promise.setFailure(e);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 刷新</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        ctx.flush();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 连接</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(ChannelHandlerContext ctx, </span><br><span class="hljs-params">                       SocketAddress remoteAddress,</span><br><span class="hljs-params">                       SocketAddress localAddress, </span><br><span class="hljs-params">                       ChannelPromise promise)</span> &#123;<br>        <span class="hljs-comment">// 处理连接</span><br>        ctx.connect(remoteAddress, localAddress, promise);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 断开连接</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">disconnect</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> &#123;<br>        ctx.disconnect(promise);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 关闭</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> &#123;<br>        ctx.close(promise);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>ChannelPromise与ChannelFuture</p><p>ChannelOutboundHandler中的大部分方法都需要一个ChannelPromise参数，以便在操作完成时得到通知。ChannelPromise是ChannelFuture的一个子类，其定义了一些可写的方法，如setSuccess()和setFailure()，从而使ChannelFuture不可变。</p></blockquote><p>Channel和ChannelPipeline的事件流是从头到尾的；<br>ChannelHandlerContext的事件流是从当前ChannelHandler开始往后的。</p><h3 id="ChannelHandlerAdapter"><a href="#ChannelHandlerAdapter" class="headerlink" title="ChannelHandlerAdapter"></a>ChannelHandlerAdapter</h3><p>ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter类分别提供了ChannelInboundHandler和ChannelOutboundHandler的基本实现。</p><p><img src="https://s2.loli.net/2025/03/12/kJPd9S5a8Vmvywc.png" alt="image.png"></p><p>ChannelHandlerAdapter还提供了实用方法isSharable()。如果其对应的实现被标注为Sharable，那么这个方法将返回true，表示它可以被添加到多个ChannelPipeline中。</p><p>在ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter中所提供的方法体调用了其相关联的ChannelHandlerContext上的等效方法，从而将事件转发到了ChannelPipeline中的下一个ChannelHandler中。</p><h1 id="ChannelPipeline接口"><a href="#ChannelPipeline接口" class="headerlink" title="ChannelPipeline接口"></a>ChannelPipeline接口</h1><p>ChannelPipeline是一个拦截流经Channel的入站和出站事件的ChannelHandler实例链。</p><p>每一个新创建的Channel都将会被分配一个新的ChannelPipeline。这项关联是永久性的；Channel既不能附加另外一个ChannelPipeline，也不能分离其当前的。在Netty组件的生命周期中，这是一项固定的操作，不需要开发人员的任何干预。</p><p>根据事件的起源，事件将会被ChannelInboundHandler或者ChannelOutboundHandler处理。随后，通过调用ChannelHandlerContext实现，它将被转发给同一超类型的下一个ChannelHandler。</p><p><img src="https://s2.loli.net/2025/03/12/28wICQaWAtldJNn.png" alt="image.png"></p><p>在ChannelPipeline传播事件时，它会测试ChannelPipeline中的下一个ChannelHandler的类型是否和事件的运动方向相匹配。如果不匹配，ChannelPipeline将跳过该ChannelHandler并前进到下一个，直到它找到和该事件所期望的方向相匹配的为止。​（当然，ChannelHandler也可以同时实现ChannelInboundHandler接口和ChannelOutboundHandler接口。​）</p><p>ChannelHandler可以通过添加、删除或者替换其他的ChannelHandler来实时地修改ChannelPipeline的布局。​（它也可以将它自己从ChannelPipeline中移除。​）这是Channel- Handler最重要的能力之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ..;<br><span class="hljs-type">FirstHandler</span> <span class="hljs-variable">firstHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FirstHandler</span>(); ← -- 创建一个FirstHandler 的实例 pipeline.addLast(<span class="hljs-string">&quot;handler1&quot;</span>, firstHandler);　 ← -- 将该实例作为<span class="hljs-string">&quot;handler1&quot;</span> 添加到ChannelPipeline 中 <br>pipeline.addFirst(<span class="hljs-string">&quot;handler2&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondHandler</span>());　 ← -- 将一个SecondHandler的实例作为<span class="hljs-string">&quot;handler2&quot;</span>添加到ChannelPipeline的第一个槽中。这意味着它将被放置在已有的<span class="hljs-string">&quot;handler1&quot;</span>之前 <br>pipeline.addLast(<span class="hljs-string">&quot;handler3&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThirdHandler</span>());　 ← -- 将一个ThirdHandler 的实例作为<span class="hljs-string">&quot;handler3&quot;</span>添加到ChannelPipeline 的最后一个槽中　 <br>...<br>pipeline.remove(<span class="hljs-string">&quot;handler3&quot;</span>);　 ← -- 通过名称移除<span class="hljs-string">&quot;handler3&quot;</span>　 <br>pipeline.remove(firstHandler);　 ← -- 通过引 用移除FirstHandler（它是唯一的，所以不需要它的名称）　<br>pipeline.replace(<span class="hljs-string">&quot;handler2&quot;</span>, <span class="hljs-string">&quot;handler4&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForthHandler</span>()); ← -- 将SecondHandler(<span class="hljs-string">&quot;handler2&quot;</span>)替换为FourthHandler:<span class="hljs-string">&quot;handler4&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>ChannelHandler的执行和阻塞<br>通常ChannelPipeline中的每一个ChannelHandler都是通过它的EventLoop（I&#x2F;O线程）来处理传递给它的事件的。所以至关重要的是不要阻塞这个线程，因为这会对整体的I&#x2F;O处理产生负面的影响。<br>但有时可能需要与那些使用阻塞API的遗留代码进行交互。对于这种情况，ChannelPipeline有一些接受一个EventExecutorGroup的add()方法。如果一个事件被传递给一个自定义的EventExecutorGroup，它将<strong>被包含在这个EventExecutorGroup中的某个EventExecutor所处理</strong>，从而<strong>被从该Channel本身的EventLoop中移除</strong>。对于这种用例，Netty提供了一个叫DefaultEventExecutorGroup的默认实现。</p></blockquote><p>总结一下：</p><ul><li>ChannelPipeline保存了与Channel相关联的ChannelHandler；</li><li>ChannelPipeline可以根据需要，通过添加或者删除ChannelHandler来动态地修改；</li><li>ChannelPipeline有着丰富的API用以被调用，以响应入站和出站事件。</li></ul><h1 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h1><p><img src="https://s2.loli.net/2025/03/12/D9ZHiyL7oS16CAn.png" alt="image.png"><br>ChannelHandlerContext代表了ChannelHandler和ChannelPipeline之间的关联，每当有ChannelHandler添加到ChannelPipeline中时，都会创建ChannelHandlerContext。ChannelHandlerContext的主要功能是管理它所关联的ChannelHandler和在同一个ChannelPipeline中的其他ChannelHandler之间的交互。<br>ChannelHandler可以通知其所属的ChannelPipeline中的下一个ChannelHandler，甚至可以动态修改它所属的ChannelPipeline。</p><p>ChannelHandlerContext有很多的方法，其中一些方法也存在于Channel和ChannelPipeline本身上，但是有一点重要的不同。</p><ul><li>如果调用Channel或者ChannelPipeline上的这些方法，它们将沿着<strong>整个ChannelPipeline</strong>进行传播。</li><li>而调用位于ChannelHandlerContext上的相同方法，则将从<strong>当前所关联的ChannelHandler</strong>开始，并且只会传播给位于该ChannelPipeline中的<strong>下一个</strong>能够处理该事件的ChannelHandler。</li></ul><p>为什么会想要从ChannelPipeline中的某个特定点开始传播事件呢？</p><ul><li>为了减少将事件传经对它不感兴趣的ChannelHandler所带来的开销。</li><li>为了避免将事件传经那些可能会对它感兴趣的ChannelHandler。</li></ul><p>当使用ChannelHandlerContext的API的时候，请牢记以下两点：</p><ul><li>ChannelHandlerContext和ChannelHandler之间的关联（绑定）是永远不会改变的，所以缓存对它的引用是安全的；</li><li>如同我们在本节开头所解释的一样，相对于其他类的同名方法，ChannelHandlerContext的方法将产生更短的事件流，应该尽可能地利用这个特性来获得最大的性能。</li></ul><p>只应该在确定了你的ChannelHandler是线程安全的时才使用@Sharable注解。</p><p>为何要共享同一个ChannelHandler？<br>在多个ChannelPipeline中安装同一个ChannelHandler的一个常见的原因是用于收集跨越多个Channel的统计信息。</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="入站异常"><a href="#入站异常" class="headerlink" title="入站异常"></a>入站异常</h2><p>需要在ChannelInboundHandler实现中重写下面的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InboundExceptionHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123; 　　　<br>cause.printStackTrace();<br>ctx.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为异常将会继续按照入站方向流动（就像所有的入站事件一样）​，所以实现了前面所示逻辑的ChannelInboundHandler通常位于ChannelPipeline的最后。这确保了所有的入站异常都总是会被处理，无论它们可能会发生在ChannelPipeline中的什么位置。</p><ul><li>ChannelHandler.exceptionCaught()的默认实现是简单地将当前异常转发给ChannelPipeline中的下一个ChannelHandler；</li><li>如果异常到达了ChannelPipeline的尾端，它将会被记录为未被处理；</li><li>要想定义自定义的处理逻辑，你需要重写exceptionCaught()方法。然后你需要决定是否需要将该异常传播出去。</li></ul><h2 id="出站异常"><a href="#出站异常" class="headerlink" title="出站异常"></a>出站异常</h2><p>用于处理出站操作中的正常完成以及异常的选项，都基于以下的通知机制。</p><p>每个出站操作都将返回一个ChannelFuture。注册到ChannelFuture的Channel-FutureListener将在操作完成时被通知该操作是成功了还是出错了。</p><p>几乎所有的ChannelOutboundHandler上的方法都会传入一个ChannelPromise的实例。作为ChannelFuture的子类，ChannelPromise也可以被分配用于异步通知的监听器。但是，ChannelPromise还具有提供立即通知的可写方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ChannelPromise <span class="hljs-title function_">setSuccess</span><span class="hljs-params">()</span>;<br>ChannelPromise <span class="hljs-title function_">setFailure</span><span class="hljs-params">(Throwable cause)</span>;<br></code></pre></td></tr></table></figure><p>添加ChannelFutureListener只需要调用ChannelFuture实例上的addListener(ChannelFutureListener)方法。</p><p>第一种（最常用的）方式是，调用出站操作（如write()方法）所返回的ChannelFuture上的addListener()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> channel.write(someMessage); <br>future.addListener(<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture f)</span> &#123;<br><span class="hljs-keyword">if</span> (!f.isSuccess()) &#123;<br>f.cause().printStackTrace();<br>f.channel().close();<br>&#125; <br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>第二种方式是将ChannelFutureListener添加到即将作为参数传递给ChannelOutboundHandler的方法的ChannelPromise。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutboundExceptionHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span> &#123; 　<br><span class="hljs-meta">@Override</span> 　<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> &#123; <br>promise.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123; 　　　<br><span class="hljs-meta">@Override</span> 　　　<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture f)</span> &#123; 　　<br><span class="hljs-keyword">if</span> (!f.isSuccess()) &#123; 　　<br>f.cause().printStackTrace(); 　　　　　<br>f.channel().close(); 　　　　　　<br>&#125; 　　　　<br>&#125; 　　　<br>&#125;); 　<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于细致的异常处理，第一种方式，在调用出站操作时添加ChannelFutureListener更合适。<br>而对于一般的异常处理，第二种方式，自定义的ChannelOutboundHandler实现的方式更加的简单。</p><p>如果你的ChannelOutboundHandler本身抛出了异常会发生什么呢？在这种情况下，Netty本身会通知任何已经注册到对应ChannelPromise的监听器。</p>]]></content>
    
    
    <categories>
      
      <category>backend</category>
      
      <category>Netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty in Action 5 - ByteBuf</title>
    <link href="/posts/60d194bc.html"/>
    <url>/posts/60d194bc.html</url>
    
    <content type="html"><![CDATA[<p>The main points we covered in this chapter:</p><ul><li>The use of distinct read and write indices to control data access</li><li>Different approaches to memory usage—backing arrays and direct buffers</li><li>The aggregate view of multiple ByteBufs using CompositeByteBuf</li><li>Data-access methods: searching, slicing, and copying</li><li>The read, write, get, and set APIs</li><li>ByteBufAllocator pooling and reference counting</li></ul><h2 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h2><p>Some of the advantages of the <code>ByteBuf</code> API:</p><ul><li>It’s extensible to user-defined buffer types.</li><li>Transparent zero-copy is achieved by a built-in composite buffer type.</li><li>Capacity is expanded on demand (as with the JDK StringBuilder).</li><li>Switching between reader and writer modes doesn’t require calling ByteBuffer’s<br>flip() method.</li><li>Reading and writing employ distinct indices.</li><li>Method chaining is supported.</li><li>Reference counting is supported.</li><li>Pooling is supported.</li></ul><h2 id="Usage-Patterns"><a href="#Usage-Patterns" class="headerlink" title="Usage Patterns"></a>Usage Patterns</h2><p>Netty的ByteBuf有三种使用模式(Usage Patterns)，分别是堆缓冲区(Heap Buffer)、直接缓冲区(Direct Buffer)和复合缓冲区(Composite Buffer)。</p><h3 id="堆缓冲区-Heap-Buffer"><a href="#堆缓冲区-Heap-Buffer" class="headerlink" title="堆缓冲区(Heap Buffer)"></a>堆缓冲区(Heap Buffer)</h3><ul><li>最常用的类型。</li><li>ByteBuf的backing array是指ByteBuf底层的字节数组。它只在堆缓冲区(HeapByteBuf)中可用，直接缓冲区(DirectByteBuf)没有backing array。</li></ul><p>特点：</p><ul><li>数据存储在JVM堆中</li><li>可以快速分配和释放</li><li>会受到GC影响<ul><li>创建和销毁速度快</li><li>读写操作时需要复制到直接缓冲区，有额外开销</li></ul></li><li>适合小数据量、临时存储<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建堆缓冲区</span><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">heapBuf</span> <span class="hljs-operator">=</span> Unpooled.buffer();  <span class="hljs-comment">// 非池化</span><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">pooledHeapBuf</span> <span class="hljs-operator">=</span> PooledByteBufAllocator.DEFAULT.heapBuffer(); <span class="hljs-comment">// 池化</span><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-type">byte</span>[] array;<br><span class="hljs-keyword">if</span> (heapBuf.hasArray()) &#123;<br>    array = heapBuf.array(); <span class="hljs-comment">// 可以直接访问</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> heapBuf.arrayOffset() + heapBuf.readerIndex();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> heapBuf.readableBytes();<br>    handleArray(array, offset, length);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="直接缓冲区-Direct-Buffer"><a href="#直接缓冲区-Direct-Buffer" class="headerlink" title="直接缓冲区(Direct Buffer)"></a>直接缓冲区(Direct Buffer)</h3><p>特点</p><ul><li>数据存储在堆外内存</li><li>IO操作效率高，适合频繁IO操作</li><li>分配和释放较慢</li><li>不受GC影响</li><li>适合长生命周期的大数据量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建直接缓冲区</span><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">directBuf</span> <span class="hljs-operator">=</span> Unpooled.directBuffer();  <span class="hljs-comment">// 非池化</span><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">pooledDirectBuf</span> <span class="hljs-operator">=</span> PooledByteBufAllocator.DEFAULT.directBuffer(); <span class="hljs-comment">// 池化</span><br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">if</span> (!directBuf.hasArray()) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> directBuf.readableBytes();<br>    <span class="hljs-type">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>    directBuf.getBytes(directBuf.readerIndex(), array); <span class="hljs-comment">// 需要拷贝回来</span><br>    handleArray(array, <span class="hljs-number">0</span>, length);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="复合缓冲区-Composite-Buffer"><a href="#复合缓冲区-Composite-Buffer" class="headerlink" title="复合缓冲区(Composite Buffer)"></a>复合缓冲区(Composite Buffer)</h3><ul><li>CompositeByteBuf 的 hasArray() 返回值取决于其组成部分的类型。只有当所有组件都是 HeapByteBuf 时，CompositeByteBuf 才有 backing array。</li></ul><p>特点</p><ul><li>将多个ByteBuf组合成一个逻辑上的ByteBuf</li><li>避免内存拷贝</li><li>支持动态添加或删除组件</li><li>适合需要组合多个缓冲区的场景<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建复合缓冲区</span><br><span class="hljs-type">CompositeByteBuf</span> <span class="hljs-variable">compositeBuf</span> <span class="hljs-operator">=</span> Unpooled.compositeBuffer();<br><br><span class="hljs-comment">// 添加缓冲区</span><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">headerBuf</span> <span class="hljs-operator">=</span> ...;  <span class="hljs-comment">// 消息头</span><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">bodyBuf</span> <span class="hljs-operator">=</span> ...;    <span class="hljs-comment">// 消息体</span><br>compositeBuf.addComponents(headerBuf, bodyBuf);<br><br><span class="hljs-comment">// 访问数据</span><br><span class="hljs-keyword">if</span> (!compBuf.hasArray()) &#123;  <span class="hljs-comment">// 可能是true也可能是false</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> compBuf.readableBytes();<br>    <span class="hljs-type">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>    compBuf.getBytes(compBuf.readerIndex(), array);<br>    handleArray(array, <span class="hljs-number">0</span>, length);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="应用场景参考"><a href="#应用场景参考" class="headerlink" title="应用场景参考"></a>应用场景参考</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageHandler</span> &#123;<br>    <span class="hljs-comment">// 处理小消息，使用堆缓冲区</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleSmallMessage</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">heapBuf</span> <span class="hljs-operator">=</span> Unpooled.buffer(data.length);<br>        heapBuf.writeBytes(data);<br>        <span class="hljs-keyword">try</span> &#123;<br>            processMessage(heapBuf);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            heapBuf.release();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 处理大文件，使用直接缓冲区</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleLargeFile</span><span class="hljs-params">(FileChannel fileChannel)</span> &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">directBuf</span> <span class="hljs-operator">=</span> Unpooled.directBuffer();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (fileChannel.read(directBuf.nioBuffer()) != -<span class="hljs-number">1</span>) &#123;<br>                processChunk(directBuf);<br>                directBuf.clear();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            directBuf.release();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 消息组装，使用复合缓冲区</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">assembleMessage</span><span class="hljs-params">(ByteBuf header, ByteBuf body)</span> &#123;<br>        <span class="hljs-type">CompositeByteBuf</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> Unpooled.compositeBuffer();<br>        <span class="hljs-keyword">try</span> &#123;<br>            message.addComponents(<span class="hljs-literal">true</span>, header, body);<br>            sendMessage(message);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            message.release();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ByteBufAllocator"><a href="#ByteBufAllocator" class="headerlink" title="ByteBufAllocator"></a>ByteBufAllocator</h2><p>Netty provides two implementations of ByteBufAllocator: <code>PooledByteBufAllocator</code> and <code>UnpooledByteBufAllocator</code>.<br>The former pools ByteBuf instances to improve performance and minimize memory fragmentation. This implementation uses an efficient approach to memory allocation known as jemalloc4 that has been adopted by a number of modern OSes.<br>The latter implementation doesn’t pool ByteBuf instances and returns a new instance every time it’s called.</p><p>使用ByteBufAllocator的优势：</p><ul><li>支持内存池化</li><li>更好的内存管理</li><li>更高的性能</li><li>更灵活的配置选项</li><li>更好的资源重用</li></ul><p>最佳实践：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferAllocatorUsage</span> &#123;<br>    <span class="hljs-comment">// 1. 有Channel上下文时</span><br>    <span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title function_">withContext</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        <span class="hljs-keyword">return</span> ctx.alloc().buffer();<br>    &#125;<br>    <span class="hljs-comment">// 或者Channel</span><br>    <span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title function_">withChannel</span><span class="hljs-params">(Channel channel)</span> &#123;<br>        <span class="hljs-keyword">return</span> channel.alloc().buffer();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 有明确的分配器配置时</span><br>    <span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title function_">withAllocator</span><span class="hljs-params">(ByteBufAllocator allocator)</span> &#123;<br>        <span class="hljs-keyword">return</span> allocator.buffer();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. 简单的独立工具方法</span><br>    <span class="hljs-keyword">public</span> ByteBuf <span class="hljs-title function_">standalone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Unpooled.buffer();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>backend</category>
      
      <category>Netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>期权投资策略2 - 卖出备兑看涨期权</title>
    <link href="/posts/f302f546.html"/>
    <url>/posts/f302f546.html</url>
    
    <content type="html"><![CDATA[<p>卖出备兑看涨期权，对标的股票应当是稍微看多的，至少是中性的。通过卖出call，投资者可以降低持股风险。如果股票由于某种原因下跌，至少还可以从卖出的call中获得一定的收益。但卖出备兑看涨期权限制了也限制了股票大幅上涨情况下的潜在盈利。</p><h1 id="1-卖出备兑看涨期权的重要性"><a href="#1-卖出备兑看涨期权的重要性" class="headerlink" title="1. 卖出备兑看涨期权的重要性"></a>1. 卖出备兑看涨期权的重要性</h1><ol><li>对下行风险的保护：相比不卖call的情况，多收取了call的权利金，减少了总亏损。<ol><li>之后的操作：可以考虑再卖出一手call</li></ol></li><li>股价适度上涨时（未涨到行权价）：call的权利金完全收取到，且不用行权（还有股票上涨的一小部分利润）</li><li>股价大幅上涨时：call的权利金完全收取到，并赚取股价与行权价之间的差价。</li></ol><p>下面的公式总结了卖出备兑看涨期权的潜在盈利和盈亏平衡点：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">最大潜在盈利 </span>=<span class="hljs-string"> 行权价 - 股价 + 看涨期权价格</span><br><span class="hljs-string">下行盈亏平衡点 = 行权价 - 看涨期权价格</span><br></code></pre></td></tr></table></figure><p>图形：<br><img src="https://s2.loli.net/2025/03/06/hzic5mvRqeXjSn8.png" alt="image.png"></p><h1 id="2-卖出备兑看涨期权的哲学"><a href="#2-卖出备兑看涨期权的哲学" class="headerlink" title="2. 卖出备兑看涨期权的哲学"></a>2. 卖出备兑看涨期权的哲学</h1><p>相对于实值卖出备兑来说，虚值卖出备兑能提供更高的潜在收益，但对风险的保护程度则较低。根据在建立合约时该看涨期权实值或虚值的程度，投资者可以建立一个进攻型或防守型的卖出备兑头寸。实值卖出更多地是防守型卖出备兑头寸。</p><p>#3. 卖出备兑的总收益的概念</p><p>实值卖出备兑则更像是一个“总的”头寸，能从相对大的期权权利金中得到好处。如果股价下跌，这个头寸仍然可以盈利，事实上，它甚至可能获得最大盈利。当然，如果股价上涨，实值卖出备兑也可以赚钱，只是其盈利的百分比一般没有虚值卖出备兑的那么大。</p><p>有的备兑卖出者不愿意因为行权而失去他们的股票，因此，他们常常卖出深度虚值的看涨期权，以减小在到期日被指派的可能性。这样的哲学，与其说是在操作卖出备兑策略，不如说是一个股票持有者在就自己所持有的股票而交易期权。</p><p>真正的保守型的卖出备兑是指总头寸是保守的——它的风险更小而盈利的可能性更高。在实值卖出中，即使股票自身不是保守型的，如果期权选择得当，也可以变成一个保守型的总头寸。 </p><h1 id="4-计算投资收益"><a href="#4-计算投资收益" class="headerlink" title="4. 计算投资收益"></a>4. 计算投资收益</h1><p>在建立头寸之前，有三个关于卖出备兑的基本因素需要计算。</p><ul><li>第一个因素是行权收益（return if exercise）。这是在股票被交割的情况下卖出者会得到的投资收益。</li><li>更有利的方法是计算无变化时收益（return if unchanged），即如果期权到期时标的股价不变时的收益。此时，投资者可以使用股价不变收益来对虚值和实值卖出备兑做更公平的比较，这时对股价变动就没有做过多的假设。</li><li>备兑卖出者应当考虑的第三个重要的统计数据是在考虑了所有费用之后的下行盈亏平衡点（downside break-even point）。</li></ul><p>在计算时，手续费也需要被考虑进收益内。备兑期权的卖出者需要记住这一点，更低的手续费率当然会带来更高的收益。</p><h1 id="5-卖出备兑指令的执行"><a href="#5-卖出备兑指令的执行" class="headerlink" title="5. 卖出备兑指令的执行"></a>5. 卖出备兑指令的执行</h1><p>在建立卖出备兑头寸的时候，通常会有这样的问题：应当先交易哪一个？先买股票还是先卖期权？正确的答案是，哪一个都不应当先交易。事实上，想要让卖出备兑的双边都以期望的价格成交，唯一的办法就是同时买入股票和卖出期权。<br>如果先建了一条“腿”​，即先买入了股票，然后再设法卖出期权，或者是反过来，那么投资者就将自己置于风险之中。</p><blockquote><p>最好将卖出备兑头寸视为一个整体的头寸。尤其是实值。</p></blockquote><h1 id="6-选择卖出备兑头寸"><a href="#6-选择卖出备兑头寸" class="headerlink" title="6. 选择卖出备兑头寸"></a>6. 选择卖出备兑头寸</h1><p>由于大多数投资者进行卖出备兑的主要目的都是想在持有股票的同时增加收入，因此在选择卖出哪个期权时，投资的收益就是一个重要的考虑因素。但是，这个决定不能仅考虑收益。股票的波动率越大，所提供的收益就越高，但相应的风险也就越大，因为它们的价格有迅速下跌的可能性。因此，在卖出备兑上，对价格下行的保护也是一个重要的目标。最后，标的股票自身的质量以及它的技术面和基本面的前景也很重要。</p><h2 id="预计收益"><a href="#预计收益" class="headerlink" title="预计收益"></a>预计收益</h2><p>在确定什么是最低的可接受的收益时，一个普遍的规则是，<strong>只有在股价不变收益每个月至少为1%时，才考虑进行卖出备兑交易。</strong></p><ul><li>对于卖出实值备兑期权来说，如果股价上升、保持不变，或者甚至在到期日时略微跌了一点儿，它都能够实现预期的收益。</li><li>对于卖出虚值备兑期权来说，如果股价上升，那就有可能获得更高的潜在收益。但是，如果股价保持不变或者下跌，那么其表现一般而言就要比卖出实值要差。</li></ul><h2 id="策略的重要性"><a href="#策略的重要性" class="headerlink" title="策略的重要性"></a>策略的重要性</h2><p>使用一两个按顺序排列的卖出备兑头寸的名单，每天利用计算机对下面的类别之一或同时进行排序，来帮助建立最有吸引力的保守型卖出备兑。一个名单应当在固定最小下行保护水平（如10%）的情况下，对年化收益进行排序。另一个名单应当在固定可接受的股价不变收益（如12%）的情况下，对下行保护百分比进行排序。</p><p>根据某些数学上的分析，我们有理由相信，在长期中，卖出适度虚值备兑的表现要好于卖出实值备兑。</p><p>在选择卖出备兑上最后一个重要的考虑因素是标的股票自身。建立一个卖出备兑头寸，并不一定是对标的股票看多的。只要不预期标的股票会下跌，就可以建立卖出备兑的头寸。一般而言，如果某个投资者对标的股票的看法是中性或者稍微看多的，那就最好不过了。</p><p>某个卖出备兑的策略家所要达到的结果，是在可接受的收益与下行保护之间寻找一种平衡。在这两者之中，如果有哪一个不能满足他的要求，他就不应当建立这样的策略。如果他对某只股票是看空的，他也不会建立这样的策略。从这点出发，卖出备兑所达到的结果就是某个保守型的卖出备兑程序所要实现的目的：<strong>为某个波动较小的投资组合增加收益，提供保护，降低组合波动率。</strong></p><h1 id="7-就已持有的股票卖出备兑"><a href="#7-就已持有的股票卖出备兑" class="headerlink" title="7. 就已持有的股票卖出备兑"></a>7. 就已持有的股票卖出备兑</h1><p>关于换股：</p><ul><li>可能换成了一个波动更大且不支付股息的股票。虽然静态的卖出备兑收益可能较高，但在做出最终决定时，应该考虑到以波动率为基础来计算的风险。</li><li>卖出者需要寻找能带来最佳总收益的卖出备兑。事实上，月复一月，季复一季，即使没有收益也只就已持有的股票进行卖出备兑，很可能是个错误。</li></ul><p>如果某个投资者不想卖出自己的股票，那么在就这些股票卖出看涨期权时，他就必须非常小心。如果某个投资者因为某种原因（例如税收考虑或是感情上不舍得等）而不能卖出股票时，他就确实不应当就这样的股票卖出看涨期权。对这样的股票持有者来说，买入保护性看跌期权（后文会讨论）也许会是一个更好的策略。</p><h1 id="8-在卖出备兑中对收益和保护分散化"><a href="#8-在卖出备兑中对收益和保护分散化" class="headerlink" title="8. 在卖出备兑中对收益和保护分散化"></a>8. 在卖出备兑中对收益和保护分散化</h1><h2 id="一半实值一半虚值（不同行权价）"><a href="#一半实值一半虚值（不同行权价）" class="headerlink" title="一半实值一半虚值（不同行权价）"></a>一半实值一半虚值（不同行权价）</h2><p>为了尽可能达到分散化的目的，卖出者通常可以对他一半的头寸就一只股票卖出虚值的看涨期权，再对另一半就同一股票卖出实值的看涨期权。对下面这样的股票来说，这种方法特别具有吸引力：这种股票的虚值看涨期权看上去不能提供足够的下行保护，与此同时，它的实值看涨期权又提供不了足够的收益。</p><p>通过卖出这两种看涨期权，该卖出者就有可能解决在只卖出虚值期权或只卖出实值期权时一定会遇到的问题。由于这个“组合的”卖出备兑，当卖出者在一开始不持看空或看多立场时，他不必一定看空（卖出实值）或是看多（卖出虚值）。对一个低波动率、交易价在两个行权价之间的股票来说，这样做常常是有必要的。<br><img src="https://s2.loli.net/2025/03/12/APdi5l92yKhO7Db.png" alt="image.png"></p><h2 id="一半近期一半远期（不同存续期）"><a href="#一半近期一半远期（不同存续期）" class="headerlink" title="一半近期一半远期（不同存续期）"></a>一半近期一半远期（不同存续期）</h2><p>对于大额的持有者来说，通常所做的，不但是要至少卖出两个行权价，还要卖出不同存续期的期权，以实现分散化。例如，三分之一的头寸卖出近期看涨期权，三分之一卖出中期看涨期权，剩余三分之一卖出远期看涨期权</p><p>好处：<br>投资者不再局限于某一系列看涨期权到期时的期权权利金水平。例如，投资者卖出的全部为9个月的看涨期权，并且在它们到期时将它们挪仓，那么他就有可能接受较低的潜在收益。如果在该卖出者要卖出更多看涨期权的时候，期权权利金水平刚好较低，他将会建立一个长达9个月的低于最优值的卖出备兑头寸。<br>如果能将他的交易分散在不同的时段里，即使出现最糟糕的情形，他也只有三分之一的头寸的权利金较低。在随后的3个月里，权利金还有希望会上涨，这样，在他投资组合的下一个三分之一里，他就可以得到相对较好的权利金。</p><h1 id="9-后续行动"><a href="#9-后续行动" class="headerlink" title="9. 后续行动"></a>9. 后续行动</h1><h2 id="股价下跌时采取的保护性行动"><a href="#股价下跌时采取的保护性行动" class="headerlink" title="股价下跌时采取的保护性行动"></a>股价下跌时采取的保护性行动</h2><p>投资者面对标的股价相对显著的下跌而不采取保护性行动，就有可能遭受大笔的亏损。因为卖出备兑是一个潜在盈利有限的策略，投资者应当限制亏损，不然一次亏损可以抵消掉好几次盈利。</p><h3 id="向下挪仓"><a href="#向下挪仓" class="headerlink" title="向下挪仓"></a>向下挪仓</h3><p>通常采取的形式是买回初始卖出的看涨期权，然后再卖出另一个行权价或到期日不同的看涨期权来替代。这种类型的调整叫作<strong>挪仓行动（rolling action）</strong>。当标的股价下跌时，投资者通常买回初始的看涨期权（由于标的股价下跌了，从而获得一定的盈利），然后再以较低的行权价卖出另一种看涨期权。这就是所谓的向下挪仓（rolling down），因为新的期权的行权价较低。</p><ul><li>向下挪仓不仅能在股价进一步下跌时提供更多的保护，还能在股价稳定时产生额外的收入。如果股价进一步下跌、保持不变甚至略为上涨，向下挪仓都是有利的。</li><li>向下挪仓一般会降低卖出备兑的<strong>最大潜在盈利</strong>。不过，当一只股票在下跌时，最大盈利也许是次要的考虑。在这样的情况下，额外的下行保护常常是更紧迫的需要。</li></ul><p><img src="https://s2.loli.net/2025/03/11/YgyFbMRk24UeSIT.png" alt="image.png"></p><blockquote><p>如果投资者在买入一手看涨期权的同时卖出另一手看涨期权，他就是在执行一个价差指令。后文会对价差进行仔细讨论。不过，备兑卖出者必须意识到，在挪仓的时候，他可以下达价差指令。一般情况下，这样做可以让卖出者的指令得到更好的执行价格。</p></blockquote><h3 id="替代向下挪仓的方法"><a href="#替代向下挪仓的方法" class="headerlink" title="替代向下挪仓的方法"></a>替代向下挪仓的方法</h3><h4 id="部分向下挪仓"><a href="#部分向下挪仓" class="headerlink" title="部分向下挪仓"></a>部分向下挪仓</h4><p>备兑卖出者可以采取另一种方法来得到对市场下跌的额外保护，并且不一定需要锁定亏损。简单地说，该卖出者可以只将他的一部分卖出备兑头寸进行挪仓。</p><p>这个策略一般被称为部分向下挪仓（partial roll-down）​，其中，与更传统的全部向下挪仓（complete roll-down）不同，只有一部分初始的看涨期权向下挪仓了。</p><p>对那些想要向下挪仓但又不想锁定亏损的备兑卖出者，或者是认为股票在到期日之前会有一定反弹的人来说，应当考虑只将他的部分头寸向下挪仓。</p><h4 id="向下挪仓时利用不同的到期月系列"><a href="#向下挪仓时利用不同的到期月系列" class="headerlink" title="向下挪仓时利用不同的到期月系列"></a>向下挪仓时利用不同的到期月系列</h4><p>挪仓到更远的到期月系列的好处是可以得到更多的保护点数。当标的股票就某种技术分析或基本面分析来看变得令人担心时，人们常常采取这一行动。当使用更远期的看涨期权向下挪仓的时候，卖出者是在更长的一段时期里牺牲了他的部分潜在盈利。因此，只有当卖出者认为股票不能够保持现有的价格水平时，他才应当使用更长时期的看涨期权。<br>在向下挪仓到较远期看涨期权的情况里，尤其可以使用部分挪仓的策略。如果只是部分头寸向下挪仓，而当股价反弹时，卖出者仍然有获利的机会。</p><p>如果卖出者因为诸如标的股价突然下跌这种不受他控制的原因而不得不向下挪仓并且锁定亏损的话，事实上他可以挪仓到近期月的合约。这样他就可以在尽可能短的时间里拿回从短期看涨期权中得到的时间价值。</p><h2 id="股票上涨时采取的行动"><a href="#股票上涨时采取的行动" class="headerlink" title="股票上涨时采取的行动"></a>股票上涨时采取的行动</h2><p>一种让备兑卖出者高兴的情况是，标的股票的价格在建立了卖出备兑头寸之后上涨。这种情况下，卖出者可以决定什么都不做，让股票指派行权，从而得到建立这个头寸时所希望的收益。另一方面，如果标的股票价格上涨得非常快，卖出的看涨期权达到了持平价，卖出者也可以提前将头寸平仓，或者将看涨期权向上挪仓。</p><h3 id="向上挪仓"><a href="#向上挪仓" class="headerlink" title="向上挪仓"></a>向上挪仓</h3><p>凡是向上挪仓，总会有支出出现。也就是说，投资者必须存入额外的现金到这个卖出备兑的头寸里去。</p><p>下行盈亏平衡点在向上挪仓时向上移动的数量，总是与挪仓所需的支出数量相等。</p><p>在向上挪仓时，挪到较远的月份常常是有利的，这会减少所需的支出。</p><p><img src="https://s2.loli.net/2025/03/12/YplAg3fOs9bxQLG.png" alt="image.png"></p><p>向上挪仓增加了投资者盈利的潜在可能，但是，也增加了一旦股价朝反向运动就必须面临的风险暴露。因此，它所引进的就不仅是增进收益的可能性，还有风险因素。一般而言，如果不能承受股价至少10%的回调，那就不应当向上挪仓。</p><p>卖出备兑的初始目的在建立头寸时就已经确定。当股票上升，这些目的已经达到时，卖出者就应当仔细考虑，是否要把盈利置身于风险中。</p><blockquote><p>严重但常见的错误：<br>第一，支出（大额的）资金来买回所有的看涨期权，从而使他持有的全部股票都暴露于下跌的风险中。需要注意的是，此时的下跌可能是在前期大幅上涨，以及因为挪仓而不停支出之后发生的。<br>第二，他卖出一些无备兑的虚值看跌期权来得到收入，以减少向上挪仓所带来的支出。后一种行动比前一种更糟，因为整个头寸现在都高度依靠杠杆支撑，一旦股票价格突然下跌，就会导致可怕的损失，程度也许会严重到亏损整个账户中的资产。<br>就像命中注定似的，这样的错误通常出现在股票的价格接近或是到达顶峰的时候。快速上涨之后的下跌总是急剧和令人痛苦的。<br>要避免这类后果可能很严重的错误，最好的方法是：让股票在某一点上被指派行权。然后，使用得到的资金，要么在另一只股票上建立新的头寸，要么换一个策略来使用。</p></blockquote><h3 id="同时平仓看涨期权和股票"><a href="#同时平仓看涨期权和股票" class="headerlink" title="同时平仓看涨期权和股票"></a>同时平仓看涨期权和股票</h3><p>随着股价的上升，卖出的看涨期权将失去它的时间价值，而且有可能在持平价附近交易。卖出者此时（或许离到期日还较远）可以在持平价附近把头寸平仓，买回卖出的看涨期权且卖掉股票。</p><p>提前在持平价卖出备兑平仓的好处是，卖出者在比预期更短的时间里兑现了最大限度的收益。这样做，他就增加了这个头寸上的年化收益率。</p><p>不过这里牵涉到一些如果他把头寸持有至看涨期权到期日就不会遇到的额外开销。第一，买入期权（买回来）的手续费是一笔额外的开支。第二，他将按比行权价更高的价格卖出他的股票，因此，在这笔交易上，他也要付出略高的手续费。如果在到期日前还有股息，且他提前把卖出备兑头寸平仓，他就得不到这个股息。卖出者在提前平仓之前，应当准确地知道他的支出会是多少。</p><h1 id="10-局部抽身策略"><a href="#10-局部抽身策略" class="headerlink" title="10. 局部抽身策略"></a>10. 局部抽身策略</h1><p>当股价上涨，股票有被指派的风险时，就可以应用该策略。如果备兑卖出者希望被指派，那就没有什么问题。但在很多情况下，卖出者都希望买回看涨期权和向上挪仓。在这个策略中，<strong>部分标的股票被卖出了，收回的资金可用来买回备兑看涨期权</strong>。如果愿意的话，此时还可以卖出更高行权价的新看涨期权。</p><p>投资者是在间接地以高价卖出股票。毕竟股票已经上涨了很多，这可能是处理一些股票的好时机。</p><p>这个实践的抽身策略有一些好的特征，其中最大的一点是，投资者通过卖出少量的股票，就让自己不用再担心实值备兑看涨期权的指派问题。该策略可以在备兑看涨期权变得非常深度实值之前就使用。</p><h2 id="到期或接近到期时采取的行动"><a href="#到期或接近到期时采取的行动" class="headerlink" title="到期或接近到期时采取的行动"></a>到期或接近到期时采取的行动</h2><h3 id="向前挪仓"><a href="#向前挪仓" class="headerlink" title="向前挪仓"></a>向前挪仓</h3><p>随着到期日的临近，卖出的看涨期权的时间价值会逐渐消失，备兑卖出者常常会想要向前挪仓（roll forward，买回先前卖出的看涨期权，并卖出行权价相同的较长期看涨期权）。</p><ul><li>对实值看涨期权来说，向前挪仓的最好时间一般是当看涨期权的时间价值完全消失了的时候。</li><li>对虚值看涨期权来说，移入更远的期权系列的正确时间是当近期期权所提供的收益小于更远期看涨期权所提供的收益的时候。<blockquote><p>你可以计算卖出的看涨期权中剩余的日收益，再把它同较长期的看涨期权的日净收益加以比较。如果较长期看涨期权的日收益较高，你就应当向前挪仓。</p></blockquote></li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gauss">示例：<br>某个投资者持有一个卖出备兑头寸，其中，他就<span class="hljs-number">500</span>股<span class="hljs-built_in">XYZ</span>普通股卖出了<span class="hljs-number">5</span>手<span class="hljs-number">1</span>月<span class="hljs-number">30</span>看涨期权。目前距到期日还有<span class="hljs-number">1</span>个月，有下列的价格存在。<br><span class="hljs-built_in">XYZ</span>普通股股票　<span class="hljs-number">29.50</span><br><span class="hljs-number">1</span>月<span class="hljs-number">30</span>看涨期权　<span class="hljs-number">0.50</span><br><span class="hljs-number">4</span>月<span class="hljs-number">30</span>看涨期权　<span class="hljs-number">2.50</span><br><br>在到期日之前的剩余时间里，备兑看涨期权的卖出者只能得到<span class="hljs-number">0.50</span>点的时间价值。如果他向前挪仓到<span class="hljs-number">4</span>月<span class="hljs-number">30</span>看涨期权，他有可能会更有效地使用资金。要做真正的比较，必须从<span class="hljs-number">4</span>月<span class="hljs-number">30</span>看涨期权的权利金中减去向前挪仓的手续费。<br><br>如果保留<span class="hljs-number">1</span>月<span class="hljs-number">30</span>看涨期权，在<span class="hljs-number">1</span>月到期之前剩余的<span class="hljs-number">30</span>天里，卖出者最多可以获得<span class="hljs-number">250</span>美元。这对应平均每天<span class="hljs-number">8.33</span>美元的收益。挪仓的手续费大约是<span class="hljs-number">100</span>美元，包括买回和再卖出。目前<span class="hljs-number">4</span>月<span class="hljs-number">30</span>看涨期权的时间价值是每手<span class="hljs-number">250</span>美元，这就意味着，在<span class="hljs-number">4</span>月到期之前的<span class="hljs-number">120</span>天里，卖出者可以获得<span class="hljs-number">250</span>美元乘以<span class="hljs-number">5</span>，再减去<span class="hljs-number">100</span>美元的手续费，即<span class="hljs-number">1150</span>美元，除以<span class="hljs-number">120</span>天之后等于每天<span class="hljs-number">9.58</span>美元。因此，去掉手续费之后，<span class="hljs-number">4</span>月<span class="hljs-number">30</span>的日收益还是高于<span class="hljs-number">1</span>月<span class="hljs-number">30</span>的日收益。这时候卖出者应当将他的头寸向前挪仓。<br><br>由于向前挪仓有正的现金流（也就是说，这是一笔收入交易）​，因此这既能增加卖出者的最大潜在盈利，也能降低盈亏平衡点。在上面的示例里，向前挪仓得到的收入是<span class="hljs-number">2</span>点，因此盈亏平衡点就降低了<span class="hljs-number">2</span>点，最大潜在盈利也增加了<span class="hljs-number">2</span>点。<br></code></pre></td></tr></table></figure><h3 id="向上挪仓-1"><a href="#向上挪仓-1" class="headerlink" title="向上挪仓"></a>向上挪仓</h3><p>在到期或接近到期时，为了保留股票，投资者也许就不得不卖出高一档行权价的看涨期权。不过，这不一定是一笔支出交易。如果这只股票的波动率足够高，那投资者甚至不花钱就可以向上挪仓，有时甚至还可以得到一些收入。如果真有这样的机会，你千万不要错过。</p><h3 id="向下挪仓-1"><a href="#向下挪仓-1" class="headerlink" title="向下挪仓"></a>向下挪仓</h3><p>在到期或接近到期时的另一个选择是向下挪仓。这出现在当投资者让卖出的看涨期权无价值地到期，股票价格大幅度低于行权价的情况里。卖出者此时需要决定，究竟是卖出低权利金的虚值看涨期权还是卖出较高权利金的实值看涨期权。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gauss">示例：<br>在<span class="hljs-number">1</span>月<span class="hljs-number">25</span>看涨期权刚刚无价值地到期之后：<br><span class="hljs-built_in">XYZ</span>的价格是<span class="hljs-number">22</span><br><span class="hljs-built_in">XYZ</span> <span class="hljs-number">7</span>月<span class="hljs-number">25</span>看涨期权的价格是<span class="hljs-number">0.75</span><br><span class="hljs-built_in">XYZ</span> <span class="hljs-number">7</span>月<span class="hljs-number">20</span>看涨期权是<span class="hljs-number">3.50</span><br><br>如果这个投资者现在要卖出<span class="hljs-number">7</span>月<span class="hljs-number">25</span>看涨期权，他就只能得到<span class="hljs-number">0.75</span>点的下行保护。但是，如果<span class="hljs-built_in">XYZ</span>在到期时上涨到<span class="hljs-number">25</span>，那他的最大潜在盈利就会相当大。另一方面，价格为<span class="hljs-number">3.50</span>的<span class="hljs-number">7</span>月<span class="hljs-number">20</span>看涨期权具有很大的吸引力，它提供了相当大的下行保护，而且，它的时间价值为<span class="hljs-number">1.50</span>点，是<span class="hljs-number">7</span>月<span class="hljs-number">25</span>看涨期权的两倍。<br><br>单纯从分析的角度来看，不应当用过去的表现来作为今天决定的基础，但是，在实践中很难按这样的说法去做。如果这个投资者是用较高的价格买入<span class="hljs-built_in">XYZ</span>的，他肯定会偏向于<span class="hljs-number">7</span>月<span class="hljs-number">25</span>看涨期权。但是，如果他用与市价几乎相同的价格买入的<span class="hljs-built_in">XYZ</span>，那他在卖出<span class="hljs-number">7</span>月<span class="hljs-number">20</span>看涨期权时就不会有什么内疚心理。在这里，没有适用于所有情况的绝对规则。<br><br>不过，任何情况下，卖出能维持收益和下行保护之间最好平衡的看涨期权，往往能给投资者带来更大的好处。投资者只有在对标的股票看多（bullish）时才应当卖出<span class="hljs-number">7</span>月<span class="hljs-number">25</span>看涨期权。<br></code></pre></td></tr></table></figure><blockquote><p>看多：卖出虚值看涨期权<br>看空：卖出实值看涨期权</p></blockquote><h2 id="避免无备兑的头寸"><a href="#避免无备兑的头寸" class="headerlink" title="避免无备兑的头寸"></a>避免无备兑的头寸</h2><p>如果备兑卖出者在卖出的看涨期权停止交易的那一天考虑要采取任何后续行动的话，他都应当对一条保证金规则非常注意——如果在同一天<strong>卖出另一个看涨期权</strong>，即使先前卖出的期权显然要无价值地到期，但从保证金的角度来看，在周末的时候，这个卖出者会被看作是无备兑的，因此有义务为其无备兑的期权头寸提供质押。</p><h2 id="什么时候让股票被指派行权"><a href="#什么时候让股票被指派行权" class="headerlink" title="什么时候让股票被指派行权"></a>什么时候让股票被指派行权</h2><p>如果满足下面的两个条件，让股票被指派行权的选择一般而言就是最聪明的策略：<br>（1）向前挪仓只能提供很有限的收益；<br>（2）向上或向前挪仓会显著地提高盈亏平衡点，使得该头寸相对来说失去了股价下跌时所需的保护。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gauss">示例：<br>某个卖出备兑头寸是通过 按<span class="hljs-number">49</span>买入<span class="hljs-built_in">XYZ</span>股票 和 按<span class="hljs-number">3</span>点卖出<span class="hljs-number">4</span>月<span class="hljs-number">50</span>看涨期权 来建立起来的。因此初始的盈亏平衡点是<span class="hljs-number">46</span>。<br><br>在临近到期日时，假设<span class="hljs-built_in">XYZ</span>上涨到了<span class="hljs-number">56</span>，<span class="hljs-number">4</span>月<span class="hljs-number">50</span>看涨期权的交易价是<span class="hljs-number">6</span>。如果这个投资者想要向前挪仓，现在正是这样做的时候，因为看涨期权处于持平价上。不过，他注意到他的选择是有限的。假设当<span class="hljs-built_in">XYZ</span>是<span class="hljs-number">56</span>时有下列的期权价格存在：<span class="hljs-built_in">XYZ</span> <span class="hljs-number">10</span>月<span class="hljs-number">50</span>看涨期权的价格是<span class="hljs-number">7</span>，<span class="hljs-built_in">XYZ</span> <span class="hljs-number">10</span>月<span class="hljs-number">60</span>看涨期权的价格是<span class="hljs-number">2</span>。<br><br>如果该卖出者试图挪仓到<span class="hljs-number">10</span>月<span class="hljs-number">50</span>看涨期权，那么，在<span class="hljs-number">10</span>月之前，他最多只能得到<span class="hljs-number">1</span>点的额外盈利（这个看涨期权的时间价值）​。它对应的收益率极低，卖出者应当拒绝这个选择，因为如果就其他证券进行卖出备兑交易，可能获得更好的收益。<br>另一方面，如果这个卖出者打算向上和向前挪仓，这需要花费<span class="hljs-number">4</span>点：<span class="hljs-number">6</span>点买回<span class="hljs-number">4</span>月<span class="hljs-number">50</span>，减去从<span class="hljs-number">10</span>月<span class="hljs-number">60</span>中得到的<span class="hljs-number">2</span>点。这个支出意味着他的盈亏平衡点将从初始的<span class="hljs-number">46</span>上移到新的<span class="hljs-number">50</span>。如果普通股股票的价格跌到<span class="hljs-number">54</span>以下，他就会损失掉已经到手的盈利，因为在当前股价为<span class="hljs-number">56</span>时，<span class="hljs-number">10</span>月<span class="hljs-number">60</span>看涨期权只提供了<span class="hljs-number">2</span>点的保护。如果这个卖出者对<span class="hljs-built_in">XYZ</span>的牛市前景不是很有把握的话，他就不应当向上或者向前挪仓。<br></code></pre></td></tr></table></figure><h1 id="11-特殊的卖出备兑情形"><a href="#11-特殊的卖出备兑情形" class="headerlink" title="11. 特殊的卖出备兑情形"></a>11. 特殊的卖出备兑情形</h1><h2 id="可转换证券卖出备兑"><a href="#可转换证券卖出备兑" class="headerlink" title="可转换证券卖出备兑"></a>可转换证券卖出备兑</h2><p>可转换证券（Convertible Securities）是一种<strong>兼具债券和股票特性的混合型金融工具</strong>，持有人有权在特定条件下将其转换为发行公司的普通股。常见的类型包括可转换债券（Convertible Bonds）和可转换优先股（Convertible Preferred Shares）。</p><p>使用可转换证券的一个优势是它常常能产生比使用普通股更高的收益（一般股息更高）。可转换债券（convertible bonds）和可转换优先股（convertiblepreferred stocks）就是为了这个目的而常常使用的证券。</p><p>升水是可转换证券的售价与转换过后的股价的差价。一般而言，如果一个可转换证券的升水过高，就不会有人要买它。如果某个可转换证券的升水高于所计算出的价值的15%，那么就可以说它的升水过高了。</p><p>在就可转换证券卖出备兑时的另一个考虑是对指派的处置。如果卖出者被指派，他就会将他的优先股转换成普通股，然后交割普通股股票；或者在市场上卖出优先股，再用所得资金从市场上买入100股普通股股票，按照指派通知交割这些股票。如果该可转换证券有升水，那么第二种选择一般就更可取，因为将优先股转换为普通股会损失优先股中所有的升水；当为可转换债券时，则会损失累积的利息。<br>卖出者同时还应当注意，他的可转换证券是否是可以赎回的（callable）​。如果是的话，具体的赎回条件是什么。一旦可转换证券被该公司赎回，它就不再按其与标的股票的关系而交易，而是按赎回价交易。因此，如果股票急剧上涨，卖出者卖出的期权会产生亏损，而无法从可转换证券处得到任何弥补。如果可转换证券被赎回，一般而言，整个头寸就应当立即平仓，卖掉可转换证券并买回期权。</p><h2 id="权证卖出备兑"><a href="#权证卖出备兑" class="headerlink" title="权证卖出备兑"></a>权证卖出备兑</h2><p>权证（Warrant）是一种<strong>由公司或金融机构发行的金融衍生工具</strong>，赋予持有人在特定时间内以约定的价格（行权价）购买或卖出标的资产（通常是发行公司的股票）的权利。</p><p>权证与期权的区别：</p><table><thead><tr><th><strong>特征</strong></th><th><strong>权证</strong></th><th><strong>期权</strong></th></tr></thead><tbody><tr><td><strong>发行方</strong></td><td>公司或第三方金融机构</td><td>交易所标准化合约（无特定发行人）</td></tr><tr><td><strong>标准化</strong></td><td>条款由发行人定制（非标准化）</td><td>标准化（交易所统一规定）</td></tr><tr><td><strong>稀释效应</strong></td><td>行权时公司需增发新股（股权稀释）</td><td>行权不涉及新股（从市场购买股票）</td></tr><tr><td><strong>流动性</strong></td><td>通常较低（依赖发行人信用）</td><td>较高（交易所集中交易）</td></tr><tr><td><strong>期限</strong></td><td>较长（1-5年）</td><td>较短（通常数月至1年）</td></tr></tbody></table><p>使用权证的好处是，如果它们深度实值，它们就会给现金备兑卖出者带来较高的收益，因为它们只需要较少的投资。</p><p>由于同时有期权和权证交易的股票数量不多，以及核实可获得收益的固有问题，实际进行权证卖出备兑的交易并不常见。不过，在某些情况下，进行<strong>深度实值权证卖出备兑</strong>交易，卖出者确实可以获得一定的好处。一般不建议就平值或虚值的权证卖出备兑，因为如果标的股价下跌，权证会更大比例下跌，从而形成一个高风险的头寸。同时，在这个示例里，如果卖出者向下挪仓到一个行权价比权证行权价更低的期权时，他的投资额就有可能会增加。</p><h2 id="长期期权卖出备兑"><a href="#长期期权卖出备兑" class="headerlink" title="长期期权卖出备兑"></a>长期期权卖出备兑</h2><p>卖出备兑看涨期权的一种形式是通过买入长期期权（LEAPS）看涨期权，并卖出更短期虚值看涨期权的方式来构造的。这个策略与权证卖出备兑很相似。第25章在讨论对角价差时，会更详细地讨论这个策略。</p><h2 id="增额收益的概念（收入挪仓）"><a href="#增额收益的概念（收入挪仓）" class="headerlink" title="增额收益的概念（收入挪仓）"></a>增额收益的概念（收入挪仓）</h2><p>卖出备兑看涨期权的增额收益概念是指，备兑卖出者可以获得股票在今天的股价与目标卖出价格（可能比今天的股价高出许多）之间的增值部分的全部价值。与此同时，卖出者还能从卖出期权过程中获得增额的正收益。</p><p>这个策略并不是只适用于机构资金管理者，也适用于普通投资者。只是投资者的持股数量最好较大（至少是500股，最好是在1000股之上）​。增额收益的概念适用于所有像这样的投资者，他们会一直持有股票（即使中途出现短暂下跌）​，直到股价达到事先确定的、更高的价格，他们才愿意卖出。</p><p>增额收益策略的基本方法是，一开始只就所持有的全部股票中的一部分卖出看涨期权，而且是卖出那些行权价离当前股价最接近的看涨期权。然后，如果股价上涨到更高一级的行权价，投资者就通过增加卖出备兑的数量来实现向上挪仓和获得收入。为收入而挪仓是必不可少的，它是整个策略的关键。最后，当股票达到了目标价格时，股票被指派行权，投资者以目标价卖出了所有股票，此外，他还能额外得到所有期权交易中所积累的总的收入。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss">示例：<br><span class="hljs-built_in">XYZ</span>的价格是<span class="hljs-number">60</span>，投资者持有<span class="hljs-number">1000</span>股，他的目标价格是<span class="hljs-number">80</span>。他可以按每手<span class="hljs-number">7</span>卖出<span class="hljs-number">3</span>手最远期的<span class="hljs-number">60</span>看涨期权。<br>如果<span class="hljs-built_in">XYZ</span>在一个月里涨到了<span class="hljs-number">70</span>，那<span class="hljs-number">3</span>手初始的看涨期权就会被买回去，然后在<span class="hljs-number">70</span>的价格上卖出足够的看涨期权，并产生一笔收入（<span class="hljs-number">5</span>手<span class="hljs-built_in">XYZ</span> <span class="hljs-number">10</span>月<span class="hljs-number">70</span>看涨期权）​。<br>如果股价在下一个月里继续上升到<span class="hljs-number">80</span>，这<span class="hljs-number">5</span>手看涨期权就会被买回去，而此时整个股票头寸都会以目标价格进行卖出备兑（<span class="hljs-number">10</span>手看涨期权）​。<br>如果<span class="hljs-built_in">XYZ</span>的价格保持在<span class="hljs-number">80</span>以上，股票就会被指派行权，所有<span class="hljs-number">1000</span>股股票都会按<span class="hljs-number">80</span>的目标价格卖掉。另外，投资者还可以挣到一路上所有卖出期权而得到的收入。它们的总额达到<span class="hljs-number">2800</span>美元。<br>因此，这个卖出者不仅得到了股票上涨到目标价格的整个增值部分，还得到了卖出期权所产生的增额的、正收益。<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/03/12/1OyB6cVKbZ4th2X.png" alt="image.png"></p><blockquote><ol><li>如果股价上涨：向上挪仓；如果股价不变：向前挪仓；</li><li>每次卖出获得的权利金需要高于买入平仓的权利金。</li></ol></blockquote><p>如果目标价格最终被触及，而此时该卖出者希望保留一些股票，当卖出的看涨期权开始失去它们的时间价值时，那就可以使用先前提到的“部分抽身策略”​。当从某个头寸中“抽身”出来后，投资者就可以设定更高的目标价格，开始整个过程的重复。</p><h1 id="12-总结"><a href="#12-总结" class="headerlink" title="12. 总结"></a>12. 总结</h1><p>卖出备兑看涨期权是一个有活力的策略，因为它减少了持有股票所带来的风险，同时也减小了短期市场运动给某个投资者的投资组合所带来的波动性。不过，卖出备兑看涨期权的表现有可能会比只持有股票差，因为股票有可能会大幅上涨，而卖出备兑则对潜在盈利的上限进行了限制。</p><p>相对于卖出虚值看涨期权，卖出实值看涨期权从策略上来说要更为保守一些，因为它得到了更大份额的市场下行保护。</p><p>卖出备兑看涨期权的总收益的概念，是想在各种来源的收入（期权权利金、股票持有权和股息）和市场下行保护之间维持最大的平衡。为了实现这个平衡，通常在股价接近行权价，或稍微实值，或稍微虚值时卖出备兑看涨期权。</p><p>可以卖出一部分虚值看涨期权和另一部分实值看涨期权，以实现收入和保护之间的平衡。</p><p>如果投资者对某只股票是看空的，他就不应当就其卖出看涨期权。卖出者对标的股票应当是略为看多的，或者至少是中性的。</p>]]></content>
    
    
    <categories>
      
      <category>financing</category>
      
      <category>期权投资策略</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty 学习</title>
    <link href="/posts/464fc54d.html"/>
    <url>/posts/464fc54d.html</url>
    
    <content type="html"><![CDATA[<h1 id="Netty-简介"><a href="#Netty-简介" class="headerlink" title="Netty 简介"></a>Netty 简介</h1><p><strong>Netty</strong> 是一个利用 Java 的高级网络的能力，隐藏了 Java 背后的复杂性然后提供了一个易于使用的 API 的客户端&#x2F;服务器框架。支持应用以较低的成本来获得更大的吞吐量和可用性。 </p><h2 id="Netty-的技术和方法的特点"><a href="#Netty-的技术和方法的特点" class="headerlink" title="Netty 的技术和方法的特点"></a>Netty 的技术和方法的特点</h2><ul><li>设计<ul><li>针对多种传输类型的统一接口 - 阻塞和非阻塞</li><li>简单但更强大的线程模型</li><li>真正的无连接的数据报套接字支持</li><li>链接逻辑支持复用</li></ul></li><li>易用性<ul><li>大量的 Javadoc 和 代码实例</li><li>除了在 JDK 1.6 + 额外的限制。（一些特征是只支持在Java 1.7 +。可选的功能可能有额外的限制。）</li></ul></li><li>性能<ul><li>比核心 Java API 更好的吞吐量，较低的延时</li><li>资源消耗更少，这个得益于共享池和重用</li><li>减少内存拷贝</li></ul></li><li>健壮性<ul><li>消除由于慢，快，或重载连接产生的 OutOfMemoryError</li><li>消除经常发现在 NIO 在高速网络中的应用中的不公平的读&#x2F;写比</li></ul></li><li>安全<ul><li>完整的 SSL &#x2F; TLS 和 StartTLS 的支持</li><li>运行在受限的环境例如 Applet 或 OSGI</li></ul></li><li>社区<ul><li>发布的更早和更频繁</li><li>社区驱动</li></ul></li></ul><h1 id="Netty-核心组件"><a href="#Netty-核心组件" class="headerlink" title="Netty 核心组件"></a>Netty 核心组件</h1><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p><a href="http://docs.oracle.com/javase/7/docs/api/java/nio/channels/Channel.html">Channel</a> 是 NIO 基本的结构。它代表了一个用于连接到实体如硬件设备、文件、网络套接字或程序组件,能够执行一个或多个不同的 I&#x2F;O 操作（例如读或写）的开放连接。</p><p>现在，把 Channel 想象成一个可以“打开”或“关闭”，“连接”或“断开”和作为传入和传出数据的运输工具。</p><h2 id="Callback-回调"><a href="#Callback-回调" class="headerlink" title="Callback (回调)"></a>Callback (回调)</h2><p>callback (回调)是一个简单的方法,提供给另一种方法作为引用,这样后者就可以在某个合适的时间调用前者。这种技术被广泛使用在各种编程的情况下,最常见的方法之一通知给其他人操作已完成。</p><p>Netty 内部使用回调处理事件时。一旦这样的回调被触发，事件可以由接口 ChannelHandler 的实现来处理。</p><h2 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h2><p><code>Future</code> 提供了另外一种通知应用操作已经完成的方式。这个对象作为一个异步操作结果的占位符,它将在将来的某个时候完成并提供结果。</p><p>JDK 附带接口 <code>java.util.concurrent.Future</code> ，但所提供的实现只允许您手动检查操作是否完成或阻塞了。这是很麻烦的，所以 Netty 提供自己了的实现,<code>ChannelFuture</code>,用于在执行异步操作时使用。</p><p><code>ChannelFuture</code> 提供多个附件方法来允许一个或者多个 <code>ChannelFutureListener</code> 实例。这个回调方法 <code>operationComplete()</code> 会在操作完成时调用。事件监听者能够确认这个操作是否成功或者是错误。如果是后者,我们可以检索到产生的 <code>Throwable</code>。简而言之, <code>ChannelFutureListener</code> 提供的通知机制不需要手动检查操作是否完成的。</p><p>每个 Netty 的 outbound I&#x2F;O 操作都会返回一个 <code>ChannelFuture</code>，这样就不会阻塞。这就是 Netty 所谓的“自底向上的异步和事件驱动”。</p><p>下面例子简单的演示了作为 I&#x2F;O 操作的一部分 ChannelFuture 的返回。当调用 connect() 将会直接是非阻塞的，并且调用在背后完成。由于线程是非阻塞的，所以无需等待操作完成，而可以去干其他事，因此这令资源利用更高效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ...;<br><span class="hljs-comment">//不会阻塞</span><br><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> channel.connect(            <span class="hljs-comment">//1</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;192.168.0.1&quot;</span>, <span class="hljs-number">25</span>));<br>future.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;  <span class="hljs-comment">//2</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> &#123;<br>    <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;                    <span class="hljs-comment">//3</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> Unpooled.copiedBuffer(<br>                <span class="hljs-string">&quot;Hello&quot;</span>, Charset.defaultCharset()); <span class="hljs-comment">//4</span><br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">wf</span> <span class="hljs-operator">=</span> future.channel().writeAndFlush(buffer); <span class="hljs-comment">//5</span><br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> future.cause();        <span class="hljs-comment">//6</span><br>        cause.printStackTrace();<br>    &#125;<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ol><li>异步连接到远程对等节点。调用立即返回并提供 <code>ChannelFuture</code>。</li><li>操作完成后通知注册一个 <code>ChannelFutureListener</code> 。</li><li>当 <code>operationComplete()</code> 调用时检查操作的状态。</li><li>如果成功就创建一个 <code>ByteBuf</code> 来保存数据。</li><li>异步发送数据到远程。<code>再次返回ChannelFuture</code>。</li><li>如果有一个错误则抛出 <code>Throwable</code>,描述错误原因。</li></ol><h2 id="Event-和-Handler"><a href="#Event-和-Handler" class="headerlink" title="Event 和 Handler"></a>Event 和 Handler</h2><p>Netty 使用不同的事件来通知我们更改的状态或操作的状态。这使我们能够根据发生的事件触发适当的行为，如：日志、数据转换、流控制、应用程序逻辑。</p><p>由于 Netty 是一个网络框架，事件跟入站或出站数据流相关。</p><p>因为一些事件可能触发传入的数据或状态的变化包括：</p><ul><li>活动或非活动连接</li><li>数据的读取</li><li>用户事件</li><li>错误</li></ul><p>出站事件是由于在未来操作将触发一个动作。这些包括:</p><ul><li>打开或关闭一个连接到远程</li><li>写或冲刷数据到 socket</li></ul><p>每个事件都可以分配给用户实现处理程序类的方法。这说明了事件驱动的范例可直接转换为应用程序构建块。</p><p>Netty 的 <code>ChannelHandler</code> 是各种处理程序的基本抽象。想象下，<strong>每个处理器实例就是一个回调，用于执行对各种事件的响应。</strong></p><p>下图显示，一个事件可以由一连串的事件处理器来处理。每个 <code>Channel</code> 都有一个关联的 <code>ChannelPipeline</code>，即 <code>ChannelHandler</code> 实例的链。</p><p><img src="https://s2.loli.net/2024/12/18/rmP89aZLR2k1obB.png" alt="image.png"></p><p>在此基础之上，Netty 也提供了一组丰富的预定义的处理程序,您可以开箱即用。比如，各种协议的编解码器包括 HTTP 和 SSL&#x2F;TLS。在内部,<code>ChannelHandler</code> 使用事件和 <code>future</code> 本身,创建具有 Netty 特性抽象的消费者。</p><h3 id="Sharable"><a href="#Sharable" class="headerlink" title="@Sharable"></a>@Sharable</h3><p><code>@Sharable</code>注解用于标记<code>ChannelHandler</code>，表明同一个<code>ChannelHandler</code>的实例可以被多次添加到一个或多个<code>ChannelPipeline</code>中，而不会出现竞争条件（race condition）。</p><blockquote><p>如果一个<code>ChannelHandler</code>没有标记<code>@Sharable</code>，在添加到一个<code>ChannelPipeline</code>时，每次都需要创建一个新的handler实例，因为它的成员变量是不可共享的。</p></blockquote><p>使用<code>@Sharable</code>注解的主要场景包括：</p><ol><li><strong>性能提升</strong>：通过共享同一个<code>ChannelHandler</code>实例，可以减少频繁创建handler实例带来的系统开销。</li><li><strong>信息共享</strong>：适用于需要在多个<code>Channel</code>之间共享信息的场景，例如日志服务、计数服务等。</li><li><strong>无状态的Handler</strong>：适用于没有成员变量的encoder、decoder，或者在处理粘包问题时需要共享中间数据、变量的情况。</li></ol><blockquote><p>注意，如果一个<code>ChannelHandler</code>被标记为<code>@Sharable</code>，那么它应该是线程安全的，因为它可能会被多个线程同时访问。</p></blockquote><h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><h3 id="FUTURE-CALLBACK-和-HANDLER"><a href="#FUTURE-CALLBACK-和-HANDLER" class="headerlink" title="FUTURE, CALLBACK 和 HANDLER"></a>FUTURE, CALLBACK 和 HANDLER</h3><p>Netty 的异步编程模型是建立在 <code>future</code> 和 <code>callback</code> 的概念上的。所有这些元素的协同为自己的设计提供了强大的力量。</p><p>拦截操作和转换入站或出站数据只需要您提供 <code>callback</code> 或 <code>future</code> 返回执行的操作。这使得链操作简单、高效，有利于编写可重用的、通用的代码。一个 Netty 的设计的主要目标是促进“关注点分离”：你的业务逻辑从网络基础设施应用程序中分离。</p><h3 id="SELECTOR-EVENT-和-EVENT-LOOP"><a href="#SELECTOR-EVENT-和-EVENT-LOOP" class="headerlink" title="SELECTOR, EVENT 和 EVENT LOOP"></a>SELECTOR, EVENT 和 EVENT LOOP</h3><p>Netty 通过触发事件从应用程序中抽象出 <code>Selector</code>，从而避免手写调度代码。<code>EventLoop</code> 分配给每个 <code>Channel</code> 来处理所有的事件，包括：</p><ul><li>注册感兴趣的事件</li><li>调度事件到 <code>ChannelHandler</code></li><li>安排进一步行动</li></ul><p><code>EventLoop</code> 本身由一个线程驱动，它为一个 <code>Channel</code> 处理所有的 I&#x2F;O 事件，并且在 <code>EventLoop</code> 的生命周期内不会改变。这个简单而强大的线程模型消除你可能对你的 <code>ChannelHandler</code> 同步的任何关注，这样你就可以专注于提供正确的回调逻辑来执行。</p>]]></content>
    
    
    <categories>
      
      <category>backend</category>
      
      <category>Netty</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux 命令</title>
    <link href="/posts/9da1ef6b.html"/>
    <url>/posts/9da1ef6b.html</url>
    
    <content type="html"><![CDATA[<p>命令通用格式：<code>command -options arguments</code></p><h1 id="几个简单命令"><a href="#几个简单命令" class="headerlink" title="几个简单命令"></a>几个简单命令</h1><ul><li><code>date</code>: 显示当前时间和日期</li><li><code>cal</code>: 显示当前月份的日历</li><li><code>df</code>: 磁盘的当前可用空间</li><li><code>free</code>: 查看可用内存容量</li><li><code>exit</code>: 结束终端会话，也可使用<code>ctrl-D</code></li><li><code>pwd</code>: 输出当前的工作目录名称</li></ul><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p><code>cd $&#123;dir&#125;</code>: 修改目录。<br>一些有用的便捷写法：</p><ul><li><code>cd</code>: 将当前工作目录更改为用户主目录</li><li><code>cd -</code>: 将当前工作目录切换回前一个工作目录</li><li><code>cd ~$&#123;user_name&#125;</code>: 将当前工作目录更改为用户user_name的主目录。例如，输入<code>cd ~bob</code>，会切换到bob的主目录</li></ul><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p><code>ls</code>: 列出当前目录内容。<br>其他用法：</p><ul><li><code>ls $&#123;dir1&#125;</code>: 列出dir1目录中的内容</li><li><code>ls $&#123;dir1&#125; $&#123;dir2&#125;</code>: 同时列出dir1和dir2中的内容</li><li><code>-l</code>: 输出结果的格式改成长格式</li><li><code>-t</code>: 表示依照文件修改时间对输出结果排序<ul><li>也可加上<code>--reverse</code>倒序</li></ul></li><li><code>-a, --all</code>: 列出所有文件，包括以点号开头的隐藏文件</li><li><code>-A, --almose-all</code>: 与<code>-a</code>类似，但不列出<code>.</code>和<code>..</code></li><li><code>-d, --directory</code>: 一般与<code>-l</code>结合使用，可查看目录的详细信息，而不是其中的内容</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Search &amp; Pagination</title>
    <link href="/posts/ed1d4064.html"/>
    <url>/posts/ed1d4064.html</url>
    
    <content type="html"><![CDATA[<p><strong>When to use the <code>useSearchParams()</code> hook vs. the <code>searchParams</code> prop?</strong></p><p>You might have noticed you used two different ways to extract search params. Whether you use one or the other depends on whether you’re working on the client or the server.</p><ul><li><code>&lt;Search&gt;</code> is a Client Component, so you used the <code>useSearchParams()</code> hook to access the params from the client.</li><li><code>&lt;Table&gt;</code> is a Server Component that fetches its own data, so you can pass the <code>searchParams</code> prop from the page to the component.</li></ul><p>As a general rule, if you want to read the params from the client, use the <code>useSearchParams()</code> hook as this avoids having to go back to the server.</p><h2 id="Debouncing"><a href="#Debouncing" class="headerlink" title="Debouncing"></a>Debouncing</h2><p><strong>Debouncing</strong> is a programming practice that limits the rate at which a function can fire. In our case, you only want to query the database when the user has stopped typing.</p><blockquote><p><strong>How Debouncing Works:</strong></p><ol><li><strong>Trigger Event</strong>: When an event that should be debounced (like a keystroke in the search box) occurs, a timer starts.</li><li><strong>Wait</strong>: If a new event occurs before the timer expires, the timer is reset.</li><li><strong>Execution</strong>: If the timer reaches the end of its countdown, the debounced function is executed.</li></ol></blockquote><p>You can implement debouncing in a few ways, including manually creating your own debounce function. To keep things simple, we’ll use a library called <a href="https://www.npmjs.com/package/use-debounce"><code>use-debounce</code></a>.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To summarize, in this chapter:</p><ul><li>You’ve handled search and pagination with URL search parameters instead of client state.</li><li>You’ve fetched data on the server.</li><li>You’re using the <code>useRouter</code> router hook for smoother, client-side transitions.</li><li>Used <code>use-debounce</code> to avoid query on every keystroke</li></ul>]]></content>
    
    
    <categories>
      
      <category>full stack</category>
      
      <category>Next.js</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学历无用论</title>
    <link href="/posts/8c500a47.html"/>
    <url>/posts/8c500a47.html</url>
    
    <content type="html"><![CDATA[<h1 id="美国式的人才雇佣方法"><a href="#美国式的人才雇佣方法" class="headerlink" title="美国式的人才雇佣方法"></a>美国式的人才雇佣方法</h1><p>在日本，不论是职员还是公司，都有一个根深蒂固的看法，就是一个人一生只能在一家公司工作。从自古以来的儒教精神来看，这相当于“忠臣不事二主”。一旦雇佣关系成立，就要在那里“奉公”工作到最后。<br>而在美国依靠投标制度产生的雇佣关系中，什么时候都需要对照“求职申请表”对职员做出评价。即便是对好不容易招来的职员，如果公司一旦发现他并不能达到“求职申请表”的要求，公司就会在说明理由后将其辞退。实际上，在美国，雇佣关系没满一年就被公司辞退是非常平常的事。</p><p>在美国，大公司因为人手不足会录用应届大学毕业生（这不像日本公司，即使不缺人手，每年还是要不停录用新人）。被录用的人也不会想着一旦录用就要在那里工作一辈子。<br>与大公司为获取人才所做的努力相仿，被雇佣的一方也认为偶尔换一换公司比较好，因为这样能够正确评价自己的能力，增加自己找到好工作的机会。</p><h1 id="公司不是游乐场"><a href="#公司不是游乐场" class="headerlink" title="公司不是游乐场"></a>公司不是游乐场</h1><p>论资排辈制度能够保证员工从一张白纸的状态进入公司一直到不能工作——也就是退休为止，不停地升职加薪，尽管每次的幅度都很小。这有效抑制了员工跳槽的欲望。</p><p>终身雇佣制度超出了纯粹的商业范畴，带来了“忠诚”和“我们公司”的意识。这种观念实在不可思议，它在创造了极高生产率的同时，也保证了一旦当公司遇到什么困难时，全体员工能够团结一致共渡难关。在“为了我们公司刻苦勤勉工作”的道义教育下，长时间、高强度的劳动也就理所当然了。</p><p>在传统的日本社会中，充分利用业余时间享受人生的做法是离经叛道的。但战后，日本的衣食住行发生了翻天覆地的变化。现在的日本，人们的生活变得十分富足。勤劳光荣、享乐可耻的观念已经转变成心理学家杰文斯说的那样，“劳动是为了获得报酬而不得不忍耐的肉体上和精神上的痛苦”。</p><p>在假日旅行期间，需要尽可能的放松神经，回复生活能力，调节心情。因此，选择不带有很大压力的娱乐方式是理所当然的。比如打高尔夫，就没有必要执着于谁胜谁负，击球姿势是否优美等问题。早上也不用着急，慢悠悠地出门，慢悠悠地吃完早饭，打完球后在球场转半圈，累了的话就躺在草坪上休息休息，然后慢悠悠地回家。</p><p>公司不是娱乐的地方，而是来工作的地方。赚到钱之后在公司外面去娱乐，根本没有必要把公司变成娱乐的地方。当然这并不是说要否定良好的人际关系和工作效率的重要性，而是说在公司里没有必要过分追求游乐设施，甚至把公司变成游乐场。</p><p>经营者认同的研究计划与具体负责为的研究者所认同的研究计划之间必然存在分歧，解决办法是明确“到底为了什么而研究”。<br>在庞大的IBM研发部门中，如果你打算做自己想做的研究，第一步就要使最高管理者理解这个研究主题的根本理念。研究者要说明自己打算研究的主题。虽然这个主题现在还是基础性研究，但是等研究完成的时候，就会通过什么过程和IBM的业务联系起来了。完成这项研究需要花费多少钱。<br>或者研究已经进展到这种地步了，我们还需要一个人，需要更多资金。研究者必须这样随时向研究所的负责人汇报自己的理念、进度和要求，否则研究就得不到认可，得不到认可就意味着没有钱。<br>在美国，为公司研究的理念非常清楚。如果跟公司的利益没有直接关系，即使该选题有划时代的意义，公司都不会出一个子儿。</p><p>日本有这样一种说法：“工作富有乐趣，此生即属极乐；工作仅为义务，人间即为地狱”。这种说法具有重大意义，它并不是提倡要从工作环境中获得娱乐，而是说要做有意义的工作。</p><h1 id="学历无用论"><a href="#学历无用论" class="headerlink" title="学历无用论"></a>学历无用论</h1><p>美国公司招聘员工和买东西是相同的。说得复杂点，买东西的大前提是东西必须具有价值，购买劳动的时候也会要求员工能够做某种工作，这里所谓的工作其实是指工作职位。在美国，购买劳动之前首先考虑的是是否有职位空缺。公司的职位有了，职务分工也明确了，直接找人填充就行了。</p><p>必须要把员工从“平庸度日的职员”变成富有进取心的商人“。</p><blockquote><p>使用股权&#x2F;期权激励是一个方法。</p></blockquote><p>学历&#x3D;能力吗？企业在激烈的过度竞争中厮杀，根据实力来决定胜负；但是在企业中工作的人却根据参加工作前接受教育的“场所”来评价。仅仅几年的学校教育，居然能够在以后的几十年里成为那个人的招牌而畅通无阻，这实在让人觉得奇怪。</p><p>一个人从什么学校毕业、学的是什么专业，说到底只是那个人所拥有的资产中的一项而已。他将如何活用这项资产以及能够为社会做出多大贡献，是与他本人今后的努力分不开的。应当根据他活用这项资产的程度以及实际业绩来评价他的价值。</p><p>根据学历来评价一个人，这种不合理的制度之所以能够盛行，其中一个很重要的原因就是社会没有认真思考应当如何评价一个人的工作，但现实中又必须评价，于是采取了一个偷懒的办法，就是直接援引学校成绩作为基准进行评价。<br>在美国，雇佣关系是流动的，雇佣方和被雇佣方一直相互比较工作和报酬，也即实力和对应的价格，自然养成了认真思考个人价值的习惯，也明确了工作要与报酬相对应的观念。</p><p>如果我国所有的政府机关、公司企业都无视学历的话，学生们肯定会为了提高个人能力而更加用功地学习，各个学校也肯定会最大限度地强化自己的办学特色。</p><p>刚从学校毕业，很多公司都来招人。该去哪家呢？这家公司规模挺大，工资也不低，就去这儿吧。如果这样选择就麻烦了。正确的做法应当是首先考虑自己能做什么工作，然后看哪家公司让自己去，最后再做出决定。</p><p>真正的专才都在某一方面掌握了对企业而言不可或缺的知识，但同时，又有着对企业整体的广泛认识。</p><p>在日本，随着工作年限的增加，部下的数目也自然而然地增加，一方面自己必须变得杰出起来，另一方面即使自己不想杰出也不得不杰出。可是，在变杰出的同时，自己也远离了具体事务。谈到什么事情的时候，总是会说“问问我的科员吧”，“回头考虑考虑吧”之类的话，逐渐疏远了专门知识和具体知识。事实上，即使成了经理，也应当继续像专才一样亲力亲为，不断更新知识结构。</p><h1 id="怠工高管驱逐论"><a href="#怠工高管驱逐论" class="headerlink" title="怠工高管驱逐论"></a>怠工高管驱逐论</h1><p>在日本的终身雇佣体制下，只要不犯什么大错就能够一直工作到退休。与其说是通过娱乐来缓解工作压力，倒不如说是为了追求压力而通宵打麻将、早上天不亮就起床驱车去高尔夫球场。因为在工作中太放松了，所以打算通过娱乐来寻求压力，这可真是够滑稽的。</p><p>以对最高管理人实施严格的实力评价为契机，公司内也就能全面树立起实力评价机制了。这又一次触及了企业的根本理念。最高管理人的真正工作并不是对雇佣者进行实力评价。在公司里引入实力主义、能力主义的目的是尽量发挥雇员的能力，尽可能用最少的人完成最大量的工作。所谓的考评、评定，都只不过是一种手段，并不是说要像学校的老师一样，把打分当做工作本身。</p>]]></content>
    
    
    <categories>
      
      <category>book notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一些全栈工具</title>
    <link href="/posts/85e79a17.html"/>
    <url>/posts/85e79a17.html</url>
    
    <content type="html"><![CDATA[<h1 id="create-t3-app"><a href="#create-t3-app" class="headerlink" title="create-t3-app"></a>create-t3-app</h1><p>A easier way to start a full-stack, typesafe Next.js app.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm create t3-app@latest<br></code></pre></td></tr></table></figure><h1 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h1><p>Build and deploy web projects with automatic scaling and support for modern web technologies like serverless functions.<br><a href="https://vercel.com/docs/getting-started-with-vercel">https://vercel.com/docs/getting-started-with-vercel</a></p><h1 id="Prisma"><a href="#Prisma" class="headerlink" title="Prisma"></a>Prisma</h1><p>A next-generation ORM.<br><a href="https://www.prisma.io/docs/getting-started/quickstart-sqlite">https://www.prisma.io/docs/getting-started/quickstart-sqlite</a></p><p>Prisma Studio: <a href="https://www.prisma.io/studio">https://www.prisma.io/studio</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx prisma studio<br></code></pre></td></tr></table></figure><h1 id="Untun"><a href="#Untun" class="headerlink" title="Untun"></a>Untun</h1><p>A proxy that tunnel your local HTTP(s) server to the world! powered by Cloudflare Quick Tunnels.<br><a href="https://github.com/unjs/untun">https://github.com/unjs/untun</a></p><h1 id="Clerk"><a href="#Clerk" class="headerlink" title="Clerk"></a>Clerk</h1><p>Used for Authentication and User Management.<br><a href="https://clerk.com/docs/quickstarts/nextjs">Clerk Next.js Quickstart</a></p><h1 id="Stripe"><a href="#Stripe" class="headerlink" title="Stripe"></a>Stripe</h1><p>Process payments from 100+ global payment methods.<br><a href="https://docs.stripe.com/get-started">https://docs.stripe.com/get-started</a></p><h1 id="Aurinko"><a href="#Aurinko" class="headerlink" title="Aurinko"></a>Aurinko</h1><p>A mailbox data sync solution.<br><a href="https://docs.aurinko.io/getting-started/getting-started-with-aurinko">https://docs.aurinko.io/getting-started/getting-started-with-aurinko</a></p><h1 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h1><p>An open source project that helps you find and fix problems with your JavaScript code.</p>]]></content>
    
    
    <categories>
      
      <category>full stack</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Shadcn UI 介绍及使用</title>
    <link href="/posts/8602d57a.html"/>
    <url>/posts/8602d57a.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Shadcn UI 是一个现代前端的灵活组件库，它与其他 UI 组件库如 Material UI、Ant Design、Element UI 的设计理念截然不同。Shadcn UI 允许用户<strong>将单个 UI 组件的源代码直接下载到项目</strong>中，提供了更大的灵活性和定制空间。它并不是一个传统的组件库，而是可以复制并粘贴到应用中的可重用组件的集合。</p><p>Shadcn UI 的显著特性包括：</p><ol><li><strong>简洁且易于使用</strong>：Shadcn UI 提供了直观且易于理解的文档，可以轻松地开始使用。它不需要复杂的配置步骤，只需简单的复制粘贴或使用CLI安装即可快速集成到项目中。</li><li><strong>卓越的可访问性</strong>：Shadcn UI 在设计之初就充分考虑到了可访问性，确保其组件符合Web内容可访问性指南（WCAG）标准。</li><li><strong>精细控制与高度可定制</strong>：Shadcn UI 允许直接访问每个组件的源代码，这意味着可以根据项目的具体需求轻松调整代码，而无需受限于预定义的模板或样式。</li></ol><p>使用 Shadcn UI 的方式也很简单，可以通过CLI工具快速添加组件到项目中，例如使用命令 <code>npx shadcn-ui@latest add button</code> 来添加 Button 组件。</p><p>Shadcn UI 的底层是 Radix UI，这是一个 headless 组件库，意味着它的组件没有任何的样式，提供了可以定制化样式的方式，让我们自定义组件的样式。Shadcn UI 使用 Tailwind CSS 封装了 Radix UI 的组件，从而提供了 Tailwind CSS 的踪迹。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参考链接(使用Next.js的情况): <a href="https://ui.shadcn.com/docs/installation/next">https://ui.shadcn.com/docs/installation/next</a></p>]]></content>
    
    
    <categories>
      
      <category>full stack</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP - Chapter 1 - A Tour of Computer Systems</title>
    <link href="/posts/ab6f0cb4.html"/>
    <url>/posts/ab6f0cb4.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Information-Is-Bits-Context"><a href="#1-Information-Is-Bits-Context" class="headerlink" title="1. Information Is Bits + Context"></a>1. Information Is Bits + Context</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* hello.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, world\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>The representation of <code>hello.c</code> illustrates a fundamental idea: All information in a system—including disk files, programs stored in memory, user data stored in memory, and data transferred across a network—is represented as a bunch of bits. The only thing that distinguishes different data objects is the context in which we view them.</p><blockquote><p>For example, in different contexts, the same sequence of bytes might represent an integer, floating-point number, character string, or machine instruction.</p></blockquote><h2 id="Origins-of-the-C-programming-language"><a href="#Origins-of-the-C-programming-language" class="headerlink" title="Origins of the C programming language"></a>Origins of the C programming language</h2><p>C was developed from 1969 to 1973 by Dennis Ritchie of Bell Laboratories. The American National Standards Institute (ANSI) ratified the ANSI C standard in 1989, and this standardization later became the responsibility of the International Standards Organization (ISO). The standards define the C language and a set of library functions known as the C standard library.Kernighan and Ritchie describe ANSI C in their classic book, which is known affectionately as <strong>“K&amp;R”</strong>(B. Kernighan and D. Ritchie. The C Programming Language, Second Edition. Prentice Hall, 1988.). </p><p>In Ritchie’s words, C is “quirky, flawed, and an enormous success.” So why the success?</p><ul><li><strong>C was closely tied with the Unix operating system.</strong> C was developed from the beginning as the system programming language for Unix. Most of the Unix kernel (the core part of the operating system), and all of its supporting tools and libraries, were written in C.</li><li><strong>C is a small, simple language.</strong> The design was controlled by a single person, rather than a committee, and the result was a clean, consistent design with little baggage. The K&amp;R book describes the complete language and standard library, with numerous examples and exercises, in only 261 pages. The simplicity of C made it relatively easy to learn and to port to different computers.</li><li><strong>C was designed for a practical purpose.</strong> C was designed to implement the Unix operating system. Later, other people found that they could write the programs they wanted, without the language getting in the way.<blockquote><p>C is the language of choice for system-level programming, and there is a huge installed base of application-level programs as well. However, it is not perfect for all programmers and all situations. C pointers are a common source of confusion and programming errors. C also lacks explicit support for useful abstractions such as classes, objects, and exceptions. Newer languages such as C++ and Java address these issues for application-level programs.</p></blockquote></li></ul><h1 id="2-Programs-Are-Translated-by-Other-Programs-into-Different-Forms"><a href="#2-Programs-Are-Translated-by-Other-Programs-into-Different-Forms" class="headerlink" title="2. Programs Are Translated by Other Programs into Different Forms"></a>2. Programs Are Translated by Other Programs into Different Forms</h1><p>On a Unix system, the translation from source file to object file is performed by a compiler driver:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">gcc -o hello hello.c</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/10/xdw5oimXcuTUHzP.png" alt="the compilation system.png"></p><p>The translation is performed in the sequence of four phases. The programs that perform the four phases (<em>preprocessor</em>, <em>compiler</em>, <em>assembler</em>, and <em>linker</em>) are known collectively as the <em>compilation system</em>.</p><h2 id="Preprocessing-phase"><a href="#Preprocessing-phase" class="headerlink" title="Preprocessing phase"></a>Preprocessing phase</h2><p>The preprocessor (cpp) modifies the original C program according to directives that begin with the ‘#’ character. For example, the <code>#include &lt;stdio.h&gt;</code> command in line 1 of <code>hello.c</code> tells the preprocessor to read the contents of the system header file <code>stdio.h</code> and insert it directly into the program text. The result is another C program, typically with the .i suffix.</p><h2 id="Compilation-phase"><a href="#Compilation-phase" class="headerlink" title="Compilation phase"></a>Compilation phase</h2><p>The compiler (cc1) translates the text file <code>hello.i</code> into the text file <code>hello.s</code>, which contains an assembly-language program. This program includes the following definition of function main:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">main:<br>subq $8, %rsp<br>movl $.LC0, %edi<br>call puts<br>movl $0, %eax<br>addq $8, %rsp<br>ret<br></code></pre></td></tr></table></figure><blockquote><p>Assembly language is useful because it provides a common output language for different compilers for different high-level languages. For example, C compilers and Fortran compilers both generate output files in the same assembly language.</p></blockquote><h2 id="Assembly-phase"><a href="#Assembly-phase" class="headerlink" title="Assembly phase"></a>Assembly phase</h2><p>Next, the assembler (as) translates hello.s into machine language instructions, packages them in a form known as a relocatable object program, and stores the result in the object file <code>hello.o</code>. This file is a binary file containing 17 bytes to encode the instructions for function main. If we were to view <code>hello.o</code> with a text editor, it would appear to be gibberish.</p><h2 id="Linking-phase"><a href="#Linking-phase" class="headerlink" title="Linking phase"></a>Linking phase</h2><p>Notice that our hello program calls the <code>printf</code> function, which is part of the standard C library provided by every C compiler. The printf function resides in a separate precompiled object file called <code>printf.o</code>, which must somehow be merged with our <code>hello.o</code> program. The linker (ld) handles this merging. The result is the <code>hello</code> file, which is an executable object file (or simply executable) that is ready to be loaded into memory and executed by the system.</p><h1 id="3-It-Pays-to-Understand-How-Compilation-Systems-Work"><a href="#3-It-Pays-to-Understand-How-Compilation-Systems-Work" class="headerlink" title="3. It Pays to Understand How Compilation Systems Work"></a>3. It Pays to Understand How Compilation Systems Work</h1><p>There are some important reasons why programmers need to understand how compilation systems work:</p><h2 id="Optimizing-program-performance"><a href="#Optimizing-program-performance" class="headerlink" title="Optimizing program performance"></a>Optimizing program performance</h2><p>In order to make good coding decisions in our C programs, we do need a basic understanding of machine-level code and how the compiler translates different C statements into machine code.</p><blockquote><p>For example, is a switch statement always more efficient than a sequence of if-else statements? How much overhead is incurred by a function call? Is a while loop more efficient than a for loop? Are pointer references more efficient than array indexes? Why does our loop run so much faster if we sum into a local variable instead of an argument that is passed by reference? How can a function run faster when we simply rearrange the parentheses in an arithmetic expression?</p></blockquote><h2 id="Understanding-link-time-errors"><a href="#Understanding-link-time-errors" class="headerlink" title="Understanding link-time errors"></a>Understanding link-time errors</h2><p>In our experience, some of the most perplexing programming errors are related to the operation of the linker, especially when you are trying to build large software systems.</p><blockquote><p>For example, what does it mean when the linker reports that it cannot resolve a reference?What is the difference between a static variable and a global variable? What happens if you define two global variables in different C files with the same name?What is the difference between a static library and a dynamic library? Why does it matter what order we list libraries on the command line? And scariest of all, why do some linker-related errors not appear until run time?</p></blockquote><h2 id="Avoiding-security-holes"><a href="#Avoiding-security-holes" class="headerlink" title="Avoiding security holes"></a>Avoiding security holes</h2><p>For many years, <em>buffer overflow vulnerabilities</em> have accounted for many of the security holes in network and Internet servers. These vulnerabilities exist because too few programmers understand the need to <strong>carefully restrict the quantity and forms of data they accept from untrusted sources</strong>. A first step in learning secure programming is to understand the consequences of the way data and control information are stored on the program stack.</p><h1 id="4-Processors-Read-and-Interpret-Instructions-Stored-in-Memory"><a href="#4-Processors-Read-and-Interpret-Instructions-Stored-in-Memory" class="headerlink" title="4. Processors Read and Interpret Instructions Stored in Memory"></a>4. Processors Read and Interpret Instructions Stored in Memory</h1><h2 id="Hardware-Organization-of-a-System"><a href="#Hardware-Organization-of-a-System" class="headerlink" title="Hardware Organization of a System"></a>Hardware Organization of a System</h2><p><img src="https://s2.loli.net/2024/11/11/iEILBt8dcWAku7b.png" alt="Hardware organization of a typical system.png"></p><h3 id="Buses"><a href="#Buses" class="headerlink" title="Buses"></a>Buses</h3><p>Running throughout the system is a collection of electrical conduits called buses that carry bytes of information back and forth between the components. Buses are typically designed to transfer fixed-size chunks of bytes known as <code>words</code>.</p><h3 id="I-O-Devices"><a href="#I-O-Devices" class="headerlink" title="I&#x2F;O Devices"></a>I&#x2F;O Devices</h3><p>Each I&#x2F;O device is connected to the I&#x2F;O bus by either a <code>controller</code> or an <code>adapter</code>. The distinction between the two is mainly one of packaging.<br>Controllers are chip sets in the device itself or on the system’s main printed circuit board (often called the motherboard).<br>An adapter is a card that plugs into a slot on the motherboard.<br>Regardless, the purpose of each is to transfer information back and forth between the I&#x2F;O bus and an I&#x2F;O device.</p><h3 id="Main-Memory"><a href="#Main-Memory" class="headerlink" title="Main Memory"></a>Main Memory</h3><p>Physically, main memory consists of a collection of dynamic random access memory(DRAM) chips.</p><h3 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h3><p>At CPU’s core is a word-size storage device (or register) called the <em>program counter (PC)</em>. At any point in time, the PC points at (contains the address of) some machine-language instruction in<br>main memory.<br>There are only a few of these simple operations, and they revolve around main memory, the <em>register file</em>, and the <em>arithmetic&#x2F;logic unit (ALU)</em>. The register file is a small storage device that consists of a collection of word-size registers, each with its own unique name. The ALU computes new data and address values.</p><p>Here are some examples of the simple operations that the CPU might carry out at the request of an instruction:</p><ul><li><em>Load</em>: Copy a byte or a word from main memory into a register, overwriting the previous contents of the register.</li><li><em>Store</em>: Copy a byte or a word from a register to a location in main memory, overwriting the previous contents of that location.</li><li><em>Operate</em>: Copy the contents of two registers to the ALU, perform an arithmetic operation on the two words, and store the result in a register, overwriting the previous contents of that register.</li><li><em>Jump</em>: Extract a word from the instruction itself and copy that word into the program counter (PC), overwriting the previous value of the PC.</li></ul><h2 id="Running-the-hello-Program"><a href="#Running-the-hello-Program" class="headerlink" title="Running the hello Program"></a>Running the <code>hello</code> Program</h2><p><img src="https://s2.loli.net/2024/11/11/WxsiolqVvAM5gnK.png" alt="Reading the hello command from the keyboard.png"><br>Initially, the shell program is executing its instructions, waiting for us to type a command. As we type the characters .&#x2F;hello at the keyboard, the shell program reads each one into a register and then stores it in memory.</p><p><img src="https://s2.loli.net/2024/11/11/o2yGauFwJnNz1hp.png" alt="Loading the executable from disk into main memory.png"><br>When we hit the enter key on the keyboard, the shell knows that we have finished typing the command. The shell then loads the executable hello file by executing a sequence of instructions that copies the code and data in the <code>hello</code> object file from disk to main memory. The data includes the string of characters <code>hello, world\n</code> that will eventually be printed out.</p><blockquote><p>Using a technique known as <em>direct memory access</em> (DMA, discussed in Chapter 6), the data travel directly from disk to main memory, without passing through the processor.</p></blockquote><p><img src="https://s2.loli.net/2024/11/11/LtcrOVb4GCAqERT.png" alt="image.png"><br>Once the code and data in the <code>hello</code> object file are loaded into memory, the processor begins executing the machine-language instructions in the <code>hello</code> program’s main routine. These instructions copy the bytes in the <code>hello, world\n</code> string from memory to the register file, and from there to the display device, where they are displayed on the screen.</p><h1 id="5-Caches-Matter"><a href="#5-Caches-Matter" class="headerlink" title="5. Caches Matter"></a>5. Caches Matter</h1><p>An important lesson from this simple example is that a system spends a lot of time moving information from one place to another. From a programmer’s perspective, much of this copying is overhead that slows down the “real work” of the program. Thus, a major goal for system designers is to make these copy operations run as fast as possible.</p><p><img src="https://s2.loli.net/2024/11/11/C1OVGkJTKigyE59.png" alt="image.png"><br>System designers include smaller, faster storage devices called <em>cache memories</em> (or simply <em>caches</em>) that serve as temporary staging areas(过渡区) for information that the processor is likely to need in the near future.<br>An L1 cache on the processor chip holds tens of thousands of bytes and can be accessed nearly as fast as the register file. A larger L2 cache with hundreds of thousands to millions of bytes is connected to the processor by a special bus. The L1 and L2 caches are implemented with a hardware technology known as <em>static random access memory (SRAM)</em>. Newer and more powerful systems even have three levels of cache: L1, L2, and L3.</p><p>One of the most important lessons in this book is that application programmers who are aware of cache memories can exploit them to improve the performance of their programs by an order of magnitude.</p><h1 id="6-Storage-Devices-Form-a-Hierarchy"><a href="#6-Storage-Devices-Form-a-Hierarchy" class="headerlink" title="6. Storage Devices Form a Hierarchy"></a>6. Storage Devices Form a Hierarchy</h1><p><img src="https://s2.loli.net/2024/11/11/rdLDHEoZGb1gyqN.png" alt="An example of a memory hierarchy.png"><br>The main idea of a memory hierarchy is that storage at one level serves as a cache for storage at the next lower level.</p><h1 id="7-The-Operating-System-Manages-the-Hardware"><a href="#7-The-Operating-System-Manages-the-Hardware" class="headerlink" title="7. The Operating System Manages the Hardware"></a>7. The Operating System Manages the Hardware</h1><p><img src="https://s2.loli.net/2024/11/11/TreJAvIFSuzyXaD.png" alt="Layered view of a computer system.png"><br>We can think of the <em>operating system</em> as a layer of software interposed between the application program and the hardware. All attempts by an application program to manipulate the hardware must go through the operating system.</p><p>The operating system has two primary purposes: </p><ol><li>to protect the hardware from misuse by runaway applications;</li><li>to provide applications with simple and uniform mechanisms for manipulating complicated and often wildly different low-level hardware devices.</li></ol><p><img src="https://s2.loli.net/2024/11/11/uQ7vKslaI5O3RHm.png" alt="Abstractions provided by an operating system.png"><br>The operating system achieves both goals via the fundamental abstractions: <em>processes</em>, <em>virtual memory</em>, and <em>files</em>. As this figure suggests, files are abstractions for I&#x2F;O devices, virtual memory is an abstraction for both the main memory and disk I&#x2F;O devices, and processes are abstractions for the processor, main memory, and I&#x2F;O devices.</p><h2 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h2><p>A process is the operating system’s abstraction for a running program. Multiple processes can run concurrently on the same system, and each process appears to have exclusive use of the hardware.</p><p>Traditional systems could only execute one program at a time, while newer multicore processors can execute several programs simultaneously. In either case, a single CPU can appear to execute multiple processes concurrently by having the processor switch among them. The operating system performs this interleaving with a mechanism known as <em>context switching</em>.<br><img src="https://s2.loli.net/2024/11/11/TduV6kKias2YmyG.png" alt="Process context switching.png"></p><p>The transition from one process to another is managed by the operating system <em>kernel</em>. The kernel is the portion of the operating system code that is always resident in memory. When an application program requires some action by the operating system, such as to read or write a file, it executes a special system call instruction, transferring control to the kernel.</p><blockquote><p>Note that the kernel is not a separate process. Instead, it is a collection of code and data structures that the system uses to manage all the processes.</p></blockquote><h2 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h2><p>In modern systems a process can actually consist of multiple execution units, called <em>threads</em>,<br>each running in the context of the process and sharing the same code and global data.</p><p>It is easier to share data between multiple threads than between multiple processes, and threads are typically more efficient than processes.</p><h2 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h2><p><img src="https://s2.loli.net/2024/11/11/aXsNoH8gtw9OfQu.png" alt="Process virtual address space.png"><br>Virtual memory is an abstraction that provides each process with the illusion that it has exclusive use of the main memory. Each process has the same uniform view of memory, which is known as its virtual address space.</p><p>In Linux, the topmost region of the address space is reserved for code and data in the operating system that is common to all processes. The lower region of the address space holds the code and data defined by the user’s process.</p><ul><li><strong>Program code and data.</strong> Code begins at the same fixed address for all processes, followed by data locations that correspond to global C variables. The code and data areas are initialized directly from the contents of an executable object file—in our case, the <code>hello</code> executable.</li><li><strong>Heap.</strong> The code and data areas are followed immediately by the run-time heap. Unlike the code and data areas, which are fixed in size once the process begins running, the heap expands and contracts <strong>dynamically</strong> at run time as a result of calls to C standard library routines such as <code>malloc</code> and <code>free</code>.</li><li><strong>Shared libraries.</strong> Near the middle of the address space is an area that holds the code and data for shared libraries such as the C standard library and the math library.</li><li><strong>Stack.</strong> At the top of the user’s virtual address space is the user stack that the compiler uses to implement function calls. Like the heap, the user stack expands and contracts <strong>dynamically</strong> during the execution of the program. In particular, each time we call a function, the stack grows. Each time we return from a function, it contracts.</li><li><strong>Kernel virtual memory.</strong> The top region of the address space is reserved for the kernel. Application programs are not allowed to read or write the contents of this area or to directly call functions defined in the kernel code. Instead, they must <strong>invoke the kernel</strong> to perform these operations.</li></ul><p>For virtual memory to work, a sophisticated interaction is required between the hardware and the operating system software, including a hardware translation of every address generated by the processor. The basic idea is to <strong>store the contents of a process’s virtual memory on disk and then use the main memory as a cache for the disk.</strong></p><h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p><strong>A <em>file</em> is a sequence of bytes, nothing more and nothing less.</strong> Every I&#x2F;O device, including disks, keyboards, displays, and even networks, is modeled as a file. All input and output in the system is performed by reading and writing files, using a small set of system calls known as <em>Unix I&#x2F;O</em>.</p><h1 id="8-Systems-Communicate-with-Other-Systems-Using-Networks"><a href="#8-Systems-Communicate-with-Other-Systems-Using-Networks" class="headerlink" title="8. Systems Communicate with Other Systems Using Networks"></a>8. Systems Communicate with Other Systems Using Networks</h1><p><img src="https://s2.loli.net/2024/11/11/7hATLe6BakbZHJz.png" alt="A network is another I/O device.png"><br>From the point of view of an individual system, the network can be viewed as just another I&#x2F;O device.</p><h1 id="9-Important-Themes"><a href="#9-Important-Themes" class="headerlink" title="9. Important Themes"></a>9. Important Themes</h1><h2 id="Amdahl’s-Law"><a href="#Amdahl’s-Law" class="headerlink" title="Amdahl’s Law"></a>Amdahl’s Law</h2><p>Suppose some part of the system requires a fraction <em>α</em> of this time, and that we improve its performance by a factor of <em>k</em>.<br>$$<br>\begin{split}<br>T_{new}&amp;&#x3D;(1-\alpha)T_{old}+(\alpha{T_{old}})&#x2F;k\\<br>T_{new}&amp;&#x3D;T_{old}[(1-\alpha)+\alpha&#x2F;k]\\<br>S &amp;&#x3D; \frac{T_{old}}{T_{new}}\\&amp;&#x3D;\frac{1}{(1-\alpha)+\alpha&#x2F;k}<br>\end{split}<br>$$<br>Set <em>k</em> to ∞, we get<br>$$<br>S_{\infty}&#x3D;\frac{1}{1-\alpha}<br>$$The major insight of Amdahl’s law — to significantly speed up the entire system, we must improve the speed of <strong>a very large fraction of the overall system</strong>.</p><h2 id="Concurrency-and-Parallelism"><a href="#Concurrency-and-Parallelism" class="headerlink" title="Concurrency and Parallelism"></a>Concurrency and Parallelism</h2><p>We use the term <em>concurrency</em> to refer to the general concept of a system with multiple, simultaneous activities, and the term <em>parallelism</em> to refer to the use of concurrency to make a system run faster. Parallelism can be exploited at multiple levels of abstraction in a computer system.</p><h3 id="Thread-Level-Concurrency"><a href="#Thread-Level-Concurrency" class="headerlink" title="Thread-Level Concurrency"></a>Thread-Level Concurrency</h3><p><img src="https://s2.loli.net/2024/11/11/mSR2lf8VFg56rHX.png" alt="Multi-core processor organization.png"><br>Multi-core processors have several CPUs (referred to as “cores”) integrated onto a single integrated-circuit chip. The figure illustrates the organization of a typical multi-core processor, where the chip has four CPU cores, each with its own L1 and L2 caches, and with each L1 cache split into two parts—one to hold recently fetched instructions and one to hold data. The cores share higher levels of cache as well as the interface to main memory.</p><p>Hyperthreading, sometimes called simultaneous multi-threading, is a technique that allows a single CPU to execute multiple flows of control.<br>It involves having <strong>multiple copies</strong> of some of the CPU hardware, such as program counters and register files, while having only single copies of other parts of the hardware, such as the units that perform floating-point arithmetic.<br>Whereas a conventional processor requires around 20,000 clock cycles to shift between different threads, a hyperthreaded processor decides which of its threads to execute on a cycle-by-cycle basis. It enables the CPU to take better advantage of its processing resources.</p><blockquote><p>For example, if one thread must wait for some data to be loaded into a cache, the CPU can proceed with the execution of a different thread.</p></blockquote><h3 id="Instruction-Level-Parallelism"><a href="#Instruction-Level-Parallelism" class="headerlink" title="Instruction-Level Parallelism"></a>Instruction-Level Parallelism</h3><p>In Chapter 4, we will explore the use of <em>pipelining</em>, where the actions required to execute an instruction are partitioned into different steps and the processor hardware is organized as a series of stages, each performing one of these steps. The stages can operate in parallel, working on different parts of different instructions.</p><h3 id="Single-Instruction-Multiple-Data-SIMD-Parallelism"><a href="#Single-Instruction-Multiple-Data-SIMD-Parallelism" class="headerlink" title="Single-Instruction, Multiple-Data (SIMD) Parallelism"></a>Single-Instruction, Multiple-Data (SIMD) Parallelism</h3><p>At the lowest level, many modern processors have special hardware that allows a single instruction to cause multiple operations to be performed in parallel, a mode known as <em>single-instruction, multiple-data (SIMD)</em> parallelism.</p><blockquote><p>For example, recent generations of Intel and AMD processors have instructions that can add 8 pairs of single-precision floating-point numbers (C data type float) in parallel.</p></blockquote><p>These SIMD instructions are provided mostly to speed up applications that process image, sound, and video data.</p><h2 id="The-Importance-of-Abstractions-in-Computer-Systems"><a href="#The-Importance-of-Abstractions-in-Computer-Systems" class="headerlink" title="The Importance of Abstractions in Computer Systems"></a>The Importance of Abstractions in Computer Systems</h2><p>The use of <em>abstractions</em> is one of the most important concepts in computer science. For example, one aspect of good programming practice is to formulate a simple <em>application program interface (API)</em> for a set of functions that allow programmers to use the code without having to delve into its inner workings.</p><p><img src="https://s2.loli.net/2024/11/11/BvuYDbgAySwRjtq.png" alt="Some abstractions provided by a computer system.png"></p><blockquote><p>A major theme in computer systems is to provide abstract representations at different levels to hide the complexity of the actual implementations.</p></blockquote><p>On the operating system side, we have introduced three abstractions: files as an abstraction of I&#x2F;O devices, virtual memory as an abstraction of program memory, and processes as an abstraction of a running program. To these abstractions we add a new one: the <em>virtual machine</em>, providing an abstraction of the entire computer, including the operating system, the processor, and the programs.</p>]]></content>
    
    
    <categories>
      
      <category>computer basics</category>
      
      <category>CSAPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>期权投资策略1 - 期权定义</title>
    <link href="/posts/cd2d07a5.html"/>
    <url>/posts/cd2d07a5.html</url>
    
    <content type="html"><![CDATA[<p>对于期权而言，评估其适当性尤为重要：期权的买方可能会在短期内亏完其全部资金，而无备兑期权的卖方则可能面临巨大的财务风险。</p><h1 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a>1. 基本定义</h1><h2 id="期权价格与股票价格之间的关系"><a href="#期权价格与股票价格之间的关系" class="headerlink" title="期权价格与股票价格之间的关系"></a>期权价格与股票价格之间的关系</h2><p><strong>实值（in-the-money）</strong>和<strong>虚值（out-of-the-money）</strong>。如果股票价格低于看涨期权的行权价，则该看涨期权被称为虚值。如果股票价格高于看涨期权的行权价，则该看涨期权被称为实值。（看跌期权相反）</p><p>实值看涨期权的内在价值（intrinsic value）等于股票价格超出行权价的那部分金额。如果该看涨期权是虚值的，则它的内在价值为零。卖出期权的价格一般被称为<strong>权利金（premium）</strong>。权利金与<strong>时间价值权利金[time value premium</strong>，简称为<strong>时间价值（time premium）</strong>]有明显区别。时间价值等于该期权权利金超过其内在价值的那部分金额。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs math">实值看涨期权的时间价值 = 看涨期权的价格 + (行权价 - 股票的价格)<br></code></pre></td></tr></table></figure><p>如果看涨期权是虚值的，那么它的权利金和时间价值相等。</p><p>一般来说，当股票价格等于行权价时，期权的时间价值最大。随着期权变为深度实值或虚值，它的时间价值会显著地减小。</p><p><img src="https://s2.loli.net/2024/10/13/SdbCQYzjPgZ35my.png" alt="image.png"></p><p>持平（parity）：按其内在价值进行交易的期权被称为与标的证券持平的期权。</p><h1 id="2-影响期权价格的因素"><a href="#2-影响期权价格的因素" class="headerlink" title="2. 影响期权价格的因素"></a>2. 影响期权价格的因素</h1><p>期权价格与标的股票和该期权条款的性质相关。</p><p>主要可量化因素：</p><ol><li><p>标的股票的价格；</p></li><li><p>期权自身的行权价；</p></li><li><p>该期权的剩余存续期；</p></li><li><p>标的股票的波动率；</p><p>标的股票的波动率越大，期权价格越高。（股票具有能运动到相对更远向上距离的能力）</p></li><li><p>当前无风险利率（例如90天政府债券利率）；</p></li><li><p>标的股票的股息率。</p><p>标的股票的股息越高，它的看涨期权的价格就越低。因为除息（ex-dividend）时，股票价格会减少。</p></li></ol><blockquote><p>还有一些其他因素，比如市场情绪。不过这些影响只会在情绪激动的市场阶段发挥作用。</p></blockquote><h1 id="3-行权和指派：运作机制"><a href="#3-行权和指派：运作机制" class="headerlink" title="3. 行权和指派：运作机制"></a>3. 行权和指派：运作机制</h1><h2 id="预见到指派"><a href="#预见到指派" class="headerlink" title="预见到指派"></a>预见到指派</h2><p>指派往往会在下面的集中情形里出现：</p><ol><li><p>在到期时，看涨期权是实值的；</p><p>自动行权：如果期权在到期时是实值的，那就一定会被指派。</p></li><li><p>在到期前，期权在贴水（discount）交易；</p><p>当看涨期权以持平价或低于持平价交易时，往往就会发生提前行权。套利者（arbitrageurs，场内交易员或会员公司的交易员，他们只需支付很少量的交易费用）会利用这种贴水状态的机会进行交易。</p></li><li><p>标的股票支付高额股息，而且就要分红。</p><p>场内期权的持有者也许会因为预计到股价会下跌，而决定在除息日之前在二级市场卖掉这个期权。卖出的看涨期权数量足够多，期权的价格就有可能变为持平，甚至出现贴水。这样，套利者就有可能买入期权并行权。</p></li></ol><p>此外，当期权没有时间价值时，卖出者可以预期其会被指派。当期权还有时间价值时，它一般就不会被行权。</p><h1 id="4-期权市场"><a href="#4-期权市场" class="headerlink" title="4. 期权市场"></a>4. 期权市场</h1><p>股票市场采用专业商（Specialist）制度来做两件事：</p><ol><li>当某个股票缺乏公众投资者的买入或卖出指令时，他们必须用他们自己持有的头寸来为这个股票做市；</li><li>他们要保管公众订单簿，其中包括公众的买入或卖出现价指令（limit order），以及止损指令（stop order）。</li></ol><p>当场内期权开始交易时，芝加哥期权交易所引进了类似的交易机制，做市商（market-maker）和交易所经纪人（board broker）制度。做市商需要再缺乏公众指令的情况下提供买卖报价以买卖期权。交易所经纪人负责维持限价指令簿。</p><p>美国股票交易所（American Stock Exchange）在其期权交易中使用了专业商制度，但它也有功能与做市商类似的场内交易商（floor trader）。</p><h1 id="5-期权代码学"><a href="#5-期权代码学" class="headerlink" title="5. 期权代码学"></a>5. 期权代码学</h1><p>绝大多数经纪商和报价软件显示的期权如下格式：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">IBM</span> Jan(<span class="hljs-number">21</span>) <span class="hljs-number">2011</span> <span class="hljs-number">45</span> call<br></code></pre></td></tr></table></figure><p>其中，IBM为股票代码，Jan为到期月份，21为到期日，2011为到期年度，45为行权价，call为期权类型。</p><h1 id="6-期权交易细节"><a href="#6-期权交易细节" class="headerlink" title="6. 期权交易细节"></a>6. 期权交易细节</h1><ol><li>临近最后交易日，期权交易会变得狂热。投资者应选择还有很多时间剩余时下单，而不是等到期权存续期的最后时间里“冲击”交易。</li><li>期权交易的结算周期是一天。交易是在交易之后的第2个工作日进行结算的。</li><li>期权是以轮转方式（in rotation）开盘交易的。在轮转之中，参与者可以对每个特定的期权系列（如XYZ1月45看涨期权）逐一地申报买价和卖价，直到各种到期日和行权价的所有的call和put都开盘了为止。并不一定要每个系列都有交易发生，只要有买卖报价就行。<br>期权的开盘价一般都是不现实的。<br>大多数期权交易者都不会在轮转时交易，因此一个市价指令有可能会拿到一个很糟糕的价格。想在轮转期间交易应当使用限价指令。</li><li>当标的股票拆股、支付股息时，合约的条款会被调整。可能会导致出现带分数的行权价和每手合约不为100股股票的期权。</li><li>所有的期权都是以每股为基础进行报价的，不管这个期权对应了多少股股票。正常情况下，期权的报价应该对应100股标的股票。但是，假如UVW股票支付了5%的股票股息，那它每手的期权就对应了105股股票。如果该UVW4月38.1 call的售价为3美元（原本行权价是40），那买入它将实际花费315美元（3美元 * 105）。</li><li>标的股票的价格变化会产生新的行权价的期权。随着价格波动，交易所会加挂新的行权价的期权。</li><li>一个或一组投资者在市场的<strong>同侧</strong>（如买call和卖put都是看多）买入或卖出一种股票的期权合约数量不能超出一个限定数量（持仓限额，position limit）。</li><li>在一段特定的时间（一般是5个工作日）里可以行权的合约数量也同样遵守为持仓限额所规定的数量。这样的行权限额（exercise limit）是为了避免某个或某组投资者通过不断地在某一天买入看涨期权，然后第二天将它们行权，反复操作，从而对一个股票进行“逼仓”。</li></ol><h1 id="7-下单"><a href="#7-下单" class="headerlink" title="7. 下单"></a>7. 下单</h1><h2 id="指令的信息"><a href="#指令的信息" class="headerlink" title="指令的信息"></a>指令的信息</h2><p>各种不同的指令都包括：</p><ol><li>这笔交易是买入还是卖出；</li><li>期权是被买入还是卖出；</li><li>是开仓还是平仓；</li><li>是否是价差交易（spread）；</li><li>想要的价格。</li></ol><h2 id="指令的类型"><a href="#指令的类型" class="headerlink" title="指令的类型"></a>指令的类型</h2><ol><li>市价指令（market order）。</li><li>市场无责任指令（market not held order）。这种指令</li><li>限价指令（limit order）。</li><li>止损指令（stop order）。</li><li>止损-限价指令（stop-limit order）。</li><li>撤销前有效指令（good-until-canceled order，GTC）。</li></ol><blockquote><p>通过网络经纪人交易的客户无法使用“市场无责任指令”，也有可能不能使用“止损指令”和“撤销前有效指令”。</p></blockquote><h1 id="8-盈亏图形"><a href="#8-盈亏图形" class="headerlink" title="8. 盈亏图形"></a>8. 盈亏图形</h1><p>表格和图形可以比较直观地说明策略。简单举例：<br><img src="https://s2.loli.net/2024/11/09/JbHAu6RFtWTgY58.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>financing</category>
      
      <category>期权投资策略</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>对位</title>
    <link href="/posts/9cf75d1.html"/>
    <url>/posts/9cf75d1.html</url>
    
    <content type="html"><![CDATA[<h1 id="三六度"><a href="#三六度" class="headerlink" title="三六度"></a>三六度</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li><p>直接避免在对位中会犯的错误</p><ol><li>不和谐音程的问题，没准备、没解决</li><li>和谐音程的问题，比如平行五八度</li></ol></li><li><p>在两声部的情况下保证和声的完整和唯一性</p><blockquote><p>比如，在五八度的情况下，没有三音，和弦不确定，有可能是大三和弦、小三和弦；而三六度保障了三音的存在，不是根音和三音，就是三音和五音</p></blockquote></li></ol><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul><li><p>两个声部全是三度平行</p></li><li><p>两个声部全是六度平行</p></li><li><p>其中一个声部不动，另一个声部从三度跳到六度&#x2F;从六度跳到三度</p><blockquote><p>通常用在赋格的开头，声部的运动相对少的时候</p></blockquote></li><li><p>两个声部都朝某一方向运动，可以三变六&#x2F;六变三</p><p>如果最近时相差三度：其中一个声部要走三度，另一个声部要走二度</p><p>如果最近时相差六度：两个声部都需要走三度</p><blockquote><p>在赋格中，一般走三度的那个声部在过程中会增加一个二度的经过音</p><p>经过音八度平行也是被允许的</p></blockquote></li><li><p>两个声部中有跳动，实现三变六&#x2F;六变三</p><ul><li><p>一个声部走二度，另一个声部反向跳跃四度</p><blockquote><p>四度、五度跳进不需要准备</p></blockquote></li></ul></li></ul><h1 id="四五度"><a href="#四五度" class="headerlink" title="四五度"></a>四五度</h1><p>总结：四度和五度分别是三度和六度的不稳定状态。</p><h2 id="四度"><a href="#四度" class="headerlink" title="四度"></a>四度</h2><p>在对位的体系里，<strong>四度是一个不和谐音程</strong>。</p><p>把音程看作相对地面（最低音）的不同高度位置的东西。</p><p>把四度看成<em>三度的不稳定状态</em>，迟早要被解决到三度。</p><p>不要直接放一个四度，而是应该先放一个（稳定的）和谐音程（三度或六度），然后把地板（最低音）降低使得它们成为四度关系，再把地板上的四度解决到稳定的和谐音程。</p><p>不和谐音程（张力大，音量大）要出现在强拍上，解决后的和谐音程（张力小，音量小）在弱拍上。</p><h2 id="五度"><a href="#五度" class="headerlink" title="五度"></a>五度</h2><p>五度是一个和谐音程。</p><p>弱点：不具备和声的唯一性（比如，可以是大三也可以是小三）。</p><p>五度和四度的关系：声部可以对调，所以可以把五度看作是<em>六度的不稳定状态</em>，要解决到六度。此时因为声部对调，所以应该把最高音看作天花板，先构造稳定的三度或六度，把天花板移动构造五度，最后把下方的声部解决到六度。</p>]]></content>
    
    
    <categories>
      
      <category>music</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>巴菲特致股东的信 - 财务与投资</title>
    <link href="/posts/1dc30059.html"/>
    <url>/posts/1dc30059.html</url>
    
    <content type="html"><![CDATA[<h1 id="财务与投资"><a href="#财务与投资" class="headerlink" title="财务与投资"></a>财务与投资</h1><p>成功投资的关键是，在好公司的市场价格远远低于其价值时出手。</p><p>在20世纪70年代早期，大多数机构投资者在决定交易价格时，认为企业价值与价格的关系不大。现在看来，这简直是难以置信。然而，这些机构都中了名牌商学院的学术魔法，他们鼓吹一种新型时尚的理论，认为股票市场是完全有效的，因此，企业的价值计算——甚至计算本身，在投资活动中无足轻重。（我们非常感激这些学者，在一场理智的竞赛中——无论是打牌、下棋还是选股，如果你的对手被教育说“思考纯属浪费精力”，还有什么比这能使你更具优势呢？</p><h2 id="A-市场先生"><a href="#A-市场先生" class="headerlink" title="A. 市场先生"></a>A. 市场先生</h2><p>你应该将市场报价想象为一个名叫“市场先生”的人，他是你的私人公司的合伙人，是一个乐于助人的热心人。他每天都来给你一个报价，从不落空。在这个价格上，他既可以买你手中持有的股份，你也可以买他手中的股份。</p><p>即便你们俩拥有的这家公司运营良好，市场先生的报价也不一定稳定，悲观地说，这个可怜的家伙有着无法治愈的精神病症。在他感觉愉快的时候，只会看到企业的有利影响因素。在这种心情中，他会报出很高的买卖价格，因为他怕你抢夺他的利益，掠走他近在眼前的利润。在他情绪低落的时候，他只会看到企业和世界的负面因素。在这种悲观心情中，他会报一个很低的价格，因为他害怕你会将你的股权甩给他。</p><p>市场先生还有一个可爱的特点：他不介意被忽视。如果你今天对他的报价不感兴趣，他明天还会给你带来一个新报价。是否交易，完全由你抉择。在这种情况下，他的行为越是狂躁抑郁，越是对你有利。</p><p>市场先生在那里服务于你，而不是指导你。你会发现他的钱袋更有用，而不是智慧。如果他哪天出现了特别愚蠢的情绪，你的选择是，可以视而不见，也可以利用这样的机会。但是，如果你受到他情绪的影响，将会是一场灾难。的确，如果你不懂得你的公司，不能比市场先生更准确地评估你的公司，你就不要参与这场游戏。</p><h3 id="买家应该更喜欢股价的下跌"><a href="#买家应该更喜欢股价的下跌" class="headerlink" title="买家应该更喜欢股价的下跌"></a>买家应该更喜欢股价的下跌</h3><p>当你读到类似“投资者因股市大跌而亏损”的新闻头条时，应该感到高兴。你们应该在心里将其重新编辑为：“撤资者因股市大跌而亏损，但投资者在获益。”记者们常常会忘记这条常识：每一个买家都对应着一个卖家，一个人受到的伤害往往成就另一个人。</p><h2 id="B-套利"><a href="#B-套利" class="headerlink" title="B. 套利"></a>B. 套利</h2><p>我们集团旗下的保险子公司有时会参与套利活动，作为手中短期现金等价物的替代方式（既保持很高流动性，又能获得一定的收益）。当然，我们的偏好是长期投资，但经常会遇到“现金多过好主意”的情况。这个时候，套利能提供比国债高得多的回报。除此之外，同样重要的是，这样做可以令我们面对放松长期投资标准的诱惑时冷静下来。</p><p>套利（arbitrage）这个词，曾经仅仅用于证券或外汇，指在两个不同市场上同时买卖的行为，目的是为抓住不同市场间的微小差价。例如荷兰皇家石油公司的股票，以荷兰盾计价在阿姆斯特丹交易，以英镑计价在伦敦交易，以美元计价在纽约交易。在不同市场间，经过汇率的折算，股价并非完全相等。有些人会在不同市场间倒手，意图赚取差价。你不必感到惊讶，从业者为此选了一个法语词汇：套利。</p><p>自第一次世界大战以来，套利的定义——或者，现在称之为“风险套利”——已经扩展了很多，包括从一个宣布的公司事件中追逐利润，例如公司出售、合并、重组、改制、清算、自我收购等。在很多情况下，套利所期待的利润与股市行为无关，其面临的主要风险是宣布的事件没有发生。</p><p>近些年来，大多数套利行为涉及到公司的收购接管，有友好的，也有敌意的。随着反垄断挑战几乎不存在，以及出价越来越高，并购热潮愈加繁荣蔓延，套利行为极为昌盛。他们不需要具有特别的天赋就能干得很好，窍门只不过就像演员彼得·塞勒（Peter Sellers）在电影中所说的：“恰逢其时”。在华尔街，有条不断重复的古老谚语：“授人以鱼，只能养活他一天；教他如何套利，能养活他一辈子。”</p><p>在评估套利条件时，你必须回答四个问题：<br>（1）承诺的事情发生的概率有多大？<br>（2）你用于套利的资金能挺多长时间？<br>（3）出现更好事情的可能性有多大？例如，有人提出更具竞争力的收购报价。<br>（4）如果一些预期中的事情没有发生，会怎么样？这些事情包括反垄断、财务差错等等。</p><p>伯克希尔进行的套利活动与很多其他套利者不同。</p><p>首先，我们每年参与的套利活动很少，但通常规模很大。业内很多其他参与者，通常进行次数很多，也许有50次，甚至更多。如果需要同时做很多事情，就像同时将很多烙铁放在火中，人们就必须花大量的时间，既要监控交易的过程，又要监控市场股价的波动。这不是芒格和我所想的生活模式。（<strong>如果只是为了赚钱而整天盯着股票行情，这种生活有什么意义可言？</strong>）</p><p>我们与其他套利交易者的另一个不同之处在于，我们只根据公开的信息进行交易，不会根据谣言进行买卖，也不会试图猜测谁是接管的下家。我们只是阅读新闻报纸，思考少数几个大的主意，根据我们自己感觉的概率行事。</p><p>套利仓位本来是安排短期现金等价物的一个替代方式，在过去一段时期，我们持有的现金处于较低水平。在另一些时候，虽然持有较大规模的现金仓位，我们也没有参与套利活动。主要原因是，我们认为交易对我们而言没有经济上的意义，这种套利交易接近于玩“谁是更傻的傻瓜”的游戏。正如华尔街人士雷·迪福（Ray DeVoe）所说的那样：“天使都害怕交易的地方，傻瓜却蜂拥而入。”我们仍将会时不时地参与套利活动，有时规模还会很大，但仅仅在我们认为胜券在握的时候才会出手。</p><h2 id="C-戳穿标准教条"><a href="#C-戳穿标准教条" class="headerlink" title="C. 戳穿标准教条"></a>C. 戳穿标准教条</h2><p>“市场有效理论”（efficient market theory，EMT）：20世纪70年代，这种教条在学术圈子里十分流行，实际上几乎被奉为“圣经”。从本质上而言，这种理论认为，股票分析毫无用处，因为所有的与股票相关的公开信息，都已经相应地反映在股价中。换而言之，市场总是无所不知。由是推之，传授市场有效理论的教授会说，一个人往股票清单上随意扔飞镖选出的股票组合，完全可以与一个最聪明、最努力的证券分析师选出的股票组合的表现相媲美。</p><p>令人惊讶的是，接受市场有效理论的不仅有学者，还有很多投资专家和公司管理层。他们能正确地观察到市场运行“通常”是有效的，却不正确地得出市场“总是”有效的结论。</p><p>于是很自然地，那些受到市场有效理论伤害的学生和受骗上当的投资者，实际上为我们以及其他格雷厄姆的追随者提供了非同一般的服务。无论是哪一种形式的竞赛，无论是财务上、心理上还是体力上，面对一群被灌输了“努力也会徒劳无益”的对手，我们于是拥有了巨大的优势。从利己主义的观点出发，格雷厄姆的信徒们应该捐助大学里的教学职位，以确保市场有效理论的教学能一直持续下去。</p><p><strong>不要卖出皇冠上的宝石</strong></p><p>当我们拥有具备杰出管理层的杰出企业的股份时，我们喜欢的持有时间是永远。有些人在持有的公司表现稍好之时，就会匆忙卖出变现利润，但他们却坚定地持有那些表现不佳的公司，我们与这些人截然相反。彼得·林奇（Peter Lynch）将这种行为恰当地比喻为“剪除鲜花，浇灌杂草”。</p><p>有趣的是，作为公司管理层，当他们专注于企业本身的运营时，并不难发现这一点：在完全忽视股价的情况下，一家拥有子公司的母公司，如果子公司长期表现优异，母公司是不可能出售子公司的。“为什么要卖出？”CEO会问，“难道要我卖出皇冠上的宝石吗？”然而，当同样的事情变成他个人的投资时，他会在经纪人一知半解的鼓动下，冲动地——甚至鲁莽地不停买卖，从一个公司的股票切换到另一个公司的股票。</p><p>在我们看来，对待企业的方法同样适用于股票。一个投资者，哪怕他持有的股票仅仅是一家杰出公司的一小部分，他也应该同样具有坚忍不拔的精神，就像一个企业家拥有整个公司一样。</p><p>很久以前，芒格和我认为，在一生的投资生涯中，很难做出数以百计的明智决策。随着伯克希尔的资本规模急剧增长，决断的压力变得愈加巨大，而且，能影响我们业绩的投资空间急剧缩小。因此，我们采取的策略是，对自己仅仅要求次数有限的聪明，而不是过分聪明。的确，我们现在每年只落实一个好主意。</p><p><strong>模糊的正确胜过精确的错误</strong></p><p>在评估风险的时候，一个追求贝塔的纯粹主义者会不屑于调查公司的产品、竞争力如何或公司的负债情况，他甚至没有动力去了解公司的名字。他所重视的不过是该公司股票的历史价格。与此相反，我们很高兴无视股票的历史股价情况，取而代之的是，我们关心有什么信息能令我们对公司更加了解。</p><p>一个投资者真正的风险衡量在于，应该评估<strong>是否在其预期的持股期间，其投资的税后收益总和（包括他卖出所得）会带给他至少在投资开始之初同等的购买力，加上合理的利率因素</strong>。尽管，这种风险无法如同工程计算一样精确，但在一些例子中，可以用一些有用的精确度来判断。与这种评估有关的主要因素有：<br>（1）评估公司长期保持经济特征的确定性。<br>（2）评估公司管理层能力的确定性，这些能力既包括充分实现企业潜力的能力，也包括明智运用企业现金流的能力。<br>（3）公司管理层回报股东而不是回报自己的确定性。<br>（4）购买公司的价格。<br>（5）将会遇到的通货膨胀和税务水平，这些将会影响投资者购买力的缩减程度。</p><p>相比其他电脑公司或零售商，真的很难计算可口可乐和吉列公司的长期商业风险会低多少？ [3] 在世界范围内，可口可乐的销售占据44%的软饮料市场份额，吉列占有超过60%（按价值计算）的刀片市场份额。谈到口香糖，如果剔除主导商家——箭牌公司，我还真不知道在这个行业有什么其他的领先公司享有这样的全球影响力。<br>此外，近年来在世界范围内，可口可乐和吉列的市场份额实际上还在提升。它们的品牌力，它们的产品属性，它们分销系统的实力，这些都赋予它们巨大的竞争优势，在其经济城堡外围建立了一条护城河。</p><p><strong>投资者的真正风险</strong></p><p>由贝塔孕育出来的理论家，没有办法区分不同公司之间的内在风险。例如，一家销售宠物石头或呼啦圈的玩具公司的内在固有风险，和另外一家拥有单一大富翁游戏或芭比娃娃的玩具公司的内在风险，二者有何不同？但是，对于普通投资者而言，只要对消费行为和长期竞争力优劣具有适度的理解能力，区分它们的不同毫无难度。很明显，每个投资者都会犯错误。但是，如果将自己限制在一个相对有限且容易明白的行业，一个智力正常、见多识广、勤奋努力的人就能够以相当的精确度判断投资风险。</p><p>有时候，我们自身智力的短板阻碍了我们的理解，但有时，这些行业的特性本身就是拦路石。例如，一家必须不断面临科技快速变化的公司，让人无法进行可靠的长期经济前景的评估。我们当中，有谁能在30年前，预见到电视制造业或电脑行业所发生的变化？当然没有。（大多数热衷于该行业的投资者和公司管理层也没有预见到。）那么，芒格和我又怎么能认为我们能够预见那些迅速变化的公司的未来呢？我们会<strong>坚守在那些易于理解的行业</strong>。一个视力平平的人，没有必要在干草堆里寻找绣花针。</p><p><strong>多元化投资vs. 集中投资</strong></p><p>有些投资策略——例如，我们多年以来的套利活动——要求广泛的多元化。如果单个交易蕴藏巨大的风险，那么，通过进行多个相互独立的交易，可以降低整体风险。这样，如果你认为权衡概率之后，你的获利大大超过你的损失，而且，如果你能抓住一系列类似的，却相互不关联的机会时，就可以进行有意识的风险投资，实际上这很有可能引起损失或伤害。大多数风险投资运用这样的策略。</p><p>另一种要求多元化的情况是，当一个投资者并不了解特定公司的经济状况，仅凭兴之所至，相信自己可以成为某个美国公司的长期股东。这样的投资者应该拥有大量股票，并且分开多次买入。例如，通过定期投资指数的方式，一个知之甚少的投资者实际上能够战胜大多数投资专家。有意思的是，当“傻”钱承认自己的局限，它就不再傻了。</p><p>另一方面，如果你是一个有一定知识储备的投资者，懂得经济，并能找到五到十家价格合理的、具有长期竞争优势的公司，那么，传统的多元化投资策略对你而言并无意义，它只会拉低你的投资收益率，并提高你的风险。我无法明白，如果一个投资者有一列喜欢的公司名单，为什么要将资金投到排在第20名的公司，而不是投资在首选前列的公司里，它们才应该是最了解、风险最低的标的，具有最大的利润回报潜力。</p><p>我们一直坚持不动如山的原则，这种行为表达了我们的一个观点：股市是一个不断重新定位的地方，在这里，钱会从活跃者手中流向耐心者手中。（根据在有限范围内进行的调查，我认为近来发生的事件表明，那些饱受诟病的“有钱有闲的富人”已经遭到了负面评价：他们维持或提升了财富水平，而同时那些“精力旺盛的富人”——进取的不动产运作商、公司并购者、石油钻探商等——则眼看着自己的财富消失。）</p><p>我们继续寻找那些业务易懂，可持续经营，具有令人垂涎的经济特征，拥有杰出才能和股东利益导向的管理层的大型公司。我们既必须以合理价格购买，又需要让企业的表现证明符合我们的预期。仅仅关注于这些并不能保证结果，但是，这个投资方法——寻找超级明星——为我们提供了真正成功的唯一机会。考虑到我们打交道的资金数量巨大，芒格和我还没有聪明到，可以通过熟练地买进、卖出平庸公司获得高额利润的程度。我们也不认为，会有其他很多人，可以通过在不同花朵之间跳来跳去的方式，取得长期的投资成功。实际上，我们认为将那些频繁买卖的机构称为“投资者”，就像将那些喜欢一夜情的家伙称为浪漫主义者一样可笑。</p><p>约翰·梅纳德·凯恩斯（John Maynard Keynes）是一位杰出的经济学家，与其杰出经济思想相匹配的，他也是一个杰出的投资实践家。他说：“随着时光的流逝，我越来越感到确信，投资的正确方式是将相当分量的资金，投资于你了解并拥有令人充分信任的管理层的公司。”那种认为通过广泛投资于知之甚少的不同公司，自信可以降低风险的想法是盲目且错误的。一个人的知识和经验注定是有限的，在某些特定的时间段，使我感受到充分信心的公司很少超过两或三家。</p><p><strong>谁会被股市波动所伤害？</strong></p><p>很多市场评论人士就近期观察到的事件，所得出的结论是不正确的。他们喜欢说，在当前大机构飘忽不定的行为主导的市场中，小投资者已经没有赚钱的机会。这个结论是相当错误的。<strong>这种市场无论对任何投资者都是理想的，无论大小，只要他坚守自己的投资系统。</strong>由那些握有巨资的基金经理所导致的市场波动，恰恰为真正的投资者提供了更多的明智投资的机会。只有在市场艰难的时候，投资者被迫卖出——无论是来自财务压力，还是心理压力——他才会被股市波动所伤害。</p><h2 id="D-“价值”投资：多余的两个字"><a href="#D-“价值”投资：多余的两个字" class="headerlink" title="D.“价值”投资：多余的两个字"></a>D.“价值”投资：多余的两个字</h2><p>是买下具有控制权的公司股份，还是买入上市公司在市场上可流通的部分股票，在这两者之间，我们真的没发现有什么不同。但无论在哪种情况下，我们都试图买入那些具有良好经济前景的公司。我们的目标是发现那些价格合理的杰出公司，而不是价格便宜的平庸公司。芒格和我发现，给我们丝绸，让我们织出丝绸钱包，我们可以干得很好，但巧妇难为无米之炊。</p><p>在买入控制权类的企业投资和非控制权的股票类投资中，我们不仅仅是买好公司，而且希望它具备德才兼备的、令人喜爱的管理层。如果我们遇上了志不同、道不合的管理层，那么，控制权类的投资赋予我们更多优势，因为我们可以用权力进行改变。然而，在实践中，这个优势是有点虚幻的，管理层的改变，就像婚姻的改变一样，是痛苦的、耗时漫长的、具有风险的。</p><p>控制类投资有两个主要优势。</p><p>第一，如果我们控制了一家公司，我们就能支配该公司的资产配置；而当我们仅仅是投资了一些可流通股票，我们对于公司资产的配置则毫无话语权。这一点可能非常重要，因为，很多公司的领导人并不擅长资产配置。大多数老板获得今天的领导地位，往往由于他们在某一领域的优秀，或是市场，或是生产，或是工厂，或是行政，甚至机构政治。</p><p>通过投资可流通证券进而控股公司的第二个优势是税务方面。作为一个公司的持有者，伯克希尔通过持有部分股票的形式，吸收了相当分量的税务成本，而这点在持有超过80%股份的情况下是不存在的。税务的不利一直伴随着我们，但是在1986年，新税务法规的变动，令这种影响大大增加。新税法导致的结果是，那些持股超过80%的子公司相对于那些持股比例更少的公司，可以输送给伯克希尔的利润可以多达50%或更多。</p><p>持有可流通证券的劣势有时会被巨大的优势所抵消，股票市场经常会提供给我们机会，能以低得非常可笑的价格购买杰出公司的非控制部分权益，股价会明显低于转移控制权谈判中要求的价格。例如，我们在1973年以5.63美元&#x2F;股的价格，购买《华盛顿邮报》的股票，到了1987年每股运营利润为10.30美元（税后）。类似的例子，也发生在盖可保险公司身上，我们分别在1976年、1979年和1980年以平均6.67美元的价格买入，去年的每股税后运营利润为9.01美元。在这些例子中，市场先生看来是一个不错的朋友。</p><p>我们挑选可流通证券的方法，与我们评估企业、进而收购全部股权的方法并无二致。我们要求这家公司具有以下几个特征：<br>①我们能够理解；<br>②具有良好的长期前景；<br>③具有诚实且能干的管理层；<br>④能以非常有吸引力的价格买到。</p><p>我们认为“价值投资”这个术语是非常多余的。在投资过程中，我们采取的行动都是寻找价值的行动，至少是物有所值，否则，什么是“投资”呢？<strong>有意识地为一只股票支付高价，然后希望以更高的价格迅速卖出，这种行为应该被贴上投机的标签。</strong>以我们的观点，这样做，虽然不违反法规与道德，也不能赚大钱。</p><p><strong>成长是价值的组成部分</strong></p><p>如何确定什么是“有吸引力的价格”？在回答这个问题上，很多分析师认为他们必须在两个通常相互对立的风格上做出抉择：“价值”和“成长”。我们认为，这两种观点时时交汇在一起，在计算价值时，成长其实就是价值的组成部分，它构成一个变量，这个变量的影响范围可以从微小到巨大，可以是消极负面因素，也可以是积极正面因素。</p><p>公司的成长本质上没有告诉我们什么有关价值的事。的确，成长通常对于价值有着积极的影响，有时达到惊人的比例。但是，这种影响难以确定。例如，投资者经常将金钱投入到国内航空公司，去资助毫无利润可言（甚至更糟）的成长。</p><p>只有在某一个点上，当公司的投资带来可观的边际增量回报时，成长才对投资者有利。换言之，只有当资助成长的每一美元长期而言，能创造出大于一美元的市场价值时，成长才对投资者有利。在那些边际回报率低下的公司里，成长有损于投资者利益（因为这些所谓的成长，通常会要求更多的融资支持）。</p><p><strong>价值方程式</strong></p><p>约翰·伯尔·威廉姆斯（John Burr Williams）在其著作《价值投资理论》（The Theory of Investment Value）一书中提出了价值方程式，我们在此精简如下：<strong>任何股票、债券或公司今天的价值取决于，在可以预期的资产存续期间，以合适利率进行贴现的现金流入和流出。</strong></p><p>注意，这个公式对于股票和债券通用。即便如此，对于两者而言，这里有一个重要但难以处理的地方：债券有明确的票息和到期日，能够确定未来的现金流；而对于权益资产，投资分析师必须自行分析估计未来的“票息”。此外，公司管理层的品质对于债券票息的影响较小，他们的无能或不诚信可能主要表现为暂停付息。相比之下，公司管理层的能力却能极大地影响权益的“票息”。</p><p>以现金流贴现的方式计算所得出的最便宜的对象，是投资者应该买入的投资标的——无论公司是否成长，无论公司的盈利是波动还是平稳，无论相对于当前盈利和账面值其股价的高低。此外，尽管这个价值方程式显示权益较债券便宜，但结果绝非必然。当债券经过计算显示出更具吸引力时，投资者应该买债券。</p><p>在伯克希尔，我们试图从两个方面评估权益：</p><p>第一，<strong>我们努力坚守我们认为自己了解的东西</strong>。这意味着，它们必须相当简单，并且经济特征稳定。如果一家公司的情况太复杂，或一直不断变化，那么，我们无法聪明到可以预测其未来现金流的程度。顺便说一句，这一缺点并未令我们感到困扰。对于投资中的大多数人而言，他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误。</p><p>第二，同样重要的是，<strong>我们坚持在买入时的安全边际</strong>。如果我们计算一只股票的价值仅是略微高于其价格，我们没有兴趣购买。我们相信，格雷厄姆强烈主张的安全边际原则是投资成功的基石。</p><h2 id="E-聪明的投资"><a href="#E-聪明的投资" class="headerlink" title="E.聪明的投资"></a>E.聪明的投资</h2><p>不动如山令我们像一个智者。无论是我们，还是大多数公司的管理层，都不会因为预期美联储些微的利率变动，或华尔街某些专家观点的改变，而狂热地出售那些盈利颇佳的公司。那么，对于我们持有的二级市场股票，虽然可能仅是小股东的位置，有何必要采取不同的策略呢？成功投资于上市公司股票的艺术，与成功收购全部公司股权的艺术，并无二致。在这两者中，无论哪一类，你应该考虑的仅仅是，<strong>标价合理、质地优良的公司，以及具有能干且诚实的管理层。在此之后，你需要做的只是观察这些品质是否能够得以保持。</strong></p><p>当一个投资者执行这类投资策略时，常常会导致他集中持有的几只股票占据了其投资组合的大部分。至于建议投资者将其最为成功的投资卖掉，仅仅因为它们带来的收益占据了投资组合的大部分，这样的建议就像让公牛队卖掉大明星迈克尔·乔丹一样，原因竟然是他的得分实在太多了，这当然是愚蠢的，因为他对于整个球队而言，实在太重要了。</p><p>我们喜欢的公司和行业，不大可能经历重大的变化。这样做的原因很简单：无论哪一种投资，我们寻找那些我们相信在未来10年、20年几乎可以肯定依然具有竞争优势的公司。一个环境迅速变化的行业或许会提供巨大的胜利机会，但是它不具备我们寻找的确定性。</p><p>应该强调的是，作为一个公民，芒格和我欢迎变化，新鲜的想法、新颖的产品、创新的过程，以及那些提升我们国家生活水平的东西，这些当然很好。然而，作为投资者，对那些处于发酵中而迅速膨胀、变化的行业，我们的态度就像我们对于太空探索的态度一样：我们会鼓掌欢迎，但不会参与其中。</p><p>在可流通证券投资方面，我们寻找同样的可预测性。以可口可乐为例，与可乐产品的销售维系在一起的热情与想象力，已经在CEO罗伯特·古兹维塔（Roberto Goizueta）的领导下，显得风生水起，他以杰出惊人的贡献为股东创造了非凡的价值。在协助下，罗伯特重新思考并改进了公司的各个方面。但可口可乐公司的基本面因素——可乐的竞争优势和出色的经济特质所带来的品质，多年以来一直保持稳定。</p><p>很显然，很多高科技公司或处于萌芽期的公司会以突飞猛进的方式发展，如果以百分比衡量，它们会比上述“注定如此成功”的公司成长更迅速。但我更喜欢一个确定的良好结果，而不是一个期望的伟大结果。</p><p>当然，你可以为最好的公司支付很高代价。但以我们的观点，支付过高的价格所带来的风险在周期之后会显露出来。而且，现在实际上所有的股票价格都已经相当高，包括那些“注定如此成功”的伟大公司在内。<strong>当市场过热时，投资者必须意识到，即便对于一家杰出的公司（如果支付了高价），常常可能需要很长的时间，才能产出与支付价格相匹配的价值。</strong></p><p>大多数投资者，包括机构和个人，会发现<strong>投资股票最好的方法是持有指数基金</strong>，指数基金的管理费很少。采取这种方法的人肯定会战胜<br>绝大多数投资专家的净回报（扣除费用和成本之后）。</p><p>但是，如果你打算构建自己的投资组合，这里有些想法值得记住。聪明的投资并不复杂，尽管远不能说容易。一个投资者所需要的是，能够正确地评估所选择企业的能力。注意“选择”这个词，你不必成为懂得任何公司的专家，或者，你也不必成为懂得很多公司的专家。你需要的仅仅是，<strong>能够正确地评估在你能力圈内的公司</strong>。这个圈子的大小并不特别重要，然而，知道这个圈子的边际非常关键。</p><p>为了投资的成功，你不需要懂得贝塔、有效市场、现代投资组合理论或新兴市场。实际上，你最好根本不知道这些东西。当然，我的这种观点并不是在多数商学院里盛行的观点，在那里，它们的财务金融课程都被这些主题所主导。尽管，我们的观点认为，学习投资的学生只需要学好两门功课就足够了—<strong>如何评估一家公司的价值，以及如何对待市场价格。</strong></p><p>作为一个投资者，你的目标很简单，就是<strong>以理性的价格，购买一家容易明白的，它的盈利从今天到未来的5年、10年、20年确定能大幅增长的企业</strong>。随着时光流逝，你会发现符合这样标准的企业并不多。所以，当发现符合条件的企业时，你应该<strong>大幅买入</strong>（而不是小赌怡情）。你还必须忍受那些让你背离原则的诱惑，如果你不打算持有一只股票10年，那就不必考虑甚至持有10分钟。当你持有一个盈利总额不断增长的投资组合，年复一年，你的投资组合的市值也会随之不断增长。</p><p>很多投资者没有选择指数基金，他们经历的结果分布范围从平庸到糟糕。导致这种表现不佳的原因有三个：<br>第一，高成本。通常是由于投资者交易频繁，或支付太多的管理费。<br>第二，以股评和市场流行风尚作为投资决策的依据，而不是深思熟虑的企业定量分析。<br>第三，以不合时宜的方式进出市场（常常是牛市进入，熊市退出）。</p><p>投资者应该牢记，亢奋与成本是他们的敌人。如果他们坚持尝试选择参与股票投资的时机，他们应该<strong>在别人贪婪的时候恐惧，在别人恐惧的时候贪婪。</strong></p><p>如果有两种公司让我们做出选择：一个价格合适但运营有问题，另一个价格有问题但运营良好，我们会倾向于后者。当然，最吸引我们的是，价格合适且运营良好的公司。</p><h2 id="F-捡烟蒂和惯性驱使（机构强迫症）"><a href="#F-捡烟蒂和惯性驱使（机构强迫症）" class="headerlink" title="F.捡烟蒂和惯性驱使（机构强迫症）"></a>F.捡烟蒂和惯性驱使（机构强迫症）</h2><h3 id="捡烟蒂"><a href="#捡烟蒂" class="headerlink" title="捡烟蒂"></a>捡烟蒂</h3><p>如果你以足够低廉的价格买入一只股票，那么，通常企业的价值波动会给你提供机会，让你以合理的利润脱手股票，即便从长期而言，这个公司或许很糟糕，你的回报也还行。这种投资方式，我称之为“捡烟蒂”投资法。在大街上发现地下有一节还能抽一口的雪茄烟蒂，尽管所剩无几，但因“代价便宜”，也可以获利。除非你是一名专业清算师，否则上述这种投资方法就是愚蠢的。</p><p>首先，最初看似“便宜”的价格可能最终根本不便宜。一家处境艰难的公司，在解决了一个难题之后，不久便会有另一个问题冒出来，就像厨房里如果有蟑螂，不可能只有一只。</p><p>其次，任何你得到的初始优势会很快被公司的低回报所侵蚀。例如，你以800万美元买下一个公司，能迅速以1000万美元卖出或清算，而且可以立刻执行，那么你能实现高回报。但是，如果这家公司是在十年之后以1000万美元处理掉，即便在此期间每年有几个点的分红，那么这项投资也是令人失望的。时间是优秀企业的朋友，是平庸企业的敌人。</p><p>当一个声誉卓著的管理者接手一家徒有虚名而经济状况不佳的公司时，能保全的只有这家公司的虚名。</p><p>伟大的投资机会往往发生在一家优秀公司遭遇一次性、可解决的问题时。</p><h3 id="惯性驱使"><a href="#惯性驱使" class="headerlink" title="惯性驱使"></a>惯性驱使</h3><p>在企业内部，有一种看不见的力量足以压倒一切，我们可以称其为“惯性驱使”或“机构强迫症”。</p><p>例如：<br>（1）似乎受到牛顿第一运动定律的控制，机构会抗拒在当前方向上的任何改变。<br>（2）就像工作的延伸会渐渐填满所有的时间一样，公司不断延伸的项目或收购行为会耗尽所有的现金。<br>（3）公司领导人所渴望进行的项目，无论多么愚蠢，都会迅速得到下属精心准备的有关回报论证和战略分析的支持。<br>（4）同行的行为，无论他们是扩张、收购、制定管理层薪酬等等，都会被不加思考地模仿。</p><p>如果我们在伯克希尔使用了更高的杠杆，尽管这样做仍然符合传统负债习惯，会取得远远高于我们已实现的23.8%的年回报率。甚至在<br>1965年，我们或许完全可以判断，动用杠杆能以99%的概率带来更高的回报率，几乎可以说是“十拿十稳”。相应地，我们大约有仅仅1%的机会看到，由于外部的或内部的一些突发因素，会导致即便是传统负债比率也会发生从暂时痛苦到违约之间的结果。</p><p>我们不喜欢这种99∶1的发生概率，永远不会。我们认为，一个小的丢脸或痛苦不可能被一个大的额外回报所抵消。如果你的行动是合理的，你肯定会得到良好的结果。在绝大多数情况下，杠杆只会加速事情的运动。芒格和我从来不会匆匆忙忙，我们享受投资过程远胜于收获的结果，我们学会了与之朝夕相处。</p><h2 id="G-生命与负债"><a href="#G-生命与负债" class="headerlink" title="G. 生命与负债"></a>G. 生命与负债</h2><p>毫无疑问，一些人通过使用财务杠杆变得非常富有。然而，这种方法通常也会令人穷困潦倒。当使用杠杆时，它会放大你的收益。这时，你的配偶会认为你很聪明，你的邻居会羡慕你。<strong>但杠杆这个东西是会令人上瘾的，一旦你奇迹般获利，很少有人会愿意再回到从前保守的状态。</strong>就像我们在三年级所学习的，一些人在2008年再次学习了，任何序列的正数，无论多么大的数字，只要乘以一个零，都会蒸发殆尽，一切归零。历史告诉我们，所有的杠杆通常导致的结果会是零，即便使用它的人非常聪明。</p><p><strong>我们持有的现金基本上是放在美国政府国债上，避免放在其他即便回报高出几个点，却风险不确定的短期证券上。</strong>早在2008年9月金融危机期间，商业票据和货币市场发生问题之前，我们就一直坚持这么做。我们同意投资作家雷·德沃（RayDeVoe）的观察：“人们过度追求收益所造成的损失，超过了被人持枪打劫！”</p><p>此外，在过去的40年中，伯克希尔没有动用过一分钱进行分红或回购股份。取而代之的是，我们留存了所有盈利，用于增强公司实力，这种实力以每月10亿美元的速度增长。在过去的40年中，我们公司的净资产因此从4800万美元增长到1570亿美元，我们的内在价值增长得更多。没有任何一家美国公司能以这种持之不懈的方式构建其财务实力。</p>]]></content>
    
    
    <categories>
      
      <category>financing</category>
      
      <category>巴菲特致股东的信</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>巴菲特致股东的信 - 与所有者相关的企业原则</title>
    <link href="/posts/bb7079a4.html"/>
    <url>/posts/bb7079a4.html</url>
    
    <content type="html"><![CDATA[<h1 id="与所有者相关的企业原则"><a href="#与所有者相关的企业原则" class="headerlink" title="与所有者相关的企业原则"></a>与所有者相关的企业原则</h1><ol><li><p>虽然组织形式上是公司制，但我们以合伙人的态度来行事。芒格和我将我们的股东视作我们的合伙人，而我们自己则是执行合伙人（因为无论是好是坏，从所占比例来说，我们都是控股合伙人）。我们并不将公司本身看作资产的最终所有者，而是认为公司仅仅是我们持有资产的一个渠道。</p></li><li><p>大多数的公司董事会成员将伯克希尔视为自己的产业，他们财富的主要部分就是持有公司股份所带来的价值。换而言之，我们吃自己做的饭。</p><blockquote><p>芒格90%以上的家庭资产都放在伯克希尔的股票上，而我则是98%～99%。此外，我的许多亲戚，比如姐妹和堂表亲，也都有很大一部分资产在持有我们公司的股票。</p><p>芒格和我对于这种把所有鸡蛋都放在同一个篮子里的状况感到很舒服，因为<strong>伯克希尔本身持有一系列多元化的杰出企业</strong>。事实上，无论是拥有这些企业的控股权还是少数权益，我们都相信伯克希尔是一个拥有股权质量和多样性都非常好的企业，这是伯克希尔的独一无二之处。</p></blockquote></li><li><p>我们长期的经济目标（受到限制的部分会在后面提及）是伯克希尔公司每股内在价值的平均年回报率最大化。我们并不以公司规模来衡量经济意义或表现，而是以每股的增长来衡量。我们确信未来每股的增长率将会下降——这是由于资产规模过大所致。但如果我们的增长率无法超过美国大型企业的平均增长率，我们将会非常失望。</p></li><li><p>为了达成目标，我们的首选是直接持有一系列多元化的企业，从中获得稳定的现金流和持续的高于市场平均水平的资本回报。我们的第二选择是通过旗下的保险公司，主要是在市场上寻找便于交易的股票，从而持有一些类似企业的股票。股票的价格和可获得的程度，以及保险资金的需求决定了任何特定年份的资本配置。</p><blockquote><p>一个低迷的股票市场，对我们而言是一件好事。</p><p><strong>第一，它使我们可以用更低的价格买下整个公司；</strong></p><p><strong>第二，低迷的市场使得我们的保险公司可以更容易地在一个具有吸引力的价格上，购买一些优秀企业的股票，包括我们已经持有部分股票的公司；</strong></p><p><strong>第三，一些优秀的企业，例如可口可乐，会持续回购自己的股票，于是它们和我们都能以更便宜的价格买入股票。</strong></p><p>总之，伯克希尔和它的长期持有者会从下跌的股市中获得好处，就像一个需要购买日常食品的消费者，从食品价格的下跌中获得的好处一样。所以当市场大跌时，和平常一样，不用担忧，不用沮丧，这对于伯克希尔反而是个好消息。</p></blockquote></li><li><p>由于我们的企业所有权方式以及传统会计方式的局限性，综合会计报表显示出的盈利无法真实体现出我们实际的经济成果。芒格和我既是所有者又是管理者，实际上会忽略这些由综合会计报表提供的数据。然而，我们会向你们报告我们所控制的重要企业所产生的收益和那些我们认为重要的数字。这些数字和我们提供的其他信息一起，将有助于你们做出判断。</p></li><li><p>账面的结果不会影响到我们的运作和资本分配的决策。在收购成本相近的时候，我们宁可购买那些根据标准会计准则，未在账面体现出来，但实际可以带来2美元盈利的资产，而不愿购买可以在账面上体现出来，但仅能获得1美元盈利的资产。这正是我们经常面临的情况，因为一个完整企业全部资产（所有利润都在报表中体现）的价格有可能会两倍于一个企业的部分资产（大部分利润未在报表中体现）。从整体和长期来看，我们希望那些未体现的盈利，通过资本增值的形式体现在我们的内在价值里。</p></li><li><p><strong>我们非常谨慎地使用债务。当进行借款时，我们试图将长期利率固定下来。</strong>我们宁愿拒绝一些诱人的机会，也不愿意过分负债。虽然这种保守的策略会影响我们的收益，但是考虑到我们身后的保险客户、贷款人和那些将相当大部分财产交由我们管理的投资者，考虑到对他们的信托责任，这种方式是唯一能让我们觉得安心的办法。（就像印第安纳波利斯（Indianapolis）500汽车拉力赛的获胜者所说的：“想成为第一，首先你必须完成比赛。”）</p><blockquote><p>芒格和我所采取的计算方法，从不要求我们为了每一点额外的小利而无法安枕。我不会用我的家人、朋友所拥有和所需要的东西去冒险，为了得到他们原本没有和不需要的东西。</p><p>此外，伯克希尔采用的两种低成本、无风险的杠杆资源使得我们可以安全地获取远超权益资本的总资产：递延纳税和保险浮存金。保险浮存金是我们的保险公司在进行偿付之前取得的保费收入的沉淀。这两项资金来源增长迅速，并且经常是无成本的。递延纳税这项负债无须承担利息。关于浮存金这部分，只要我们能够承保业务并且取得收支平衡，那么浮存金的成本也是零。我们应该明白，这两项都不是权益而是债务，但它们是没有契约规定到期日的债务。事实上，它们给我们带来了债务的好处（获取更多的可运营资产），却避免了债务的弊端。</p><p>我们喜欢长期、固定利率贷款。当我们进行大型收购时，例如BNSF，我们会从母公司借款，但为期很短。</p></blockquote></li><li><p>（伯克希尔会继续收购活动，）但管理层的这些“愿景清单”决不会让股东花冤枉钱。我们不会置长期的经济结果于不顾，花高价收购公司以追求多元化。我们使用你们的钱就像花我们自己的钱一样，并将你们从这些多元化行为中得到的价值，与直接投资所能获得的价值相权衡。</p><blockquote><p>芒格和我只对能够增加伯克希尔每股内在价值的收购感兴趣。我们的薪水高低、办公室的大小永远不会和伯克希尔的资产规模相联系。</p></blockquote></li><li><p>我们需要定期根据结果反思政策。我们会考察留存在公司里的利润，长期而言，每留存1美元利润，至少创造不少于1美元的市值。迄今为止，这个“1美元”原则都得以实现。我们未来会继续以每五年为周期进行观察。随着我们的资产日益增长，留存利润将越来越难以寻得运用良机。</p></li><li><p>我们只有在物有所值的情况下，才会以发行新股的方式进行收购。这一原则不仅仅运用在我们进行企业并购或股票投资上，还会运用在股债互换、股票期权、可转换证券等方面的投资上。发行新股实际上就是出售公司的一部分，我们出售公司部分股份的估值方式与我们对于整体公司的估值并无二致。</p></li><li><p>你们应该注意到，芒格和我的一种态度不利于我们的财务表现：无论价格如何，我们都没有兴趣卖掉伯克希尔所拥有的优质资产。</p><p>对于那些表现不尽如人意的企业，只要它们还能够产生哪怕微薄的现金流，只要管理层和劳资关系还不错，我们就不会出售。有人建议对表现不佳的企业投入大量资金以重振旗鼓，对于这样的建议，我们持极其谨慎的态度。（虽然有些项目看起来前途光明，但是，大量对于糟糕行业的额外投资，最终就像在流沙里挣扎一样，毫无意义。）但是拉米牌（rummy）游戏的玩法（当每轮出牌的机会来临，就放弃最没有希望的企业）并不是我们的风格。我们宁愿整体上略微遭受不利的影响，也不愿意这么做。</p><blockquote><p>我们会继续避免上述拉米牌游戏的玩法，的确，在苦苦挣扎了近20年之后，我们在20世纪80年代中期结束了伯克希尔原有的纺织类业务，因为我们认为这将是一项永远无法盈利的、填不满的窟窿。但是，我们不会轻易抛弃那些需要些许发展资金的业务，或需要花些时间关照的落后企业。</p></blockquote></li><li><p>在与股东沟通企业经营状况的过程中，我们会坦诚、如实地汇报好与不好的地方。我们的方针主要是采用换位思考的方式，如果我处在你们的位置上，希望了解哪些情况，我们不会亏欠你们一丝一毫。</p><p>此外，作为一个旗下拥有大型媒体的企业，在信息报道的准确、平衡、鲜明等方面，我们不会采用双重标准。我们始终认为诚实将令人受益，作为管理者也一样。那些在公众场合能误导大众的人，最终，也会在私下里误导自己。</p><blockquote><p>在我们所有的沟通形式中，我们对所有股东一视同仁。我们不会像市场上的惯例一样，将盈利预测指引信息专门供给业内的分析师和大股东。我们的目标是所有的股东同时得到同样的信息。</p></blockquote></li><li><p>虽然我们有开诚布公的态度，但只会在法规监管的范围内讨论我们的证券市场行为。因为好的投资主意非常稀缺，所以很宝贵，会引来竞争，就像优秀的产品或企业并购主意一样。</p><p>同理，我们也不会讨论我们的投资活动、股票交易。甚至那些已经出售的证券，我们也不会讨论（因为未来可能再买回来）。对那些传言中的投资，我们也不谈论，因为如果一会儿说“不谈论”，一会儿说“无可奉告”，那后者就被信以为真了。</p></li><li><p>我们希望股东在持有股票期间，能够获得与公司每股内在价值损益同步的收益。</p><p>为了这一目标，公司的内在价值与股价需要保持一致，能“一比一”最好，我们宁愿看到一个“合理”的股价，而不是“高估”的股价。显而易见，芒格和我都无法控制股价，但通过我们的政策与沟通，我们可以令股东们保持信息畅通和理性，这样反过来，能够使股价保持理性，股价过高或过低都不好。</p><p>这种态度可能会令一些股东感到失望，尤其是有卖出打算的人。但我们认为<strong>合理的股价能够吸引我们所需要的长期投资者，这些投资者从公司的长足发展中获益，而不是从合作伙伴的错误中获利。</strong></p></li><li><p>我们常常将伯克希尔每股账面价值的表现与标准普尔500指数比较，希望长期超越大盘，否则投资者何必把钱交给我们？</p><p>但这样做也有缺憾。现在我们在每个年度基础上进行这种比较，已经不如早前的比较那么准确，因为现在我们持有的资产中，与标普500同向变化的比重越来越少，不像我们早期的比重大。此外，标普500成分股的盈利全部会被计算在内，而我们由于联邦税率的缘故，只有65%被计算在内。因此，<strong>我们预期熊市时会超越大盘，而牛市时则会跑输。</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>financing</category>
      
      <category>巴菲特致股东的信</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>属和弦</title>
    <link href="/posts/a12f09b2.html"/>
    <url>/posts/a12f09b2.html</url>
    
    <content type="html"><![CDATA[<h1 id="属七和弦"><a href="#属七和弦" class="headerlink" title="属七和弦"></a>属七和弦</h1><p>D7</p><p>大调和小调里，属七和弦都是大三和弦加一个小三度</p><p>属七和弦中，根音和七音之间二度的摩擦感，相比普通属和弦，被解决到T的欲望更强烈</p><p>如果要使用五音在下的属和弦，要把七音加上：五音在下的属七和弦，可以正常使用，不像其他三和弦中五音在下有争议</p><p>属和弦也可以七音在下，只需要在D下面写7，不需要写在右上角</p><h1 id="属九和弦"><a href="#属九和弦" class="headerlink" title="属九和弦"></a>属九和弦</h1><p>D79</p><p>两种：属七和弦加小三度&#x2F;大三度</p><p>大调里一般用属大九（属七和弦加大三度）</p><p>小调里一般用属小九（属七和弦加小三度）</p><p>属小九有时在大调里出现，属大九几乎不会在小调里出现</p><p><img src="https://s2.loli.net/2024/10/06/8yt9POQTvurkwRc.png" alt="image.png"></p><p>更有张力和导向性</p><p>不常用，一般是在整首曲子最高潮的部分</p><p>一般是以原位出现；即使不以原位出现，按照低音声部与旋律凑三六度来转位即可</p><h1 id="导七和弦"><a href="#导七和弦" class="headerlink" title="导七和弦"></a>导七和弦</h1><p>可以看作属九和弦去掉根音（将属九和弦中的D划掉）</p><p><strong>导七比属九更常用</strong>：少一个音，少了一些摩擦感</p><p>属大九去掉根音：减小七的导七和弦</p><p><strong>属小九去掉根音：减七的导七和弦，Dv<em>（更常用，因为大小调都出现）</em></strong></p><p>使用方法和规则，与属九和弦相同：三音往上，七音和九音往下解决</p><p>导七和属七的关系：导七的九音往下解决，就是属七</p><h2 id="减七和弦"><a href="#减七和弦" class="headerlink" title="减七和弦"></a>减七和弦</h2><p>从低到高四个音，其中两两互为小三度关系</p><p>特殊性质：连续的12个音弹减七和弦，只有3组和弦不同，每组内的4个和弦完全一样</p><p>减七导七和弦和主和弦的关系：导七和弦（属九，去除根音前）的三音（导音）往上小二度，就是主和弦的根音</p><p>重要结论：<strong>主音属于同一个减七和弦的四对大小调，它们的减七导七听起来是一样的。所以是最常用的转调和弦。</strong></p><h1 id="副属和弦"><a href="#副属和弦" class="headerlink" title="副属和弦"></a>副属和弦</h1><p>不是去1级主的直接属和弦，而是去其他级大小三和弦的间接属和弦，用(D)表示。</p><p>几乎所有的附属和弦都是有七音的，用(D7)表示。用七音明确自己不是主和弦，还没有到稳定状态。</p><p>副属九和副属导七和弦也非常常用。</p><p>因为有一些调外音，可以随时加在它们目的地和弦的前面，制造惊喜感。</p><h1 id="重属和弦"><a href="#重属和弦" class="headerlink" title="重属和弦"></a>重属和弦</h1><p>去<em>属和弦</em>的副属和弦。用两个重叠的D表示。</p><p>一般都用转位，与下属和弦几乎相同，除了s的根音要升半音。</p><p>S6 -&gt; DD7 -&gt; D的进行很顺</p><p><img src="https://s2.loli.net/2024/10/07/wu7S6FfDqpaBgdG.png" alt="image.png"></p><p>S56 -&gt; DDv -&gt; D46的进行也很顺</p><p><img src="https://s2.loli.net/2024/10/07/c1bDRN3SoyBEwFe.png" alt="image.png"></p><blockquote><p>减七导七里只有降3级，没有升2级，所以是2级-&gt;降3级-&gt;3级</p></blockquote><p>下属和弦和重属和弦的种类：</p><p><img src="https://s2.loli.net/2024/10/07/QtTNAWUqZXyzCKY.png" alt="image.png"></p><h1 id="导六和弦"><a href="#导六和弦" class="headerlink" title="导六和弦"></a>导六和弦</h1><p>2级音作为低音的六和弦。</p><p>也是属七和弦去掉根音，把五音放在最下面。</p><p>常用终止式和弦，为属七作为标准终止式做铺垫。</p><blockquote><p>因为缺少根音，所以给人悬着的感觉：</p><ol><li>可以用在乐章结束，继续下一乐章。</li><li>可以用在歌剧中表示暧昧、疑问。</li></ol></blockquote><p><img src="https://s2.loli.net/2024/10/07/IvJ5qBYR8L1cXxu.png" alt="image.png"></p><p>可以重复2级音，也可以重复4级音，只要不重复导音就行。</p><p>导六的七音可以往上解决（而属七是往下解决），可以根据七音的去向来选择使用导六还是属七和弦。</p><p><img src="https://s2.loli.net/2024/10/07/GImVDR8nv3dMpfB.png" alt="image.png"></p><h2 id="属三四和弦"><a href="#属三四和弦" class="headerlink" title="属三四和弦"></a>属三四和弦</h2><p>与导六和弦非常相似，只是多了个根音。</p><p><img src="https://s2.loli.net/2024/10/07/Dd1FI9eq8jSQX7p.png" alt="image.png"></p><p>与导六和弦相似，七音可以往上解决。</p><h2 id="重属导六和弦"><a href="#重属导六和弦" class="headerlink" title="重属导六和弦"></a>重属导六和弦</h2><p>6级音上构造一个六和弦（4级音要升半音）</p><p><img src="https://s2.loli.net/2024/10/07/yEH2KWhPerZisgw.png" alt="image.png"></p><p>经常用在半终止。</p>]]></content>
    
    
    <categories>
      
      <category>music</category>
      
      <category>harmony</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>下属和弦</title>
    <link href="/posts/8ccd8ed4.html"/>
    <url>/posts/8ccd8ed4.html</url>
    
    <content type="html"><![CDATA[<h1 id="下属和弦"><a href="#下属和弦" class="headerlink" title="下属和弦"></a>下属和弦</h1><p>s经常在大调里出现，但S很少在小调里出现</p><h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><p>461</p><h2 id="S56"><a href="#S56" class="headerlink" title="S56"></a>S56</h2><p>4612</p><h2 id="S6"><a href="#S6" class="headerlink" title="S6"></a>S6</h2><p>462</p><p>S6可以避免S56中五音和六音之间的摩擦</p><p>很常用，频率和S平齐</p><h2 id="s6"><a href="#s6" class="headerlink" title="s6"></a>s6</h2><p>4b62（三音降半音）</p><h2 id="sb6-那不勒斯和弦，sN"><a href="#sb6-那不勒斯和弦，sN" class="headerlink" title="sb6 (那不勒斯和弦，sN)"></a>sb6 (那不勒斯和弦，sN)</h2><p>4b6b2（三音、五音都降半音）</p>]]></content>
    
    
    <categories>
      
      <category>music</category>
      
      <category>harmony</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MuseScore快捷键</title>
    <link href="/posts/ab407669.html"/>
    <url>/posts/ab407669.html</url>
    
    <content type="html"><![CDATA[<h1 id="MuseScore快捷键"><a href="#MuseScore快捷键" class="headerlink" title="MuseScore快捷键"></a>MuseScore快捷键</h1><p>N：打开音符输入</p><p>[A-G]：在谱的相应位置输入音符</p><p>Ctrl+上方向键：将蓝色的刚输入的音符上移八度</p><p>Ctrl+下方向键：将蓝色的刚输入的音符下移八度</p><p>W：将蓝色的刚输入的音符节拍延长一半</p><p>Q：将蓝色的刚输入的音符节拍缩短一半</p><p>Shift+W：将蓝色的刚输入的音符延长一个附点</p><p>Shift+Q：将蓝色的刚输入的音符缩短一个附点</p><p>[1-6]：直接设定待输入音符的节拍</p><p>Shift+[A-G]：在蓝色的刚输入的音符基础上输入其他和弦音</p>]]></content>
    
    
    <categories>
      
      <category>music</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>主和属的持续音</title>
    <link href="/posts/1a7b05eb.html"/>
    <url>/posts/1a7b05eb.html</url>
    
    <content type="html"><![CDATA[<h1 id="主和属的持续音"><a href="#主和属的持续音" class="headerlink" title="主和属的持续音"></a>主和属的持续音</h1><p>一种常用技巧：<strong>当低音用主和属的持续音时，上方用三六度代替和弦。</strong></p><p>一般用在乐曲开头，最低声部</p><ul><li><p>T上会出现T, S, D，且持续音上的TST比较常见</p></li><li><p>D上会出现T, D(7)（S在浪漫派逐渐变得常见）</p></li></ul><p>注意：一定要等到持续音所对应的正确的和弦（如，主或者属）出现，才可以结束这个持续音</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>与上方的和声和旋律产生有趣的摩擦</li><li>使得低音和声有很慢的感觉，控制和声节奏</li><li>有效避免功能的逆进行所带来的问题</li><li>当低音旋律出现一定重复时，考虑前半段加上更低的持续音，后半段就可以让低音旋律动起来了（比如低八度）</li><li>还能削弱终止式的强度</li></ol>]]></content>
    
    
    <categories>
      
      <category>music</category>
      
      <category>harmony</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>织体</title>
    <link href="/posts/3b9c5769.html"/>
    <url>/posts/3b9c5769.html</url>
    
    <content type="html"><![CDATA[<h1 id="织体：和声骨架之上的装饰"><a href="#织体：和声骨架之上的装饰" class="headerlink" title="织体：和声骨架之上的装饰"></a>织体：和声骨架之上的装饰</h1><p>高低声部严格，中间可以放水</p><p>和声骨架不能平行八度的原因：加厚旋律，不是和声考虑范畴，而是织体</p><p>节奏和声部都要有变化，不要太死板</p><p>四部和声也是一种织体：不装饰有时候是最好的装饰</p><h2 id="最重要，却最容易被忽视的织体：休止符"><a href="#最重要，却最容易被忽视的织体：休止符" class="headerlink" title="最重要，却最容易被忽视的织体：休止符"></a>最重要，却最容易被忽视的织体：休止符</h2><p>知道什么时候该闭嘴</p><ul><li><p>比如起拍为休止</p><p>可能是很长的起拍，比如一整个小节（在实际两个小节为一个“小节”的情况）</p></li><li><p>比如几个小节中只有几个地方配和声，其他时候都是休止</p></li><li><p>比如正拍上配休止</p><p>节奏上对位</p></li><li><p>比如功能没有改变的自由旋律，配休止即可</p><p>可以不用跟着旋律的节奏走</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>music</category>
      
      <category>harmony</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>和弦的转位</title>
    <link href="/posts/12494fc8.html"/>
    <url>/posts/12494fc8.html</url>
    
    <content type="html"><![CDATA[<h1 id="转位的作用"><a href="#转位的作用" class="headerlink" title="转位的作用"></a>转位的作用</h1><p>选择合适的转位：</p><ol><li>明显提升最低声部的旋律性</li><li>最低声部和旋律声部之间的对位关系</li></ol><h1 id="选择转位（最低声部）的快捷方法"><a href="#选择转位（最低声部）的快捷方法" class="headerlink" title="选择转位（最低声部）的快捷方法"></a>选择转位（最低声部）的快捷方法</h1><p>选择转位即选择低音</p><ol><li><p>开头用原位，终止式用原位</p></li><li><p>中间：和旋律凑三六度</p><blockquote><p>有多个音要配的时候，跟第一个音配上，再检查有没有其他影响即可</p></blockquote><p>以下情况可以脱离三六度思维：</p><ol><li>在终止式附近（前面一个小节），可以都用原位</li><li>上下两个声部都是有导向型的音，如属七的三音和七音（只要导向的地方是三六度就行）</li></ol></li><li><p>注意五音除了属七之外，不能在下</p></li></ol><h1 id="选择其余声部的方法"><a href="#选择其余声部的方法" class="headerlink" title="选择其余声部的方法"></a>选择其余声部的方法</h1><p>右手或左手额外增加一个中声部</p><h2 id="保障三六，缺啥补啥"><a href="#保障三六，缺啥补啥" class="headerlink" title="保障三六，缺啥补啥"></a>保障三六，缺啥补啥</h2><p>和声中，保障与旋律至少有一个三度和一个六度</p><blockquote><p>比如低声部和旋律为三度了，中声部就考虑与旋律凑六度。</p></blockquote><p>和弦的三个音里，缺了哪一个音就补哪一个音</p><blockquote><p>如果低音和旋律都是根音了，就必须补三音，不补五音。</p></blockquote><h2 id="能近则近，注意导音"><a href="#能近则近，注意导音" class="headerlink" title="能近则近，注意导音"></a>能近则近，注意导音</h2><p>能近则近：尽量不要跳太远</p><p>注意导音：注意导音的走向</p>]]></content>
    
    
    <categories>
      
      <category>music</category>
      
      <category>harmony</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>终止式</title>
    <link href="/posts/bdad8990.html"/>
    <url>/posts/bdad8990.html</url>
    
    <content type="html"><![CDATA[<h1 id="终止式的条件"><a href="#终止式的条件" class="headerlink" title="终止式的条件"></a>终止式的条件</h1><ol><li><p>跨小节线*</p><blockquote><p>小节线不一定是真正的小节线，视情况而定</p></blockquote></li><li><p>换功能</p><p>D46-35非常常用</p></li></ol><h1 id="终止式类型"><a href="#终止式类型" class="headerlink" title="终止式类型"></a>终止式类型</h1><h2 id="半终止：不是D-D"><a href="#半终止：不是D-D" class="headerlink" title="半终止：不是D -&gt; D"></a>半终止：不是D -&gt; D</h2><p>不是D -&gt; D46-35</p><h2 id="全终止：D-T"><a href="#全终止：D-T" class="headerlink" title="全终止：D -&gt; T"></a>全终止：D -&gt; T</h2><p>D46-35 -&gt; T</p><blockquote><p>不一定要一个半终止一个全终止，半终止也可以用一个弱一点的全终止代替，比如结束在三音而不是根音。</p></blockquote><h1 id="T46-35：D-7-T"><a href="#T46-35：D-7-T" class="headerlink" title="T46-35：D(7)-&gt;T"></a>T46-35：D(7)-&gt;T</h1><p>与D46-35的半终止相对应</p><p>D一般都会有七音</p><h2 id="半终止D46-35上的T-D"><a href="#半终止D46-35上的T-D" class="headerlink" title="半终止D46-35上的T-D:"></a>半终止D46-35上的T-D:</h2><p>低音5上面351(T)到257(D)</p><h2 id="全终止T上的D-7-T"><a href="#全终止T上的D-7-T" class="headerlink" title="全终止T上的D(7)-T:"></a>全终止T上的D(7)-T:</h2><p>低音1上面257(D)到351(T)</p><h1 id="Period-乐段"><a href="#Period-乐段" class="headerlink" title="Period 乐段"></a>Period 乐段</h1><p>乐段：上半句与下半句<strong>等长</strong>，且有明显<strong>呼应</strong>；且上半句结束在半终止，下半句结束在全终止。</p><p>上下半句的前半段可以不一样，仅需要一定的动机联系。</p><p>如果照抄前半段，则从某个点开始<strong>全都不一样</strong>。</p><h2 id="已知半终止，如何写完整句？"><a href="#已知半终止，如何写完整句？" class="headerlink" title="已知半终止，如何写完整句？"></a>已知半终止，如何写完整句？</h2><h3 id="1-简单粗暴二法"><a href="#1-简单粗暴二法" class="headerlink" title="1. 简单粗暴二法"></a>1. 简单粗暴二法</h3><ol><li>照抄提前：前半段照抄，后半段抄一部分，最后在T结束</li><li>照抄压缩：前半段照抄，后半段全抄压缩，最后加上T</li></ol><p>保证最后是T就行</p><h3 id="2-T上的D-7-T削弱终止感"><a href="#2-T上的D-7-T削弱终止感" class="headerlink" title="2. T上的D(7)-T削弱终止感"></a>2. T上的D(7)-T削弱终止感</h3><p>与D46-35呼应</p><h3 id="3-自由发展"><a href="#3-自由发展" class="headerlink" title="3. 自由发展"></a>3. 自由发展</h3><p>前后半段都可以不一样</p><h2 id="已知全终止，如何向前扩充？"><a href="#已知全终止，如何向前扩充？" class="headerlink" title="已知全终止，如何向前扩充？"></a>已知全终止，如何向前扩充？</h2><p>可以用在作曲中觉得太短了，需要加长的情况</p><h3 id="1-简单粗暴二法-1"><a href="#1-简单粗暴二法-1" class="headerlink" title="1. 简单粗暴二法"></a>1. 简单粗暴二法</h3><ol><li>交换：比如最后两音互换</li><li>换尾：最后几个音换成其他音</li></ol><h3 id="2-移位"><a href="#2-移位" class="headerlink" title="2. 移位"></a>2. 移位</h3><p>即平移，如最后的音321移到432</p><h3 id="3-自由"><a href="#3-自由" class="headerlink" title="3. 自由"></a>3. 自由</h3><p>但需要有动机联系</p><h1 id="如何削弱终止感？"><a href="#如何削弱终止感？" class="headerlink" title="如何削弱终止感？"></a>如何削弱终止感？</h1><ul><li>不用原位而用转位（凑三六度）</li><li>用主和属的持续音</li><li>旋律放在弱拍</li></ul>]]></content>
    
    
    <categories>
      
      <category>music</category>
      
      <category>harmony</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>四季便当Ⅱ-冬</title>
    <link href="/posts/4926cc34.html"/>
    <url>/posts/4926cc34.html</url>
    
    <content type="html"><![CDATA[<h1 id="冬"><a href="#冬" class="headerlink" title="冬"></a>冬</h1><h2 id="关东煮便当-引发憎恨的白萝卜"><a href="#关东煮便当-引发憎恨的白萝卜" class="headerlink" title="关东煮便当 | 引发憎恨的白萝卜"></a>关东煮便当 | 引发憎恨的白萝卜</h2><h3 id="关东煮便当"><a href="#关东煮便当" class="headerlink" title="关东煮便当"></a>关东煮便当</h3><p>所需时间：120分钟</p><p>份量：3-4人份</p><ul><li><p>关东煮材料</p><p>魔芋、白萝卜、水煮蛋、鱼糕、昆布、竹轮（圆筒形鱼糕）、章鱼（脚部、水煮）、炸豆腐等</p></li><li><p>调味汁材料</p><p>昆布、柴鱼片、黄糖、生抽、盐、味醂</p></li><li><p>小饭团材料</p><p>白米饭、辛子明太子（辣味鱼籽）、海苔、玉米粒、蛋黄酱、胡椒粉、黄油</p></li></ul><p>制作步骤</p><p>煮食材时，先放入魔芋、白萝卜等难以入味的食物，关火后放置几个小时使之入味。用餐前再放入鱼糕等容易煮熟的材料。</p><p>关东煮按个人口味可加黄芥末享用。做好的关东煮可当晚餐主菜，若要带便当，控水后再放入便当盒。因关东煮的水分多，盒子需选择有密封性的。</p><ol><li><p>处理白萝卜、魔芋</p><p>白萝卜（半根）去皮后切成厚片（3厘米左右），切上十字纹，水煮一刻钟。魔芋（1包）先用盐和饮用水清晰，切片后切成细条，用小锅煮2分钟备用。</p></li><li><p>处理其他材料</p><p>竹轮等材料切小块备用。鱼糕、炸豆腐等油炸材料用开水清洗，去除多余的油脂。章鱼切小块后用竹签穿起来备用。</p></li><li><p>做调味汁</p><p>昆布（10-15厘米见方，约15克）洗净后放入大砂锅里，加入饮用水（1500毫升），开大火，半小时后调小火。煮开后马上关火并取出昆布。接下来放入柴鱼片（3把，约20克），调小火，继续煮5分钟后关火，冷却。取出柴鱼片后加生抽（2-3汤匙）、黄糖（1汤匙），按个人口味加入味醂（2汤匙），用盐（少许）调味。取出来的昆布切条、打结后与其他食材一道加热食用。取出来的柴鱼片可以扔掉。</p></li><li><p>煮材料</p><p>将调味汁放入大砂锅里，开中火并放入白萝卜、水煮蛋（3-4个）、魔芋和昆布，煮开后调小火继续加热40分钟，关火。用餐之前放入鱼糕、章鱼等食材加热，煮开即可。</p></li><li><p>准备小饭团</p><p>用筷子将明太子（约30克）外层薄膜撕开，去除鱼籽，用平底锅加热到发白。按个人口味加黄油（少许），搁在小碗里备用。玉米粒也用平底锅加热，用蛋黄酱和胡椒粉调味备用。</p></li><li><p>做小饭团</p><p>在保鲜膜上放白米饭（少许），在米饭中央位置放明太子（少许），轻轻捏成小丸子。步骤5的玉米粒白米饭里，同样捏成小丸子。做好的小饭团用海苔包裹。</p></li></ol><h3 id="便当小贴士：日本人最喜欢的“锅料理”"><a href="#便当小贴士：日本人最喜欢的“锅料理”" class="headerlink" title="便当小贴士：日本人最喜欢的“锅料理”"></a>便当小贴士：日本人最喜欢的“锅料理”</h3><p>大部分关东煮的食材富含膳食纤维（如魔芋、昆布），高蛋白低脂肪（如竹轮等鱼糕类），切烹饪过程中不放油，是日本料理中的营养优等生。</p><p>据老牌食品公司“纪文”发布的白皮书记载，以家庭主妇为主的受访人最喜欢的“锅料理”（做好菜肴之后把整个锅端上餐桌享用的料理，如寿喜锅、涮涮锅、关东煮、汤豆腐等）是关东煮，这一排名从2006年保持至今。</p><p>大家最喜欢的关东煮里的食材，第一名是白萝卜，第二名是水煮蛋，第三名是竹轮，再往下是年糕豆皮包（餅巾着，类似年糕福袋）和牛筋。关东煮的食材可以自由搭配，如土豆、卷心菜肉卷、香肠、鸡翅、青菜……若当天吃不完，也可以热一下当第二天的早餐。</p><p>关东煮怎么吃？“以关东煮为主菜，配米饭吃”占52.6%，“不吃主食”占47.4%。大家搭配关东煮的饮料是啤酒优先，接下来是软饮料、清酒或烧酒等。</p><h3 id="引发憎恨的白萝卜"><a href="#引发憎恨的白萝卜" class="headerlink" title="引发憎恨的白萝卜"></a>引发憎恨的白萝卜</h3><p>出汁在日本的家庭料理中是不可缺的，味噌汤、炖菜、玉子烧等都可以加，按具体用途来调整昆布和柴鱼片的份量以及加热时间。关东煮用的出汁，一般是鲣鱼（柴鱼片的原料）味较浓，昆布味较淡，所以柴鱼片可以煮得略久一些。</p><p>厚实的白萝卜需要多煮会儿才能入味，而且削皮后最好切上十字纹。</p><p>做关东煮看起来很简单，但其实事先的准备工作和步骤并不少。若考虑到为一餐关东煮花费的功夫，也许在便利店买售价为70-100日元的关东煮更划算。但我还是执念于家里做的关东煮，对我来说，这道料理就是家的象征，象征着在寒冷的冬日里，守护着自己的家。</p><h2 id="照烧鸡肉米汉堡-快餐店杂记"><a href="#照烧鸡肉米汉堡-快餐店杂记" class="headerlink" title="照烧鸡肉米汉堡 | 快餐店杂记"></a>照烧鸡肉米汉堡 | 快餐店杂记</h2><h3 id="照烧鸡肉米汉堡"><a href="#照烧鸡肉米汉堡" class="headerlink" title="照烧鸡肉米汉堡"></a>照烧鸡肉米汉堡</h3><p>所需时间：50分钟</p><p>份量：2人份</p><ul><li><p>照烧鸡肉米汉堡材料</p><p>白米饭、鸡腿肉、生粉、姜末、蜂蜜、生抽、料酒、青苏叶（按个人口味）、黑胡椒（按个人口味）、蛋黄酱（按个人口味）</p></li></ul><p>制作步骤</p><p>取剔骨鸡腿肉，可在肉铺请店员处理，也可用鸡胸肉代替鸡腿肉。</p><p>米汉堡可夹其他材料，如牛蒡金平等。常备菜金平的做法参见本篇“便当小贴士”。</p><ol><li><p>做照烧鸡肉</p><p>将鸡腿肉（1块，约250克）用姜末（少许）和料酒腌制2-3分钟，中火预热平底锅后，将带鸡皮的一面朝下开始煎。鸡腿肉的油脂较多，故无需放油。若析出的油分太多，可以用吸油纸吸取一部分。</p></li><li><p>调味</p><p>鸡皮呈金黄色后翻面，继续加热到鸡肉八分熟。从锅边倒入生抽、料酒和蜂蜜（各1-2汤匙），并把火势调小。调味汁煮沸的泡沫变小后，盖上盖子焖2分钟。鸡皮呈亮色，酱汁变稠厚关火。</p></li><li><p>做米汉堡胚</p><p>将白米饭与生粉（约2撮）轻轻搅拌后，用保鲜膜包住，放入直径约7厘米的小盅里，用手指压实后取出。</p></li><li><p>加热</p><p>平底锅里铺上烘焙纸，放置做好的米饭饼皮。用小火慢慢加热，呈焦黄后关火备用。</p></li><li><p>夹入照烧鸡肉</p><p>将照烧鸡肉切小块，夹在饼皮中间。按个人喜好可加青苏叶、黑胡椒或蛋黄酱。</p></li></ol><h3 id="便当小贴士：牛蒡“豆知识”"><a href="#便当小贴士：牛蒡“豆知识”" class="headerlink" title="便当小贴士：牛蒡“豆知识”"></a>便当小贴士：牛蒡“豆知识”</h3><p>晚春初夏是牛蒡的当季时令。</p><p>秋日的牛蒡较有嚼劲，适合做金平。把牛蒡洗净后切细条或用刀削成细条，泡在水中以去除涩味。捞出后用炒锅加热，加料酒、糖和生抽，炒熟后再放点芝麻油，按个人喜好可加七味粉。金平在冰箱里可以保存五天左右，是日本家庭的一大常备菜。牛蒡金平也可做米汉堡的馅。</p><p>春日的牛蒡口味比秋日的更清新，切细条后用开水一焯，就是做沙拉的好材料。撒上白芝麻凉拌也是一道美味。除凉拌外也适合做成浓汤，牛蒡富含的纤维素、酵素和植物多酚，一碗牛蒡汤可算作一道防癌抗氧化的排毒汤。做好的牛蒡汤倒入耐热玻璃容器里，放入冰箱冷藏保存，与便当一并携带，食用时用微波炉加热即可。</p><p>牛蒡浓汤做法</p><p>所需时间：40分钟</p><p>份量：2人份</p><ul><li><p>材料</p><p>牛蒡、洋葱、黄油、鸡精、胡椒、盐、米醋、牛奶</p></li></ul><p>制作步骤</p><ol><li><p>将牛蒡削成小片</p><p>牛蒡（半根，约100克）用刷子洗好后刀削（类似削铅笔），削好的牛蒡泡在加了几滴米醋的水里。</p></li><li><p>炒制</p><p>洋葱（半颗）切片，用黄油（1汤匙）炒2分钟，再加牛蒡、饮用水（200毫升）、鸡精（半汤匙）和香叶（1枚），用小火继续加热7-8分钟。</p></li><li><p>搅拌</p><p>牛蒡变软后取出香叶，用搅拌机搅匀。然后将做好的液体放回小锅，加牛奶（少许）加热，最后用胡椒和盐调味。</p></li></ol><h3 id="快餐店杂记"><a href="#快餐店杂记" class="headerlink" title="快餐店杂记"></a>快餐店杂记</h3><p>在马尼拉，快餐连锁店“祖乐比”颇受当地人欢迎。菲律宾人的口味偏甜，不管是汉堡、热狗或意大利面，都会浇上香蕉番茄酱(banana ketchup)。</p><p>在日本，“立式荞麦”速度快到极致，也很便宜，一份面不到300日元。有一种和风洋食快餐经典是“摩斯汉堡”在日本开售的米汉堡。</p><blockquote><p>只用米饭做成的面饼很容易解体，拌入生粉后才能渐渐成形。</p></blockquote><p>北京的快餐：驴肉火烧。</p><h2 id="豆皮巾着便当-《千与千寻》与三味线"><a href="#豆皮巾着便当-《千与千寻》与三味线" class="headerlink" title="豆皮巾着便当 | 《千与千寻》与三味线"></a>豆皮巾着便当 | 《千与千寻》与三味线</h2><h3 id="豆皮巾着便当"><a href="#豆皮巾着便当" class="headerlink" title="豆皮巾着便当"></a>豆皮巾着便当</h3><p>所需时间：30分钟</p><p>份量：2-3人份</p><ul><li><p>豆皮巾着材料</p><p>豆皮（长方形）、鸡蛋、白糖、味淋（或料酒）、生抽、木鱼精、牙签</p></li><li><p>和风鸡肝材料</p><p>鸡肝、生姜、料酒、白糖、生抽、七味粉（按个人口味）</p></li><li><p>煮秋葵材料</p><p>秋葵、盐</p></li></ul><p>制作步骤</p><p>豆皮巾着：形状酷似过去日本人随身携带的“巾着”小口袋。可放冰箱保存1-2天。</p><p>和风鸡肝（常备菜）：营养丰富的常备菜。可放冰箱保存3-4天。</p><ol><li><p>准备豆皮</p><p>豆皮（2枚）用菜刀切一半。把生鸡蛋（4个）从开口处往里倒入，用牙签封口备用。</p></li><li><p>煮豆皮</p><p>用小锅煮开水（约150毫升），加白糖（半汤匙）、味淋和生抽（各1汤匙）以及木鱼精（少许），之后调小火，再放进封了口的豆皮。盖好盖子，煮5分钟后翻面，再加热几分钟即可。</p></li><li><p>准备鸡肝</p><p>鸡肝（300克）用盐水洗净，去除脂肪（黄色部分），并用菜刀切小块。生姜（1小块））去皮后切丝备用。</p></li><li><p>煮鸡肝</p><p>用小锅煮调味汁，料酒（3汤匙）、白糖（1汤匙）和生抽（1汤匙）煮开后调小火，加鸡肝和生姜。继续加热7-8分钟，直到鸡肝煮熟。食用时按个人口味撒七味粉。</p></li><li><p>加热秋葵</p><p>秋葵先撒盐，用手轻轻揉搓以去除绒毛，再洗净。用小锅煮开水，放入秋葵烫1分钟后捞出。过冰水冷却，沥水备用。</p></li></ol><h3 id="便当小贴士：便当汤汁的问题"><a href="#便当小贴士：便当汤汁的问题" class="headerlink" title="便当小贴士：便当汤汁的问题"></a>便当小贴士：便当汤汁的问题</h3><p>二段便当盒，上层空间比较小的盒子一般带有塑料密封内盖，适合放菜，这样汤汁就不会漏出来。但便当做对了，就不会有太多汤汁。</p><p>注意：</p><ol><li><p>少油：油脂变冷后容易凝固，口感也不佳。便当菜肴用的肉可以用低脂的。另外，炒肉前可以沾点淀粉，这样菜肴变冷后仍能保持软嫩。</p></li><li><p>浓郁：菜肴变冷后舌头不太容易感觉出味道，因此便当菜肴可以多加点糖、盐、醋和生抽。这样能延长菜肴的保鲜时间。</p></li><li><p>汁少：酱汁尽量少些，因为容易渗到其他饭菜，甚至可能弄脏包。若要留酱汁，可以再加热收干一些。</p></li><li><p>让调料吸收水分：日式便当里的常用调料，不但丰富了菜肴的风味，还能锁住便当里的水分。做凉拌菠菜时，加1汤匙份量的芝麻粉或一点柴鱼片，就可以吸收蔬菜渗出来的水分。再如，汉堡肉饼或猪肉生姜烧旁边可以放点土豆沙拉，吸收了汤汁的土豆别具风味。</p></li></ol><p>豆皮巾着中，煮好的豆皮含有水分，装盒前先在小碗沥干。</p><h3 id="《千与千寻》与三味线"><a href="#《千与千寻》与三味线" class="headerlink" title="《千与千寻》与三味线"></a>《千与千寻》与三味线</h3><p>到车站下公交车，我接着往梅屋的方向走去。车站附近有一条商店街，只是到了傍晚时分，不少店主拉下卷帘门，而白天不怎么起眼的居酒屋、夜总会和俱乐部灯光开始点亮。我的身边晃悠着寻觅小酒馆的上班族。</p><p>去买三味线弦的那晚，在某一刻，我与千寻一样，站在那个神秘的隧道口。</p><p>若大家仔细追溯记忆，也许能想起一些类似的故事。就像《千与千寻》里钱婆婆说的，“曾经发生过的事情不可能忘记，只是想不起来而已”。那些记忆，正等着你去唤醒。</p><h2 id="豚汁便当-摄制组便当的奥义"><a href="#豚汁便当-摄制组便当的奥义" class="headerlink" title="豚汁便当 | 摄制组便当的奥义"></a>豚汁便当 | 摄制组便当的奥义</h2><h3 id="豚汁便当"><a href="#豚汁便当" class="headerlink" title="豚汁便当"></a>豚汁便当</h3><p>所需时间：20分钟</p><p>份量：3-4人份</p><ul><li><p>豚汁材料</p><p>五花肉（薄片）、白萝卜、胡萝卜、芋头、大葱、魔芋、味噌、植物油、木鱼精（按个人口味）</p></li><li><p>什锦散寿司材料（简易版）</p><p>寿司饭（白米饭、白醋、白糖和盐）、蛋皮（鸡蛋、盐和植物油）、干香菇、胡萝卜、生姜、白糖、生抽、料酒、毛豆、白芝麻（按个人口味）</p></li></ul><p>制作步骤：</p><p>豚汁：用猪肉做的味噌汤，是日本家常菜肴，一般在冬天吃得比较多。若是简单的午餐，一碗豚汁可以当作主菜。除猪肉外加白萝卜、胡萝卜、芋头、大葱等蔬菜，还可以加牛蒡、荷兰豆等。按个人口味可以把芋头换成红薯，小朋友会喜欢。</p><p>什锦散寿司：本篇介绍的是简易版。寿司饭做法参见“春日便当” &gt; “什锦散寿司”。</p><ol><li><p>炒肉片和蔬菜</p><p>五花肉（150克）切成3厘米大小，白萝卜和胡萝卜各1小段切小片。芋头（4-5个）洗净后削皮并切成小块，大葱（1根）切片。魔芋（半块）用手指撕碎，并用开水烫一会，以便去腥。置中火，往大锅倒植物油和加热，再往锅里倒入肉片、白萝卜片、胡萝卜片、芋头和魔芋。</p></li><li><p>加水、继续加热</p><p>肉片颜色变白，白萝卜变半透明后加饮用水（700-800毫升），煮开后用勺子去除浮沫。按个人口味加木鱼精（1汤匙），用小火继续加热。等所有材料煮熟，最后加大葱。</p></li><li><p>加味噌</p><p>等芋头小块变软，加大葱和味噌（3汤匙），味噌加入汤里后不宜煮开，，以免失去香味。煮开之前关火。</p></li><li><p>准备甜煮香菇</p><p>干香菇（3-4个）泡发后切丝，胡萝卜（小块）和生姜（小块）切薄片后再切丝。在小锅里放香菇切片和胡萝卜丝、料酒（2汤匙）、白糖（半汤匙）和生抽（半汤匙），加热5-6分钟，关火冷却。</p></li><li><p>准备毛豆</p><p>将毛豆（半斤）清洗干净，用剪刀切去两端的梗，沥干水分后放入大碗中，加盐（2汤匙）反复揉搓片刻。往小锅里加水（约1公升），毛豆不需要再洗净，水煮开后直接放入锅中，调小火煮5分钟，毛豆变软后捞出即可。</p><blockquote><p>毛豆是最佳下酒菜，喝酒的时候剩一点，作为什锦散寿司的装饰。</p></blockquote></li><li><p>拌寿司</p><p>将寿司饭和其他材料（蛋皮、香菇、胡萝卜和毛豆）轻轻拌均匀。最后按个人口味撒上白芝麻。</p></li></ol><h3 id="便当小贴士：选择慰劳点心的技巧"><a href="#便当小贴士：选择慰劳点心的技巧" class="headerlink" title="便当小贴士：选择慰劳点心的技巧"></a>便当小贴士：选择慰劳点心的技巧</h3><p>推荐的慰劳点心：焦糖布丁、甜甜圈、泡芙、分开包装的饼干、巧克力、竹轮（即食）、鱿鱼干、炸猪排三明治、纸盒包装的蔬果汁和养乐多。</p><h3 id="摄制组便当的奥义"><a href="#摄制组便当的奥义" class="headerlink" title="摄制组便当的奥义"></a>摄制组便当的奥义</h3><p>在日本提到便当，其实也有不同种类：有家庭风味的便当，比如本书中的手作便当；有在中国也相当普及的便利店便当（500日元左右）；有日本餐厅提供的高级便当（一两千日元甚至更贵）；还有花样多且带有各地特色的铁路便当（1000日元左右）。</p><p>还有一种“外拍便当”，即影视行业工作者在外拍摄时吃的便当。订这种便当是个难事，AD (Assistant Director) 选的便当能否被大家认可，对拍摄现场的气氛有着直接的影响。</p><h2 id="红烧鸭肉便当-岁末荞麦面"><a href="#红烧鸭肉便当-岁末荞麦面" class="headerlink" title="红烧鸭肉便当 | 岁末荞麦面"></a>红烧鸭肉便当 | 岁末荞麦面</h2><h3 id="红烧鸭肉便当"><a href="#红烧鸭肉便当" class="headerlink" title="红烧鸭肉便当"></a>红烧鸭肉便当</h3><p>所需时间：40分钟</p><p>份量：2人份</p><ul><li><p>红烧鸭肉材料</p><p>鸭胸肉、红萝卜、大葱、白糖、料酒、生抽、生姜、七味粉（按个人口味） </p></li><li><p>炸藕片材料</p><p>莲藕、盐、白醋、食用油</p></li><li><p>荞麦面沙拉材料</p><p>荞麦面（干面）、黄瓜、蛋黄酱、白芝麻粉、盐</p></li></ul><p>制作步骤</p><p>炸藕片和啤酒特别搭，据说这是村上春树最喜欢的搭档，推荐试试。</p><p>沙拉用荞麦面无需特意去煮，吃荞麦汤面的时候可以多煮些，剩下的面条做成沙拉，可在冰箱放1天。</p><ol><li><p>做炸藕片</p><p>莲藕（小块，4-5厘米）洗净后去皮，切成薄片。在小碗里加白醋（少许），将藕片在水中浸泡1分钟。藕片捞出，用厨房纸吸收水分后撒盐备用。预热平底锅加植物油（少许），放入藕片煎炸，炸至两面金黄即可出锅，再用厨房纸吸收多余的油分。</p></li><li><p>做红烧鸭肉</p><p>鸭胸肉（1条）和红萝卜（半根）切小块备用。开中火用平底锅煎鸭肉然后放入白糖（1汤匙），鸭肉表皮变色后放入生抽（半汤匙）、料酒（2汤匙）、红萝卜和生姜。用小火继续加热直到汤汁收干。食用时按个人口味加七味粉。</p></li><li><p>煎大葱</p><p>大葱洗净后切小段。取出红烧鸭肉后的平底锅不用洗，利用留下的油脂煎大葱（1根）1分钟。</p></li><li><p>做荞麦面沙拉</p><p>用小锅煮开饮用水，煮面约5-6分钟后用冷水激一下并洗掉面条上的淀粉，让面条更加筋道，然后控水备用。将黄瓜（半根）切丝，加荞麦面（100克）、蛋黄酱（1-2汤匙）、盐（少许）和白芝麻粉（1汤匙），用筷子搅拌。</p></li></ol><h3 id="便当小贴士：荞麦面和落语"><a href="#便当小贴士：荞麦面和落语" class="headerlink" title="便当小贴士：荞麦面和落语"></a>便当小贴士：荞麦面和落语</h3><p>“日本人吃面发出的吸溜声”在海外似乎很有名。有人说没有发出吸溜声，等于是侮辱这家荞麦面店，表示这碗面不好吃。但我吃面一般也不会发出声音，也没有一次被别人指责过。还是以自己开心为主，吃完微笑着跟店员说一句“谢谢款待”即可。</p><h3 id="岁末荞麦面"><a href="#岁末荞麦面" class="headerlink" title="岁末荞麦面"></a>岁末荞麦面</h3><p>在日本，过年吃荞麦面的习俗始自何时？有种说法是，源自江户时代商家的习惯，做生意的，到了年底总是忙得不可开交。这个时候，做起来简单，吃起来也利索的荞麦面是最合适的食物。就像中国的寿面，日本人认为荞麦面又细又长，可以托“长寿”的福气。但和中国的寿面不同的是，荞麦面比高筋粉做的面条更容易切断。日本人解释说可以断去一年的苦恼和灾害。在日本，过年荞麦面一般在傍晚到晚上吃，而且一定要在晚上零点前吃完。</p><p>店里的荞麦面快卖完了，老板会催我去门外取下深蓝色的暖帘。按日本的习惯，这块染着店名的暖帘挂在外面，就表示该店“营业中”。客人见暖帘收了起来，就不会进来了。</p><p>“富士荞麦”是一家著名连锁店，主要提供“立食”（站着吃）服务，这种地方的客人一般以男性上班族和学生为主，目的是以最便宜、快速的方式填饱肚子。</p><p>“狸猫荞麦面”里并没有狸子肉块，而是放了天妇罗的碎渣，“狐狸荞麦面”也不是有狐狸肉，而是放一块金黄色甜煮油炸豆皮的热荞麦汤面，日本民间传说中护理最喜欢吃油炸豆皮。</p><p>“鸭南蛮荞麦面”是有鸭肉的，“南蛮”指的是大葱，因为日本古代称印尼等南方地区为“南蛮”，从那里运过来的货物也就带上了这个名号。大葱和鸭肉口味上非常搭配，鸭肉可滋补强身，大葱可去除腥味，亦有驱寒的功效，二者的组合自然是绝佳冬季美食。日本有句谚语是“鸭子背着大葱来”，意思是“好事送上门”，也是有道理的。</p><p>吃完荞麦面，剩下要做的事儿就不多了，回酒店看看“红白歌会”。手提包里，整整用了一年365天的手帐也快完成使命了。我在最后的任务——“过年荞麦面”上打勾。现在已经很多人改用手机来管理生活和工作，但我还是喜欢昨完每一件事情后用笔打勾的感觉，有一种即时的充实感。明年用的手帐也已经买好了，打开新的手帐，总可以闻到淡淡的墨水味儿，总让我勾起对全新日子的憧憬。</p><h2 id="豆腐饼便当-“米西米西”是什么意思？"><a href="#豆腐饼便当-“米西米西”是什么意思？" class="headerlink" title="豆腐饼便当 | “米西米西”是什么意思？"></a>豆腐饼便当 | “米西米西”是什么意思？</h2><h3 id="豆腐饼便当"><a href="#豆腐饼便当" class="headerlink" title="豆腐饼便当"></a>豆腐饼便当</h3><p>所需时间：60分钟（含煮米饭的时间）</p><p>份量：2人份</p><ul><li><p>豆腐饼材料</p><p>豆腐、蟹味棒（鱼糕）、面粉、蛋黄酱、植物油、葱末</p></li><li><p>赤饭（红豆饭）材料</p><p>红豆、生糯米、熟黑芝麻、盐</p></li><li><p>凉拌菠菜豆腐材料</p><p>菠菜、豆腐、白糖、熟白芝麻粉、盐（按个人口味）</p></li><li><p>肉末南瓜材料</p><p>鸡肉馅（鸡胸肉、鸡腿肉均可）、南瓜、生姜、植物油、生抽、白糖、料酒、生粉</p></li></ul><p>制作步骤</p><p>赤饭 (sekihan)：红豆糯米饭。昔日逢喜庆日子，如孩子升学、就业等时候才做。</p><p>肉末南瓜：除当便当小菜外，还适合给幼儿做的一道菜。南瓜再煮烂一点，肉末里不加生姜即可。</p><p>凉拌菠菜豆腐：按个人喜好还可以加胡萝卜丝、魔芋丝（需烫一下以便除腥味）等。</p><ol><li><p>准备赤饭</p><p>红豆（60克）洗净后用小锅，加水（约280毫升）用中火煮。煮开后调小火，继续加热3-4分钟，关火放凉。生糯米（300克）洗净后倒入电饭锅里，先加煮红豆的水。若水分不够，加饮用水。接着放入红豆，按普通方式煮饭即可。煮好的赤饭用勺子搅拌备用，食用时撒上熟黑芝麻和盐。</p></li><li><p>准备豆腐和蔬菜</p><p>豆腐（250克）切块，用厨房纸或干净的布包起来，去除多余的水分。菠菜（2-3把）洗净，用滚水烫1分钟，放凉后挤干水分备用。南瓜用勺子去核，若皮厚，用菜刀削去，切3-4厘米的小块。</p></li><li><p>做豆腐浆</p><p>蟹味棒（7-8根）用手指撕成条备用。去除水分的豆腐（150克）放入小碗里，加面粉（2汤匙）、蟹味棒丝、蛋黄酱（1汤匙），按个人口味加葱末（1汤匙），用勺子搅拌均匀。</p></li><li><p>煎豆腐饼</p><p>预热平底锅，倒入植物油后用勺子加入少量豆腐浆，做成豆腐饼，用筷子调整豆腐饼大小。中火煎制，中间翻一次面。做好的豆腐饼放在厨房纸上，吸收多余的油脂。</p></li><li><p>做凉拌菠菜豆腐</p><p>把豆腐（控水后，约100克）、白糖（半汤匙）和熟白芝麻粉放进碗里，用勺子搅拌均匀。菠菜切断后与豆腐酱搅拌，按个人口味用盐调味。</p></li><li><p>做肉末南瓜</p><p>小锅用中火预热，加植物油（半汤匙），然后放入鸡肉馅（150克）和姜泥（1小块生姜），鸡肉馅变白后加生抽（2汤匙）、白糖（1汤匙）、料酒（2汤匙）、饮用水（约150毫升）和南瓜小块（400克）。煮开后用勺子去除白色泡沫，用蜡纸盖上，然后用小火加热10分钟。南瓜变软后关火。</p></li><li><p>做调味汁</p><p>把南瓜搁在小碗里备用。剩下的汤汁再次用小火加热，煮开后用生粉水（半汤匙生粉加1-2汤匙饮用水）勾芡，浇在南瓜上。</p></li></ol><h3 id="便当小贴士：汤豆腐的配菜"><a href="#便当小贴士：汤豆腐的配菜" class="headerlink" title="便当小贴士：汤豆腐的配菜"></a>便当小贴士：汤豆腐的配菜</h3><p>汤豆腐制作步骤：</p><p>先准备出汁。约5厘米见方的昆布小块用干净的布块擦净。土锅里放入饮用水和昆布静置半小时，然后开小火，煮开后马上取出昆布，轻轻放入豆腐块。豆腐开始浮荡时马上关火，捞出放入小碗里，撒上葱末、白萝卜泥等“药味”和生抽后享用。宛如白开水一般极简的味道，却能让人身心一并暖和起来。</p><p>捞出豆腐后，汤汁可以不倒掉。第二天早上放入用剩的豆腐、一点点白米饭和一个鸡蛋煮开，营养又好吃的昆布味泡饭就做好了，冬日早晨的味道。</p><h3 id="“米西米西”是什么意思？"><a href="#“米西米西”是什么意思？" class="headerlink" title="“米西米西”是什么意思？"></a>“米西米西”是什么意思？</h3><p>汤豆腐用的原材料要看个人口味，有人喜欢口感滑嫩、味道浓郁的“绢豆腐”（相当于中国的内酯豆腐，将豆浆和凝固剂放入容器制成，口感细嫩），也有人喜欢结实醇厚的“木棉豆腐”（相当于中国的北豆腐，容器里放木棉布料，再将豆浆和凝固剂放入容器压制而成。口感比绢豆腐更为结实）。</p>]]></content>
    
    
    <categories>
      
      <category>book notes</category>
      
      <category>四季便当</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>四季便当Ⅱ-秋</title>
    <link href="/posts/6337b8d2.html"/>
    <url>/posts/6337b8d2.html</url>
    
    <content type="html"><![CDATA[<h1 id="秋"><a href="#秋" class="headerlink" title="秋"></a>秋</h1><h2 id="烤秋刀鱼寿司便当-灾难中必备的秋刀鱼"><a href="#烤秋刀鱼寿司便当-灾难中必备的秋刀鱼" class="headerlink" title="烤秋刀鱼寿司便当 | 灾难中必备的秋刀鱼"></a>烤秋刀鱼寿司便当 | 灾难中必备的秋刀鱼</h2><h3 id="烤秋刀鱼寿司便当"><a href="#烤秋刀鱼寿司便当" class="headerlink" title="烤秋刀鱼寿司便当"></a>烤秋刀鱼寿司便当</h3><p>所需时间：50分钟</p><p>份量：2人份</p><ul><li><p>烤秋刀鱼寿司材料</p><p>秋刀鱼（可用青花鱼代替）、白米饭、海苔、熟白芝麻、青紫苏、白醋、白糖、盐、生姜（可选）、柠檬（可选）</p></li><li><p>腌渍生姜材料</p><p>嫩生姜、白糖、米醋、盐、昆布（或木鱼精）</p></li><li><p>玉子烧材料</p><p>鸡蛋、白糖、盐、植物油</p></li></ul><p>制作步骤</p><p>玉子烧材料和做法参见【春日便当】 &gt; 【玉子烧便当】。</p><ol><li><p>做寿司饭</p><p>将白醋（3汤匙）、白糖（1汤匙）和盐（少许）搅拌备用。准备热的白米饭（约2碗），放在大碗里，加入调料后用勺子轻轻混合，同时扇风让米饭快速冷却。青紫苏切丝备用。</p></li><li><p>准备烤秋刀鱼</p><p>准备生的秋刀鱼（2条），洗净后撒盐。</p></li><li><p>烤秋刀鱼</p><p>秋刀鱼放在铝箔纸上，放进烤箱里烤制一刻钟，若秋刀鱼太长，可以切半后烤制。温度设定约180-190℃，烤制时间和温度视具体情况而定。烤好的秋刀鱼用筷子去除骨头和内脏。按个人口味洒柠檬汁（少许），以便去腥。</p></li><li><p>卷秋刀鱼寿司</p><p>准备一大张海苔，放在竹帘或保鲜膜上，将寿司饭铺在海苔上，大约铺成2-3粒米饭的厚度。海苔的末端需要留1厘米不要放米饭，以免卷到最后时饭粒溢出。寿司饭上撒点熟白芝麻，靠近跟前的部分放秋刀鱼肉和青紫苏。然后将竹帘或保鲜膜卷起，使得海苔包裹住寿司饭。注意不要把竹帘一并卷进去。</p></li><li><p>切卷寿司</p><p>卷好的寿司封口朝下，放置几分钟后用菜刀切成5-6块。准备干净的湿布块，每次切完用布把刀擦净。按个人口味蘸生抽享用。</p></li><li><p>做腌渍生姜</p><p>嫩生姜（250-300克）用刀去皮后切丝或切薄片。切片时沿着纤维切开，口感更佳。生姜薄片撒盐，放置3分钟，拧干水分备用。用小锅煮水（150毫升），加昆布小片（约3厘米见方）或木鱼精（半汤匙），煮开后关火，取出昆布，加白糖（4汤匙）、米醋（150毫升）和盐（少许），搅拌后加生姜，腌渍3小时即可。可冷藏保存两三个月。</p></li></ol><h3 id="便当小贴士：秋刀鱼的得体吃法"><a href="#便当小贴士：秋刀鱼的得体吃法" class="headerlink" title="便当小贴士：秋刀鱼的得体吃法"></a>便当小贴士：秋刀鱼的得体吃法</h3><p>礼仪1：生抽</p><p>烤秋刀鱼一般配去腥用的白萝卜泥，生抽一般不会直接洒在鱼肉上，而是洒在白萝卜泥上，吃鱼头的时候一起吃掉。</p><p>礼仪2：顺序（1）</p><p>在秋刀鱼身中间，从头部到尾部用筷子画一条线，然后从背面吃起。</p><p>礼仪3：顺序（2）</p><p>吃完背面的鱼肉，开始吃下方肚子的肉，这里的小骨头多，用筷子去除后放置在左上方。</p><p>礼仪4：顺序（3）</p><p>去除大骨头，放置盘子上方。去除内脏周围的小骨头后享用即可。</p><h3 id="灾难中必备的秋刀鱼"><a href="#灾难中必备的秋刀鱼" class="headerlink" title="灾难中必备的秋刀鱼"></a>灾难中必备的秋刀鱼</h3><p>在东京的出租屋里我有一个急救包，这是按东京政府免费公布的《地震自救手册》准备的背包，里面有方便随身携带的LED灯、既能御寒又能加热食物的暖宝宝、洗净身体用的大湿巾、便携式厕所以及饮用水等。除了这些官方推荐的物品之外，我还放了一堆事物，如巧克力、咖啡、茶包、饼干、梅干、印度咖喱汁真空包、米饭真空包以及罐头，这些都是我平时像囤积口粮的松鼠一样，看到喜欢吃的、又可以在常温下长期保存的食物时，一点点收集起来的。</p><h2 id="大学芋便当-半块烤红薯"><a href="#大学芋便当-半块烤红薯" class="headerlink" title="大学芋便当 | 半块烤红薯"></a>大学芋便当 | 半块烤红薯</h2><h3 id="大学芋便当"><a href="#大学芋便当" class="headerlink" title="大学芋便当"></a>大学芋便当</h3><p>所需时间：40分钟</p><p>份量：2人份</p><ul><li><p>大学芋材料</p><p>红薯、白糖、生抽、料酒、熟黑芝麻、植物油</p></li><li><p>青椒肉丝材料</p><p>瘦肉、清水笋丝（袋装水煮冬笋丝）、青椒、蒜末、蚝油、料酒、植物油</p></li></ul><p>制作步骤</p><p>大学芋除了当作配菜之外，也可以当作甜点。</p><p>青椒肉丝是日本最有名的中国料理之一，已经相当本土化，给食菜单里经常出现。本篇介绍的是简易版。</p><ol><li><p>切红薯</p><p>红薯（1个，约200克）洗净后切小块，在水里浸泡3分钟后用干净的布块擦去水分。我一般会留下红薯皮做大学芋，一是美观，二是健康。若是不喜欢红薯皮的口感，可以提前去皮。</p></li><li><p>炸红薯</p><p>平底锅里倒入植物油（1汤匙），开中火，油温升到160℃时放入红薯块，油煎约5-6分钟。</p></li><li><p>红薯调味</p><p>往平底锅里放白糖（半汤匙）、生抽（2-3滴）、料酒（1汤匙）和盐（少许），开小火，边搅拌边慢慢加热。等糖浆和红薯适当融合，撒上熟黑芝麻（少许）即可。</p></li><li><p>处理青椒和肉丝，准备调料</p><p>瘦肉（150克）和青椒（2个）切丝，清水笋丝（100克）用清水淘洗一遍，控干水分后放入小碗备用。姜末（少许）、料酒（1汤匙）和蚝油（半汤匙）放入小碗里搅拌。</p></li><li><p>炒青椒肉丝</p><p>平底锅里加植物油（少许），油热后下肉丝并快速炒散。肉丝炒到约七成熟时，再加青椒丝和笋丝炒匀，最后加调料炒匀出锅。</p></li></ol><h3 id="便当小贴士：日本的红薯"><a href="#便当小贴士：日本的红薯" class="headerlink" title="便当小贴士：日本的红薯"></a>便当小贴士：日本的红薯</h3><p>据统计，日本近年产量最大的是“红东”(beni azuma)和“高系”(koke)。味道香甜，口感软糯，烤、蒸、炸都能呈现其美味。以上两种几乎占去日本红薯市场的半壁江山。另外“黄金千贯”和“白豊”两个品种一般用来做烧酒，产地集中在九州地区的宫崎县和鹿儿岛县。还有另外一种偏白的“玉豊”，适合做“干芋”(hoshi-imo)，就是中国的地瓜干。</p><p>红薯的营养成分比一般谷物要多，比如膳食纤维、钙质、维生素等，可谓一种兼具谷物和蔬菜优点的食物。除当作点心外，红薯和芋头一样，也可以做成味噌汤，男女老少都会喜欢。</p><h3 id="半块烤红薯"><a href="#半块烤红薯" class="headerlink" title="半块烤红薯"></a>半块烤红薯</h3><p>严冬的下午，忙完家务、处理完工作邮件后，先去菜市场买菜，回程路上再顺道买上半斤刚出炉的栗子，急匆匆赶到家，搭配一杯牛奶咖啡，享受一个人的温暖黄昏。</p><p>根据“日本大学芋爱协会”的考证，大学芋的名称来源众说纷纭。有人说，是东京大学附近的一家刨冰店，为了解决寒冬营业额锐减的问题，想出卖红薯的点子。也有人说这里的大学不是东大，而是指早稻田大学，因为早稻田大学附近也曾经有过销售类似大学芋点心的店铺。还有人说，大学芋做起来很费事，就像把孩子培养成大学生一样麻烦，故名。</p><h2 id="日式青紫苏饺子便当-在天安门见"><a href="#日式青紫苏饺子便当-在天安门见" class="headerlink" title="日式青紫苏饺子便当 | 在天安门见"></a>日式青紫苏饺子便当 | 在天安门见</h2><h3 id="日式青紫苏饺子便当"><a href="#日式青紫苏饺子便当" class="headerlink" title="日式青紫苏饺子便当"></a>日式青紫苏饺子便当</h3><p>所需时间：40分钟</p><p>份量：3-4人份</p><ul><li><p>日式青紫苏饺子材料</p><p>猪肉馅、卷心菜、韭菜、青紫苏、饺子皮、蒜末、姜末、生抽、芝麻油、料酒、白糖、盐、植物油、白胡椒粉（按个人口味）</p></li></ul><p>制作步骤：</p><ol><li><p>准备蔬菜</p><p>将卷心菜（150克）、韭菜（1把，约50克）和青紫苏（约10枚）洗净切碎。卷心菜和韭菜放入小碗，加适量盐抓匀，出水后挤干水分，再加青紫苏备用。</p></li><li><p>做肉馅</p><p>将猪肉馅（150克）充分搅拌，直到变得有劲道、有粘性。接下来将步骤1中的蔬菜、蒜末（1汤匙）、姜末（1汤匙）、生抽（1汤匙）、芝麻油（半汤匙）、料酒（少许）、白糖（少许）、盐，按个人口味加白胡椒粉后用手搅拌。盖上保鲜膜，放入冰箱半个小时。</p></li><li><p>包饺子</p><p>将肉馅放在饺子皮（约30张）中心并对折，用手指蘸水湿润皮的边缘，用手将右半边饺子皮的边缘捏一个小波浪，然后捏紧，再往左继续捏6-7个小波浪，直到封口。</p></li><li><p>煎饺子</p><p>平底锅预热，加植物油（1汤匙）后放上饺子，随后马上倒开水，加到饺子三分之一的高度，转大火并加盖加热3-4分钟。水分蒸发后，调小火并取下盖子，再加植物油（1汤匙）继续煎，直到饺子下层微焦呈浅黄色即可。</p></li></ol><h3 id="便当小贴士：饺子和米饭"><a href="#便当小贴士：饺子和米饭" class="headerlink" title="便当小贴士：饺子和米饭"></a>便当小贴士：饺子和米饭</h3><p>去日本旅行，想吃日式饺子，可以去“饺子的王将”这样的连锁店，如果附近没有，那去拉面店也错不了。一碗猪骨拉面、一盘煎饺，这是我和朋友在夜晚的东京填饱肚子的最快的办法。</p><p>日式饺子皮很薄，适合当配菜来吃。日式拉面的油脂、盐分含量多，再加上煎饺，绝不是健康的饮食方式。然而，深夜在熟悉的小店里吸溜着拉面，和朋友分享着盘里的煎饺，一定会积蓄起“明天继续努力”的力量。</p><h3 id="在天安门见"><a href="#在天安门见" class="headerlink" title="在天安门见"></a>在天安门见</h3><p>川菜钟水饺是水煮的，皮厚而有弹性，味道又甜又辣，吃完还可以免费喝饺子汤。</p><p>北京的饺子色泽洁白，喝钟水饺大不相同。口感爽滑筋道，馅大且鲜香多汁，同样美味极了。钟水饺要用小勺将碗中的各种调料搅合在一起吃，而北京的饺子是用筷子夹起蘸着醋吃，这也是一种透过味蕾感觉到的文化差异。  </p><h2 id="鲑鱼昆布卷便当-吴服屋与裙带菜"><a href="#鲑鱼昆布卷便当-吴服屋与裙带菜" class="headerlink" title="鲑鱼昆布卷便当 | 吴服屋与裙带菜"></a>鲑鱼昆布卷便当 | 吴服屋与裙带菜</h2><h3 id="鲑鱼昆布卷便当"><a href="#鲑鱼昆布卷便当" class="headerlink" title="鲑鱼昆布卷便当"></a>鲑鱼昆布卷便当</h3><p>所需时间：50分钟</p><p>份量：2人份</p><ul><li><p>鲑鱼昆布卷材料</p><p>鲑鱼片、昆布、料酒、白糖、生抽、米醋、盐、生姜、干瓢（可用牙签代替）</p></li><li><p>炒青椒材料</p><p>青椒、杏鲍菇、盐、白胡椒、植物油</p></li></ul><p>制作步骤</p><p>昆布卷：日本家庭的常备菜之一，适合作为配菜搁在便当盒角落里。昆布在中国不太容易买到，用中国产的海带也可以。</p><p>干瓢：昆布卷外层需用干瓢系住。但在中国也不容易买到，可以用牙签代替。</p><ol><li><p>准备昆布和鲑鱼片</p><p>用干净的纱巾出去昆布（约4*15厘米，50克左右）上的灰尘，用饮用水（约400毫升）浸泡一刻钟，变软后取出来（浸泡过昆布的水要留下来）。鲑鱼片（约300克）切条后撒上盐（少许），洒上料酒（1汤匙），放一刻钟，随后用厨房纸巾吸收水分。生姜去皮，切丝。</p></li><li><p>卷昆布</p><p>把鲑鱼和将死放在昆布的一端，卷紧。最后用牙签固定。</p></li><li><p>煮昆布卷</p><p>将卷好的昆布卷放入小锅，用步骤1留下来的水，加米醋（半汤匙）和料酒（2汤匙），用小火煮一刻钟。随后加生抽和白糖，继续用小火加热收干。</p></li><li><p>盖昆布卷</p><p>加生抽（1汤匙）和白糖（2汤匙）后，可用厨房纸巾做锅中盖，按锅子大小裁切烹饪纸（烘焙纸），上面打几个洞，盖在昆布卷上，使其入味。</p></li><li><p>保存</p><p>做好的昆布卷可以冷藏保存4-5天。食用前切小块，若是用牙签固定的，除去牙签即可。</p></li><li><p>炒蔬菜</p><p>青椒（半个）切条。平底锅预热后方锅植物油，翻炒青椒和杏鲍菇，用盐和白胡椒调味。</p></li></ol><h3 id="便当小贴士：日本海藻“三君子”"><a href="#便当小贴士：日本海藻“三君子”" class="headerlink" title="便当小贴士：日本海藻“三君子”"></a>便当小贴士：日本海藻“三君子”</h3><p>昆布：生活中常见的食材，除了做菜也可以用于高汤。海带属于海带目海带科，昆布属于海带目翅藻科。可以用海带代替昆布。</p><p>若布：指裙带菜。生裙带菜不易保存，一般会经过晒干或腌制处理。用水浸泡后可做味噌汤、凉拌沙拉，也能用于炒菜。当季的裙带菜适合生吃，用生抽加点姜汁蘸着吃，是春天里的一道美味。</p><p>海苔：紫菜和海苔是同一种植物，只是加工方式不同。用来做寿司的海苔一般不添加调料。</p><h3 id="吴服屋与裙带菜"><a href="#吴服屋与裙带菜" class="headerlink" title="吴服屋与裙带菜"></a>吴服屋与裙带菜</h3><p>七五三：过去小孩死亡率比较高，日本有个老派说法，认为孩子在七岁前都是由神明照看，所以女孩满三岁和七岁，男孩满三岁和五岁之际，父母会带着孩子到神社感谢神明的庇护。</p><h2 id="肉饭团便当-驾驶证和“一夜渍”奋斗法"><a href="#肉饭团便当-驾驶证和“一夜渍”奋斗法" class="headerlink" title="肉饭团便当 | 驾驶证和“一夜渍”奋斗法"></a>肉饭团便当 | 驾驶证和“一夜渍”奋斗法</h2><h3 id="肉饭团便当"><a href="#肉饭团便当" class="headerlink" title="肉饭团便当"></a>肉饭团便当</h3><p>所需时间：40分钟（除腌制所需时间）</p><p>份量：2人份</p><ul><li><p>肉饭团材料</p><p>五花肉（薄片，可用牛肉薄片代替）、白米饭、生抽、白糖、料酒、姜末、熟白芝麻（按个人口味）、植物油</p></li><li><p>一夜渍材料</p><p>莲藕、胡萝卜、昆布、盐、白醋、红辣椒（按个人口味）</p></li><li><p>菠菜玉子烧材料</p><p>菠菜、鸡蛋、盐、白糖、植物油</p></li></ul><p>制作步骤</p><p>在疫情期间，我还想象过骑摩托车出去的化，会带什么样的便当。骑摩托车挺累的，所以便当里少不了荤菜和米饭。我想可能肉饭团挺合适。再加上蛋白质（玉子烧），再放一点一夜渍，就可以做出营养丰富、回忆美好的便当了。</p><p><strong>肉卷饭团</strong>：饭团可用白米饭、糙米饭等，饭团里也可以拌入切丝的青紫苏或切末梅干肉等，以使口味更加丰富。</p><p>一夜渍放入便当盒里时，需要适当地拧干水分，以免出水。一夜渍可用各种蔬菜制作，详情请参见本篇”便当小贴士“。</p><ol><li><p>做小饭团</p><p>把一张保鲜膜放在手掌上，取少量白米饭做成圆形小饭团，饭团不要做得太大。然后把肉片贴上去，最后的体积会比原来的饭团稍大。</p></li><li><p>肉片贴上饭团</p><p>用肉片卷起小饭团。请注意用肉片把饭团整个儿裹住。</p></li><li><p>做调味汁</p><p>小碗里加生抽（2汤匙）、白糖、料酒（各1汤匙）和姜末（少许），搅拌备用。</p></li><li><p>煎肉卷饭团</p><p>平底锅预热，倒入植物油，将肉饭团轻轻放入锅中。用筷子慢慢拨动饭团，让所有的部分都均匀受热。盖上盖子继续加热30秒，以便充分加热饭团。</p></li><li><p>倒入调味汁</p><p>取下盖子，倒入调味汁，然后用筷子慢慢翻滚饭团，让所有的肉片都沾上调味汁。加热到调味汁收干即可。按个人口味撒上熟白芝麻。</p></li><li><p>制作一夜渍（常备菜）</p><p>将莲藕（1节，约300克）剥皮，切小块后水煮1分钟。胡萝卜（1&#x2F;4）切丝，加盐（1-2撮）、昆布片（3*3厘米大小）和几滴白醋搅拌，按个人口味再加红辣椒（1个）。放入食品袋后用手轻揉，绑紧袋口冷藏半个小时。</p></li><li><p>制作玉子烧（常备菜）</p><p>菠菜水煮后，搁在小碗里备用。做玉子烧时把菠菜放在中间并卷起即可。（玉子烧的详细做法请参见“春日便当”部分的“玉子烧便当”。）</p></li></ol><h3 id="便当小贴士：一夜渍的变化"><a href="#便当小贴士：一夜渍的变化" class="headerlink" title="便当小贴士：一夜渍的变化"></a>便当小贴士：一夜渍的变化</h3><p>利用盐分促进材料脱水入味，在短时间内让生蔬菜变成一道小菜，这是一夜渍的核心。除了颜色和味道外，口感也很重要。虽然是一种腌渍物，但因为腌渍时间短，能保持蔬菜本身的口感和酥脆感，这是一夜渍的魅力。所以大白菜等叶菜，建议沿着纤维切开，以免腌渍后变得太软，失去口感。另外，做一夜渍时可以加些切丝的青紫苏、柚子皮（日本的柚子，在中国称为香橙或罗汉橙）和辣椒，丰富口感。</p><h3 id="驾驶证和“一夜渍”奋斗法"><a href="#驾驶证和“一夜渍”奋斗法" class="headerlink" title="驾驶证和“一夜渍”奋斗法"></a>驾驶证和“一夜渍”奋斗法</h3><p>“一夜渍” (ichiya zuke) 又称“浅渍” (asa zuke) 或“即席渍”，是短时间腌制的简易版咸菜。口感上只略带咸味，更像是沙拉，却又比沙拉更下饭一些，而且热量也不高。做一夜渍不需要特制容器，用一个食品袋就可以轻松做出来，可谓相当家常的菜肴。从“一夜渍”派生出来的引申义是“临时抱佛脚”，专指那些平时不看书学习的孩子，在考试前一天猛翻课本，通宵学习。</p><p>“一夜渍”学习的问题是，记住的东西很容易忘光。离开日本后，我的驾驶证真的变成一张身份证，几乎没有发挥原本的作用。那些日子就像“一夜渍”的蔬菜般，清淡中带有一丝咸味，在舌尖上没有作太大的主张，就慢慢消失了。</p><h2 id="菊花和物便当-菊花宴"><a href="#菊花和物便当-菊花宴" class="headerlink" title="菊花和物便当 | 菊花宴"></a>菊花和物便当 | 菊花宴</h2><h3 id="菊花和物便当"><a href="#菊花和物便当" class="headerlink" title="菊花和物便当"></a>菊花和物便当</h3><p>所需时间：40分钟</p><p>份量：2人份</p><ul><li><p>菊花和物材料</p><p>菊花（食用菊）、米醋、白糖、盐、鸡胸肉</p></li><li><p>味噌肉末材料</p><p>肉馅（鸡肉和猪肉皆可）、味噌、姜末、白糖、料酒、生抽、七味粉（按个人口味）</p></li><li><p>焯西兰花材料</p><p>西兰花、盐、橄榄油</p></li></ul><p>制作步骤：</p><p>食用菊：为保持菊花花瓣的色泽，烫花瓣时需要加醋，否则花瓣很快会变暗。煮开1公升的水，加约50毫升的醋即可。</p><p>菊花和物（常备菜）：糖果的菊花花瓣（调味前）可以冷藏保存1-2天，若想要保存时间更久，也可以冷冻保存。冷冻后的花瓣需要放在冷藏室慢慢解冻。</p><p>味噌肉末（常备菜）：做好的肉末可冷藏保存2-3天，也可冷冻保存2-3周。食用前用微波炉解冻即可。</p><ol><li><p>将菊花分小瓣</p><p>将菊花（100-150克）洗净，用手指轻轻分成小瓣。最中间的部分味道比较苦，最好不要食用。</p></li><li><p>烫花瓣</p><p>小锅里煮开水（1公升）并加米醋（约50毫升），放入花瓣，加热5秒后马上捞出，控水后放凉备用。</p></li><li><p>菊花调味、加鸡胸肉</p><p>小碗里放米醋（2汤匙）、白糖（半汤匙）和盐（少许）搅拌，再将烫过的花瓣放入小碗里搅和。按个人口味加切丝的白煮鸡胸肉，也可以加即食鸡肉。</p></li><li><p>做味噌肉末</p><p>开中火预热平底锅，放入肉馅（250克）、料酒、白糖（各1汤匙）和姜末（少许），用筷子边搅拌边加热。肉馅熟透后加味噌（1-2汤匙）和生抽（少许）调味。按个人口味加七味粉。</p></li><li><p>焯西兰花</p><p>把西兰花切成小朵，放进大盆用流水洗一遍，用小锅煮开水，调小火后加盐（少许）和橄榄油（以便保持西兰花的颜色和口感），再放入西兰花，加热1-2分钟后捞出来，放进干净的大盆里过凉。</p></li></ol><h3 id="便当小贴士：“和物”的盛法"><a href="#便当小贴士：“和物”的盛法" class="headerlink" title="便当小贴士：“和物”的盛法"></a>便当小贴士：“和物”的盛法</h3><p>和物，是日本家庭料理中经常出现的菜肴说明，它是将食材用调料搅拌后做成的小菜。调料种类很多，有味噌、生抽、芥末、芝麻、米醋等。能用来做和物的食材也很多，比如菠菜、胡萝卜、茄子、黄瓜、海鲜、海草、鸡肉等等。食材和调料的组合几乎是无限的，和中国的凉拌菜相近。</p><p>和物和渍物的最大差别：调味时间。渍物的食材和调料接触的时间比较久，而和物一般食材切好、调料准备好，开动之前搅拌就可以上桌了。</p><p>做和物的要点是食材的水分和温度，不管食材是用生的还是熟的，都需将食材水分沥干，然后放凉后调味。</p><p>因为和物是将食材和调料搅拌而成，如盛在太大或太平的容器里，外观给人感觉比较“杂”，也不够优雅，因此在餐桌上的和物一般都是盛在小钵里（即体积小、开口小，但有一定深度的小容器），盛法是菜肴中间部分堆得高，像“山形”。和物在一般情况下不能当主菜，只是用来补足餐桌上或便当盒里的色彩、口感和营养。反过来，寿司、天妇罗等主菜级、诱人的菜肴可以摆在大的平盘上，让人充分欣赏到食物本身的美。</p><h3 id="菊花宴"><a href="#菊花宴" class="headerlink" title="菊花宴"></a>菊花宴</h3><p>在日本吃生鱼片，盘子上会有“辛味”和“褄”。辛味指山葵、芥末、姜末等，用筷子挑起少许放在生鱼片上，再蘸点生抽送进嘴里，可以去除鱼身的腥味。褄则是为展现菜肴的季节感，且令口感更清爽而添加，如裙带菜、紫苏花、穗紫苏、菊花、紫芽、白萝卜丝、土当归、茗荷等等。</p><p>生鱼片盘上的小菊花，可以轻轻摘下几片花瓣，撒进放生抽的小碟子里，这样生鱼片蘸生抽后会带有淡淡的菊花香。紫苏花和穗紫苏，需用手指把花穗揉一揉，将其香味激发出来，然后再用筷子或手指将花穗轻轻捋一下，放入生抽碟里。</p><p>在百货公司地下食品部门，价格略贵的生鱼片套餐上偶尔会看到穗紫苏、紫苏花和紫芽等配料。</p><h2 id="午餐肉寿司便当-青山的“便当”"><a href="#午餐肉寿司便当-青山的“便当”" class="headerlink" title="午餐肉寿司便当 | 青山的“便当”"></a>午餐肉寿司便当 | 青山的“便当”</h2><h3 id="午餐肉寿司便当"><a href="#午餐肉寿司便当" class="headerlink" title="午餐肉寿司便当"></a>午餐肉寿司便当</h3><p>所需时间：50分钟</p><p>份量：3-4人份</p><ul><li><p>午餐肉寿司材料</p><p>午餐肉、白米饭、海苔、米醋、白糖、盐、植物油</p></li><li><p>糖醋藕片材料</p><p>莲藕、白糖、米醋、盐、辣椒</p></li><li><p>玉子烧材料</p><p>鸡蛋、白糖、盐、葱末、植物油</p></li></ul><p>制作步骤</p><p>寿司不一定要用生鱼片，也可以用玉子烧甚至火腿。</p><p>若在家里吃寿司，还可以配味噌汤。用小锅煮几样切丝的蔬菜，熟透后加日式高汤颗粒（鲣鱼味、昆布味）和味噌即可。加味噌后不要用大火煮滚，以免味噌的香味流失。</p><p>没吃完的寿司饭最好常温保存，不宜放入冰箱，会严重影响其口感。建议按个人食量制作。</p><ol><li><p>准备糖醋藕片</p><p>莲藕（1节，约300克）去皮后切0.5厘米厚度的小片。洗净藕片后，平底锅里放水（少许）、白糖（3汤匙）、米醋（3汤匙）和盐（少许），开中火后放入藕片，加热大约3分钟。锅里的水煮开后关火，按个人口味加辣椒。</p></li><li><p>准备寿司饭</p><p>用电饭锅煮白米饭，准备调味料。将米醋（50毫升）、白糖（1汤匙）和盐（3克）调好备用。米饭煮好后，取4-5碗的份量，趁热放进大盘子里，加入调料，放置约10秒使之入味。随后用勺子混合米饭和调料，同时扇风让米饭快速冷却。做好的寿司饭用布盖好，以免蒸发过多水分。</p></li><li><p>煎午餐肉</p><p>午餐肉切片，平底锅加入植物油煎2分钟。午餐肉两面呈金黄色即可。</p></li><li><p>做玉子烧片</p><p>用方锅做玉子烧。打鸡蛋（3个），加白糖（1-2汤匙）、盐（少许）和葱末（1汤匙）后搅拌。玉子烧做法参考“春日便当” &gt; “玉子烧便当”。玉子烧在竹帘上放凉后，用刀切成0.7厘米厚的小片。</p></li><li><p>做小饭团</p><p>用保鲜膜取少量寿司饭，用手捏成椭圆形小饭团。</p></li><li><p>做握寿司</p><p>海苔用剪刀剪成1厘米宽的细条。将玉子烧片和午餐肉片放在小饭团上，用手轻轻捏紧后，用海苔固定。卷到最后若有多余的海苔条，用剪刀剪除即可。</p></li></ol><h3 id="便当小贴士：运动会的今与昔"><a href="#便当小贴士：运动会的今与昔" class="headerlink" title="便当小贴士：运动会的今与昔"></a>便当小贴士：运动会的今与昔</h3><p>1964年东京奥运会后，那一届奥运开幕的10月10日后来被定为体育日，10月也称为学校举办运动会的月份。</p><p>但不少学校近年来改到初夏五月前后举办运动会。变化的原因：一是秋天有其他活动，如学艺会、音乐会等；二是气候因素，虽有“秋高气爽”一说，但日本的秋天也常有台风和“秋老虎”。</p><p>青空午餐（指在室外蔚蓝的天空下吃的午餐）：小朋友与家长一起在操场上吃便当。</p><h3 id="青山的“便当”"><a href="#青山的“便当”" class="headerlink" title="青山的“便当”"></a>青山的“便当”</h3><p>中小学的运动会把学生分为红、白两组，进行对抗赛，据说这源自八百多年前平安时代的坛之浦合战（发生于日本平安时代末期，为源平合战的关键战役之一。平宗盛率领的平氏是红色战旗，源义经率领的源氏则是白色战旗）。</p>]]></content>
    
    
    <categories>
      
      <category>book notes</category>
      
      <category>四季便当</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>四季便当Ⅱ-夏</title>
    <link href="/posts/4cf3fb66.html"/>
    <url>/posts/4cf3fb66.html</url>
    
    <content type="html"><![CDATA[<h1 id="夏"><a href="#夏" class="headerlink" title="夏"></a>夏</h1><h2 id="手作梅干-梅干日记"><a href="#手作梅干-梅干日记" class="headerlink" title="手作梅干 | 梅干日记"></a>手作梅干 | 梅干日记</h2><h3 id="手作梅干"><a href="#手作梅干" class="headerlink" title="手作梅干"></a>手作梅干</h3><p>所需时间：约1个月</p><p>份量：两个人每天各一颗，够吃一年</p><ul><li><p>手作梅干材料</p><p>青梅（6公斤）、盐（份量约青梅的15%-20%）、烧酒（容器和青梅灭菌用，100毫升左右）、紫苏（1公斤）</p></li><li><p>手作梅干工具</p><p>陶罐：腌制青梅用，可用玻璃瓶或珐琅容器，避免用金属容器。</p><p>内盖（压板）：腌制过程中，置于青梅和重物之间。木制、塑料皆可，避免用金属材料。</p><p>重物：载荷用石头，需为青梅重量的1-2倍。</p><p>牙签：挑青梅蒂用，竹制或木制为佳。</p></li></ul><blockquote><p>青梅重量：在步骤1的过程中需要挑出有刮伤等瑕疵的梅子，所以建议多买一些梅子。</p><p>盐分含量：梅干的盐分含量传统上是占梅子重量的20%，现在比较常见的是18%。不少家庭出于健康考虑制作减盐梅干，盐分含量约10%。</p><p>烧酒：一种蒸馏酒，酒精度约35度。在日本，做梅干和青梅酒时用的烧酒叫white liquor，是一种白色蒸馏酒。</p><p>陶罐容量：制作过程中除了梅子外，还会放重物和紫苏等，所以容器容量要比青梅体积大一些。</p><p>腌制梅干用的容器、重物、内盖和外盖都要避免金属材料，以免与梅子中的酸发生化学反应。</p></blockquote><p>制作重点</p><p>[1] 请保持卫生，以免梅子发霉。</p><p>[2] 梅干的盐分含量：按个人口味可以增减，但盐分含量12%一下的梅干容易发霉。若需要保存五年以上，建议盐分含量不低于15%。</p><p>[3] 梅干可以长期储存，放在玻璃瓶或陶瓷缸里，置于阴凉处即可。</p><ol><li><p>青梅的选购和“追熟”</p><p>在日本比较常见的是南高梅，但按个人喜好和各地条件，可用“白加贺”或“藤五郎”等。做梅干用的青梅以果皮薄、果肉多为佳，选购时要注意是否有虫害、刮伤或黑斑。但有一点瑕疵的梅子还可以用来制作青梅酒、青梅糖浆和果酱，不要浪费。青梅不能直接腌制，先放在通风较好且低温的地方，花几天的时间进行“追熟”，让青梅变柔软、颜色变黄。若买来的青梅已经变黄，可直接开始腌制</p></li><li><p>去蒂</p><p>用牙签去蒂后，用流水洗净青梅。准备干净的布块，擦干青梅上的水分。</p></li><li><p>算盐量</p><p>经筛选、去蒂并洗净后的青梅共有5170克，用15%的盐分含量来腌制，所需的盐就是766克。</p></li><li><p>撒盐</p><p>擦容器后，将烧酒（少许）洒在青梅上（消毒用），接着把盐裹上青梅，放入容器里。放一层青梅，再撒一层盐，如此重复两三次，直到青梅和盐都用完。</p></li><li><p>用重物压住</p><p>用内盖覆盖青梅，再放上重物和外盖，重物需要至少和青梅同等的重量，但不能太重，以免青梅被压坏。最后用纸把瓷缸上方抱起来，再阴凉处放五六天，等白梅醋出来。</p></li><li><p>减轻重物</p><p>腌制后的第二天，梅子开始出水（白梅醋）。等到腌出来的白梅醋漫过所有梅子，将重物的重量减轻一半。大概两周后将部分白梅醋舀出来，放入玻璃瓶备用。</p></li><li><p>处理紫苏叶</p><p>洗净紫苏叶，用盐拌匀（浓度与梅干的一致）后轻轻搓揉至叶片萎蔫。拧干渗出的水分，加白梅醋（2-3汤匙），使之增色。再次拧干并铺在缸里的梅子上，放重物继续腌制两周，直到梅雨期结束。</p><p>这个步骤可以跳过，不加紫苏叶的梅干被称为“白干” 。</p></li><li><p>晒干</p><p>将梅干晒一天。</p></li><li><p>进行“夜干”</p><p>晒到傍晚，用报纸轻轻覆盖住梅子，继续放在室外，直到第二天早上。早上揭开梅子上的报纸，继续晒。到傍晚再用报纸盖住梅子，继续放在室外。晒干和夜干步骤共持续三天三夜。</p></li><li><p>梅子放回容器，密封保存</p><p>晒梅子后的第四天，即可将梅子放回容器储存。先用开水洗净储存容器并彻底晾干，再把梅子放入其中。放梅子的同时把晒好的部分紫苏铺在梅子上，同时洒少量梅醋或烧酒，以防发霉。</p><p>晒干后剩下的梅醋和紫苏叶不要扔，梅醋可以保存在玻璃瓶里，当作凉拌、炒菜调料，紫苏叶可以做成拌饭料。</p></li></ol><h3 id="便当小贴士：紫苏拌饭料"><a href="#便当小贴士：紫苏拌饭料" class="headerlink" title="便当小贴士：紫苏拌饭料"></a>便当小贴士：紫苏拌饭料</h3><p>将一部分紫苏叶彻底晒干，然后用锤子或磨粉器弄碎，放在小瓶里保存即可，比梅干更方便携带。这种拌饭料，在日本超市可以买到，比如三岛食品开发的“优佳丽”。</p><p>做好的紫苏拌饭料可以直接洒在米饭上；也可以拌入米饭做成饭团，用青苏叶包起来，是美味的夏日简餐。</p><h3 id="梅干日记"><a href="#梅干日记" class="headerlink" title="梅干日记"></a>梅干日记</h3><p>采购鲜梅、洗净以及腌制：6月中旬-下旬</p><blockquote><p>腌制用的容器可以用“常滑烧”瓷缸（产于日本六大古窑之一“常滑”），隔热性好。</p></blockquote><p>取白梅醋，加紫苏：7月上旬</p><p>进行“土用干”：7月下旬</p><blockquote><p>7月20日左右的“夏土用”，阳光充沛，很多家庭会在那两天晒出自家的梅子。</p></blockquote><p>密封保存：7月下旬</p><blockquote><p>腌制完最好过几个月吃，口感更好。腌上三年的时候是最美味的。梅干并没有所谓的保质期，只要密封良好，一年、十年，甚至百年后都可以吃。</p></blockquote><h2 id="味噌烤饭团便当-富士山之味"><a href="#味噌烤饭团便当-富士山之味" class="headerlink" title="味噌烤饭团便当 | 富士山之味"></a>味噌烤饭团便当 | 富士山之味</h2><h3 id="味噌烤饭团便当"><a href="#味噌烤饭团便当" class="headerlink" title="味噌烤饭团便当"></a>味噌烤饭团便当</h3><p>所需时间：40分钟</p><p>份量：2人份</p><ul><li><p>味噌烤饭团材料</p><p>白米饭、味噌、海苔、盐、白糖、料酒</p></li><li><p>鸡肉奶酪卷材料</p><p>小鸡胸肉、奶酪片、海苔（大片）、淀粉、鸡蛋、面包糠、盐、白胡椒、植物油</p></li></ul><p>制作步骤：</p><p>烤饭团：夏天做饭团需要注意卫生，捏饭团时建议用保鲜膜（而不是直接用手捏），馅料要避开水分多的材料，甚至不加馅料也可以。另外，煮米饭时加白醋（1小汤匙），可防止米饭变质，在加热过程中白醋的味道会散掉，煮好的米饭不会有醋的味道。</p><ol><li><p>做饭团</p><p>白米饭（3碗）装入大碗里，撒盐（少许）。将一张保鲜膜铺在手掌上，放一小碗分量的米饭。用双手把包了保鲜膜的米饭捏成三角形，捏好的饭团搁在盘子里备用。</p></li><li><p>烤饭团</p><p>将味噌（1汤匙）、白糖和料酒（各半汤匙）一并放入小碗里搅拌。在平底锅里铺一层烘焙纸，开小火，放入饭团。同时用刷子在饭团的一面涂上味噌调料，微焦后翻面，再涂另一面，共烘烤约6-7分钟（注意涂上味噌调料后容易烧焦）。烤好的饭团搁在盘子里冷却，用干净的剪刀将海苔剪成小块（约5*10厘米），然后包起烤饭团。</p></li><li><p>处理小鸡胸肉</p><p>小鸡胸肉（2块）用刀从侧面剖开，片成两片，每面均撒上盐和白胡椒（各少许）。</p></li><li><p>准备海苔和奶酪</p><p>海苔用剪刀剪成奶酪片一般大小。奶酪片铺在海苔上，卷成细长条，再用鸡胸片包裹备用。</p></li><li><p>裹上外层</p><p>准备三个小盘子，分别盛淀粉（2汤匙）、蛋液（1个鸡蛋）和面包糠（4汤匙），将步骤4的鸡肉卷，首先均匀裹上淀粉，接下来沾一层蛋液，最后沾上面包糠。面包糠比较容易脱落，可以用手轻按固定。</p></li><li><p>炸制</p><p>平底锅里倒入植物油，大约1-2厘米深。置中火，油温升至170℃时放入三个鸡肉卷，封口朝下。刚放入时面包糠容易脱落，3分钟内不要用筷子触碰。等下层变金黄色后再轻轻翻面，继续炸至完全呈金黄色。全过程共需约10分钟。炸好的鸡肉卷置于铺有厨房纸巾的盘子里备用。</p></li></ol><h3 id="便当小贴士：饭团和海苔"><a href="#便当小贴士：饭团和海苔" class="headerlink" title="便当小贴士：饭团和海苔"></a>便当小贴士：饭团和海苔</h3><p>有的人觉得吸收饭团水分，软塌塌的海苔比较美味，米饭上带有海苔的香味和淡淡的印迹，海苔也带有米饭温和的香味。也有人认为海苔还是要有那种脆感，需要尽量避免水分。有个秘诀，做好的饭团放在盘子里散热一会儿，再用海苔包起来，这样海苔就不会吸收太多水分，可以避免中午揭开保鲜膜时，海苔黏在保鲜膜上。如果喜欢干燥的海苔，可以把饭团用保鲜膜包起来，另外带小包装的海苔（比如波力海苔的包装就挺合适），吃的时候把海苔贴在饭团上即可。</p><h3 id="富士山之味"><a href="#富士山之味" class="headerlink" title="富士山之味"></a>富士山之味</h3><p>日本人登山或郊游时经常带着饭团上路。饭团体积小、包装简单（一张保鲜膜），放在背包里一点不占空间。而且米饭有适当的含水量，即使不配饮料也容易吞进肚子。 </p><h2 id="鲑鱼饭团便当-母亲节的“什么都做券”"><a href="#鲑鱼饭团便当-母亲节的“什么都做券”" class="headerlink" title="鲑鱼饭团便当 | 母亲节的“什么都做券”"></a>鲑鱼饭团便当 | 母亲节的“什么都做券”</h2><h3 id="鲑鱼饭团便当"><a href="#鲑鱼饭团便当" class="headerlink" title="鲑鱼饭团便当"></a>鲑鱼饭团便当</h3><p>所需时间：20分钟</p><p>份量：1人份</p><ul><li><p>鲑鱼饭团材料</p><p>鲑鱼片、白米饭、油菜花、木鱼精（或干贝素）、熟白芝麻、盐、植物油、生抽、鸡蛋（按个人口味）</p></li><li><p>香菇豆皮材料</p><p>香菇、豆皮、白糖、生抽、料酒</p></li><li><p>和风魔芋材料</p><p>魔芋、生抽、木鱼精、芝麻油</p></li></ul><p>制作步骤</p><p>本篇介绍的常备菜较多，油菜花可以冷藏保存一天，鲑鱼肉末、香菇豆皮、和风魔芋保质期大约为3-4天，而红生姜可长达半年。冰箱里有这些常备菜，做便当时可以省下不少时间。</p><ol><li><p>做鲑鱼肉末</p><p>鲑鱼片（1片）去皮和小骨头。用小锅（或做玉子烧用的方锅）预热植物油，加鲑鱼后用勺子或筷子慢慢捣成肉末，并加入木鱼精（或干贝素）和生抽（各少许）调味。</p></li><li><p>烫油菜花（常备菜）</p><p>用锅把水烧开，加盐（少许）和植物油（3-4滴）后，将洗好的油菜花烫30秒。捞出，冷却后切段备用。</p></li><li><p>做鲑鱼饭团</p><p>盛一碗白米饭，加鲑鱼肉末（1汤匙）、切碎的油菜花和熟白芝麻，用保鲜膜捏成圆形的饭团。可加炒蛋（少许）。</p></li><li><p>做香菇豆皮（常备菜）</p><p>小锅里放白糖（3汤匙）、生抽（1汤匙）和料酒（少许），开中火加热。调料煮开后放入切丝的蘑菇，再次煮开后调小火，放入切成小块的豆皮。等调料充分渗入香菇和豆皮后关火。</p></li><li><p>做和风魔芋（常备菜）</p><p>魔芋切小块或打结后，用开水烫1分钟，去除腥味。小锅内放入魔芋、生抽（1汤匙）和木鱼精（半汤匙），加热2分钟，最后加芝麻油（少许）。与汤汁一并冷藏，保存一天后更入味。</p></li></ol><h3 id="便当小贴士：红生姜的来历和用途"><a href="#便当小贴士：红生姜的来历和用途" class="headerlink" title="便当小贴士：红生姜的来历和用途"></a>便当小贴士：红生姜的来历和用途</h3><p>牛肉盖浇饭上的红色腌菜，就是红生姜。红生姜可以用自制梅干的副产品赤梅醋（加了紫苏叶之后渗出的梅醋）腌制。</p><p>做法：生姜（约1斤）洗净，嫩生姜不用去皮，沿着生姜的纤维切成2-3毫米厚的薄片或切丝，放入小碗里并加盐（1汤匙）放一刻钟。随后用双手拧出水分，放入保存用容器里，再加赤梅醋（150毫升），腌渍2-3小时即可。冷藏可保存约半年。</p><p>红生姜的味道偏咸、微酸，具有促进食欲的功效。除了牛肉盖浇饭外，大阪烧、乌冬面、日式炒面、炒饭、稻荷寿司（豆皮寿司）等比较庶民化的食物，经常会配红生姜。除此外，红生姜还可以作为一种食材食用，比如做章鱼烧、炒菜等都会加红生姜。</p><h3 id="母亲节的“什么都做券”"><a href="#母亲节的“什么都做券”" class="headerlink" title="母亲节的“什么都做券”"></a>母亲节的“什么都做券”</h3><p>我先把纸裁成卡片大小，用铅笔描框，然后写上“锤肩券”、“洗碗券”、“擦鞋券”……基本都是平时母亲反复叮嘱我做的家务。最后，还有一张大出血级别的“什么都做券”。</p><p>这类券全日本的小朋友都知道。曾有百货店的失物招领处收到一张“锤肩券”，消息一经广播，逛商场的父母纷纷拿出钱包确认是不是自己丢的。</p><h2 id="水羊羹-夏日逸品水羊羹"><a href="#水羊羹-夏日逸品水羊羹" class="headerlink" title="水羊羹 | 夏日逸品水羊羹"></a>水羊羹 | 夏日逸品水羊羹</h2><h3 id="水羊羹"><a href="#水羊羹" class="headerlink" title="水羊羹"></a>水羊羹</h3><p>所需时间：20分钟</p><p>份量：2-3人份</p><ul><li><p>水羊羹材料</p><p>豆沙、琼脂（粉状和方块皆可）、腌制樱花叶或竹叶（装饰用）</p></li></ul><p>制作步骤</p><p>琼脂融化在水里后，需要小火沸腾几分钟，方可使其完全融化。若用方块（非粉末），则需要提前泡软。</p><p>用琼脂可以做透明凉糕，冷却后切成小方块，并加以装饰。琼脂不加糖则易发生离水现象，凝固时会变得白浊，需要加少许白糖才可呈透明状。</p><ol><li><p>煮琼脂</p><p>琼脂（2克）洗净，撕成小块并放入大碗，加清水浸泡1小时。准备小锅，倒入饮用水（约300毫升）和琼脂，开小火煮沸约5分钟，确认琼脂完全融化后关火。</p></li><li><p>加豆沙</p><p>往小锅里倒入豆沙（250克），并用木勺搅拌均匀。用慢火煲热稍许，关火。</p></li><li><p>冷却</p><p>倒入保鲜盒，用冰箱冷却1小时后切小块即可享用。或倒入小碗里，冷却后直接用勺子食用，可加腌制樱花叶或竹叶做装饰。</p></li></ol><h3 id="便当小贴士：寒天与和菓子"><a href="#便当小贴士：寒天与和菓子" class="headerlink" title="便当小贴士：寒天与和菓子"></a>便当小贴士：寒天与和菓子</h3><p>寒天在日本用来做点心、凉拌菜和汤，有条状（角寒天）和粉末状。4克粉末状寒天的凝固里相当于一条角寒天（约8克），可以凝固450-600毫升水。另外，在日本，用寒天做出来的凝固物也叫做寒天，比如牛奶寒天、水果寒天等。</p><p>寒天在日本是有名的减肥产品，主要成分为海藻胶，热量接近零，富含膳食纤维。煮米饭的时候放少量寒天粉末一起煮食（大米150克配1克粉末寒天或1&#x2F;6角寒天），有助于降低血糖、增加饱腹感、通便。</p><p>金鳄、水羊羹等都是寒天食物。</p><h3 id="夏日逸品水羊羹"><a href="#夏日逸品水羊羹" class="headerlink" title="夏日逸品水羊羹"></a>夏日逸品水羊羹</h3><p>羊羹大致有三种做法：一是水羊羹；二是蒸羊羹，豆沙里加些面粉和淀粉后上蒸笼整制；三是练羊羹，将豆沙和寒天混合制成。水羊羹比练羊羹水分更多，口感更显滑嫩清爽，适合在炎热的夏季享用。</p><h2 id="日式炒面-大叔！炒面一份！"><a href="#日式炒面-大叔！炒面一份！" class="headerlink" title="日式炒面 | 大叔！炒面一份！"></a>日式炒面 | 大叔！炒面一份！</h2><h3 id="日式炒面"><a href="#日式炒面" class="headerlink" title="日式炒面"></a>日式炒面</h3><p>所需时间：30分钟</p><p>份量：2人份</p><ul><li><p>日式炒面材料</p><p>乌冬面、五花肉（薄片）、卷心菜、柴鱼片、沙司酱（可用蚝油代替）、植物油、胡椒粉、海苔丝</p></li><li><p>一夜渍材料</p><p>黄瓜、卷心菜、芜菁、红辣椒、盐</p></li><li><p>藜麦沙拉材料</p><p>藜麦、胡萝卜、盐、橄榄油、米醋</p></li></ul><p>制作步骤</p><p>日式炒面用的碱水面条不易买到，可改用真空包装的乌冬面。味道比较接近，而且做法更为简单。</p><p>藜麦在国内普通超市相对少见，可在进口食品店购入。煮好的藜麦可冷藏保存2-3天，可煮多一些，做沙拉、凉拌菜和意大利面时适量拌入，健康又美味。</p><ol><li><p>切菜</p><p>卷心菜（4-5片）洗净，切小块。五花肉片（150克）切小块备用。</p></li><li><p>准备面条</p><p>用小锅煮开水，将乌冬面（2袋）放入滚水里。加热30秒后捞起沥干水分备用。</p></li><li><p>炒肉、炒面</p><p>开中火预热平底锅，放入植物油（半汤匙）和五花肉片，炒1分钟后放入卷心菜，烧至八成熟。下乌冬面略炒一下，淋入沙司酱或蚝油（适量），翻炒均匀即可出锅。</p></li><li><p>调味</p><p>炒面装盘后撒上柴鱼片（3-5克），按个人口味撒胡椒粉和海苔丝等调味。</p></li><li><p>做一夜渍（常备菜）</p><p>把黄瓜、芜菁和卷心菜洗净，沥干水分。黄瓜和芜菁切1-2毫米厚的薄片，卷心菜切成3厘米左右的小方片。把蔬菜放入大碗里，加盐（约为蔬菜重量的2%）用手搓20秒。把碗里的全部蔬菜放入食品袋，加红辣椒（2个），把袋子里的空气挤出后扎紧，放入冰箱3-4小时。可保存两天，开袋即食。</p></li><li><p>做藜麦沙拉（常备菜）</p><p>藜麦（50克）用凉水淘洗后，放进锅中加饮用水，开中火，煮开后调小火，继续加热10-15分钟，直到藜麦变半透明状。倒掉剩下的水，煮好的藜麦搁在小碗里备用。胡萝卜（1根）切丝拌入，再加入橄榄油（2-3汤匙）与盐和米醋（各少许）即可。</p></li></ol><h3 id="便当小贴士：日本夏日祭“屋台”的十大小吃"><a href="#便当小贴士：日本夏日祭“屋台”的十大小吃" class="headerlink" title="便当小贴士：日本夏日祭“屋台”的十大小吃"></a>便当小贴士：日本夏日祭“屋台”的十大小吃</h3><p>在日本可以看到卖小吃的“屋台”（yatai，摊子），但时间和地点都比较固定，最有人气的是夏天的盂兰盆节、烟火祭，以及元旦放假期间的各地神社、寺庙附近。</p><p>日本夏日祭的小吃，有的与中国小吃相仿，有的则多了沙司酱和红生姜。</p><h4 id="1-炒面"><a href="#1-炒面" class="headerlink" title="1. 炒面"></a>1. 炒面</h4><p>如前文介绍，炒面的亮点是最后淋上沙司酱的瞬间散发出的诱人香气。炒面一般会配上红生姜。</p><h4 id="2-章鱼烧"><a href="#2-章鱼烧" class="headerlink" title="2. 章鱼烧"></a>2. 章鱼烧</h4><p>现在卖的丸子越来越大，有的还加了芝士等等。经典版本则比较小，丸子可以一口吃掉。材料一定要有卷心菜、章鱼、面浆、面酥（做天妇罗时捞起来的炸过的面衣碎）和红生姜。</p><h4 id="3-乌贼烧"><a href="#3-乌贼烧" class="headerlink" title="3. 乌贼烧"></a>3. 乌贼烧</h4><p>又一款香气诱人的小吃。站着或坐在旁边的石头上当场吃掉，才算内行。拿到家里乖乖坐下来吃，就觉得没那么好吃了。</p><h4 id="4-烤玉米"><a href="#4-烤玉米" class="headerlink" title="4. 烤玉米"></a>4. 烤玉米</h4><p>生抽和黄油混搭烤制的焦香味确实不错。推荐去北海道（日本著名玉米产地）旅行的朋友试一试。</p><h4 id="5-大阪烧-御好烧"><a href="#5-大阪烧-御好烧" class="headerlink" title="5. 大阪烧 &#x2F; 御好烧"></a>5. 大阪烧 &#x2F; 御好烧</h4><p>材料与章鱼烧差不多——卷心菜、肉片、面浆，然后撒上柴鱼片、青海苔和沙司酱，最后添上少许红生姜。</p><h4 id="6-烤鸡肉串"><a href="#6-烤鸡肉串" class="headerlink" title="6. 烤鸡肉串"></a>6. 烤鸡肉串</h4><p>冰啤酒的最佳拍档。据说，啤酒、烤鸡肉串、毛豆，这三者是一般日本家庭中的父亲们参加祭典活动的唯一动力。</p><h4 id="7-棉花糖"><a href="#7-棉花糖" class="headerlink" title="7. 棉花糖"></a>7. 棉花糖</h4><p>和中国一样。夏日祭的角落里，大叔把砂糖灌进棉花糖制作机，砂糖变成长长的丝状，大叔用木制筷子绕成一团后拿给你，味道单纯，正如儿时的回忆。</p><h4 id="8-巧克力香蕉"><a href="#8-巧克力香蕉" class="headerlink" title="8. 巧克力香蕉"></a>8. 巧克力香蕉</h4><p>巧克力和香蕉是黄金搭配。插在一次性筷子上的香蕉，沾一层巧克力就身价倍增，这就是夏日祭的魔法。</p><h4 id="9-奶油薄饼-可丽饼"><a href="#9-奶油薄饼-可丽饼" class="headerlink" title="9. 奶油薄饼 &#x2F; 可丽饼"></a>9. 奶油薄饼 &#x2F; 可丽饼</h4><p>日本祭典小吃摊上的必备品种。奶油薄饼的定番是香蕉，大量的奶油中加两三片香蕉切片，卷起来，上面撒少许巧克力碎（热量应该是极高）。</p><h4 id="10-热狗"><a href="#10-热狗" class="headerlink" title="10. 热狗"></a>10. 热狗</h4><p>市面上热狗有两种，一种是把香肠夹在面包里，另外一种是将香肠裹上面浆（小麦粉、白糖、鸡蛋）后炸制而成。日本小吃摊卖的热狗多属于后者，又称美式热狗，一般浇上番茄酱和黄芥末来吃。</p><h3 id="大叔！炒面一份！"><a href="#大叔！炒面一份！" class="headerlink" title="大叔！炒面一份！"></a>大叔！炒面一份！</h3><p>据统计，从上个世纪90年代到现在21世纪初，日本男性自己会做的菜肴种类增加了不少。茶碗蒸、煮鱼、土豆炖肉、炸鸡块、炸猪排、天妇罗、味噌汤、寿喜锅、大阪烧、奶汁烤菜、玉子烧、汉堡肉、意大利面、咖喱饭、蔬菜沙拉、炒饭、炒面、白米饭、烤吐司、方便面（袋装）这二十种“菜肴”中，会做的人比率从52%增加到66%。</p><p>在日本，炒面现身的标准场合是节庆时的神社附近，不管是夏日盂兰盆节还是春天夜樱节，只要人多热闹，就会有人支起摊子，摆上一大块铁板做炒面。只见大叔闷头用铁铲子翻炒面条，看到客人走近就抬起头大声吆喝道：“保证好吃！来一份吧！”</p><h2 id="干咖喱便当-“给食”圆舞曲"><a href="#干咖喱便当-“给食”圆舞曲" class="headerlink" title="干咖喱便当 | “给食”圆舞曲"></a>干咖喱便当 | “给食”圆舞曲</h2><h3 id="干咖喱便当"><a href="#干咖喱便当" class="headerlink" title="干咖喱便当"></a>干咖喱便当</h3><p>所需时间：30分钟</p><p>份量：2人份</p><ul><li><p>干咖喱材料</p><p>肉馅（鸡肉、牛肉、猪肉皆可）、洋葱、青椒、番茄酱、咖喱粉、盐、葡萄干、玉米、植物油</p></li><li><p>腌制鸡蛋材料</p><p>鸡蛋、米醋、生抽</p></li></ul><p>制作步骤</p><p>日式咖喱一般会附上“福神渍”。</p><ol><li><p>准备腌制玉子</p><p>做水煮蛋（2-3个），剥壳之后放入食品袋，再加米醋（4汤匙）和生抽（2汤匙）。在冰箱里可以保存一天。</p></li><li><p>炒洋葱和肉末</p><p>将洋葱（半个）切碎，开中火预热平底锅，放入植物油（半汤匙）后，先炒洋葱末，待锅中洋葱末的体积减去一半后，再加入肉馅（200克）。</p></li><li><p>加调料</p><p>肉馅熟透后，加咖喱粉（1-2汤匙）和番茄酱（2汤匙），搅拌后盖上盖子，用小火煮10分钟，用盐调味。</p></li><li><p>加青椒</p><p>青椒（2个）切小块，最后倒入，并加热5分钟。按个人喜好加葡萄干和玉米。</p></li></ol><h3 id="便当小贴士：咖喱与福神渍"><a href="#便当小贴士：咖喱与福神渍" class="headerlink" title="便当小贴士：咖喱与福神渍"></a>便当小贴士：咖喱与福神渍</h3><p>福神渍是用白萝卜、茄子、莲藕等七种材料制作而成，东京谷中一带有祭“七福神”的各个神社和寺庙，故得名福神渍。另外有个说法是，只要有美味的福神渍配米饭，就觉得不需要其他菜肴了，可节省不少伙食费，感觉家里来了福神一般。</p><p>做好的福神渍可冷藏保存一周。</p><p>所需时间：50分钟</p><p>份量：1小瓶（约200毫升）</p><ul><li><p>材料</p><p>蔬菜（白萝卜、胡萝卜、莲藕、香菇等）、生姜丝、生抽、白糖、白醋、盐、白芝麻、干辣椒、味淋</p></li></ul><p>制作步骤</p><ol><li><p>切蔬菜</p><p>做其他菜肴的时候，收集蔬菜边角料（共250克左右），晒上几个小时，或者把蔬菜切薄片，直接烹饪也可以。一小块生姜切丝备用。</p></li><li><p>调味</p><p>小锅里加入生抽（3汤匙）、白糖（3汤匙）、白醋（半汤匙）和盐（少许），按个人口味加味淋（半汤匙），开小火。煮开后放入蔬菜边角料、生姜丝、白芝麻和干辣椒，加热1分钟后关火，放凉。</p></li><li><p>保存</p><p>放入保鲜盒里，可冷藏保存约1周。</p></li></ol><h3 id="“给食”圆舞曲"><a href="#“给食”圆舞曲" class="headerlink" title="“给食”圆舞曲"></a>“给食”圆舞曲</h3><p>学校比较重视食用当季食材：春天的各种叶菜、夏日的餐后水果、秋日的菌菇类、冬日的根菜类等，让孩子们慢慢了解到食物与季节之间的关联。</p><p>我们所在的小学给食时段一般不播放音乐，，好让孩子们边聊边吃。而从午餐结束到打扫卫生的二十分钟里，学校播放时会播放肖邦的音乐。至今，我在家里打扫卫生的时候，也偶尔会放肖邦的《小狗圆舞曲》《华丽大圆舞曲》等，简直是巴甫洛夫式的条件反射，一听就启动打扫模式。</p>]]></content>
    
    
    <categories>
      
      <category>book notes</category>
      
      <category>四季便当</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>四季便当Ⅱ-春</title>
    <link href="/posts/e6fdf516.html"/>
    <url>/posts/e6fdf516.html</url>
    
    <content type="html"><![CDATA[<p>很治愈的一本书：一些简单的食谱，每个食谱附带一篇相关的小故事，还有日本料理的小科普。</p><h1 id="春"><a href="#春" class="headerlink" title="春"></a>春</h1><h2 id="花见便当-樱花下的小丸子"><a href="#花见便当-樱花下的小丸子" class="headerlink" title="花见便当 | 樱花下的小丸子"></a>花见便当 | 樱花下的小丸子</h2><h3 id="花见便当"><a href="#花见便当" class="headerlink" title="花见便当"></a>花见便当</h3><p>所需时间：60分钟</p><p>份量：2人份</p><ul><li><p>炸鸡块材料</p><p>鸡腿肉、鸡蛋、淀粉、盐、姜泥、蒜泥、料酒、生抽、植物油【油炸用】</p></li><li><p>炒青椒材料</p><p>青椒、盐、白胡椒、植物油</p></li><li><p>虾皮卷心菜材料</p><p>卷心菜、虾皮、玉米粒、盐、黑胡椒</p></li><li><p>樱花饭团材料</p><p>白米饭、梅干（除核）、腌制樱花、海苔</p></li><li><p>味噌魔芋材料</p><p>魔芋、味噌、白芝麻、白糖、料酒</p></li></ul><p>制作步骤</p><p>花见便当：没有固定的做法，一般大家会放炸鸡块、玉子烧等经典便当菜肴，另外会加些腌制樱花等带有春日气息的小东西。</p><p>炸鸡块：一般会进行两次油炸，第一次用160℃的植物油炸2分钟，捞起肉块，用余热使肉块熟透后再用180℃的油炸2分钟。油炸过程分两次的原因是防止过度加热而使鸡肉中的水分流失，第二次炸制主要是为了让外皮更加香脆。这次制作便当用的炸鸡块，切块更小，油炸过程也只有一次，以节省时间。</p><ol><li><p>做炸鸡块</p><p>将鸡腿肉（1根）切成10-15个小块，放入小碗，加姜泥、蒜泥、料酒（各适量）和生抽（1汤匙）。鸡肉腌半小时后，去除多余水分，加鸡蛋（1个）和淀粉（2汤匙）搅拌。将平底锅预热并倒入植物油，将鸡块用180℃的热油（将木制筷子伸入油锅，气泡沿筷子快速浮起时的温度）炸制2-3分钟。</p></li><li><p>炒青椒</p><p>将青椒洗净，去蒂和种子后切块。炸完鸡块的植物油先倒在小碗里，用厨房纸巾擦净平底锅炒青椒，佐盐和白胡椒调味。</p></li><li><p>炒卷心菜</p><p>炒完青椒的平底锅不用洗，盛出青椒后，放入洗净切丝的卷心菜（半颗）和玉米粒，用中火加热。视情况加饮用水（1汤匙），蔬菜熟透前加虾皮（少许）。按个人口味加盐和黑胡椒。</p></li><li><p>做樱花小饭团</p><p>腌制樱花用水洗净，放在厨房纸巾上吸收多余水分备用。米饭放在保鲜膜上，中间包入梅干肉，做成3-4个小小的圆形饭团。饭团上直接放上腌制樱花或贴上切细条的海苔作为装饰。</p></li><li><p>做味噌魔芋</p><p>将魔芋（1包）切成长方块，并在表面切花刀。用竹签穿起，放入小锅水煮3分钟。耐热小碟子里放味噌（1汤匙）、白芝麻（半汤匙）、白糖（半汤匙）和料酒（少许），用微波炉加热30秒后轻轻搅拌，浇在装盒后的魔芋上。</p></li><li><p>装盒</p><p>装盒的基本顺序是从大（主菜、主食）到小（配菜）。首先在便当盒的一边铺卷心菜（少许），再放主菜（炸鸡块和玉子烧），再在卷心菜上放好饭团。卷心菜的主要用途是固定圆形饭团，同时让营养更加丰富，铺在下面看不见也无所谓，也可以当早餐吃掉。最后再空隙中填入魔芋块、青椒、小番茄等配菜即可。</p></li></ol><h3 id="便当小贴士：花见团子"><a href="#便当小贴士：花见团子" class="headerlink" title="便当小贴士：花见团子"></a>便当小贴士：花见团子</h3><p>所需时间：60分钟</p><p>份量：2人份</p><ul><li><p>花见团子材料</p><p>糯米粉、内酯豆腐、草莓果酱、抹茶粉、豆沙</p></li></ul><p>制作步骤</p><ol><li><p>准备糯米粉</p><p>小碗里倒入糯米粉（150克），再直接加内酯豆腐（120克），揉搓成面团。</p></li><li><p>做三种口味的团子</p><p>揉好的面团均分为三块，制作成白（原味）、粉（草莓味）、绿（抹茶味）三色。粉面团加入的是草莓果酱（1汤匙），绿面团加入的是抹茶粉（半汤匙），再分别调匀揉搓，捏成小球。</p></li><li><p>煮团子</p><p>糯米小球放入滚水中煮至浮起。捞出后放入冰水中冷却，以保持弹性。待凉后捞出沥干水分，穿上竹签，按个人口味加豆沙即可。</p></li></ol><h3 id="樱花下的小丸子"><a href="#樱花下的小丸子" class="headerlink" title="樱花下的小丸子"></a>樱花下的小丸子</h3><p>在日本，大家争先去赏的一般都是“染井吉野”，有五枚花瓣，颜色多为半透明的浅粉色。东京周边樱花的花期为三月底到四月上旬，气象厅发布的樱前线预报也是以染井吉野的花期为基准。</p><p>而八重樱花瓣多而密，开花时间比染井吉野晚一两周，刚好在染井吉野花瓣散落的时候盛开，而且开花时间比前者长一些。八重樱也挺漂亮的，还带有淡淡的芳香。开花的时候，新叶也一并长出来，新绿和粉红花朵很搭，但视觉效果上，比起树枝上爆满淡粉色花朵的染井吉野，八重樱的花朵更和气，缺少染井吉野的那种霸气。</p><p>八重樱是樱茶的材料。樱茶的做法很简单，八重樱开到七分时摘下花朵，洗净并去除水分后用盐腌制一晚，随后加白梅醋再腌两天，阴干后撒盐保存。</p><h2 id="烧卖便当-善兵卫爷爷的草莓园"><a href="#烧卖便当-善兵卫爷爷的草莓园" class="headerlink" title="烧卖便当 | 善兵卫爷爷的草莓园"></a>烧卖便当 | 善兵卫爷爷的草莓园</h2><h3 id="烧卖便当"><a href="#烧卖便当" class="headerlink" title="烧卖便当"></a>烧卖便当</h3><p>所需时间：50分钟</p><p>份量：2人份</p><ul><li><p>烧卖材料</p><p>肉末（猪肉）、洋葱、姜末、烧卖皮（若买不到，可用现成的饺子皮代替，用擀面杖擀薄即可）、卷心菜（或白菜）、青豆、盐、白胡椒、料酒、生抽</p></li><li><p>辣油胡萝卜材料</p><p>胡萝卜、盐、辣油、白芝麻（按个人口味）</p></li><li><p>胡萝卜蛋皮材料</p><p>鸡蛋、胡萝卜、白糖、盐、植物油</p></li></ul><p>制作步骤</p><p>烧卖上的青豆：中国的烧卖不加青豆，而日式烧卖顶上的这颗青豆则不可缺少。有个说法是在日本1950年代，物资条件还没达到现有水平，有人模仿草莓奶油蛋糕（当时小孩子的梦中美食），在烧卖上放一颗青豆，并供应给学校当午餐，后来这种样式的烧卖普及到日本各地。</p><p>另，在日本超市很容易买到现成的烧卖，一盒10个，不到200日元（约合人民币13元），是一款廉价的美食。用微波炉加热之后，直接放入便当盒即可。</p><ol><li><p>准备馅料</p><p>洋葱（1&#x2F;6）切碎，与肉末（150克）、生抽（半汤匙）、姜末、料酒、白胡椒和盐（各少许）一起搅拌，做成馅料备用。若不是做便当用烧卖，可不加生抽，用餐时另备小碟子，倒入生抽，加黄芥末享用即可。</p></li><li><p>准备蒸锅</p><p>蒸锅里倒水并开中火。蒸笼里铺上少量卷心菜叶或白菜叶，以免烧卖皮和蒸笼连住，同时还可以为便当加点叶菜，丰富营养。</p></li><li><p>包上馅料</p><p>用手掌托住烧卖皮，放入肉馅（1汤匙）并用烧卖皮包住。上方开小口，放入一颗青豆。</p></li><li><p>蒸烧卖</p><p>把烧卖放入蒸锅里，加热5分钟。蒸熟后把烧卖和叶菜一并搁在盘子里备用。</p></li><li><p>做辣油胡萝卜（常备菜）</p><p>胡萝卜切丝，用平底锅炒制。用盐调味，最后加辣油（少许），按个人口味加白芝麻。</p></li><li><p>做胡萝卜蛋皮</p><p>用鸡蛋（2个）、白糖（半汤匙）和盐（少许）做蛋液。开中火预热平底锅，倒入植物油（半汤匙）加热。倒入蛋液，蛋皮上方尚未凝固时加辣油胡萝卜。翻面再加热几秒钟，关火。做好的胡萝卜蛋皮切块或切长条卷起来，以便放入便当盒。</p></li><li><p>装盒</p><p>蒸熟的卷心菜切小片，铺在便当盒下层，再放入米饭和几颗烧卖，最后在空隙处放进胡萝卜蛋皮即可。</p></li></ol><h3 id="便当小贴士：便当能否加热？"><a href="#便当小贴士：便当能否加热？" class="headerlink" title="便当小贴士：便当能否加热？"></a>便当小贴士：便当能否加热？</h3><p>传统上，日式便当是在没有加热设备的环境下吃的，所以大部分情况下便当是常温的。</p><p>另外，在日本吃的米大部分属于粳米，特点在于口感柔软、入口甘甜清香，以及水分丰富，在常温下也能保持较佳的口感和弹性，适合做便当和饭团。中国东北产的珍珠米口感和香味与日本大米很相近。</p><p>吃完一小瓶果酱后，可以把空瓶留下来，作为便当水果专用瓶。晚上把柠檬切片，和草莓、苹果等水果一起放在瓶子里，浇上一点蜂蜜，盖紧盖子后放入冰箱。早上带便当的时候拿出来，一道携带即可。中午吃完便当，小瓶子里的水果可以当作餐后水果，或留到下午喝咖啡时当点心吃。</p><h3 id="善兵卫爷爷的草莓园"><a href="#善兵卫爷爷的草莓园" class="headerlink" title="善兵卫爷爷的草莓园"></a>善兵卫爷爷的草莓园</h3><p>父亲从附近的农家租来一小块土地，把种地作为周末爱好。父亲坚持无农药无化肥的有机种植方针，头两年的收获少得可怜，但从第三年开始，蔬果品质就达到了超市的水准，其中，草莓又是父亲最为得意的。每逢初冬，他会准备约两百颗草莓苗，翌年四月底五月初，就会长出全家人吃不完的草莓，个头小但味道甜美。</p><h2 id="草饼便当-踏青"><a href="#草饼便当-踏青" class="headerlink" title="草饼便当 | 踏青"></a>草饼便当 | 踏青</h2><h3 id="草饼便当"><a href="#草饼便当" class="headerlink" title="草饼便当"></a>草饼便当</h3><p>所需时间：40分钟</p><p>份量：2人份</p><ul><li><p>草饼材料</p><p>糯米粉、内酯豆腐、艾蒿、白糖、小苏打粉、盐、豆沙（真空包装的现成品）</p></li></ul><p>制作步骤</p><p>草饼的标准制法是用糯米粉和大米粉，加温水和面，上蒸笼加热制成。我平时做的草饼是只用糯米粉，用水煮制的简易版。因为加了豆腐，过一段时间也不容易硬化。</p><ol><li><p>煮艾蒿</p><p>艾蒿去柄（约30克），用水洗净后控干。煮一小锅开水，加小苏打粉（半汤匙）和盐（少许），烫艾蒿约1分钟。</p></li><li><p>研磨艾蒿</p><p>捞出艾蒿，用冷水泡1分钟，冷却后控干水分，用研钵研磨。若没有，可用搅拌机代替。研磨过程中加白糖（半汤匙）。</p></li><li><p>做面团</p><p>研钵里直接加内酯豆腐（100克）和糯米粉（120克），揉搓成面团。搅拌到大约“耳垂般的软度”后，捏成小球。</p></li><li><p>煮团子</p><p>糯米小球放入滚水中煮至浮起。捞出后放入冰水中冷却，以保持弹性。待冰凉后捞出沥干备用。</p></li><li><p>准备豆沙</p><p>豆沙可以用真空包装的现成品。若豆沙太黏，可放入小锅，加开水加热1-2分钟，最后浇至草饼上即可。</p></li><li><p>准备黄豆粉</p><p>除了豆沙，草饼也可蘸黄豆粉食用。</p></li></ol><h3 id="便当小贴士：木制便当盒的保养"><a href="#便当小贴士：木制便当盒的保养" class="headerlink" title="便当小贴士：木制便当盒的保养"></a>便当小贴士：木制便当盒的保养</h3><p>日本秋田县产杉木制作便当盒。</p><p>无涂料的杉木制便当盒有吸水功能，有利于保证食物不会腐坏。用这种便当盒，米饭会有淡淡的杉木香味。。</p><p>木制便当盒不适合用微波炉加热。另外，木制便当盒的密封性不如塑料或金属便当盒，处理菜肴时需留心，最好不要出水，以免弄脏包里的其他东西。另外，不要放颜色太深的菜肴，以免盒子内壁染色。如用到颜色较深的酱料，建议用塑料便当盒，如果要用木制便当盒，可以先铺上烘焙纸或铝箔再放菜肴。</p><p>木制便当盒容易吸收食物的味道，用餐之后最好先用冷水洗一洗再收起来。如果白天忘了洗，晚上回家先用50℃左右的温水泡一下，再用海绵洗净。洗完便当盒，先开口朝下放一会，以免盒子里有水分残留。过一会儿把开口朝上，晾到早上做便当时即可。</p><h3 id="踏青"><a href="#踏青" class="headerlink" title="踏青"></a>踏青</h3><p>采摘艾蒿，要选嫩叶。选上面色泽鲜绿的小片嫩叶，避开下面已经长大的叶子。新摘的艾蒿叶气味清新，正面呈青绿色，反面则是白色。</p><h2 id="什锦散寿司-女儿节定番的美丽与哀愁"><a href="#什锦散寿司-女儿节定番的美丽与哀愁" class="headerlink" title="什锦散寿司 | 女儿节定番的美丽与哀愁"></a>什锦散寿司 | 女儿节定番的美丽与哀愁</h2><h3 id="什锦散寿司"><a href="#什锦散寿司" class="headerlink" title="什锦散寿司"></a>什锦散寿司</h3><p>所需时间：40分钟</p><p>份量：2人份</p><ul><li><p>什锦散寿司材料</p><p>白米饭、冬笋（水煮，真空包装）、虾仁、鸡蛋、油菜花、海苔（用剪刀剪成丝）、白芝麻、白醋、白糖、盐、料酒、生抽、植物油（做蛋皮用）、青芥末（按个人口味）</p></li></ul><p>制作步骤</p><p>日本三月份的节令食俗，是女儿节的寿司。其实女儿节和寿司并没有直接关联，但色彩缤纷的什锦散寿司、手鞠寿司、手卷寿司等让人心情愉悦，亦有春日气息，所以不少家庭在三月过节时都会准备。</p><p>蛋皮丝（常备菜）：可冷藏保存，提前一天做好放入冰箱即可。或把蛋皮冷冻保存，早上做便当的时候取出来，半解冻状态时切丝。</p><ol><li><p>做寿司饭</p><p>准备寿司饭调料。将白醋（2.5汤匙）、白糖（1汤匙）和盐（少许）搅拌备用。白米饭趁热放在碗里，加入调料后静置10秒，再用勺子混合。同时用扇子给米饭扇风，以便水分快速蒸发，使米粒色泽更加亮白。</p></li><li><p>准备虾仁</p><p>虾仁去虾线，加少量淀粉去腥后洗净。平底锅加热，用少量饮用水和料酒煮3分钟，用盐调味。</p></li><li><p>冬笋调味</p><p>冬笋切片，放入锅中，用料酒、白糖和生抽调味。</p></li><li><p>准备蛋皮丝、油菜花</p><p>蛋皮切丝备用。油菜花的处理方式参见“夏日便当” &gt; “鲑鱼饭团便当”</p></li><li><p>装盒</p><p>寿司饭放入便当盒（一半高度），撒白芝麻和海苔丝，再铺满蛋皮丝，继续放入虾仁、冬笋和油菜花即可。按个人口味在便当盒角落加青芥末（少许）。带一小瓶生抽，食用时撒一点在寿司上。</p></li></ol><h3 id="便当小贴士：文蛤清汤"><a href="#便当小贴士：文蛤清汤" class="headerlink" title="便当小贴士：文蛤清汤"></a>便当小贴士：文蛤清汤</h3><p>文蛤清汤是“潮汁”的一种。潮汁是用海鲜做成的清汤，据说继承了渔夫料理的风格，单凭海鲜的鲜味取胜。虽说潮汁可以加入鲷鱼、蚬等各种海鲜，但女儿节的定番（经典搭配）一定是什锦散寿司加文蛤清汤。</p><p>所需时间：30分钟</p><p>份量：2人份</p><ul><li><p>文蛤清汤材料</p><p>文蛤、昆布（或海带，约10厘米见方）、盐、料酒（可用黄酒代替）</p></li></ul><p>制作步骤</p><p>文蛤煮太久会变硬，开口后取出为佳。另，文蛤本身有些咸味，加盐需适中。</p><ol><li><p>处理文蛤</p><p>准备大碗，加清水和盐（适量），制成浓度为1.5%-2%的盐水。将文蛤（6-8个）放入盐水中让它们吐沙，之后用刷子清理。</p></li><li><p>加热</p><p>将昆布、文蛤和清水同时放入锅里，文火慢煮。火候控制在5-6分钟后煮沸的程度，以便充分释出文蛤和昆布的鲜味。等文蛤开口后，将文蛤和昆布取出，放入小碗里备用。</p></li><li><p>调味</p><p>汤汁取出浮沫，加入料酒（1-2汤匙）。按个人口味加盐调味后盛入碗中。可加水煮的芥菜花点缀。</p></li></ol><h3 id="女儿节定番的美丽与哀愁"><a href="#女儿节定番的美丽与哀愁" class="headerlink" title="女儿节定番的美丽与哀愁"></a>女儿节定番的美丽与哀愁</h3><p>时至今日，每逢三月女儿节，父母还会为女儿准备色泽鲜艳的什锦散寿司和文蛤清汤。女儿的汤碗里会放上成对的文蛤，而且每扇贝壳上都有一块蛤肉。</p><h2 id="玉子烧便当-毕业写真"><a href="#玉子烧便当-毕业写真" class="headerlink" title="玉子烧便当 | 毕业写真"></a>玉子烧便当 | 毕业写真</h2><h3 id="玉子烧便当"><a href="#玉子烧便当" class="headerlink" title="玉子烧便当"></a>玉子烧便当</h3><p>所需时间：20分钟</p><p>份量：2人份</p><ul><li><p>玉子烧材料</p><p>鸡蛋、白糖、盐、植物油</p></li><li><p>日式凉拌菠菜材料</p><p>菠菜、柴鱼片、生抽、芝麻油</p></li><li><p>简易版日式豆泡材料</p><p>豆泡、鲜香菇、白糖、干贝素、生抽、料酒</p></li></ul><p>制作步骤</p><p>玉子烧：做玉子烧可用平底锅或玉子烧专用方形平底锅。不管是哪一种，初学者可选特氟龙涂层的不粘锅。</p><p>日式凉拌菠菜（常备菜）：菠菜在冰箱里能存放一两天，可事先准备，一并调味即可。放柴鱼片一方面是增加风味，另一方面是吸收菠菜水分，防止出水。</p><p>日式豆泡煮物（常备菜）：做好可在冰箱里存放两三天。</p><ol><li><p>做蛋液</p><p>打鸡蛋（3个），在蛋液中放入白糖（1汤匙）和盐（少许）打匀。还可按个人喜好放料酒（少许）。蛋液不用打太均匀，可保留蛋黄和蛋白两种颜色，以便口感更松软。</p></li><li><p>做玉子烧</p><p>开中火，往锅里倒植物油（少许）加热，倒入三分之一蛋液，蛋液上层开始凝固后，将蛋皮折回三分之一，再从另一边折三分之一，方形平底锅三分之一大小的玉子烧就基本成形了。</p></li><li><p>成形玉子烧</p><p>往锅中空出的部分加植物油（少许），加入剩下蛋液的二分之一继续加热，这时要轻晃锅子，在做好的小块蛋皮下也加入蛋液。蛋液上层开始凝固后，以小块蛋皮为中心做成大一点的玉子烧。最后将剩下的蛋液全部倒入，重复上述动作。做好的玉子烧放在厨房纸巾上，自然冷却。</p></li><li><p>做凉拌菠菜</p><p>菠菜（1把）去老叶后洗净，大锅里煮开水，加芝麻油（3-4滴）并烫菠菜。先放入根部烫30秒，随后放入叶部再烫30秒，捞起并冷却。用手控干水分，切成段，用生抽调味后拌入柴鱼片（1撮，约3克）即可。</p></li><li><p>煮豆泡和香菇</p><p>香菇用干净的布块擦净后切片备用。小锅里煮开水，放入豆泡（约12颗）过水，以便去除多余的油味。另起锅开中火，加入料酒（1汤匙）、白糖（1汤匙），将豆泡和香菇煮透后放干贝素和生抽（各少许）调味。</p></li></ol><h3 id="便当小贴士：玉子烧为什么加糖？"><a href="#便当小贴士：玉子烧为什么加糖？" class="headerlink" title="便当小贴士：玉子烧为什么加糖？"></a>便当小贴士：玉子烧为什么加糖？</h3><p>玉子烧里加糖，在日本算是关东地区的做法。而关西地区的玉子烧是咸的，蛋液里回家少许“出汁”（日式高汤），口感比关东的玉子烧更柔软些。</p><p>可以尝试一种中日结合的玉子烧：加了咸蛋的玉子烧。打鸡蛋时加少许切碎的咸蛋，蛋黄、蛋白都可以，大概三个鸡蛋里加半个咸蛋即可。不加糖也不加盐。口感比加了糖的普通玉子烧稍硬一些，但味道浓郁。</p><h3 id="毕业写真"><a href="#毕业写真" class="headerlink" title="毕业写真"></a>毕业写真</h3><p>其实玉子烧便当不必加这么多小菜，就白米饭和玉子烧，再加上冰箱里的咸菜即可。</p><h2 id="面包“耳朵”法式吐司-夜晚的鸟声，山中的路"><a href="#面包“耳朵”法式吐司-夜晚的鸟声，山中的路" class="headerlink" title="面包“耳朵”法式吐司 | 夜晚的鸟声，山中的路"></a>面包“耳朵”法式吐司 | 夜晚的鸟声，山中的路</h2><h3 id="面包“耳朵”法式吐司"><a href="#面包“耳朵”法式吐司" class="headerlink" title="面包“耳朵”法式吐司"></a>面包“耳朵”法式吐司</h3><p>所需时间：40分钟</p><p>份量：2人份</p><ul><li><p>面包“耳朵”法式吐司材料</p><p>面包边、鸡蛋、牛奶、白糖、肉桂粉、黄油、糖霜（或蜂蜜）、香草精（按个人口味）</p></li></ul><p>制作步骤</p><ol><li><p>铺面包“耳朵”</p><p>平底锅里涂上黄油，然后将面包边（约20条）铺在平底锅里，建议由外侧向内侧铺。</p></li><li><p>做蛋液</p><p>将鸡蛋（1个）打匀，加牛奶（100毫升）、白糖（1汤匙），按个人口味加几滴香草精，充分混合至顺滑。</p></li><li><p>浇上蛋液</p><p>蛋液需在面包边上浇均匀，以便在平底锅里均匀受热。</p></li><li><p>加热</p><p>开中火，约2分钟后翻面，煎至两面变成金黄色即可。</p></li><li><p>撒上糖霜</p><p>撒上糖霜（或淋上蜂蜜）和肉桂粉，用刀切小片享用。</p></li></ol><h3 id="便当小贴士：在日坛公园的日子"><a href="#便当小贴士：在日坛公园的日子" class="headerlink" title="便当小贴士：在日坛公园的日子"></a>便当小贴士：在日坛公园的日子</h3><p>夹在三明治里的蔬菜，以水分较少的为佳，以保持面包松软的口感。夹蔬菜时，把水分较多的放在中间，最好不要与面包直接接触。</p><p>可以用炒胡萝卜、起司和火腿片、四季豆。加番茄酱、盐调味。</p><h3 id="夜晚的鸟声，山中的路"><a href="#夜晚的鸟声，山中的路" class="headerlink" title="夜晚的鸟声，山中的路"></a>夜晚的鸟声，山中的路</h3><p>这道甜品的名字，叫“法式吐司”。做法并不复杂，把吐司片或切片的法棍面包浸在加了牛奶和白糖的蛋液里，等面包吸收了蛋液后，用平底锅煎，然后浇上蜂蜜。</p><p>它在法国本地叫“pain perdu”（失落的面包），意指不够新鲜的面包因奶蛋汁而被重新赋予了新生命。</p><p>我现在给自己做的法式吐司比原版更朴素，用的不是吐司也不是变硬了的法棍，而是做完三明治后剩下的面包边（日语叫面包的耳朵）。用面包耳朵做的也很接近法式吐司原本的意思。</p><h2 id="味噌炸猪排便当-高中最后的便当"><a href="#味噌炸猪排便当-高中最后的便当" class="headerlink" title="味噌炸猪排便当 | 高中最后的便当"></a>味噌炸猪排便当 | 高中最后的便当</h2><h3 id="味噌炸猪排便当"><a href="#味噌炸猪排便当" class="headerlink" title="味噌炸猪排便当"></a>味噌炸猪排便当</h3><p>所需时间：60分钟</p><p>份量：2人份</p><ul><li><p>炸猪排材料</p><p>猪里脊、卷心菜、鸡蛋、面包糠、低筋面粉、黑胡椒、盐、植物油</p></li><li><p>味噌风味蘸酱材料</p><p>味噌（普通味噌即可，但最好是偏甜的“八丁味噌”）、黄糖、料酒、白芝麻（按个人口味）</p></li></ul><p>制作步骤</p><p>炸猪排用蘸酱，一般用伍斯特沙司（别称“辣酱油”，蔬果汁里加盐、糖、醋、香料煮成），而这里介绍的味噌风味蘸酱在以名古屋为中心的日本中部较为常见。</p><p>配菜可以用水煮芋头、水煮胡萝卜和凉拌油菜花，也可以用其他常备菜，如凉拌菠菜、炒胡萝卜等。</p><p>炸猪排可以做成盖浇饭，具体参见本篇“便当小贴士”。</p><ol><li><p>准备卷心菜</p><p>卷心菜（约2片）洗净后，把硬梗切掉后切丝。切好的卷心菜丝浸在冰水中1分钟，使口感更加爽脆，随后沥干水分备用。</p></li><li><p>处理猪排</p><p>猪排受热后，肥肉部分的收缩幅度比瘦肉大，为避免猪排变形，用刀将肥肉和瘦肉相接处划切几下，随后用刀背拍松猪排。两面撒上点盐和黑胡椒备用。</p></li><li><p>准备炸猪排</p><p>准备三个盘子：低筋面粉（3汤匙）、蛋液（1个鸡蛋）和面包糠（1小杯，约200毫升）。首先将猪排两面裹上面粉，多余的面粉轻轻拍掉、拂去。接下来猪排两面裹上蛋液，然后轻轻抖掉多余的蛋液。因为面包糠比较容易脱落，用手指轻轻压住猪排，使其表面均匀地裹上一层面包糠。</p></li><li><p>炸制猪排</p><p>在平底锅里倒入植物油（约1-2厘米高）。油温升至170℃（木筷放入油里，筷子周围有气泡快速浮起时的油温），将猪排轻轻放入锅里。放入后约30秒不能用筷子去碰，以免面包糠脱落。两面各炸制约3分钟，面包糠呈金黄色，油里的气泡变小后捞出。炸好的猪排放在铺上厨房纸巾的盘子里备用。（最好让猪排立在网架上，可让猪排外层更加酥脆。）</p></li><li><p>做炸猪排味噌酱</p><p>味噌（50克）、黄糖和料酒（各2汤匙）一并放入小碗里搅拌，用微波炉或小锅加热2分钟，直到呈现像蛋黄酱般的黏度。按个人口味加白芝麻，浇在切好的炸猪排上。</p></li><li><p>处理剩下的油</p><p>炸完猪排的植物油，等油温降低后，可用咖啡滤纸过滤，倒入玻璃杯，用保鲜膜盖上保存，继续用来炒菜。不过这些油因高温加热过，会氧化，不宜长期保存（一周内用完）。</p></li></ol><h3 id="便当小贴士：剩下的炸猪排可以做些什么？"><a href="#便当小贴士：剩下的炸猪排可以做些什么？" class="headerlink" title="便当小贴士：剩下的炸猪排可以做些什么？"></a>便当小贴士：剩下的炸猪排可以做些什么？</h3><p>炸猪排可以多做几块，第二天再做成盖浇饭。</p><p>炸猪排盖浇饭：</p><p>所需时间：15分钟</p><p>份量：2人份</p><ul><li><p>炸猪排盖浇饭材料</p><p>炸猪排、白米饭、洋葱、白糖、生抽、料酒、木鱼精、鸭儿芹（或香菜、豌豆仁）、七味粉（按个人口味）</p></li></ul><p>制作步骤</p><ol><li><p>准备鸭儿芹</p><p>鸭儿芹洗净切小段后碑额用。</p></li><li><p>煮洋葱</p><p>洋葱（半个）切薄片。小锅里加饮用水（100毫升）、木鱼精（半汤匙）、料酒（2汤匙）、白糖和生抽（各1汤匙）。开中火，煮开后调小火，放入洋葱加热1分钟。</p></li><li><p>加热炸猪排</p><p>洋葱变软后往锅里放入切条的炸猪排（1-2块），翻面后倒入蛋液（2个鸡蛋）。盖上盖子，继续加热10秒后关火。打开盖子放入鸭儿芹，浇在碗里的米饭上。按个人口味撒点七味粉。</p></li></ol><blockquote><p>经典的炸猪排是浇伍斯特沙司，底下铺着大量的卷心菜丝，再配上柠檬、番茄和黄瓜片。当然也少不了热乎乎的白米饭和味噌汤。</p></blockquote><h3 id="高中最后的便当"><a href="#高中最后的便当" class="headerlink" title="高中最后的便当"></a>高中最后的便当</h3><p>日本高考简单来说有两道门槛，一是统一考试，二是大学个别考试。统一考试是在高三第三学期（1-3月）伊始，那之后按照考试结果，报考国立大学的个别入学考试（简称入试）。</p><blockquote><p>和国立大学的考试流程相比，私立大学的“入试”比较多样化，时间一般集中在1-2月。有的私立大学不要求考生提交统一考试的成绩。</p></blockquote><p>入试那天是需要自己解决午餐的。子啊日本，炸猪排叫ton-katsu，后两个音同日文的胜利，所以不少日本应考生家庭会在考试前一晚吃炸猪排，或炸猪排盖饭。</p>]]></content>
    
    
    <categories>
      
      <category>book notes</category>
      
      <category>四季便当</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>福格行为模型笔记</title>
    <link href="/posts/e556f760.html"/>
    <url>/posts/e556f760.html</url>
    
    <content type="html"><![CDATA[<h1 id="行为设计的价值"><a href="#行为设计的价值" class="headerlink" title="行为设计的价值"></a>行为设计的价值</h1><p>设计出成功的习惯并改变自身行为，需要做的事：</p><ul><li>停止自我批评；</li><li>把愿望拆解为微行为；</li><li>将每一次错误当成是新发现，并利用它们不断改进。</li></ul><p>福格行为模型能够帮助摆脱改变带来的焦虑，更重要的是，无论现在的你和理想的你之间有多大的差距，它都能帮助你以一种轻松愉快的方式跨越这个差距。</p><p>从小改变着手的5个原因：</p><ol><li>可以利用碎片时间</li><li>可以立即开始改变</li><li>不需要担心会失败</li><li>一样能吃掉“大鲸鱼”</li><li>不需要依赖动机或意志力也能做到</li></ol><p>人在感觉良好而非感觉难过的状态下改变，效果最佳。</p><p>本书讲到的最深刻的改变不是那些零散习惯的形成，而是体验的本质改变：从痛苦到较少的痛苦，从恐惧到希望，从不知所措到充满力量。</p><h2 id="ABC三步骤"><a href="#ABC三步骤" class="headerlink" title="ABC三步骤"></a>ABC三步骤</h2><h3 id="A-Anchor-锚点时刻"><a href="#A-Anchor-锚点时刻" class="headerlink" title="A: Anchor 锚点时刻"></a>A: Anchor 锚点时刻</h3><p>提醒你去执行新的微行为的关键时点。例如，某个日常习惯（如刷牙）或某件必然发生的事情（如电话铃声响起）。</p><h3 id="B-Behavior-新的微行为"><a href="#B-Behavior-新的微行为" class="headerlink" title="B: Behavior 新的微行为"></a>B: Behavior 新的微行为</h3><p>锚点出现后立即去执行的微行为。这是新习惯的简化版，比如用牙线清洁一颗牙齿或做两个俯卧撑。</p><h3 id="C-Celebration-即时庆祝"><a href="#C-Celebration-即时庆祝" class="headerlink" title="C: Celebration 即时庆祝"></a>C: Celebration 即时庆祝</h3><p>完成新的微行为后要立刻庆祝。任何能带来积极情绪的事情都可以，比如说出“我很棒”之类的话。</p><h1 id="福格行为模型，影响行为的要素只有3个"><a href="#福格行为模型，影响行为的要素只有3个" class="headerlink" title="福格行为模型，影响行为的要素只有3个"></a>福格行为模型，影响行为的要素只有3个</h1><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">B = MAP<br>行为<span class="hljs-comment">(Behavior)</span> 发生于 动机<span class="hljs-comment">(Motivation)</span> &amp; 能力<span class="hljs-comment">(Ability)</span> &amp; 提示<span class="hljs-comment">(Prompt)</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/08/03/3afY7xIFuK2hGDp.png" alt="image-20240803195526755"></p><ul><li><p>既有动机又有能力，才能让行为落到行动线上方</p><blockquote><p>动机较弱时，可以降低难度（提高能力）</p><p>不断重复一种行为，会让它变得更容易做到</p></blockquote></li><li><p>没有提示，任何行为都不会发生</p></li></ul><h2 id="解决行为问题的３个步骤"><a href="#解决行为问题的３个步骤" class="headerlink" title="解决行为问题的３个步骤"></a>解决行为问题的３个步骤</h2><ol><li>检查有没有行为<strong>提示</strong>。</li><li>检查有没有行为<strong>能力</strong>。</li><li>检查有没有行为<strong>动机</strong>。</li></ol><h2 id="练习：实践福格行为模型"><a href="#练习：实践福格行为模型" class="headerlink" title="练习：实践福格行为模型"></a>练习：实践福格行为模型</h2><h3 id="探索终止习惯的方法"><a href="#探索终止习惯的方法" class="headerlink" title="探索终止习惯的方法"></a>探索终止习惯的方法</h3><ol><li>写下3个想要终止的习惯。尽量写得具体些，比如，“终止午餐时买汽水”，而不是“终止喝汽水”。</li><li>对每一个习惯，想出3种可以消除（或避免）提示的方法。</li><li>对每一个习惯，思考可以增加难度（削弱能力）的方法。</li><li>对每一个习惯，思考可以削弱动机的方法。</li><li>从步骤2-4中选出最佳解决方案。</li></ol><h1 id="要素1，动机，找到实现愿望的黄金行为"><a href="#要素1，动机，找到实现愿望的黄金行为" class="headerlink" title="要素1，动机，找到实现愿望的黄金行为"></a>要素1，动机，找到实现愿望的黄金行为</h1><h2 id="明明有动机却还是无法改变的5个原因"><a href="#明明有动机却还是无法改变的5个原因" class="headerlink" title="明明有动机却还是无法改变的5个原因"></a>明明有动机却还是无法改变的5个原因</h2><ol><li>动机很复杂<ul><li>可能有相互冲突的动机</li><li>不清楚动机的来源</li></ul></li><li>动机冲上顶峰后会迅速回落<ul><li>动机高涨时，可以做更难的行为</li></ul></li><li>动机波动十分频繁<ul><li>不过，一般来说，一天之中意志力一直在减弱</li></ul></li><li>将动机用于追逐抽象概念无法产生结果<ul><li>有动机，但不知道怎么做</li></ul></li><li>仅凭动机无法实现长期改变<ul><li>福格行为模型3要素中，动机是最不可预测、最不可靠的</li></ul></li></ol><h2 id="练习：找到黄金行为"><a href="#练习：找到黄金行为" class="headerlink" title="练习：找到黄金行为"></a>练习：找到黄金行为</h2><h3 id="通过焦点地图找到黄金行为"><a href="#通过焦点地图找到黄金行为" class="headerlink" title="通过焦点地图找到黄金行为"></a>通过焦点地图找到黄金行为</h3><ol><li>拿一张纸，在纸上画一朵云。</li><li>在云朵中间写下愿望“改善睡眠质量”。</li><li>找出10种以上能帮助改善睡眠质量的行为。把这些行为写在云朵外面的行为框中，再画上箭头，从这些行为指向云朵。行为集群就创建好了。</li><li>把这10中行为分别写到不同的卡片或小纸条上，这是绘制焦点地图的第一步。</li><li>将这些行为卡分类，根据影响度摆放。此时不考虑可行性，先聚焦在这些行为可能造成的影响上。</li><li>沿着可行性维度移动这些行为卡。现实点：你真的能让自己去做这些行为吗？</li><li>查看右上方区域，它们就是你的黄金行为。（如果这里空空如也，返回步骤3 ，重新开始。）</li><li>通过设计，让黄金行为融入生活。</li></ol><blockquote><p>无需焦点地图的简化版本：</p><ol><li>找出4-5个认为<strong>能有效实现愿望</strong>的行为，在它们边上标记星星。</li><li>圈出<strong>能够轻松完成</strong>的所有可执行行为。</li><li>找出同时标记星星和圆圈的行为，它们就是你的黄金行为。</li></ol></blockquote><h1 id="要素2，能力，让行为简单到随时顺便都能做"><a href="#要素2，能力，让行为简单到随时顺便都能做" class="headerlink" title="要素2，能力，让行为简单到随时顺便都能做"></a>要素2，能力，让行为简单到随时顺便都能做</h1><p>小的改变也许没那么吸引人，但它是一种可持续的成功。在人们想做出的大多数人生改变中，有时采取小行为也许会比大胆的行为更有效。对任何事都抱有不做大事就干脆放弃的想法，只会让你苛责自己、充满失望。</p><h2 id="分析阶段：一开始就问自己，是什么让这个行为难以做到？"><a href="#分析阶段：一开始就问自己，是什么让这个行为难以做到？" class="headerlink" title="分析阶段：一开始就问自己，是什么让这个行为难以做到？"></a>分析阶段：一开始就问自己，是什么让这个行为难以做到？</h2><h3 id="能力因素："><a href="#能力因素：" class="headerlink" title="能力因素："></a>能力因素：</h3><ol><li>你是否有足够的<strong>时间</strong>？</li><li>你是否有足够的<strong>资金</strong>？</li><li>你是否有足够的<strong>体力</strong>？</li><li>这个行为是否需要许多创意或<strong>脑力</strong>？</li><li>这个行为符合你现在的<strong>日程</strong>吗？还是需要做出调整？</li></ol><h3 id="能力链："><a href="#能力链：" class="headerlink" title="能力链："></a>能力链：</h3><p><code>时间-资金-体力-脑力-日程</code></p><p>需要<strong>识别能力链的薄弱环节</strong>，然后集中精力解决问题。当将能力链中的薄弱环节<strong>加固</strong>之后，就能重复做到这件事了。</p><h2 id="设计阶段：实现“容易做”的3种方式"><a href="#设计阶段：实现“容易做”的3种方式" class="headerlink" title="设计阶段：实现“容易做”的3种方式"></a>设计阶段：实现“容易做”的3种方式</h2><h3 id="1-提升技能"><a href="#1-提升技能" class="headerlink" title="1. 提升技能"></a>1. 提升技能</h3><p>聘请教练、在网上搜索教程…</p><h3 id="2-获取工具和资源"><a href="#2-获取工具和资源" class="headerlink" title="2. 获取工具和资源"></a>2. 获取工具和资源</h3><p>买一双舒适的运动鞋、买一套好用的厨房刀具…</p><h3 id="3-让行为变得微小"><a href="#3-让行为变得微小" class="headerlink" title="3. 让行为变得微小"></a>3. 让行为变得微小</h3><h4 id="入门步骤"><a href="#入门步骤" class="headerlink" title="入门步骤"></a>入门步骤</h4><p>如想要培养每天健走1000米的习惯，入门步骤即穿上运动鞋。</p><blockquote><p>穿上运动鞋之后，就会自然地出门走一走。</p></blockquote><p>不要过早地提高标准。不要急着做出更大的行为。把标准定低一些，有助于坚持下去。</p><h4 id="缩小规模"><a href="#缩小规模" class="headerlink" title="缩小规模"></a>缩小规模</h4><p>如想要培养每天健走1000米的习惯，那首先缩小行为，比如走到家楼下，无需更远。</p><p><img src="https://s2.loli.net/2024/08/03/DAf8gdS95UCcZki.png" alt="202408032146013.png"></p><h2 id="练习：让行为容易做"><a href="#练习：让行为容易做" class="headerlink" title="练习：让行为容易做"></a>练习：让行为容易做</h2><h3 id="练习1：对困难习惯进行分析"><a href="#练习1：对困难习惯进行分析" class="headerlink" title="练习1：对困难习惯进行分析"></a>练习1：对困难习惯进行分析</h3><ol><li>写下一个过去尝试养成却没能坚持下来的困难习惯。如果你没有任何想法，那可以分析这个习惯：每天多吃蔬菜。</li><li>问自己探索型问题：“是什么让这个行为难以做到？”围绕你能力链的薄弱环节进行思考，是因为养成习惯对时间要求太高，还是对资金要求太高了？是对体力或脑力要求太高，还是因为它扰乱了你的日程？</li></ol><h3 id="练习2：通过设计，让习惯容易培养"><a href="#练习2：通过设计，让习惯容易培养" class="headerlink" title="练习2：通过设计，让习惯容易培养"></a>练习2：通过设计，让习惯容易培养</h3><ol start="3"><li>针对能力链上的薄弱环节，问自己突破型问题：“怎样才能让它变得更容易执行？”例如，或许可以考虑减少时<br>间。但注意要确保针对每个薄弱环节都提出多个不同想法。</li><li>从步骤3的想法中挑选出3个最可行的。</li><li>想象自己按照这3个想法采取行动，试图让习惯变得更容易执行。注意探索具体操作方式的细节。</li></ol><h1 id="要素3，提示，善用锚点时刻让行为立刻发生"><a href="#要素3，提示，善用锚点时刻让行为立刻发生" class="headerlink" title="要素3，提示，善用锚点时刻让行为立刻发生"></a>要素3，提示，善用锚点时刻让行为立刻发生</h1><h2 id="生活中常见的3类提示"><a href="#生活中常见的3类提示" class="headerlink" title="生活中常见的3类提示"></a>生活中常见的3类提示</h2><h3 id="1-人物提示"><a href="#1-人物提示" class="headerlink" title="1. 人物提示"></a>1. 人物提示</h3><p>通过自己或他人的提醒采取行动。这类提示依靠的是你的内在去完成行为。</p><p>人类的记忆是不够可靠的，容易忘记。</p><h3 id="2-情境提示"><a href="#2-情境提示" class="headerlink" title="2. 情境提示"></a>2. 情境提示</h3><p>通过周围环境中的某些事物来提示行动。如：便利贴、App通知、电话铃声。</p><p>有效设计情境提示是一种技能，需要多加练习。</p><p>不过，这类提示最适合单次行为，要用于培养习惯的话，这个方法不是最佳选择。</p><h3 id="3-行动提示（锚点）"><a href="#3-行动提示（锚点）" class="headerlink" title="3. 行动提示（锚点）"></a>3. 行动提示（锚点）</h3><p>行动提示是将你已经在做的行为当作提示，以此来提醒你为培养新习惯采取必要的行动。行动提示是一种将微习惯和行为结合起来的方式。例如，打开咖啡机就可以作为做伸展运动这个新习惯的提示。</p><h2 id="设计“对”的提示的3个步骤"><a href="#设计“对”的提示的3个步骤" class="headerlink" title="设计“对”的提示的3个步骤"></a>设计“对”的提示的3个步骤</h2><h3 id="1-确定你的锚点"><a href="#1-确定你的锚点" class="headerlink" title="1. 确定你的锚点"></a>1. 确定你的锚点</h3><p>锚点必须是生活中一定会发生的事情。</p><ol><li><strong>匹配物理位置。</strong>首先要考虑新习惯发生的地点，找出已经存在于那个地点的锚点行为。比如培养写博客的行为，应该在电脑桌前寻找既有日程作为锚点。</li><li><strong>匹配频率。</strong>检视既有日程时，要考虑多久进行一次新习惯，频率需要匹配。</li><li><strong>匹配主题&#x2F;目的。</strong>可以选择与新习惯拥有相同主题或目的的锚点行为。如果喝咖啡时为了提升工作效率，那它很适合用来作为打开待办事项App的锚点行为。</li></ol><h3 id="2-用试验将锚点与黄金行为联系起来"><a href="#2-用试验将锚点与黄金行为联系起来" class="headerlink" title="2. 用试验将锚点与黄金行为联系起来"></a>2. 用试验将锚点与黄金行为联系起来</h3><p>ABC三步骤。</p><p>在最初几天或几星期的试验中，新习惯可能会发生一些改变，这是好事，意味着你正在磨练技能，正在掌握将锚点与微行为匹配起来的能力。</p><h3 id="3-利用“最后动作”优化锚点"><a href="#3-利用“最后动作”优化锚点" class="headerlink" title="3. 利用“最后动作”优化锚点"></a>3. 利用“最后动作”优化锚点</h3><p>从日程中挑选一个精确事件作为锚点至关重要。需要找到一个最精确的时刻——即锚点行为的最后一个动作。如：上厕所不是最后动作，冲厕所才是；吃完早饭不是最后动作，洗碗之后关掉水龙头才是。</p><h2 id="为自己设计“顺便习惯”"><a href="#为自己设计“顺便习惯”" class="headerlink" title="为自己设计“顺便习惯”"></a>为自己设计“顺便习惯”</h2><p>碎片时间人人都有：等红灯的时间，在杂货店排队的时间，浇花时间。与其在这些时间烦恼或者胡思乱想，不如将它们作为锚点时刻，来培养新习惯。</p><blockquote><p>比如，中午在餐厅排队和吃饭的时候，可以培养阅读RSS订阅文章的习惯。</p></blockquote><h2 id="“珍珠”习惯，管理压力与焦虑"><a href="#“珍珠”习惯，管理压力与焦虑" class="headerlink" title="“珍珠”习惯，管理压力与焦虑"></a>“珍珠”习惯，管理压力与焦虑</h2><p>珍珠习惯的本质是将原本惹人厌烦的事情，转化成美好的提示。</p><p>比如：在我感到受到冒犯的时候，我会考虑去做一些能取悦自己的事情。</p><h2 id="练习：为用户设计“定制化”提示"><a href="#练习：为用户设计“定制化”提示" class="headerlink" title="练习：为用户设计“定制化”提示"></a>练习：为用户设计“定制化”提示</h2><h3 id="练习1：对困难习惯的分析"><a href="#练习1：对困难习惯的分析" class="headerlink" title="练习1：对困难习惯的分析"></a>练习1：对困难习惯的分析</h3><p>你每天都会做的习惯（或日程）清单是非常宝贵的资源。你可以从清单上任选一个可靠的习惯，作为新习惯的提示，即锚点。</p><p>把一个完整的工作日按步骤拆解为不同的部分，这样有助于你将庞杂的习惯列为清单：</p><ol><li>列出每天早上你到公司之前的所有日常习惯。</li><li>列出你在午饭前的所有日常习惯。</li><li>列出你在中午时的所有日常习惯。</li><li>列出午后你的所有日常习惯（大多数人在下午可能没有几个可靠的习惯，不过这没关系）。</li><li>列出下班时你的所有日常习惯（或许你只有少数几个习惯，但它们可以成为新习惯的绝佳锚点）。</li><li>列出下班后你的所有日常习惯（包括在家里的那些习惯）。</li><li>列出上床睡觉前你的所有日常习惯。</li><li>保存这个清单，下一个练习会用到它。</li></ol><h3 id="练习2：基于既有习惯清单创建微习惯配方"><a href="#练习2：基于既有习惯清单创建微习惯配方" class="headerlink" title="练习2：基于既有习惯清单创建微习惯配方"></a>练习2：基于既有习惯清单创建微习惯配方</h3><p>培养新习惯有一种快速高效的方法，那就是先分析既有日常习惯，再找到可以插入其后的能自然发生的新习惯。在练习1中，你已经创建了一个庞杂的日常习惯清单，现在就要用到它了。</p><ol><li>从习惯清单中找出一个你绝对不会忘记的可靠习惯。</li><li>思考有什么新习惯可以很自然地跟在这个习惯后面发生，多想几个。</li><li>在步骤2的那些新习惯里挑出你最喜欢的那个，按照<strong>“在我……之后，我会……”</strong>的格式创建一个微习惯配方。</li><li>重复步骤1到步骤3，再挑出两个可靠习惯并再创建两个微习惯配方（同时实践3个习惯能收获更多）。</li><li>开始实践你的新习惯（别太严肃也别太紧张，放松点儿，尽情乐在其中吧）。</li></ol><h3 id="练习3：创建“珍珠习惯”，将不利变有利"><a href="#练习3：创建“珍珠习惯”，将不利变有利" class="headerlink" title="练习3：创建“珍珠习惯”，将不利变有利"></a>练习3：创建“珍珠习惯”，将不利变有利</h3><p>这个练习是为了在困局中将不利变有利。</p><ol><li>至少列出经常困扰你的10件事（排长队、摩托车的噪声、邻居家的狗狂吠等）。</li><li>选出清单上出现得最频繁、最烦人的事项。</li><li>探索在烦恼之后你可以做的新的、有益的习惯，提出至少5个选项。</li><li>在步骤3的结果里挑选出你的最佳选项，并为之创建一个微习惯配方。例如，在我发现自己必须排长队之后，我会练习单腿站立，然后再换条腿继续。</li><li>开始实践你的“珍珠习惯”（留意烦恼程度的变化）。</li></ol><h1 id="创造积极情绪，将行为固化成习惯"><a href="#创造积极情绪，将行为固化成习惯" class="headerlink" title="创造积极情绪，将行为固化成习惯"></a>创造积极情绪，将行为固化成习惯</h1><p>ABC中C(Celebration, 庆祝)的重要性。</p><p>一个人做出某种行为时的感受和他未来再重复该行为的概率，两者之间存在直接关联。</p><p>长期以来，人们一直相信“重复创造习惯”，执着于养成习惯所需要的行为重复天数。但其实只要人们能对一种行为产生强烈的积极情绪，通常用不了几天就能形成习惯。</p><p>为你的微小成功而庆祝。即使你觉得自己一时之间还无法摆脱困境，生活中的小小改变也能够产生巨大的影响力。庆祝可以成为你的救生绳。</p><h2 id="效果超强的庆祝方式"><a href="#效果超强的庆祝方式" class="headerlink" title="效果超强的庆祝方式"></a>效果超强的庆祝方式</h2><p>在大量的庆祝方式之中，需要保留至少一个效果超强的庆祝方式。对那些需要极迅速固定下来的习惯来说，强力的庆祝还是很重要的。</p><h2 id="需要庆祝的3个理由"><a href="#需要庆祝的3个理由" class="headerlink" title="需要庆祝的3个理由"></a>需要庆祝的3个理由</h2><h3 id="1-这就是行为系统的运转方式"><a href="#1-这就是行为系统的运转方式" class="headerlink" title="1. 这就是行为系统的运转方式"></a>1. 这就是行为系统的运转方式</h3><p>多巴胺是促使习惯固定下来的一个关键元素。</p><h3 id="2-庆祝是一种技巧"><a href="#2-庆祝是一种技巧" class="headerlink" title="2. 庆祝是一种技巧"></a>2. 庆祝是一种技巧</h3><p>相比于养成习惯要付出的代价，学会为自己庆祝要付出的努力不值一提。</p><h3 id="3-你正在做值得庆祝的事"><a href="#3-你正在做值得庆祝的事" class="headerlink" title="3. 你正在做值得庆祝的事"></a>3. 你正在做值得庆祝的事</h3><p>无论改变的程度或速度如何，能做出改变本身就是一件相当了不起的事。</p><p>在思考为什么要庆祝的时候，庆祝还能帮助你发现你所做的事情中更深层的意义。</p><h2 id="庆祝的3个时机"><a href="#庆祝的3个时机" class="headerlink" title="庆祝的3个时机"></a>庆祝的3个时机</h2><ol><li>你想起要执行新习惯的时刻</li><li>你正在执行新习惯的时刻</li><li>刚刚完成新习惯的时刻</li></ol><h2 id="练习：感受发光"><a href="#练习：感受发光" class="headerlink" title="练习：感受发光"></a>练习：感受发光</h2><h3 id="练习1：庆祝的不同方式"><a href="#练习1：庆祝的不同方式" class="headerlink" title="练习1：庆祝的不同方式"></a>练习1：庆祝的不同方式</h3><p>这个练习可以帮助你找到微成功的庆祝方法。试试这些选项，看有哪些是适合自己的。</p><h4 id="你喜爱的歌曲"><a href="#你喜爱的歌曲" class="headerlink" title="你喜爱的歌曲"></a>你喜爱的歌曲</h4><p>想一首能够让你感到快乐、成功和乐观的歌曲。哼唱几句歌词，以此来庆祝微成功。</p><h4 id="身体动作"><a href="#身体动作" class="headerlink" title="身体动作"></a>身体动作</h4><p>探索能让你感到快乐和成功的身体动作。这可能包括挥舞拳头、跳一小段舞，或者就点点头表示肯定。找到能帮助你感觉发光的身体动作，练习将它用于固化习惯。</p><h4 id="口头表达"><a href="#口头表达" class="headerlink" title="口头表达"></a>口头表达</h4><p>寻找可以让你感觉快乐和成功的短语。有些人会说：“哟嚯！”有些人会说：“真棒！”多探索一些选择，至少要找到一种可以让你感到发光的口头表达。</p><h4 id="声音效果"><a href="#声音效果" class="headerlink" title="声音效果"></a>声音效果</h4><p>寻找可以帮助你感受到积极情绪的声音，人群的欢呼声、嘹亮的小号声，或是老虎机中奖的声音。选一个你喜欢的声音，练习将它用于固化习惯。</p><h4 id="形象化"><a href="#形象化" class="headerlink" title="形象化"></a>形象化</h4><p>有些人会用想象力来创造发光的感觉。这可能比前4种方式更难以操作，但它更灵活，因为可以在任何地方开展，效果也更好。</p><p>花几分钟想象可以让自己感到高兴和成功的场景，孩子们的笑脸、与狗狗玩耍、最喜爱的海滩上温暖的沙子。列一个清单，任何适合你的场景都行。探索这些选择，从中找一个看似最容易想象也最有效的场景。就用这个形象化的方式来庆祝你的微成功吧！</p><h3 id="练习2：尝试“庆祝闪电战”"><a href="#练习2：尝试“庆祝闪电战”" class="headerlink" title="练习2：尝试“庆祝闪电战”"></a>练习2：尝试“庆祝闪电战”</h3><p>这个练习你一定要尝试一次，你可以把它纳入既有日程，它能带来额外的收获。</p><ol><li>找到家里或办公室里最不整洁的地方。</li><li>设定倒计时3分钟。</li><li>每完成一项清理工作之后，立刻为自己庆祝。</li><li>继续清理和庆祝。</li><li>3分钟结束后，停下来，专注于自己的感受。你的情绪发生了什么变化？你学到了什么？</li></ol><h3 id="练习3：提醒自己，成效最佳的改变源自感觉良好"><a href="#练习3：提醒自己，成效最佳的改变源自感觉良好" class="headerlink" title="练习3：提醒自己，成效最佳的改变源自感觉良好"></a>练习3：提醒自己，成效最佳的改变源自感觉良好</h3><p>我们在前面的章节介绍过这个练习。如果你之前没做，可以现在尝试一下。这个简单的练习可以帮助你记住，成效最佳的改变源自感觉良好，而非感觉糟糕。</p><ol><li>“我在感觉良好（而非感觉糟糕）的状态下进行改变，效果最佳”，将这句话写在一张小纸片上。</li><li>将纸片贴在浴室的镜子上，或其他你常看见的地方。</li><li>经常念这句话。</li><li>注意观察这句话对你和你身边人的生活产生的影响。</li></ol><h1 id="高频率小成功，让小改变自然生长"><a href="#高频率小成功，让小改变自然生长" class="headerlink" title="高频率小成功，让小改变自然生长"></a>高频率小成功，让小改变自然生长</h1><p>当人们感觉到成功时，即便只是做些小事，他们的整体动机水平也会大大提高，而有了更高的整体动机水平，人们就可以完成更困难的行为。这就是微成功改变你的工作、生活甚至思维方式的路径。记住：从你想要改变的地方开始，逐渐让自己感受到成功。接着你只需要相信这个过程，期待改变发生。</p><p>成功之前：</p><p><img src="https://s2.loli.net/2024/08/04/pb2AEyXDnIGrF87.png" alt="image-20240804122012491.png"></p><p>成功之后：</p><p><img src="https://s2.loli.net/2024/08/04/sUigVSo7qK6ZDRv.png" alt="image-20240804122030263.png"></p><h2 id="习惯的生长和繁殖"><a href="#习惯的生长和繁殖" class="headerlink" title="习惯的生长和繁殖"></a>习惯的生长和繁殖</h2><p>带着明确的愿望开启习惯设计过程，这样你会自然地形成专属于自己的生长类习惯与繁殖类习惯混合体。如果你的愿望之一是跑场马拉松，那么你很可能会设计出至少一种跟走路或跑步有关的习惯，那这就是生长类习惯。同时，你可能还会创建一些繁殖类习惯，比如多喝水，多吃新鲜蔬菜等。这些习惯可以自然繁殖，并生发出其他与加强营养有关的习惯。所有这些都能够推动你向着跑马拉松的愿望前进。</p><h3 id="习惯的生长"><a href="#习惯的生长" class="headerlink" title="习惯的生长"></a>习惯的生长</h3><p>习惯和植物一样，会按照自己的速度以不同的方式长大。练习俯卧撑的习惯或许会从2个发展到50个，但每个习惯最终的样子会因时间和个体的局限而有所不同。</p><h3 id="习惯的繁殖"><a href="#习惯的繁殖" class="headerlink" title="习惯的繁殖"></a>习惯的繁殖</h3><p>每天早上吃1个牛油果的习惯不会变成吃2个，但可能会衍生出晚饭后吃蓝莓或午餐吃芹菜的习惯。</p><h2 id="掌握技巧，变身“习惯忍者”"><a href="#掌握技巧，变身“习惯忍者”" class="headerlink" title="掌握技巧，变身“习惯忍者”"></a>掌握技巧，变身“习惯忍者”</h2><h3 id="技巧1：行为加工"><a href="#技巧1：行为加工" class="headerlink" title="技巧1：行为加工"></a>技巧1：行为加工</h3><p>如下是一些行为加工的指导方针：</p><ul><li>专注于你感兴趣的事物。有些人喜欢养成一些简单的小习惯，有些人则喜欢攻克更有挑战性的习惯。哪一种更有意思、更让你激动，那就是你应该做的事。如果你感觉有些迷惑，则可以使用默认设置：从养成3个超简单的习惯开始，然后每个月增加3个新习惯，这也是大多数习惯养成者的起步之选。</li><li>拥抱多样性。你一开始使用的技巧越多种多样，就能越快地学会改变的技巧。挑选一些入门步骤型的新习惯，比如穿上跑步鞋，接着再选一些缩小规模型的习惯，比如清洁牙齿。把与锻炼、饮食相关和工作方面的习惯混合起来去培养，也很不错。多样化的选择能够帮助你更快速地了解最适合自己的方法。</li><li>保持灵活性。如果你想创建一个理想的习惯清单，记住不要太拘泥于这个清单。你的喜好和需求是会变化的。或许今天你把每天练习倒立纳入了清单，但6星期后你或许又不关注这件事了。在前进的过程中要保持灵活性，并为学习新事物留出空间。</li></ul><h3 id="技巧2：自我洞察"><a href="#技巧2：自我洞察" class="headerlink" title="技巧2：自我洞察"></a>技巧2：自我洞察</h3><p>跟自我洞察相关的技巧：</p><ul><li>明确你的愿望或预期成果。</li><li>理解是什么激发了你的动机，也就是知晓你真正想要的和你认为你应该做的之间的区别。</li></ul><p>自我洞察的关键在于：知道哪些新习惯对你有意义。以下是可用于预测新习惯对你是否有意义的一些指南：</p><ul><li>新习惯能够助力你成为你想成为的人。如果你想成为一个充满爱心和懂得欣赏他人的人，那么，在丈夫做完饭之后说句“谢谢”的习惯就是有意义的，这也极有可能会促使你蜕变。</li><li>新习惯可以帮助你实现某个重要的愿望。如果从养成新习惯到实现愿望的路线很清晰，那么养成这个习惯就是有意义的。每天穿上跑步鞋的习惯看似微不足道，但如果你的愿望是每天跑步5千米，那么这个微习惯意义非凡。</li><li>新习惯虽然微小却能产生极大影响。每天打开燃气灶的习惯很小，但却触发了一系列变化，创造自己做饭的健康生活。</li></ul><p>关键在于要找到你可以做出的最小、最容易但意义却最大的改变。你可以通过回答一些问题来练习这项技巧：我能创建的最有意义且最微小的习惯是什么？写出的答案越多，技巧练习的效果就越好。熟练掌握这项技巧可以帮助你找到适合自己的且易于创建和维护的习惯。掌握技巧之后，你还能更好地识别那些对你来说没有意义的习惯，从而避免浪费时间。</p><p>通过练习自我洞察技巧，你能判断一个新习惯是否值得培养。如果值得，那很棒，这样你就有了全新的动机；如果不值得，那你就可以腾出空间来养成其他更重要的习惯。掌握此技巧可以让你将精力聚焦于促成更重要的改变。</p><h3 id="技巧3：循序渐进"><a href="#技巧3：循序渐进" class="headerlink" title="技巧3：循序渐进"></a>技巧3：循序渐进</h3><p>随着时间的流逝，你的习惯会改变，你会改变，你身边的世界也会改变。循序渐进技巧能帮助我们根据生活的动态变化进行调整，以此来发展和改善习惯。</p><p>这项新的技巧跟如何逐渐发展习惯直接相关，其关键在于：知道何时该推自己一把，超越微习惯，提升习惯难度。</p><p>在持续执行一个新习惯的过程中，你自然而然就会追求更多或难度更高的新习惯。那时候，你会找到舒适区的边界，并体会到略微打破边界的感觉。清楚自己的舒适区边界在哪里可以帮助你养成更复杂或难度更大的习惯，而不会因为感到力不从心的痛苦或沮丧而削弱习惯。</p><h3 id="技巧4：情境设计"><a href="#技巧4：情境设计" class="headerlink" title="技巧4：情境设计"></a>技巧4：情境设计</h3><p>情境设计技巧，其关键在于：重新设计情境使习惯更易于执行。</p><p>有两个问题可以帮助你改变环境，降低身边环境与你想养成的良好习惯之间的摩擦。</p><h4 id="第一个问题是：我如何才能让这个新习惯易于执行？"><a href="#第一个问题是：我如何才能让这个新习惯易于执行？" class="headerlink" title="第一个问题是：我如何才能让这个新习惯易于执行？"></a>第一个问题是：我如何才能让这个新习惯易于执行？</h4><p>现在我希望你专注于改善周遭的环境使之更利于习惯养成，而不是想着靠降低习惯的难度和规模来让习惯易于执行。</p><p>比如：从柜子里取出牙线，放在牙刷的旁边。对于固化清洁牙齿的习惯来说，这个小小的动作有着重大的意义。</p><h4 id="继续提问：是什么让习惯难以执行？"><a href="#继续提问：是什么让习惯难以执行？" class="headerlink" title="继续提问：是什么让习惯难以执行？"></a>继续提问：是什么让习惯难以执行？</h4><p>比如：有一天你没坚持吃黄瓜片是因为冰箱里找不到任何黄瓜，黄瓜不见了，你有了扭头去吃玉米片的绝佳理由。还有一天，你虽然找到了黄瓜，但它们还没洗过。你那天很累，也没有心情去清洗、切片，所以又吃了玉米片。</p><p>现在，想必你已经想到如何重新设计情境才能帮助你养成习惯了：</p><ul><li>养成在前一天晚上洗好黄瓜并且切片的习惯（持续的习惯）；</li><li>告诉家人不要动你的黄瓜（单次动作）；</li><li>确保冰箱够整洁，方便你能够立即找到黄瓜（每星期一次的习惯）。</li></ul><h4 id="如下是关于重新设计情境的一些指南："><a href="#如下是关于重新设计情境的一些指南：" class="headerlink" title="如下是关于重新设计情境的一些指南："></a>如下是关于重新设计情境的一些指南：</h4><ul><li>在设计新习惯时，也投入时间重新设计情境以便让习惯易于执行。</li><li>开始执行新习惯时，边执行边调整情境，并根据需要重新设计情境以便让习惯易于执行。</li><li>大胆质疑传统。没有人规定你必须把维生素片放在厨房里，把牙线放在卫生间里。也许把维生素片放在电脑旁或者将牙线放在电视遥控器旁对你养成清洁牙齿的习惯最有效呢？你是“习惯忍者”，不需要一味顺从规则，要找出对你有效的方式。</li><li>购买你所需要的装备。假设你希望每天骑行10千米去上学，风雨无阻，那么你可以依靠设计消除去激励因素，比如买些装备来减轻在风雨中骑行时的痛苦。</li></ul><blockquote><p>作者分享的具体的能帮助你健康饮食的技巧，“超级冰箱”计划：</p><p>在打开冰箱后，我们能看到一堆玻璃容器，装着已经做好的开盖即食的食物。西兰花装在容器里，已经洗干净、切好。菜花、芹菜、辣椒和洋葱也已经处理好了。还有一个容器里装着已经煮熟的藜麦。此外，冰箱里也有一些现成的可以当零食吃的新鲜水果和熟鸡蛋，还有原味全脂酸奶、多种泡菜，以及芥末等调味品。只要人一打开门就能看到一系列健康的饮食选择。冰箱里的食物，我们想什么时候吃就什么时候吃、想吃什么就吃什么、想吃多少就吃多少。</p><p>我们不会把那些跟饮食计划相悖的食物放入冰箱。每星期我们都会花时间去购物，并且整理好超级冰箱，<br>做好准备工作。每个星期天在完成超级冰箱补给工作之后，我都会花上一分钟时间去欣赏它。</p><p>下一步行动可能会困难一点，因为你不想破坏冰箱里的“风景”。这一步很关键：在接下来的一星期之中，你需要全力以赴，吃掉准备好的所有美味佳肴，什么都不要浪费。可能的话，清空所有容器。</p><p>虽然每周补给冰箱要花费我们不少时间和精力，但这份投入很快就能得到回报。如果我需要一份简单的午餐，那么你只要拿出一些食材就能搞定。准备晚餐也只需要几分钟而已。如果你在任何时候想吃点零食，即便是在午夜，只要打开超级冰箱，想吃什么都有。如果我还有点饿怎么办？我只需要到超级冰箱那里，找些东西吃就行了，里面全都是很优质的食物，我无须忍饥挨饿，也无须依赖意志力调整饮食。</p><p>使用“超级冰箱”计划的结果是体重减轻、睡眠改善、精力提升。刚开始使用“超级冰箱”时，我们做得也并不完美，但我们学会了把冰箱当作健康饮食计划中最好的盟友。</p></blockquote><h3 id="技巧5：心态调整"><a href="#技巧5：心态调整" class="headerlink" title="技巧5：心态调整"></a>技巧5：心态调整</h3><p>你应该已经学到了一些有价值的心态调整技巧：</p><ul><li>以开放、灵活和好奇的态度来应对变化。</li><li>能够降低期望。</li><li>通过为成功（不管是多小的成功）庆祝获得良好的感觉。</li><li>对改变过程保持耐心和信心。</li></ul><p>由于总是会听到人们说出“我就是那种……的人”这个句式，我决定将其纳入微习惯策略的评估流程，在为期5天的计划结束时，我要求人们补全下面这句话：“在实践微习惯之后，我现在认为自己是那种……的人。”</p><p>心态调整的关键在于：拥抱新身份。只要能做到放弃旧身份、拥抱新身份，你很快就能够提升自己从微小入手拥抱巨大变化的能力。</p><blockquote><p>经常光顾麦当劳的人和经常在农贸市场购物的人，他们所呈现的饮食习惯是完全不同的。如果你开始像去农贸市场采购的那种人一样规划饮食，大脑就会指引你转变对身份的认知并习得一系列与新身份相匹配的新习惯，“往沙拉里面加南瓜子”在你听来不再觉得奇怪，而是觉得很健康。改变身份会有助于你养成其他新习惯，那些你自己或许都没有想到的、能够让你更接近自己的愿望的新习惯。</p></blockquote><p>如何构建这些重要的身份认知技巧：</p><ul><li>用你想要拥抱的一种身份或多种身份，补全“我现在认为自己是那种……的人”这句话。</li><li>参加那些汇集了跟你的新身份相关的人员、产品和服务的活动。当我决定要吃发酵食品时，就去参加了当地的发酵节。我遇到了比我更有经验的爱好者，知道了很多新产品，参加了一个有专家讲授如何制作泡菜的工作坊，还购买了制作发酵食品所需的设备。我带着更强的身份认同感回到了家，认定自己就是会吃甚至会制作发酵食品的那种人。</li><li>学习行话，了解谁是专家。观看跟你感兴趣的变化领域相关的视频。在学习冲浪的时候，我就查阅了用来描述波浪的行话，并开始使用这些术语。我留意大型的冲浪活动，还观看了最擅长这项运动的人们的视频。我学会了理解潮汐变化，还学会了通过标志性建筑来判断潮汐的高低。在毛伊岛附近有一座火山，轮廓很明显，当地人称之为“龙”。你只需要看着“龙”就能知道潮汐的变化。如果“龙”的脖子露出来了，那就是低潮期。如果“龙”只露出了脑袋，那就是涨潮期。</li><li>穿T恤也是用来表明身份的一种常用方式。耐克牌T恤代表了跑步爱好者，而我穿的T恤上面印有冲浪板或冲浪场面的图像。我每年冲浪过百次，我可不会觉得自己是在装腔作势，将这种身份穿在身上感觉很自然。</li><li>更新你的社交媒体页面，换一张能够展现你新身份的档案照片，再看看人们的反应如何。修改网上的个人简介，加一些跟你的新身份相关的内容。</li><li>教导他人或成为榜样都能够强化你对新身份的认知。社会地位的力量是很强大的。</li></ul><h2 id="练习：改变的技巧"><a href="#练习：改变的技巧" class="headerlink" title="练习：改变的技巧"></a>练习：改变的技巧</h2><h3 id="练习1：学习掌握改变的技巧"><a href="#练习1：学习掌握改变的技巧" class="headerlink" title="练习1：学习掌握改变的技巧"></a>练习1：学习掌握改变的技巧</h3><p>在此练习中，我希望你将自己学习其他技巧的方法跟学习改变技巧联系起来。</p><ol><li>列出你已学会的至少5项技巧，如开车、说法语或是使用Photoshop软件之类的技巧。</li><li>记下你为了学习这些技巧所做的事情，即请教老师、从简单的事开始做起，以及每日练习之类的方法。我建议你至少用5分钟时间思考并做好笔记。</li><li>仔细阅读自己的笔记，思考如何使用这些方法来学习改变的技巧。</li></ol><h3 id="练习2：练习行为加工技巧"><a href="#练习2：练习行为加工技巧" class="headerlink" title="练习2：练习行为加工技巧"></a>练习2：练习行为加工技巧</h3><p>摸清楚自己能一次养成多少个习惯，是行为加工技巧的关键之一。在本练习中你要探索的就是这一点。你要尝试一次培养6个习惯，以此来找出你同时培养多个习惯的能力限度。</p><ol><li>使用至今为止在本书中学到的一切，创建6份新习惯配方。你可以在附录中找到灵感。</li><li>为每个配方写一张文摘卡。</li><li>每个配方上的行为都是微小的。如果不够微小，那就缩小它的规模。</li><li>确保每个配方的锚点都是具体而独特的。加分项是明确每个锚点的最后动作。</li><li>坚持实践这6个新习惯一星期，可以根据需要修改和演练。如果不喜欢某个新习惯，可以换成别的。</li><li>一星期后，回顾反思你对自己和微习惯策略有哪些更新的了解。在继续前进时，留下你最喜欢的新习惯即可，其他的就随它去吧。</li></ol><p>要想做好这个练习，你需要重新设计情境并进行演练，而这就是接下来两个练习的重点。</p><h3 id="练习3：练习情境设计技巧"><a href="#练习3：练习情境设计技巧" class="headerlink" title="练习3：练习情境设计技巧"></a>练习3：练习情境设计技巧</h3><p>这项技巧依靠重新设计情境来帮助你完成想要的生活改变。</p><ol><li>逐个查看行为加工练习中输出的新习惯配方。</li><li>逐个分析这些习惯，找到可以重新设计情境并让它们变得易于执行的方法。</li></ol><h3 id="练习4：练习循序渐进技巧"><a href="#练习4：练习循序渐进技巧" class="headerlink" title="练习4：练习循序渐进技巧"></a>练习4：练习循序渐进技巧</h3><p>演练新习惯并每次都为此庆祝，就是一项重要的循序渐进技巧。如下就是这样的一个练习。</p><ol><li>查看你为微习惯创建的6个配方。</li><li>针对每个配方，执行锚点行为及其新习惯。</li><li>在执行新习惯的过程中或结束后立刻进行庆祝。</li><li>重复这个行为序列7～10次。</li><li>尽量避免在演练习惯时感觉尴尬。记住，体育、商业演讲和更多领域的顶尖选手都经历过练习才成功的，这也是你在行为改变领域成为顶尖选手的方式。</li></ol><h3 id="练习5：练习心态调整技巧"><a href="#练习5：练习心态调整技巧" class="headerlink" title="练习5：练习心态调整技巧"></a>练习5：练习心态调整技巧</h3><p>心态调整技巧的关键就是要能够欣然接受自己每次只完成微小行为。可以只清洁牙齿或只做两个俯卧撑。这个练习就是为了帮助你适应这种理念。</p><ol><li>任选一个你定期执行的新习惯。如果想不出来，那就选择清洁牙齿吧。</li><li>下一次你要执行新习惯的时候，故意只做最微小版本的量，要抵制住加量的诱惑。</li><li>为自己有意地保持了微习惯还欣然接受它而庆祝。</li><li>至少连续3天重复这么做，以便能形成认可即便做出最微小的改变也很好的心态。你需要能够接受自己在履行习惯时偶尔减小规模的做法，这样才能长期坚持履行习惯。</li></ol><h3 id="练习6：练习自我洞察技巧"><a href="#练习6：练习自我洞察技巧" class="headerlink" title="练习6：练习自我洞察技巧"></a>练习6：练习自我洞察技巧</h3><p>找出生活中拥有最大意义的最小改变，是自我洞察技巧的关键之一。我认为这个练习是目前所有练习当中最困难的一个，这也是我把它留到最后的原因。</p><ol><li>列出一个对你来说最重要的生活目标，比如做一个好妈妈或是培养同情心。</li><li>花3分钟时间思考在此领域你能做到的且很有意义的最简单的单次行为。</li><li>重复步骤2，但这一次是要思考在此领域对你而言最有意义的、最微小的新习惯。</li></ol><h1 id="行为改变系统方案，一次只解一个结"><a href="#行为改变系统方案，一次只解一个结" class="headerlink" title="行为改变系统方案，一次只解一个结"></a>行为改变系统方案，一次只解一个结</h1><p>对于“难以改变”的坏习惯，人们常常这样描述：打破坏习惯、战胜成瘾习惯。我建议不要用“打破”，而是用一个别的词和一个隐喻：想象一条缠在一起、打满了结的绳子，压力过大、看屏幕时间过长和拖延等习惯就是这条绳子上的结。你无法一次解开所有结，并且从长远来看，紧拉绳子可能会让情况变得更糟。你必须逐一解开这些结，而且不需要一开始就专攻最难的部分。为什么呢？因为最难解的结是隐藏最深的，你必须有所规划，先找出最容易解开的结，从它开始。</p><blockquote><p>朱妮先列出了甜食习惯绳子上所有的绳结，之后找出了一个最容易解开的，即晚饭后不吃甜点，先做到一天不吃，然后是两天不吃……接着，她又清理了休息室里的冰激凌。最后，她连冰箱里的冰激凌也全部清理了。如果朱妮用传统观念来打破坏习惯，比如把甜甜圈换成芹菜梗，或许她早就已经放弃了，因为有些事仅凭意志力是很难做到的，迎难而上通常都无法持续。而且，如果她从一开始就不想做这件事（比如不想吃芹菜），那么好习惯是很难养成的。然后，她就会因为失败而沮丧，结果一次失败导致更多失败。</p></blockquote><p>坏习惯和好习惯的基本要素并没有本质性不同，行为就是行为，它始终是动机、能力和提示这3大要素同时作用的结果。</p><h2 id="行为改变系统方案的3个阶段"><a href="#行为改变系统方案的3个阶段" class="headerlink" title="行为改变系统方案的3个阶段"></a>行为改变系统方案的3个阶段</h2><h3 id="阶段1：致力于创建新习惯"><a href="#阶段1：致力于创建新习惯" class="headerlink" title="阶段1：致力于创建新习惯"></a>阶段1：致力于创建新习惯</h3><h4 id="改变的技巧"><a href="#改变的技巧" class="headerlink" title="改变的技巧"></a>改变的技巧</h4><p>最佳做法是先掌握改变的技巧，再熟练掌握改变过程本身。在阶段1，你应该着重培养那些能让你发挥所长的习惯。这是学习改变技巧的最佳方式——为未来增加更多技巧和见解，以让你快速取得成功。</p><h4 id="身份转变"><a href="#身份转变" class="headerlink" title="身份转变"></a>身份转变</h4><p>当你做出一系列积极的改变时，就会更加接近你想成为的自己。如果在这些改变中你感受到了成功，那你自然会重新看待自己，并开始接受自己的新身份。</p><h3 id="阶段2：致力于终止旧习惯"><a href="#阶段2：致力于终止旧习惯" class="headerlink" title="阶段2：致力于终止旧习惯"></a>阶段2：致力于终止旧习惯</h3><p>你也可以通过行为设计来改掉旧习惯，这个方法的基础仍然是福格行为模型。你可以削弱动机或降低能力，也可以移除提示，采用其中任何一种方式并坚持，都能如你所愿。</p><h4 id="让你想终止的习惯更具体"><a href="#让你想终止的习惯更具体" class="headerlink" title="让你想终止的习惯更具体"></a>让你想终止的习惯更具体</h4><p>在终止坏习惯上有一个常见的误区，即将一个抽象概念，如“不要让工作过于紧张”或“停止吃垃圾食品”当作目标。这两种描述听起来都很具体，但其实不然。它们是一堆习惯集合在一起的抽象标签，我称之为概括型习惯（General Habit）。如果只关注概括型习惯，那可能不会有多少进展，就像你想一口气解开整条绳索上的结，这是不大可能的。先锁定某一个绳结，然后再一一解开剩下的结，才能解开整条绳索。这意味着你要专心培养某个具体的习惯。行为集群可以帮助你做到这一点。</p><p>首先，写下你想要终止的概括型习惯。其次，逐个列出有助于改变概括型习惯的具体习惯，把它们写在云朵四周的文本框里。</p><p><img src="https://s2.loli.net/2024/08/04/3AdzPFIHfMkSTnE.png" alt="image.png"></p><p>如果你紧盯着概括型习惯不放，很可能就会产生沮丧或害怕的情绪，进而找借口逃避：“我现在没有时间”或“我晚些时候再做”。不过，列出和概括型习惯相关的具体习惯之后，你就会觉得这个大的坏习惯更容易管理了。</p><p>当你看到一大堆具体习惯需要改变时，请不要望而却步，也别感到不知所措，请你从中挑选一个并对它进行设计。不过，你究竟应该先挑哪些具体习惯呢？这个问题的答案至关重要，我用不同的描述来说3遍：</p><ul><li>选择最容易的那个；</li><li>选择你最确信自己能做到的那个；</li><li>选择你觉得最没什么大不了的那个。</li></ul><h4 id="聚焦于提示以终止习惯"><a href="#聚焦于提示以终止习惯" class="headerlink" title="聚焦于提示以终止习惯"></a>聚焦于提示以终止习惯</h4><p>设计动机、能力或提示中的任意一个要素都可以达到终止具体习惯的目的。不过，终止具体习惯的最优路径，就是先从<strong>提示</strong>开始。</p><h5 id="1-移除提示"><a href="#1-移除提示" class="headerlink" title="1. 移除提示"></a>1. 移除提示</h5><p>移除提示是其中最简单的，它的最佳方式就是重新设计周围环境。比如，你想终止在工作时刷社交媒体App的习惯，你可以关机、设置飞行模式，或关闭社交媒体App的通知功能，无论哪种方式，都可以移除情境提示。这样做或许可以帮助你解决这个习惯问题。<br>如果为这件事写一个微习惯配方，那大概会是：在我坐下来开始工作之后，我会关闭社交媒体App的通知功能。</p><h5 id="2-规避提示"><a href="#2-规避提示" class="headerlink" title="2. 规避提示"></a>2. 规避提示</h5><p>如果你无法移除坏习惯的提示，那就尝试规避它。比如，你想终止早晨喝咖啡配高糖点心的习惯，那就不要再去咖啡店，而是在家里自己煮咖啡，这样就避开了咖啡店里的诱惑。</p><p>规避提示的方式有4种：</p><ul><li>不要前往那些会带给你提示的地方；</li><li>不要接近那些会带给你提示的人；</li><li>不要任由别人把提示植入你的周遭环境；</li><li>避免使用那些会带给你提示的社交媒体App。</li></ul><h5 id="3-忽略提示"><a href="#3-忽略提示" class="headerlink" title="3. 忽略提示"></a>3. 忽略提示</h5><p>还可以选择忽略提示，但这种做法依赖于意志力，所以你得付出额外努力才能忽略一个位于行动线上方的习惯的提示，这意味着你必须有足够的动机和能力。</p><p>尽管从长远来看，忽略提示可能并非最佳解决方案，但如果你发现自己意志坚强，能够完成任务，那么当你成功地忽略了提示，终止了不想要的习惯时，一定要庆祝这些成功。</p><h4 id="重新设计能力以终止习惯"><a href="#重新设计能力以终止习惯" class="headerlink" title="重新设计能力以终止习惯"></a>重新设计能力以终止习惯</h4><p>能力链的5大环节：时间、资金、体力、脑力和日程。现在我们将反其道而行之，即削弱或打破这个链条，让习惯难以养成。</p><h5 id="1-增加所需时间"><a href="#1-增加所需时间" class="headerlink" title="1. 增加所需时间"></a>1. 增加所需时间</h5><p>一种做法是重新设计环境，不在家里存放冰激凌。当你下次想边看电视剧边吃冰激凌时，就没办法立刻吃到，因为你得换好鞋，走到车库，然后开车去商店里买，结完账后还要拿回家才能吃。</p><h5 id="2-增加所需资金"><a href="#2-增加所需资金" class="headerlink" title="2. 增加所需资金"></a>2. 增加所需资金</h5><p>当你设计的改变对象是别人时，从资金入手或许是一个不错的选择。如果你想让孩子们少玩电子游戏，那你可以向他们收取每小时5美元的游戏费；如果你想让员工别喝那么多汽水，那你可以抬高自动售卖机里的汽水价格；如果你不想让学校职员都开车上班，那你可以提高校区里的停车费。</p><h5 id="3-增强所需体力"><a href="#3-增强所需体力" class="headerlink" title="3. 增强所需体力"></a>3. 增强所需体力</h5><p>出门去买冰激凌需要更多时间，也需要更多体力。“禁止在冰箱里存放冰激凌”的规则之所以能奏效，原因之一就在于时间和体力发挥了双倍的作用。</p><p>改造单车电视机。要想看电视，就得有个人去踩动感单车；只要一停下来，电视机就会自动关闭。这个方案的效果好到让我意外，我们不仅看电视的时间变少了，而且还锻炼出了好体型。</p><h5 id="4-增加所需脑力"><a href="#4-增加所需脑力" class="headerlink" title="4. 增加所需脑力"></a>4. 增加所需脑力</h5><p>想想脑力因素在社交媒体App上是如何运作的。假如你将App的密码重置为“1Lik3be1ng0uT51de”之类复杂的字符串，并禁止自动保存，那每次你想登录时都得输入这一大串字符。无须思考的行为才称得上真正的习惯，所以，让完成行为需要耗费更多脑力，不失为一个终止习惯或降低其频率的好办法。</p><h5 id="5-让习惯跟重要日程发生冲突"><a href="#5-让习惯跟重要日程发生冲突" class="headerlink" title="5. 让习惯跟重要日程发生冲突"></a>5. 让习惯跟重要日程发生冲突</h5><p>想办法让自己不想要的习惯和你重视的某个习惯日程发生冲突，而你重视的日程比你想要改掉的习惯更重要。</p><h4 id="调整动机以终止习惯"><a href="#调整动机以终止习惯" class="headerlink" title="调整动机以终止习惯"></a>调整动机以终止习惯</h4><p>一提起要终止某个习惯，大多数人首先想到的就是去影响动机。但是，这在大多数情况下是错误的做法。？因为，很多下山型习惯的动机水平是很难调整的（而自由落体型习惯几乎不可能调整），所以，如果能从提示或能力入手来解决习惯问题，那最好还是不要去想依靠动机。</p><h5 id="1-削弱动机，让习惯落到行动线以下"><a href="#1-削弱动机，让习惯落到行动线以下" class="headerlink" title="1. 削弱动机，让习惯落到行动线以下"></a>1. 削弱动机，让习惯落到行动线以下</h5><p>举例，如何用其他行为削弱习惯的动机：</p><ul><li>早点睡觉，以削弱自己早晨赖床的动机；</li><li>参加聚会前先吃点儿健康食品，可以降低你在聚会上狂吃不健康食品的动机；</li><li>每星期做一次针灸，可以降低你吃止痛药的动机。</li><li>停止无节制地使用电子产品，有一种办法是把手机屏幕设置成灰度。因为，当屏幕上的色彩不再鲜艳时，那些五花八门的网络信息就不会对大脑产生较大的刺激，让大脑兴奋起来。</li></ul><h5 id="2-增加去激励因素"><a href="#2-增加去激励因素" class="headerlink" title="2. 增加去激励因素"></a>2. 增加去激励因素</h5><p>不推荐使用，可能导致自责。成效最佳的改变，源自感觉良好，而非感觉糟糕。因此，要确保你的去激励因素不会演变成自责之旅。</p><p>通过增加去激励因素来降低总体动机水平的行为示例：</p><ul><li>在Facebook上保证从此滴酒不沾；</li><li>发誓如果再抽烟，就捐款1 000美元；</li><li>想象常常熬夜玩电子游戏会让生活多么不顺心。</li></ul><h4 id="从改变一点点开始"><a href="#从改变一点点开始" class="headerlink" title="从改变一点点开始"></a>从改变一点点开始</h4><p>为什么“改变一点点”的方式可以有效？在终止习惯的时候，人们的心情往往是很矛盾的。他们一方面想这么做，另一方面又觉得这么做不对。而选择缩小规模的方式，就不会让自己望而生畏。</p><p>你的具体习惯现在有了一个变体，你可能会发现，在有限的时间内戒除要比永久戒除更容易做到。这样一来，你就可以开始收获成果，并准备好做出更大的改变了。</p><p>可以采取的具体方法包括：</p><ul><li>为终止习惯设定更短的时间周期（如戒烟3天，而不是永久戒烟）；</li><li>缩短不想要习惯的时长（如看电视30分钟，而不是4小时）；</li><li>减少不想要习惯的次数（如每天查看1次社交媒体App，而不是10次）；</li><li>降低不想要习惯的强度（如放缓饮酒速度，而不是减少杯数）。</li></ul><h3 id="阶段3：致力于用新习惯替代旧习惯"><a href="#阶段3：致力于用新习惯替代旧习惯" class="headerlink" title="阶段3：致力于用新习惯替代旧习惯"></a>阶段3：致力于用新习惯替代旧习惯</h3><p>你需要明确具体地描述你想制止的那个习惯以及用来替换它的新习惯，而明智地选择新习惯也是至关重要的。否则，替换就无法产生效果。在替换习惯行为时，需要善用习惯培养技巧，找到一个相比于旧习惯更容易执行、动机更强的新习惯。</p><h2 id="练习：逐步消灭坏习惯"><a href="#练习：逐步消灭坏习惯" class="headerlink" title="练习：逐步消灭坏习惯"></a>练习：逐步消灭坏习惯</h2><h3 id="练习1：创建用以终止坏习惯的行为集群"><a href="#练习1：创建用以终止坏习惯的行为集群" class="headerlink" title="练习1：创建用以终止坏习惯的行为集群"></a>练习1：创建用以终止坏习惯的行为集群</h3><p>选择一个你自己没有的坏习惯。为什么？因为这样能削弱它带给你的威胁感，你也能了解更多事情。</p><ol><li>假装你拥有这个坏习惯。</li><li>绘制行为集群。</li><li>在云朵中间写下概括型习惯。</li><li>在云朵的周围写下至少10个具体习惯。这需要发挥想象力。</li><li>检视行为集群，从中选出两三个最简单的具体习惯。</li></ol><p>注意：通过创建虚构行为集群的方式，你可以打磨技巧。这样等你将这个方法真正用于生活中的真实挑战时，你将会更加自信、恐惧感更弱，且更加高效。</p><h3 id="练习2：在一天内移除提示"><a href="#练习2：在一天内移除提示" class="headerlink" title="练习2：在一天内移除提示"></a>练习2：在一天内移除提示</h3><ol><li>选一个你常用的社交媒体App或体育App。</li><li>找到设置菜单，关闭通知功能。</li><li>观察接下来的24小时内会发生些什么（以及没有发生什么）。</li></ol><p>注意：如果你发现没有消息通知让生活变得更好了，那就继续关闭通知功能吧。如果情况变糟糕了，那就再把通知功能打开。无论是哪种情况，你都能了解一些事情。</p><h3 id="练习3：替换习惯，并用庆祝的方式来促进坚持"><a href="#练习3：替换习惯，并用庆祝的方式来促进坚持" class="headerlink" title="练习3：替换习惯，并用庆祝的方式来促进坚持"></a>练习3：替换习惯，并用庆祝的方式来促进坚持</h3><ol><li>找一个新垃圾桶。</li><li>把新垃圾桶放到办公室里，摆在和你惯用的垃圾桶位置不同的地方。</li><li>告诉自己，要使用新垃圾桶，而不是惯用的那个垃圾桶。</li><li>当你收到提示要丢弃或回收某些物品的时候，使用新垃圾桶，而不是旧垃圾桶。一开始，你可能无法自如地做到这一点。如果你想快速促成转变，那请跳到步骤5。</li><li>反复演练使用新垃圾桶7～10次，而且每一次都要进行庆祝。要感受到“发光”。</li><li>结束练习后，注意观察新习惯的执行情况。留意习惯转变的方式，替换习惯时的感觉至关重要，因为这个练习的目的就在于此。</li></ol><p>注意：如果你忘了使用新垃圾桶，那就结合庆祝环节多演练几次。（在你演练了几天之后，如果你想回归到旧习惯，那也是可以的。）</p><h1 id="群体行为设计，帮助其他人感受成功"><a href="#群体行为设计，帮助其他人感受成功" class="headerlink" title="群体行为设计，帮助其他人感受成功"></a>群体行为设计，帮助其他人感受成功</h1><p>你应该可以明白是什么塑造了你不想要的习惯，包括那些由社会压力造成的习惯。或许，你和家人无法做到一起吃饭时都不看手机；或许，你的公司竞争异常激烈，谁都不肯休假；或许，你所在的读书俱乐部更像是葡萄酒俱乐部。相比于个人习惯，任何集体习惯和规范都更加根深蒂固。但是，我们可以一起改变。牢记这一点至关重要。</p><p>了解了行为是如何起作用的，就可以明确是什么在支撑着你想要或不想要的那些习惯。在改变群体行为方面，主要有3种方法：</p><ul><li>设计改变自身行为，从而让自己远离群体的负面影响；</li><li>与其他人一起设计改变你们的集体行为；</li><li>为他人设计一个对他们有利的改变，记得分解成具体步骤。</li></ul><blockquote><p>作者：我自己去年的愿望之一是“在和他人的任何互动中都要帮助他人进步”。</p><p>我将从研究中洞察的一切也都用于实现这个愿望，并尝试通过提供适时反馈的方式帮助周围的人们进步：当某个学生在课堂上首次发表演讲的时候，当我的伴侣烹饪了一款新菜的时候，当某人打电话向我请教工作问题的时候。在所有这些情况下，我都有极大的机会可以帮助他们进步，他们关心自己的问题而且对此不确定。我说的都是真心诚意鼓励他们积极向上的话语。但人们往往却选择在别人处境脆弱时给出负面的反馈。比如，你的演讲开场太慢了；鱼有点干，你煮多久了？从你的问题我就可以看出你没有认真读过我的作品……千万不要这样做，请做个好忍者。</p></blockquote><h2 id="福格原则"><a href="#福格原则" class="headerlink" title="福格原则"></a>福格原则</h2><p>福格原则1：帮助人们做他们已经想做的事。</p><p>福格原则2：帮助人们感受成功。</p><h1 id="福格行为模型工具箱"><a href="#福格行为模型工具箱" class="headerlink" title="福格行为模型工具箱"></a>福格行为模型工具箱</h1><h2 id="行为设计的步骤"><a href="#行为设计的步骤" class="headerlink" title="行为设计的步骤"></a>行为设计的步骤</h2><h3 id="1-明确愿望"><a href="#1-明确愿望" class="headerlink" title="1. 明确愿望"></a>1. 明确愿望</h3><p>应该有抱负、有梦想，或者有一个愿望清单，描述自己想做的事情，越具体越好。</p><p>愿望是抽象的欲望（比如减重）；而成果更容易衡量（比如减掉12%体脂）。愿望和成果都可以作为行动的起点，但它们都不是行为。</p><blockquote><p>行为举例：每天晚饭后不吃东西。</p></blockquote><h3 id="2-探索行为选项"><a href="#2-探索行为选项" class="headerlink" title="2. 探索行为选项"></a>2. 探索行为选项</h3><p>选择一个愿望，然后列出一组有助于实现愿望的具体行为。</p><p>在图中间的云朵里写下愿望，然后在它周围的文本框里填入具体的行为。</p><p><img src="https://s2.loli.net/2024/08/03/EkBDqv4rSumGTAU.png" alt="image-20240803202552599.png"></p><p>可以参考以下几种行为类型：</p><ul><li>想做哪些一次就能完成的行为？</li><li>想养成哪些新习惯？</li><li>想终止哪些习惯？</li></ul><p><img src="https://s2.loli.net/2024/08/03/zEU18orlfQtYgN5.png" alt="image-20240803202631314.png"></p><h3 id="3-为自己匹配具体行为"><a href="#3-为自己匹配具体行为" class="headerlink" title="3. 为自己匹配具体行为"></a>3. 为自己匹配具体行为</h3><p>黄金行为的3个标准：</p><ul><li>这个行为能让你实现愿望（影响）；</li><li>你想做出这个行为（动机）；</li><li>你可以做到这个行为（能力）。</li></ul><h4 id="焦点地图"><a href="#焦点地图" class="headerlink" title="焦点地图"></a>焦点地图</h4><p><img src="https://s2.loli.net/2024/08/03/XOKIitULg8CdQB6.png" alt="image-20240803205806061"></p><p>持久改变的关键，在于为自己匹配真心想做的行为。</p><p>通过行为设计匹配的新习惯，是我们在最忙碌、最没动力且状态最不好时，也能做到的行为。</p><h3 id="4-从微习惯开始"><a href="#4-从微习惯开始" class="headerlink" title="4. 从微习惯开始"></a>4. 从微习惯开始</h3><p>在能力范围内找到行为。</p><p><img src="https://s2.loli.net/2024/08/03/uO5YLtaGiPdV31c.png" alt="image-20240803212530872"></p><p><img src="https://s2.loli.net/2024/08/03/Jt4bdTCAQsvReZ6.png" alt="image-20240803212807085.png"></p><p>从福格行为模型的角度来说，能力是维持习惯最可靠的要素。如果一个行为困难，就要让它变得更容易做到。你会发现，无论动机如何改变，能力都会变得更强。这会让你养成非常牢固的习惯。</p><p><img src="https://s2.loli.net/2024/08/03/Qic9WMRhGlDjsEI.png" alt="image-20240803212934178.png"></p><h3 id="5-找到“对”的提示（锚点）"><a href="#5-找到“对”的提示（锚点）" class="headerlink" title="5. 找到“对”的提示（锚点）"></a>5. 找到“对”的提示（锚点）</h3><p>到此，已经为自己匹配了具体行为，缩小了行为规模让它们变得容易做到，而现在，要给它们添加提示。</p><p>在我（锚点）之后，我会（新习惯）：</p><ul><li>示例微习惯配方：在我坐到工位之后，我会写下当天最重要的任务。</li></ul><blockquote><p>更多微习惯配方，列在后面了。</p></blockquote><h3 id="6-庆祝成功"><a href="#6-庆祝成功" class="headerlink" title="6. 庆祝成功"></a>6. 庆祝成功</h3><p>在工作之中，在完成需要养成习惯的动作之后，只需在待办清单上打勾，并画一个笑脸，或者就只要在心理对自己说：“没错，我搞定了！”就足以让你感到自己在发光了。</p><h3 id="7-排除障碍、重复和扩展"><a href="#7-排除障碍、重复和扩展" class="headerlink" title="7. 排除障碍、重复和扩展"></a>7. 排除障碍、重复和扩展</h3><p>舒适区边界不是一条直线，它更像是股市走势图中起起伏伏的线条。只要你坚持执行新习惯，就永远都能移动舒适区边界，但不要事先设想太多。专注于当前的舒适区边界即可。</p><p>如下是关于如何调整习惯难度的操作指南：</p><ul><li>不要给自己施加太多压力去试图养成更高阶的习惯。如果你生病了、累了，哪怕只是心情不好，那就将行为规模缩小到最微小的程度。如果你想多做一些，也随时都可以提高标准，但只要有需要，你也可以随时降低标准到最低程度。灵活性是这项技巧中的一部分。</li><li>如果你想多做一些，不要限制自己。让动机来告诉你该做多少和该怎么做。</li><li>如果你做了很多，一定要为自己额外付出的努力而庆祝。如果为了提升习惯而给自己太多压力，你就有可能觉得痛苦或沮丧，这反而会削弱习惯。如果出现了这种情况，你可以通过加倍为自己庆祝来抵消负面情绪。</li><li>利用情感标志来帮助你找到边界。沮丧、痛苦以及逃避等情绪标志着你的习惯出了问题，可能是难度提升太多、太快。但如果你是对现有习惯感到有些厌倦，那么你或许还需要再提高些难度才行。</li></ul><h2 id="可供参考的微习惯配方"><a href="#可供参考的微习惯配方" class="headerlink" title="可供参考的微习惯配方"></a>可供参考的微习惯配方</h2><p>obsidian模板：<a href="https://forum-zh.obsidian.md/t/topic/3603">https://forum-zh.obsidian.md/t/topic/3603</a></p><h3 id="职场女性的微习惯配方"><a href="#职场女性的微习惯配方" class="headerlink" title="职场女性的微习惯配方"></a>职场女性的微习惯配方</h3><ol><li>在我听到起床的闹钟响起之后，我会立即关掉它（而且不赖床）。</li><li>在我走进厨房之后，我会喝一大杯水。</li><li>在我启动咖啡机之后，我就会把午餐盒拿出来。</li><li>在我系好安全带后，我会开始播放有声读物。</li><li>在我吃完午饭后，我会绕着办公楼至少走一圈。</li><li>在我结束一天的工作，关闭电脑之后，我会快速整理好办公桌。</li><li>在我驱车离开公司停车场之后，我会立刻驶向健身房。</li><li>在我打开花洒之后，我会做3个深蹲（也许更多）。</li></ol><h3 id="改善睡眠的微习惯配方"><a href="#改善睡眠的微习惯配方" class="headerlink" title="改善睡眠的微习惯配方"></a>改善睡眠的微习惯配方</h3><ol><li>（早晨）在我穿上鞋子之后，我会出去沐浴自然光。</li><li>在我吃完午饭之后，我会到室外晒太阳。</li><li>在我决定要小睡片刻之后，我会设置闹钟，不会超过30分钟。</li><li>在我下班回到家后，我会把手机拿到厨房而非卧室里充电。</li><li>在我看完晚间的电视节目之后，我会开始进行睡前运动。</li><li>在我看到时间显示超过晚上8点之后，我会停止使用电子产品，不再盯着屏幕。</li><li>在我拉上窗帘之后，我会在卧室里喷一点薰衣草味的香水。</li><li>在我爬到床上之后，如果还没有困意，我会打开一本内容轻松的书，在不那么亮的卧室里阅读。</li><li>（晚上）在我开始担心一个问题时，我会说：“明天再说也不迟。”</li></ol><h3 id="充满活力的老人的微习惯配方"><a href="#充满活力的老人的微习惯配方" class="headerlink" title="充满活力的老人的微习惯配方"></a>充满活力的老人的微习惯配方</h3><ol><li>在我沏了一杯茶之后，我会先拿出药来吃。</li><li>在我拿到晨报之后，我会进行3次深呼吸。</li><li>在我读完晨报之后，我会拿出自己最喜欢的音乐专辑，跟音乐跳一段舞。</li><li>在清洗好早餐用的餐具之后，我会穿上步行鞋。</li><li>在我出门去散步之后，我会打电话给兄弟姐妹的其中之一。</li><li>在我走到步行道上之后，我会打开相机，拍一张照片。</li><li>在我回到我家所在的街道之后，我会去查看家里的信箱。</li><li>在我打开花园的大门之后，我会停住脚步，说：“每一天都是一份礼物。”</li><li>在我戴上园艺手套之后，我会拔掉3棵杂草。</li><li>在我看到一株美丽绽放的花朵之后，我会剪几朵放到花瓶里。</li><li>在我脱掉步行鞋之后，我会把水杯倒满水。</li><li>在我的朋友到我家之后，我会真诚地赞美他。</li></ol><h3 id="新晋管理者的微习惯配方"><a href="#新晋管理者的微习惯配方" class="headerlink" title="新晋管理者的微习惯配方"></a>新晋管理者的微习惯配方</h3><ol><li>在我吃完早餐之后，我会打开日历App，查看当天的日程。</li><li>在我向领导了解了一个新项目之后，我会在Slack中为它创建一个新群组。</li><li>在我的员工例会开始之后，我会与他们问一些有趣的问题，并倾听每个人的简短回应。比如：你最近去过哪座城市？你最喜欢的调味料是什么？你最近最喜欢听的是哪个音乐专辑？</li><li>在我们讨论完所有议题之后，我会向同事询问是否还有其他议题要讨论。</li><li>在我的下属向我提出问题之后，我会说：“你认为最好的解决方案是什么？”</li><li>在我收到表示夸赞的电子邮件或文件之后，我会把它们转存到我的绩效评估文件夹中。</li><li>在我下班关掉电脑之后，我会把办公桌上的一份文件归类整理好。</li></ol><h3 id="大学生的微习惯配方"><a href="#大学生的微习惯配方" class="headerlink" title="大学生的微习惯配方"></a>大学生的微习惯配方</h3><ol><li>在我听到闹铃之后，我会立刻把一只脚放到地板上，试着醒来。</li><li>在我开启咖啡壶之后，我会整理一下宿舍。</li><li>在我把书放进书包之后，我会从冰箱里拿出一份健康零食。</li><li>在我跨上自行车之后，我会戴上头盔（即使它会弄乱我的头发）。</li><li>在我走进图书馆之后，我会找一个安静的角落，在人少的位置坐下来。</li><li>在我结束早自习、离开教室之后，我会给妈妈或奶奶打电话（每星期一、星期三和星期五）。</li><li>在我坐下来开始吃午饭之后，我会浏览专业的新闻、了解一些时事。</li><li>在我坐下来并把笔记本电脑放到课桌上，准备听课之后，我会关掉无线网络。</li><li>在我拿起食堂的餐盘之后，我会多盛一些蔬菜和蛋白质。</li><li>在我把餐盘放到传送带上之后，我会到安静的休息室，打开一本个人理财类的书。</li><li>在我听到去酒吧的邀请之后，我会微笑着说：“谢谢，但今晚不行。”</li><li>在我收到任何一位教授发来的邮件之后，我都会立即回复，哪怕只是回复简单的“收到，谢谢”。</li><li>在我取得好成绩之后，我会把成绩单拍照发送给我的妈妈和奶奶。</li><li>在我（没来由地）感到沮丧之后，我会重看我的个人规划。</li></ol><h3 id="居家办公的微习惯配方"><a href="#居家办公的微习惯配方" class="headerlink" title="居家办公的微习惯配方"></a>居家办公的微习惯配方</h3><ol><li>在我走进厨房之后，我会喝新鲜的柠檬水。</li><li>在我倒上第一杯咖啡之后，我会穿上我的跑鞋。</li><li>在我吃完维生素之后，我会去喂狗。</li><li>在我启动电脑之后，我会查看我的团队工作进度。</li><li>在我看到一个同事完成一个项目之后，我会发送一条附带表情符号的短信给他。</li><li>在我确定好当天要做的最重要事项之后，我会启动番茄定时器。</li><li>在我听到电话铃之后，我会接起电话，一边说话一边走出房间。</li><li>在我挂断电话之后，我会快速地做几个俯卧撑或蹲起。</li><li>在我吃完午饭之后，我会绕着街区走一圈（或者打电话给我的父母）。</li><li>在我看到太阳落山之后，我会戴上防蓝光眼镜。</li><li>在我看到第一个晚间电视广告之后，我会拿出我的健身工具。</li><li>在我打开花洒之后，我会想起一件当天很顺利就完成了的事。</li></ol><h3 id="减轻压力的微习惯配方"><a href="#减轻压力的微习惯配方" class="headerlink" title="减轻压力的微习惯配方"></a>减轻压力的微习惯配方</h3><ol><li>在我早上醒来之后，我会打开窗户，进行几次深呼吸。</li><li>在我坐下来喝咖啡之后，我会打开日记本。</li><li>在我知道自己今天要出门之后，我会在手机上设置定时提醒。</li><li>在我吃完午饭之后，我会到外面走走。</li><li>在收拾好办公包之后，我会花5分钟整理我的工作空间。</li><li>在我因为家人而生气之后，我会一个人走到门口的信箱那里。</li><li>在我出门遛狗之后，我会辨别我看到的鸟或植物。</li><li>在我吃完晚餐、收拾好餐具之后，我会泡一杯花草茶。</li><li>在我放好洗澡水之后，我会在里面滴几滴精油。</li><li>在我穿上睡衣之后，我会准备第二天上班要穿的衣服。</li></ol><h3 id="提高效率的微习惯配方"><a href="#提高效率的微习惯配方" class="headerlink" title="提高效率的微习惯配方"></a>提高效率的微习惯配方</h3><ol><li>在我发现通话时间比预想的要长之后，我会这样说：“很高兴和你通话，但差不多该进入主题了，请问重要的事情是？”</li><li>在我读了一封重要的电子邮件之后，我会把它分类归档。</li><li>在我看到无法立刻处理的电子邮件之后，我会标记为“未读”。</li><li>在我看到需尽快回复的电子邮件之后，我会这样回复：“收到。我将详细审查，并尽快与您联系。”</li><li>在我关闭电脑之后，我会列出第二天的日程。</li><li>在我下班踏进家门之后，我会把钥匙挂到玄关的挂钩上。</li><li>在我走进厨房之后，我会把手机插到充电器上。</li><li>在我换好家居服之后，我会把白天穿的一件衣服挂起来或整理一下。</li></ol><h3 id="有益大脑健康的微习惯配方"><a href="#有益大脑健康的微习惯配方" class="headerlink" title="有益大脑健康的微习惯配方"></a>有益大脑健康的微习惯配方</h3><ol><li>在我打开花洒之后，我会做一个全身伸展运动。</li><li>在我按下咖啡机的启动按钮之后，我会自己打几下乒乓球。</li><li>在我喝完晨间咖啡之后，我会把瑜伽垫拿出来。</li><li>在我做好早餐之后，我会放几片鳄梨。</li><li>在我出门散步之后，我会按下播客播放器的“播放”键。</li><li>在我听完播客之后，我会思考我从中得到的一个收获。</li><li>在我注意到消极想法突然出现之后，我会问自己它们是不是真实的。</li><li>在我列好购物清单之后，我会添加一种新的水果或蔬菜。</li><li>在我进入杂货店之后，我会先走到农产品区域。</li><li>在我准备好下午要吃的点心之后，我会泡一杯绿茶。</li><li>在我下班到家之后，我会打开语言学习App。</li><li>在我在下午觉得饿了之后，我会吃一些蓝莓。</li><li>在我打开烤箱之后，我会播放古典音乐专辑。</li><li>在我吃完维生素之后，我会弹尤克里里。</li></ol><h3 id="加强亲密关系的微习惯配方"><a href="#加强亲密关系的微习惯配方" class="headerlink" title="加强亲密关系的微习惯配方"></a>加强亲密关系的微习惯配方</h3><ol><li>在我整理好床铺之后，我会给伴侣一个拥抱。</li><li>在我用牙线洁完牙之后，我会在镜子上用记号笔写一个充满爱的留言。</li><li>在我喝完午休时间的咖啡之后，我会给伴侣发短信表示感谢。</li><li>在我听了一个很棒的播客之后，我会把它的链接发给我最好的朋友。</li><li>在我与邻居碰面之后，我会挥手问：“最近怎么样，一切都好吗？”</li><li>在我和朋友坐下来开始喝咖啡之后，我会问她一个关于她生活的具体问题。</li><li>在我到杂货店里看到卡片区时，我会选择一张思念卡片送给我爱的人。</li><li>在我从网上看到一个好朋友过生日的提醒之后，我会给他发一条祝福短信。</li><li>在我和一个亲密的朋友结束活动之后，我会给他发一条感谢短信。</li><li>在我自己做了好吃的东西之后，我会与邻居或朋友分享。</li><li>在我和我的伴侣做好一日游的计划之后，我会问问他有没有特别想看或想做的事情。</li><li>在我准备好要去拜访别人之后，我将为他准备一份特别的惊喜。</li></ol><h3 id="保持专注的微习惯配方"><a href="#保持专注的微习惯配方" class="headerlink" title="保持专注的微习惯配方"></a>保持专注的微习惯配方</h3><ol><li>当我踏入办公室的门之后，我会把手机调成静音模式，并把它放到包里。</li><li>在我放下公文包之后，我会选择一项我想立即完成的重要任务。</li><li>在我挑选出重要的任务之后，我会清除桌上所有让我分心的东西。</li><li>在我清理完办公桌子之后，我会定时45分钟。</li><li>在我设置好时间之后，我会戴上耳机，向别人发出“不要打扰我”的信号。</li><li>在我戴上耳机之后，我会关闭电脑上所有不必要的窗口。</li><li>在我的定时结束之后，我会列出我的下一个任务，然后休息一下。</li><li>在我开始休息之后，我会到室外，坐下来进行3次或更长时间的冥想。</li><li>在我回到办公室之后，会倒一杯咖啡。</li><li>在我决定去吃午饭之后，我会写下我的项目的下一步（我回来后马上要做什么）。</li></ol><h3 id="终止坏习惯的微习惯配方"><a href="#终止坏习惯的微习惯配方" class="headerlink" title="终止坏习惯的微习惯配方"></a>终止坏习惯的微习惯配方</h3><ol><li>在我把要用的东西放进车里之后，我会把手机放进后备厢。</li><li>在准备睡觉之后，我会在另外一个房间给手机充电，这样我就不用在床上刷Facebook了。</li><li>在我吃完晚饭之后，我会立即刷牙，以避免在晚上吃零食。</li><li>在我开始做晚饭之后，我会给自己倒一杯不含酒精的饮料。</li><li>在我得到一份零食之后，我会把它放到零食箱里收起来。</li><li>我喝完一杯酒之后，我会将洗洁精倒进杯子里。</li><li>在我走到工位之后，我会把手机调成静音模式。</li><li>在我吃完晚饭之后，我会把餐桌上剩下的少许面包扫到餐盘里扔掉，以免吃剩饭。</li><li>在我吃完开胃菜之后，我会在薯条上撒一些胡椒。</li></ol><h3 id="出差的微习惯配方"><a href="#出差的微习惯配方" class="headerlink" title="出差的微习惯配方"></a>出差的微习惯配方</h3><ol><li>在我在家里打印好登机牌之后，我会在iPad上更新有声读物和电影。</li><li>在我收拾好行李之后，我会在早上离开家之前列出一个待办事项清单。</li><li>在我通过安检之后，我会买一份沙拉带上飞机。</li><li>在我到了登机门之后，我会舒展一下腿和肩膀。</li><li>在我到座位上坐下之后，我会戴上耳机，打开TED演讲视频。</li><li>在我到达目的地之后，我会给妻子发“我着陆了”的表情。</li><li>在我走进订好的酒店房间之后，我会打开我的商务资料和我的行李。</li><li>在我到达酒店房间、打开行李之后，我会去找找健身设施，确定它的位置。</li><li>在我听到起床闹铃之后，我会起床拉开窗帘。</li><li>在我坐下来开始喝咖啡之后，我会拿出笔记本来为会议做准备。</li><li>在我听到其他与会者的名字之后，我会把他们的名字写下来并记住。</li><li>在我（返程时）通过机场安检之后，我会去商店给孩子们买一件小礼物。</li><li>在我到登机口坐下之后，我会给妻子发短信告诉她航班情况。</li><li>在我到家一进门之后，我会立刻打开行李箱，以便把行李拿出来。</li></ol>]]></content>
    
    
    <categories>
      
      <category>book notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>被讨厌的勇气 - 阿德勒的哲学课</title>
    <link href="/posts/59809db1.html"/>
    <url>/posts/59809db1.html</url>
    
    <content type="html"><![CDATA[<p>感觉看技术以外的书（比如心理学）并不算浪费时间，把自己的心态磨练得不那么容易内耗，就能够集中精力去做重要的事情。</p><h1 id="我们的不幸是谁的错？"><a href="#我们的不幸是谁的错？" class="headerlink" title="我们的不幸是谁的错？"></a>我们的不幸是谁的错？</h1><p>阿德勒心理学是一种与虚无主义截然相反的思想和哲学。我们并不受感情支配（但并不是没有感情），也不受过去支配。过去发生的某件事是客观的，但对这件事情的冷暖感知是现在的主观感觉。无论过去发生了什么样的事情，现在的状态取决于你赋予既有事件的意义。</p><p>重要的不是被给予了什么，而是如何去利用被给予的东西。</p><h2 id="阿德勒的目的论"><a href="#阿德勒的目的论" class="headerlink" title="阿德勒的目的论"></a>阿德勒的目的论</h2><p>无论之前的人生发生过什么，都对今后的人生如何度过没有影响。</p><p>我们人类并不是会受原因论所说的精神创伤所摆弄的脆弱存在。从目的论的角度来讲，我们是用自己的手来选择自己的人生和生活方式。我们有这种力量</p><h2 id="你的人生取决于当下"><a href="#你的人生取决于当下" class="headerlink" title="你的人生取决于当下"></a>你的人生取决于当下</h2><p>需要有摒弃现在的生活方式的决心。只要有梦想，不要扯各种不能做的理由，应该现在就去做。这样的话或许能够有所成长，或许会明白应该选择别的道路。</p><h1 id="一切烦恼都来自人际关系"><a href="#一切烦恼都来自人际关系" class="headerlink" title="一切烦恼都来自人际关系"></a>一切烦恼都来自人际关系</h1><p>在人际关系中根本不可能不受伤。只要涉入人际关系就会或大或小地受伤，也会伤害别人。阿德勒曾说“要想消除烦恼，只有一个人在宇宙中生存”。但是这根本无法做到。</p><h2 id="关于自卑感"><a href="#关于自卑感" class="headerlink" title="关于自卑感"></a>关于自卑感</h2><p>阿德勒说“无论是追求优越性还是自卑感，都不是病态，而是一种能够促进健康、正常的努力和成长的刺激”。只要处理得当，自卑感也可以成为努利和成长的催化剂。</p><p>特意自吹自擂的人其实是对自己没有自信。“如果有人骄傲自大，那一定是因为他有自卑感”。</p><h2 id="人生不是与他人的比赛"><a href="#人生不是与他人的比赛" class="headerlink" title="人生不是与他人的比赛"></a>人生不是与他人的比赛</h2><p>所谓“追求优越性”是指自己不断朝前迈进，而不是比别人高出一等的意思。不与任何人竞争，只要自己不断前进即可。</p><p>健全的自卑感不是来自与别人的比较，而是来自与“理想的自己”的比较。</p><p>之所以有很多人虽然取得了社会性的成功，但却感觉不到幸福，就是因为他们活在竞争之中。因为他们眼中的世界是敌人遍布的危险所在。</p><p>事实上，最关注你的人只有你自己。</p><h2 id="控制怒气"><a href="#控制怒气" class="headerlink" title="控制怒气"></a>控制怒气</h2><p>发怒是交流的一种形态，而且不使用发怒这种方式也可以交流。我们即使不使用怒气，也可以进行沟通以及取得别人的认同。除了发怒，还有其他有效交流工具（比如，具有逻辑性的语言），没有必要依赖发怒这一“工具”。</p><p>原本主张的对错与胜负毫无关系。如果你认为自己正确的话，那么无论对方持什么意见都应该无所谓。但是，很多人都会陷入权力之争，试图让对方屈服。承认错误、赔礼道歉、退出权力之争，这些都不是失败。</p><h2 id="人生的三大课题"><a href="#人生的三大课题" class="headerlink" title="人生的三大课题"></a>人生的三大课题</h2><p>一个个体在想要作为社会性的存在生存下去的时候，就会遇到不得不面对的人际关系，这就是人生课题。</p><ul><li>交友课题</li><li>工作课题</li><li>爱的课题</li></ul><h2 id="阿德勒心理学的目标"><a href="#阿德勒心理学的目标" class="headerlink" title="阿德勒心理学的目标"></a>阿德勒心理学的目标</h2><h3 id="人的行为方面的目标"><a href="#人的行为方面的目标" class="headerlink" title="人的行为方面的目标"></a>人的行为方面的目标</h3><ul><li>自立</li><li>与社会和谐共处</li></ul><h3 id="支撑这种行为的心理方面的目标"><a href="#支撑这种行为的心理方面的目标" class="headerlink" title="支撑这种行为的心理方面的目标"></a>支撑这种行为的心理方面的目标</h3><ul><li>我有能力</li><li>人人都是我的伙伴</li></ul><h1 id="让干涉你生活的人见鬼去"><a href="#让干涉你生活的人见鬼去" class="headerlink" title="让干涉你生活的人见鬼去"></a>让干涉你生活的人见鬼去</h1><p>阿德勒心理学认为，自由就是不再寻求他人的认可。我们并不是为了满足别人的期待而活着。</p><h2 id="课题分离"><a href="#课题分离" class="headerlink" title="课题分离"></a>课题分离</h2><p>把自己和别人的“人生课题”分开来。不去干涉别人的课题，也不让别人干涉自己的课题。</p><p>分离课题并不是以自我为中心，相反干涉别人的课题才是以自我为中心的想法。一味拘泥于认可欲求的人也是及其以自我为中心的人。</p><blockquote><p>比如，父母强迫孩子学习，甚至对其人生规划指手画脚，都是以自我为中心的想法。</p></blockquote><p>基本上，一切人际关系矛盾都起因于对别人的课题妄加干涉或者自己的课题被别人妄加干涉。只要能够进行课题分离，人际关系就会发生巨大改变。</p><p>有时候，我们会受“回报”思想的束缚。如果对方为自己做了什么——即使那不是自己所期望的事情——自己也必须给予报答。但实际上，决定自己应该如何做的都应该是自己。如果人际关系中有“回报思想”存在，那就会产生“因为我为你做了这些，所以你就应该给予相应回报”的想法。</p><blockquote><p>选择了不自由生活方式的大人看着自由活在当下的年轻人就会批判其享乐主义。当然，这实际是为了让自己接受不自由生活而捏造出的一种人生谎言。选择了真正自由的大人就不会说这样的话，相反还会鼓励年轻人要勇于争取自由。</p></blockquote><h2 id="自由就是被别人讨厌"><a href="#自由就是被别人讨厌" class="headerlink" title="自由就是被别人讨厌"></a>自由就是被别人讨厌</h2><p>毫不在意别人的评价、不害怕被别人讨厌、不追求被他人认可，如果不付出以上这些代价，那就无法贯彻自己的生活方式，不能获得自由。</p><p>如果是因为你的反对就能崩塌的关系，那么这种关系从一开始就没有必要缔结，由自己主动舍弃也无所谓。活在害怕关系破裂的恐惧之中，那是为他人而活的一种不自由的生活方式。</p><h1 id="共同体"><a href="#共同体" class="headerlink" title="共同体"></a>共同体</h1><h2 id="共同体感觉"><a href="#共同体感觉" class="headerlink" title="共同体感觉"></a>共同体感觉</h2><p>把他人看作伙伴，并能够从中感到“自己有位置”的状态，就叫共同体感觉。</p><p>课题分离是人际关系的出发点，共同体感觉是人际关系的终点。</p><p>共同体感觉是幸福的人际关系最重要的指标。</p><p>无论是你还是我，我们都不是世界的中心，必须把自己的脚主动迈出一步去面对人际关系课题：不是考虑“这个人会给我什么”，而是思考“我能给这个人什么”。</p><blockquote><p>关于共同体感觉问题，阿德勒说：必须得有人开始。即使其他人不合作，那也跟你没关系。应该由你来开始，不必去考虑他人是否合作。</p></blockquote><h3 id="如何建立共同体感觉？"><a href="#如何建立共同体感觉？" class="headerlink" title="如何建立共同体感觉？"></a>如何建立共同体感觉？</h3><ol><li>自我接纳<ul><li>要分清“能够改变的”和“不能改变的”。</li><li>我们无法改变“被给予了什么”，但是，关于“如何去利用被给予的东西”，我们却可以用自己的力量去改变。</li></ul></li><li>他者信赖<ul><li>如果不敢去信赖别人，那最终就会与任何人都建立不了深厚的关系。</li><li>决定背不背叛的不是你，那是他人的课题。你只需要考虑“我该怎么做”。</li></ul></li><li>他者贡献<ul><li>他者贡献并不是舍弃“我”而为<strong>他人</strong>效劳，它反而是为了能够体会到<strong>我</strong>的价值而采取的一种手段。</li><li>即使有人讨厌你，只要没有迷失“他者贡献”这颗引导之星，那么你就做什么都可以。即使被讨厌自己的人讨厌着也可以自由地生活。</li></ul></li></ol><h2 id="有价值就有勇气"><a href="#有价值就有勇气" class="headerlink" title="有价值就有勇气"></a>有价值就有勇气</h2><p>不论是表扬还是批评，实际上都是建立在不平等的纵向关系上的。我们应该用“谢谢”来对帮助自己的伙伴表示感谢，或者用“我很高兴”之类的话来传达自己真实的喜悦，用“帮大忙了”来表示感谢。这就是基于横向关系的鼓励法。人在听到感谢之词的时候，就会知道自己能够对别人有所贡献。</p><p>阿德勒：人只有在能够感觉自己有价值（对共同体有用）的时候才可以获得勇气。</p><p>不是被别人评价说“很好”（这其实是认可欲求，通过认可欲求获得的贡献感没有自由），而是主观上就能够认为“我能够对他人做出贡献”，只有这样我们才能够真正体会到自己的价值。</p><p>判断你的贡献是否起作用的不是你，那是他人的课题，是你无法干涉的问题。是否真正作出了贡献，从原理上根本无从了解。也就是说，进行他者贡献的时候的我们即使作出看不见的贡献，只要能够产生“我对他人有用”的主观感觉即“贡献感”就可以。</p><h1 id="活在当下"><a href="#活在当下" class="headerlink" title="活在当下"></a>活在当下</h1><p>人生就像是在每一个瞬间不停旋转起舞的连续的刹那。并且，蓦然四顾时常常会惊觉：“已经来到这里了吗？”</p><p>想要到达目的地的人生可以称为“潜在性的人生”；而像跳舞一样的人生则可以称为“现实性的人生”。</p><blockquote><p>以旅游为例。旅游的目的是什么？例如你要去埃及旅行，如果你想尽早尽快地到达胡夫金字塔，然后再以最短的距离返回的话，那就不能称为旅行。跨出家门的那一刻起，旅行就已经开始。朝着目的地出发途中的每一格瞬间都是旅行。即使因为以外没能到达金字塔，那也并非没有旅行。这就是现实性的人生。</p></blockquote><p>过去发生了什么与你的“此时此刻”没有任何关系，未来会如何也不是“此时此刻”要考虑的问题。</p><p>为遥远的将来设定一个目标，并认为现在是其准备阶段。一直想着“真正想做的是这样的事情，等时机到了就去做”，是一种拖延人生的生活方式。只要在拖延人生，我们就会无所进展，只能每天过着枯燥乏味的单调生活，因为人会认为“此时此刻”只是准备阶段和忍耐阶段。</p><blockquote><p>这一点还是不能赞同。我认为还是需要有一个未来的目标，然后<strong>制定计划</strong>，再然后才踏踏实实做好此时此刻的事。此时此刻做的事是与目标有关的。</p></blockquote><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>一听到哲学也许很多人会认为难懂。但是，柏拉图的对话篇中没有用到一个专业术语。哲学不应该用只有专家才能看懂的语言来叙述。因为哲学真正的意义不在于“知识”而在于“热爱知识”，想要了解不了解的事物以及获得知识的过程非常重要。</p>]]></content>
    
    
    <categories>
      
      <category>book notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Just For Fun (只是为了好玩) - Linus自传</title>
    <link href="/posts/e1fb485d.html"/>
    <url>/posts/e1fb485d.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>多抓鱼上这本书在高价收购，准备先把想要摘抄的段落记录下来，然后把它卖掉啦。</p></blockquote><p>林纳斯从公司出来时，手里握着一听开了盖的可乐，身上则是一副典型程序员装束：牛仔裤、科技会议上派送的T恤、一成不变的短袜配凉鞋。当我问及短袜配凉鞋是不是程序员的标准着装时，他声称自己在遇见其他程序员之前，就已经喜欢上这种穿法了。他还推测说：“这一定是程序员的天性”。</p><p>游戏能一直引领技术的潮流的原因：游戏总是能够促进硬件的发展。要考验硬件的极限，得靠动作游戏。处理文字的时候，慢上个一两秒你也许不会在意，但是在游戏里，即使是十分之一秒的延迟也会非常明显。</p><p>Unix系统的独特之处，在于它所追求的一整套基本理念。这个操作系统简洁又漂亮，它有“进程”的概念，做任何事情都有一个进程。在Unix系统中，任何事情都是进程使其发生的。此外，就是文件的概念。</p><p>在Unix系统上做的几乎所有事情都是由六个基本操作（系统调用，即对操作系统的调用）完成的。</p><ul><li>fork: 创建子进程。当一个进程调用fork指令时，他就把自己给复制了一份。</li><li>exec: 执行进程。fork新建的子进程一般会用exec执行另一个进程替换掉自己。</li><li>open: 打开文件。</li><li>close: 关闭文件。</li><li>read: 读取文件。</li><li>write: 写入文件。</li></ul><p>就算你要创建复杂的任务，也不需要特别复杂的接口。只要通过一些简单进程之间的交互，就可以创建任何复杂的任务。只需要在简单的进程之间，创建它们的交流渠道——管道(pipe)。</p><p>在一个讨人厌的系统里，你想做任何事情，都需要一些特殊的接口。而Unix系统恰恰相反，它直接把搭建用的模块给你，这些模块足以用来执行任何任务。这就是所谓的“简洁”设计。</p><p>最开始吸引我进入编程世界的，是我研究计算机工作原理的过程。我在其间获得的最大乐趣，就是发现了计算机和数学的异曲同工之妙：你可以创造出一个世界来，一个自主制定规则的新世界。在物理科学中，你会被客观存在的规律所约束，但是在数学和编程中，只要合乎逻辑，什么规则都行得通。</p><p>要开发一个操作系统，就要弄明白那些系统调用的功能，然后写出自己的程序，以自己的方式去实现那些系统调用。一般来说，一个操作系统有好几百个系统调用。有些基础系统调用不光复杂，还得依靠基础设备的支持。比如，如果需要将数据写入磁盘或从磁盘读取数据，就得先创建一个磁盘驱动程序。又比如，要执行open这个系统调用，就必须创建一整套文件系统层来分析文件名，并通过该系统层在磁盘上查找文件。不过一旦写出了一个调用，其他函数就可以借鉴这一套代码了。</p><p>在Unix系统中，shell程序相当于所有程序的母程序。Linux的做法是下载了一个Bourne shell的克隆版，叫Bourne-Again shell。这是Unix系统早期的一个shell，可以从互联网免费下载。也就是后来被称为bash的shell。</p><p>Linux相比Minix，有一个杀手锏功能：分页到磁盘程序。有了这个功能，用户的计算机内存再有限，也可以运行比内存大的程序。也就是说，当计算机内存不足时，可以将计算机较早前被占用的内存挪到磁盘上，记录下这块内存的新路径，然后继续用这块内存来跑原来的程序。Linux的这个特性算是1992年新年伊始的一件大事，火了好几个星期。</p><p>我希望人们能够看到和使用这个系统，并且能无拘无束地修改和完善它，但我同时也想要确保自己能够及时掌握他们所做的任何改动。我希望能一直有权使用源代码，这样的话，一旦有人做出改进，我就可以直接拿来为自己所用。我一直坚信，要使Linux发展成为十全十美的系统，就必须保持免费和开源。一旦牵扯上金钱，一切都会变得云谲波诡。只要不牵扯到金钱，我们这个圈子就不会有贪欲了。</p><p>我们认为，在美国（相比北欧），机遇要多得多，气候更是不必说。我确信美国的员工激励体系比欧洲的实际多了，这也会产生更好的工作成果。在芬兰，如果某个员工比其他人的工作做得更好，老板会遮遮掩掩地多给他一点儿薪水。但要是在美国，老板会直接给他远远高于其他人的薪水。这种方法的确很有效。</p><p>互相竞争的Unix经销商浪费了数年的时间去开发类似的功能，仅仅是因为他们没法拿到相同的代码基资源。独立开发相类似的功能不仅拖了Unix几年时间，还导致了Unix内部的明争暗斗。</p><p>人生的金科玉律：</p><ol><li>己之所欲，施之于人。</li><li>以自己做的事为荣。</li><li>乐在其中。</li></ol><p>知识产权是一项极好的收入来源，为了创造更多的知识产权，大量的金钱会被投入。正如战争在历史上一直是许多发明和工程取得巨大飞跃的进步源泉（当初，人们也是出于纯粹的军事目的才研发计算机的），同样的道理也适用于知识产权的虚拟战争，它促进了工程的进步，还为科技发展带来了前所未见的资源。</p><p>说到技术的未来，真正要紧的是人们到底想要什么。要是把这个琢磨出来了，你就会知道，唯一的问题就是你该如何快速量产这个玩意儿，并且低价出售，让人们不必牺牲他们想要的其他东西就能轻松得到它。</p><p>哈佛大学法学院把开源模式应用到了法学范畴。他们开展了“开放法律”项目，核心理论是：当大量有法律头脑的人聚集起来为一个项目出谋划策，并且能够通过发布和转发收集到海量信息时，最有力的论据就会形成。放在IT领域中，这句话的意思就是：有一百万双眼睛盯着，所有软件的bug都会无所遁形。</p>]]></content>
    
    
    <categories>
      
      <category>book notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2. Rust Syntax</title>
    <link href="/posts/700d0f.html"/>
    <url>/posts/700d0f.html</url>
    
    <content type="html"><![CDATA[<h1 id="Rust语法"><a href="#Rust语法" class="headerlink" title="Rust语法"></a>Rust语法</h1><p>一些Rust语法的小例子：</p><ul><li><p>默认情况下，一经初始化，变量的值就不能改变了，但是在参数名前放置<code>mut</code>关键字，就可以在函数体中赋值给它们。例：函数传参<code>mut n: u64</code></p></li><li><p>要想使用某个特型（接口）的方法，就要用<code>use</code>引入它。例如，任何实现了<code>FromStr</code>特型的类型都有一个<code>from_str</code>方法，当调用<code>u64::from_str(&amp;arg)</code>时，要<code>use std::str::FromStr</code>，即使<code>FromStr</code>在程序中没有出现。</p></li><li><p>当只是<em><strong>借用</strong></em>元素，不拥有<em><strong>所有权</strong></em>时，需要用<code>&amp;</code>借用引用。如：<code>for m in &amp;numbers[1..]</code>表示该向量的所有权应该留在numbers上，m只是借用元素。<code>*m</code>表示将m<em><strong>解引用</strong></em>，取得它所引用的值。</p></li><li><p>Rust闭包的写法：<code>|$&#123;闭包参数&#125;| &#123; App::new() ... &#125;</code>。闭包是一个可以像函数一样被调用的值。</p></li><li><p>泛型函数的签名示例：<code>fn parse_pair&lt;T: FromStr&gt;(s: &amp;str, separator: char) -&gt; Option&lt;(T, T)&gt;</code>，其中<code>&lt;T: FromStr&gt;</code>的意思是实现了<code>FromStr</code>特型的任意类型<code>T</code>。</p></li><li><p>单元（Unit）类型：<code>()</code>，类似C++的void。</p></li><li><p><code>?</code>运算符：使语句更简洁易读。例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">output</span> = <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">create</span>(filename) &#123;<br>  <span class="hljs-title function_ invoke__">Ok</span>(f) =&gt; f,<br>  <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(e);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 等价于：</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">output</span> = File::<span class="hljs-title function_ invoke__">create</span>(filename)?;<br></code></pre></td></tr></table></figure></li><li><p>创建并初始化向量：宏调用<code>vec![v; n]</code>表示创建了一个长度为n的向量，元素被初始化为v。</p></li><li><p>闭包接手变量的所有权：在闭包前加上<code>move</code>关键字。</p></li></ul><h1 id="附：小知识"><a href="#附：小知识" class="headerlink" title="附：小知识"></a>附：小知识</h1><ul><li><p>曼德博集的定义：令z不会飞到无穷远的复数c的集合，其中z和c的关系：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> num::Complex;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">complex_square_add_loop</span>(c: Complex&lt;<span class="hljs-type">f64</span>&gt;) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">z</span> = Complex &#123; re: <span class="hljs-number">0.0</span>, im: <span class="hljs-number">0.0</span> &#125;;<br>  <span class="hljs-keyword">loop</span> &#123;<br>    z = z * z + c;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Rust</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1. Rust Introduction</title>
    <link href="/posts/855b0fdb.html"/>
    <url>/posts/855b0fdb.html</url>
    
    <content type="html"><![CDATA[<h1 id="Rust介绍"><a href="#Rust介绍" class="headerlink" title="Rust介绍"></a>Rust介绍</h1><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>Rust的承诺：<strong>只要程序通过了编译器检查，就不会存在未定义行为。</strong></p><p>悬空指针、双重释放和空指针解引用都能在编译期捕获。数组引用则会受到编译期检查和运行期检查的双重保护。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>高效并行编程：只要数据不可变，就可以在线程之间自由地共享这些数据。会发生变化的数据则只能使用同步原语访问。</p><p>Rust的快：Rust设计了一些“高性能”的默认选项，并赋予你自主控制内存使用和处理器算力分配方式的能力。</p><h1 id="rustup-和-Cargo"><a href="#rustup-和-Cargo" class="headerlink" title="rustup 和 Cargo"></a><code>rustup</code> 和 <code>Cargo</code></h1><h2 id="rustup"><a href="#rustup" class="headerlink" title="rustup"></a><code>rustup</code></h2><p>安装Rust：详见<code>rustup.rs</code>网站。</p><p>升级Rust版本：运行<code>rustup update</code>命令，即可升级到新版本。</p><h2 id="cargo"><a href="#cargo" class="headerlink" title="cargo"></a><code>cargo</code></h2><p><code>cargo</code>是Rust的编译管理器、包管理器和通用工具。可以用cargo启动新项目、构建和运行程序，并管理代码所依赖的外部库。</p><p>创建新的Rust包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new &lt;package-name&gt;<br></code></pre></td></tr></table></figure><h2 id="rustc"><a href="#rustc" class="headerlink" title="rustc"></a><code>rustc</code></h2><p><code>rustc</code>是Rust的编译器。通常Cargo会替我们调用此编译器，但有时也需要直接运行它。</p><h2 id="rustdoc"><a href="#rustdoc" class="headerlink" title="rustdoc"></a><code>rustdoc</code></h2><p><code>rustdoc</code>是Rust文档工具。在程序源码中以适当形式的注释编写文档，那么<code>rustdoc</code>就可以从中构建出格式良好的HTML。与<code>rustc</code>一样，通常Cargo会替我们运行<code>rustdoc</code>。</p><h1 id="Crate"><a href="#Crate" class="headerlink" title="Crate"></a><code>Crate</code></h1><p>一个Rust包，无论是库还是可执行文件，都叫做<code>crate</code>（意思是板条箱）。<code>crates.io</code>上发布了大量免费的可用的包。</p><p><code>Cargo.toml</code>中<code>[dependencies]</code>部分的每一行都给出了<code>crates.io</code>上的<code>crate</code>名称，以及我们项目中想要使用的版本。例：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;demo&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2024&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">actix-web</span> = <span class="hljs-string">&quot;1.0.8&quot;</span><br><span class="hljs-attr">serde</span> = &#123; version = <span class="hljs-string">&quot;1.0&quot;</span>, features = [<span class="hljs-string">&quot;derive&quot;</span>]&#125;<br><span class="hljs-attr">crossbeam</span> = <span class="hljs-string">&quot;0.8&quot;</span> <span class="hljs-comment"># 提供并发设施</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Rust</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RSS Feeds</title>
    <link href="/posts/295f5251.html"/>
    <url>/posts/295f5251.html</url>
    
    <content type="html"><![CDATA[<p>不错的RSS源：</p><table><thead><tr><th>名称</th><th>URL</th></tr></thead><tbody><tr><td>36氪</td><td><a href="https://36kr.com/feed">https://36kr.com/feed</a></td></tr><tr><td>DIYGod - 写代码是热爱，写到世界充满爱!</td><td><a href="https://diygod.me/atom.xml">https://diygod.me/atom.xml</a></td></tr><tr><td>程序员的喵</td><td><a href="https://catcoding.me/atom.xml">https://catcoding.me/atom.xml</a></td></tr><tr><td>让小产品的独立变现更简单 - ezindie.com</td><td><a href="https://www.ezindie.com/feed/rss.xml">https://www.ezindie.com/feed/rss.xml</a></td></tr><tr><td>Julia Evans</td><td><a href="https://jvns.ca/atom.xml">https://jvns.ca/atom.xml</a></td></tr><tr><td>InfoQ 推荐</td><td><a href="https://plink.anyfeeder.com/infoq/recommend">https://plink.anyfeeder.com/infoq/recommend</a></td></tr><tr><td>三联生活周刊</td><td><a href="https://plink.anyfeeder.com/weixin/lifeweek">https://plink.anyfeeder.com/weixin/lifeweek</a></td></tr><tr><td>美团技术团队</td><td><a href="https://tech.meituan.com/feed/">https://tech.meituan.com/feed/</a></td></tr><tr><td>一天一篇经济学人(双语)</td><td><a href="https://plink.anyfeeder.com/weixin/Economist_fans">https://plink.anyfeeder.com/weixin/Economist_fans</a></td></tr><tr><td>MIT 科技评论 - 本周热榜</td><td><a href="https://plink.anyfeeder.com/mittrchina/hot">https://plink.anyfeeder.com/mittrchina/hot</a></td></tr><tr><td>构建我的被动收入</td><td><a href="https://www.bmpi.dev/index.xml">https://www.bmpi.dev/index.xml</a></td></tr><tr><td>阮一峰的网络日志</td><td><a href="https://www.ruanyifeng.com/blog/atom.xml">https://www.ruanyifeng.com/blog/atom.xml</a></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>tips</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>金钱心理学</title>
    <link href="/posts/e8e7ec6e.html"/>
    <url>/posts/e8e7ec6e.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-没有人真的对钱失去理智"><a href="#1-没有人真的对钱失去理智" class="headerlink" title="1. 没有人真的对钱失去理智"></a>1. 没有人真的对钱失去理智</h1><p>人们做的对金钱相关的每个决定都有其合理的一面，因为这些决定是他们在掌握了当时所能掌握的信息，然后将其纳入自己对世界运作方式的独特认知框架后做出的。</p><p>每个关于金钱的决定对当时的他们来说都是合理的，是建立在他们当时具备的条件之上的选择。他们会对自己的行为及其合理性做出合乎逻辑的阐释，这种阐释源于他们<strong>独特的经历</strong>。</p><hr><p>理财的概念其实很新，“工作到一定年限后退休”这个概念在美国最多不过两代人的历史。</p><p>我们在应对现代金融体系只有20~50年的经验。我们在这个领域都是新手，并且这个领域是极易受情感而非事实影响的，导致了我们常常无法按理论上的正确方式做出财务决策。</p><h1 id="2-运气与风险"><a href="#2-运气与风险" class="headerlink" title="2. 运气与风险"></a>2. 运气与风险</h1><p>任何事都没有表面看来那样美好或糟糕。</p><p>大胆与鲁莽的界限在哪里？运气好与决策高明怎么分清？</p><p>如何区分运气、技能和风险这些不同因素导致的不同结果？</p><ol><li><p><strong>如果你想欣赏和赞扬某人，一定要小心。同样，如果你想轻视某人并避免重蹈其覆辙，也一定要三思。</strong></p><blockquote><p>不要把某件事的结果100%归于个人的努力和决策。</p><p>不是所有的成功都源自努力工作，也不是所有的贫困都是因为游手好闲。</p></blockquote></li><li><p><strong>不要太关注具体的个人和案例研究，而要看到具有普适性的模式。</strong></p><blockquote><p>极端案例的成因是复杂的，因此通常很难适用于其他非极端的情况。参考案例越极端，你就越难将其提供的经验应用在生活中，因为它们受运气或风险影响的程度越大。</p></blockquote></li></ol><h1 id="3-学会知足"><a href="#3-学会知足" class="headerlink" title="3. 学会知足"></a>3. 学会知足</h1><ol><li><p><strong>最难的理财技能是让逐利适可而止。</strong></p><blockquote><p>学会知足。幸福是你拥有的减去你期待的。</p></blockquote></li><li><p><strong>不要有攀比心态。</strong></p></li><li><p><strong>懂得应该在停止冒险的时候停止。</strong></p></li></ol><h1 id="4-复利的力量"><a href="#4-复利的力量" class="headerlink" title="4. 复利的力量"></a>4. 复利的力量</h1><p>一个规模巨大的现象的形成源自特定条件下的一个相对不起眼的变化。</p><blockquote><p>冰川时期的形成过程：地球倾斜角度的变化让雪慢慢累积，周而复始。</p></blockquote><p>投资的总时长比复利率重要得多。</p><blockquote><p>巴菲特的845亿美元金融净资产中，有815亿是在65岁之后赚到的。他每年的复利率大约是22%，并不是顶尖水平，但他的投资从孩童阶段就开始了。</p></blockquote><p>高回报的投资往往是一次性的，很难重复。好的投资是可以持续获得不错的收益并能长期重复的投资——这正是复利开始大显身手的地方。</p><h1 id="5-致富-vs-守富"><a href="#5-致富-vs-守富" class="headerlink" title="5. 致富 vs. 守富"></a>5. 致富 vs. 守富</h1><p>成功的投资并不需要你一直做出成功的决定。只要做到一直不把事情搞砸就够了。</p><p>生存应该成为一切策略的基础，无论是关于投资、规划个人职业还是经营生意的。</p><blockquote><p>巴菲特的投资秘诀：有哪些行为是他没有做过的？</p><ul><li>他没有让自己债务缠身。</li><li>在他经历过的14次经济衰退中，他始终没有惊慌失措地抛售自己的金融资产。</li><li>他没有做过让自己的商业声誉受损的事。</li><li>他不会依赖单一的策略、单一的世界观或某一种已经过时的风潮。</li><li>他不会依赖别人的资金（通过上市公司来管理投资意味着投资者是不能撤资的）。</li><li>他没有拼到精疲力竭，然后放弃或者退休。</li><li>他生存了下来，生存赋予了他的投资持久性。这是复利创造奇迹的根本原因。</li></ul></blockquote><p>培养生存至上的心态：</p><ol><li><p><strong>比起巨大的回报，财富的安全更重要。</strong>只要坚持足够长的时间，复利就能创造奇迹。</p></li><li><p><strong>规划很重要，但每项规划中最重要的部分是对意外做好预案。</strong>要留出一定的容错空间（安全边际）。</p><blockquote><p>安全边际有很多种形式：节约的预算、有弹性的思维、宽松的时间安排。（不仅仅适用于金融领域）</p></blockquote></li><li><p>要有在<strong>对未来保持乐观</strong>的同时，时刻<strong>提防阻碍你走向美好未来的因素</strong>的均衡心态。</p></li></ol><h1 id="6-尾部的胜利"><a href="#6-尾部的胜利" class="headerlink" title="6. 尾部的胜利"></a>6. 尾部的胜利</h1><p>投资者即使在一半的时间里都看走了眼，到最后依然能致富。</p><p>在商业和投资领域，<strong>尾事件</strong>有着巨大的影响。这些低发生率、高影响力的少数事件成了决定结果的主要因素。</p><blockquote><p>亚马逊在Fire Phone项目上亏损了很多钱，但这对亚马逊来说不是多大的问题，因为可以被AWS等其他业务赚来的上百亿利润抵消。尾部业务就是护身符。</p></blockquote><h1 id="7-自由"><a href="#7-自由" class="headerlink" title="7. 自由"></a>7. 自由</h1><p>时间自由是财富能带给你的最大红利。</p><blockquote><p>坎贝尔：与我们考虑过的任何客观生活条件相比，对自己的生活拥有强烈的掌控感是预测幸福这种积极感受的一项更可靠的指标。</p></blockquote><p>不是工资多少，不是房子大小，不是工作好坏，而是对自己想做什么、什么时候做、和谁一起做拥有掌控能力。这是生活中决定幸福感的通用变量。</p><p>你的储蓄能够让你有底气选择跳槽、提前退休、不必生计而担忧。</p><p>财富能提供给你更多的时间和选项。它赋予你生活的好处，没有什么奢侈品比得上。</p><h1 id="8-豪车悖论"><a href="#8-豪车悖论" class="headerlink" title="8. 豪车悖论"></a>8. 豪车悖论</h1><p>其实别人不会像你那样在意你有多少财产。</p><p>通过用金钱购买昂贵之物获得的尊重和羡慕可能远比你想象中少。如果获得尊重和羡慕是你的目标，那么一定要注意选择正确的方法。比起豪车，谦虚、善良和同情心等人格特质才能帮你获得更多尊重。</p><h1 id="9-财富是你看不见的那些"><a href="#9-财富是你看不见的那些" class="headerlink" title="9. 财富是你看不见的那些"></a>9. 财富是你看不见的那些</h1><p>炫富是让财富流失的最快途径。</p><p>绝大多数人在内心深处都想变得富有，都渴望自由而有灵活度的生活，但只有<strong>没有被挥霍掉的真正的财富</strong>才能赋予我们这样的生活。</p><p>富有的前提是克制。</p><h1 id="10-存钱"><a href="#10-存钱" class="headerlink" title="10. 存钱"></a>10. 存钱</h1><p>财富积累与你的收入或投资回报率关系没有那么大，而与你的<strong>储蓄率</strong>关系很大。</p><p>那些长期成功经营个人财富的人并不一定有着高收入。他们的一个共同点是，<strong>完全不在乎别人如何看待自己</strong>。</p><blockquote><p>当消费超越了最基本物质生活需求的水平后，它在大体上便成了虚荣的自我的反映，一种通过花钱向人们展示你有钱的方式。</p></blockquote><h1 id="11-合乎情理胜过绝对理性"><a href="#11-合乎情理胜过绝对理性" class="headerlink" title="11. 合乎情理胜过绝对理性"></a>11. 合乎情理胜过绝对理性</h1><p>在大部分情况下做出合乎情理的决策，比追求绝对理性的效果更好。</p><p>“做自己喜欢的事”，这种行为标准能通过让你长期坚持做某事来提高成功的概率。这是所有投资策略中最重要的一点。</p><blockquote><p>如果你投资了一家感兴趣的企业，它的使命、产品、团队和技术方面都合你的口味，那么当它因为收益下滑或需要帮助而进入不可避免的低谷期时，你至少会因为感到自己在做一件有意义的事而对损失没有那么在意。</p><p>这种心态会成为让你不轻言放弃并转向下一个目标的必要动力。</p></blockquote><h1 id="12-意外"><a href="#12-意外" class="headerlink" title="12. 意外"></a>12. 意外</h1><p>历史是对变化的研究，但人们却将历史当作预测未来的工具。（但历史确实存在某些规律可以利用？）</p><p>但并不意味着我们在投资理财中应该忽略历史。你对投资历史追溯得越久远，得出的结论就会越缺乏针对性。你能领会一些具有普遍意义的东西，比如人性中存在着贪婪与恐惧，人们在面对压力时的表现如何，以及人们对刺激物的反应会随着时间前进而趋于稳定。研究金钱的历史对这类认识很有帮助。</p><h1 id="13-容错空间"><a href="#13-容错空间" class="headerlink" title="13. 容错空间"></a>13. 容错空间</h1><p>每个计划中最重要的部分，就是为计划赶不上变化的情况做好预案。</p><p>在对你未来收益进行估算时，要预留出容错空间。比如：预估值比历史平均值低1&#x2F;3。</p><blockquote><p>熊市、医疗事故，这些意外都会对你的退休账户造成影响，你无法像计划中那样准时退休了。但预留容错空间，则可以做一些缓冲。</p><p>“获得幸福的最佳方式是把目标定得低一点。” ——查理·芒格</p></blockquote><p>你必须先生存下来，才有可能获得成功。可以把钱规划成“哑铃状”。用一部分来冒险，保守地把持另一部分。</p><h1 id="14-人是会变的"><a href="#14-人是会变的" class="headerlink" title="14. 人是会变的"></a>14. 人是会变的</h1><p>坚持长期计划比你想象中难得多，因为我们的目标和想法总在改变。</p><p>人们能敏锐地意识到自己相比过去发生的变化，但很容易低估自己的性格、想法和目标在将来会发生的变化。</p><p>复利的第一条原则：除非万不得已，永远不要打断定投的这个过程。</p><blockquote><p>巴菲特可以几十年如一日地坚持做一件事，让复利的雪球越滚越大。</p></blockquote><blockquote><p>一些年轻人选择了工资不高的清贫生活，但它们很喜欢这种生活方式。也有一些人为了过上奢侈的生活而拼命工作，而他们同样热爱这种生活方式。</p><p>人选择这两种生活都存在风险：前者可能要面对无法养家糊口或者安度晚年的结果，后者可能会面对把大号的青春时光浪费在格子间的悔恨。</p></blockquote><p>在做长期决定时，牢记两个原则：</p><ol><li><p><strong>应该避免极端的规划目标。</strong>无论在工作生涯的哪个节点，都要定下均衡的目标：<strong>每年做好适中的储蓄，给自己适度的自由时间，让通勤不超过适当的时长，至少花适量的时间来陪伴家人。</strong></p></li><li><p><strong>慢慢接受自己的想法一直在改变的事实。</strong>接受事物在不断改变的事实，并在需要应变的时候尽快行动。</p></li></ol><h1 id="15-世上没有免费的午餐"><a href="#15-世上没有免费的午餐" class="headerlink" title="15. 世上没有免费的午餐"></a>15. 世上没有免费的午餐</h1><p>晨星公司实践：除了少数的几只基金，进行战术性资产配置的共同基金比指数基金收益更少，波动更大，和指数基金面临同样大的下行风险。投资者原本试图规避这份代价，结果却付出了双倍的代价。</p><blockquote><p>进行战术性资产配置的共同基金：抓住合适的时机在股票和债券之间进行切换，从而在下行风险较低时获得市场回报。这种策略希望在不付出代价的情况下获得回报。</p></blockquote><p>正确的理财心态：把市场波动看作<strong>要支付的价钱</strong>而不是该缴纳的罚款。这可以让你坚持一项理财策略足够久，最终获得长期的投资收益。</p><h1 id="16-每个人的情况不同"><a href="#16-每个人的情况不同" class="headerlink" title="16. 每个人的情况不同"></a>16. 每个人的情况不同</h1><p>不要贸然从那些和你情况不同的人身上学习理财经验。</p><p>泡沫形成：当短期回报的动量吸引了足够多的资金，使投资者的主体从长线投资者变为短线投资者时。</p><p>长线投资者和短线投资者玩的是两个截然不同的游戏。长线投资者奉行的是估值相关的理念，而短线投资者不关注绝对值，只关注未来和当下的差值。</p><h1 id="17-悲观主义的诱惑"><a href="#17-悲观主义的诱惑" class="headerlink" title="17. 悲观主义的诱惑"></a>17. 悲观主义的诱惑</h1><p>一旦结果与预期相反，事先做好最坏打算就成了让自己感到惊喜的最佳方式。</p><p>极好和极糟的环境都很难长期维持，因为市场的供需会以很难预测的方式对环境进行适应。</p><blockquote><p>以石油为例：产量是固定的，需求上升，水力压裂和水平钻井等新技术也快速发展。</p><p>需求是所有创新与发明之母。</p></blockquote><h1 id="18-当你相信一切的时候"><a href="#18-当你相信一切的时候" class="headerlink" title="18. 当你相信一切的时候"></a>18. 当你相信一切的时候</h1><p>大多数人在面对不理解的事物时都没有意识到，因为它们都能根据自己认识世界的独特视角和经历创造出一种在自己看来说得通的解释，无论其视角和经历是多么片面。</p><h1 id="19-总结"><a href="#19-总结" class="headerlink" title="19. 总结"></a>19. 总结</h1><p>建议：</p><ul><li>当事态朝正确方向发展时，要保持谦逊；当事态朝错误方向发展时，要心怀谅解和同情。</li><li>虚荣越少，财富越多。</li><li>用能让你睡踏实的方式来理财。</li><li>如果你想提高投资回报，最简单而有效的方法就是拉长时间。</li><li>就算很多事出了错，也不要心态失衡。（尾事件的力量）</li><li>利用财富来获取对时间的掌控。在任何时候和喜欢的人去做喜欢的事而且想做多久就做多久的能力，才是财富能带给你的最大红利。</li><li>多一些善意，少一些奢侈。</li><li>存钱。存就是了，存钱不需要什么特定理由。</li><li>明确成功需要付出的代价。</li><li>重视容错空间。</li><li>避免设定极端的财务目标。</li><li>你应该喜欢风险，因为长期看它能带给你回报。但不能冒毁灭性的风险。</li><li>尊重每一个人。不存在统一的正确答案，适合自己的才是最好的。</li></ul><h1 id="20-作者的理财方案"><a href="#20-作者的理财方案" class="headerlink" title="20. 作者的理财方案"></a>20. 作者的理财方案</h1><p>重要的理财决策并不是依靠表格或教科书做出的，而是在餐桌上敲定的。这些决策的目的往往不是追求最高的回报，而是尽量降低让伴侣或孩子失望的可能。</p><p>维持一种低于经济能力的生活方式的附加好处：防止你产生攀比心理。在你负担得起的范围内舒适地生活，不产生过多欲望，你会避免现代西方世界中许多人要承受的巨大社会压力。</p><blockquote><p>“退出无谓的激烈竞争 ，以获得内心平静为目标来调节你的行为，才是真正的成功。”——纳西姆·塔勒布</p></blockquote><p>对大多数投资者来说，用平均成本法去投资低成本的指数基金，将是长线投资成功率最高的选择。</p><blockquote><p>平均成本法：一种以定期及定额投资去积累资产（包括股票及基金）的方法，即“定投”。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>financing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git Commit Emoji</title>
    <link href="/posts/27aeea85.html"/>
    <url>/posts/27aeea85.html</url>
    
    <content type="html"><![CDATA[<h1 id="Git-Commit-Emoji"><a href="#Git-Commit-Emoji" class="headerlink" title="Git Commit Emoji"></a>Git Commit Emoji</h1><p>参考网站：<a href="https://gitmoji.dev/">https://gitmoji.dev</a></p><p>搜索emoji：<a href="https://emojidb.org/">https://emojidb.org/</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令学习</title>
    <link href="/posts/a91d5dfc.html"/>
    <url>/posts/a91d5dfc.html</url>
    
    <content type="html"><![CDATA[<h1 id="Git常用命令学习"><a href="#Git常用命令学习" class="headerlink" title="Git常用命令学习"></a>Git常用命令学习</h1><p>推荐一个可视化git学习网站：<a href="https://learngitbranching.js.org/">https://learngitbranching.js.org/</a></p><h2 id="常用命令举例"><a href="#常用命令举例" class="headerlink" title="常用命令举例"></a>常用命令举例</h2><h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><ol><li><p>作用：（強制）移動 main 指向從 HEAD 往上數的第三個 parent commit。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -f main HEAD~3<br><span class="hljs-comment"># git branch -f main HEAD^: 往上移一个</span><br></code></pre></td></tr></table></figure></li><li><p>作用：把b及往父亲方向走直到和a的公共祖宗节点之前的路径上节点接到a的后面</p><blockquote><p>如果b是a的祖宗，则没有效果</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase a b<br><br><span class="hljs-comment"># 等价于现在HEAD在b，执行以下命令：</span><br>git rebase a<br></code></pre></td></tr></table></figure><p>怎么记？rebase a也就是换base为a，把当前commit（b）的base换成a，b接到a的后面</p></li><li><p>从当前commit新建一条分支<code>bugFix</code>，并切换到<code>bugFix</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b bugFix<br><span class="hljs-comment"># 等价于：</span><br>git branch bugFix<br>git checkout bugFix<br></code></pre></td></tr></table></figure></li><li><p>取消git修改：<code>git reset</code>或者<code>git revert</code>，例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset HEAD~3<br>git revert HEAD<br></code></pre></td></tr></table></figure></li><li><p>把commit a, b, c依次接到当前指针所在commit的后面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cherry-pick a b c<br></code></pre></td></tr></table></figure></li></ol><h3 id="远端"><a href="#远端" class="headerlink" title="远端"></a>远端</h3><ol><li><p>表示一個 fetch 以及一個 rebase。用于远端其他人提交新commit之后更新到本地，并与本地自己的更新合并（适用于在同一个分支开发）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull --rebase<br></code></pre></td></tr></table></figure><blockquote><p>本地在dev分支开发，如果远端master更新了，需要把变更合并到本地dev（本地的master一般不会动，如果动了就加个<code>--rebase</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br>git pull<br>git checkout dev<br>git rebase master / git merge master<br></code></pre></td></tr></table></figure></blockquote></li><li><p>建立一個新的 totallyNotMain branch 並且它會 track origin&#x2F;main。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b totallyNotMain origin/main<br><span class="hljs-comment"># 等价于</span><br>git branch -u origin/main totallyNotMain<br></code></pre></td></tr></table></figure></li><li><p>先到我的 repo 中的 “main” branch，抓下所有的 commit，然後到叫作 “origin” 的 remote 的 “main” branch，檢查 remote 的 commit 有沒有跟我的 repo 一致，如果沒有，就更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push &lt;remote&gt; &lt;place&gt;<br><span class="hljs-comment"># 如：</span><br>git push origin main<br></code></pre></td></tr></table></figure><blockquote><p>这个命令就不需要local当前指针一定指向main了</p></blockquote></li><li><p>當我們的 source 以及 destination 是不同的branch的時候用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin &lt;<span class="hljs-built_in">source</span>&gt;:&lt;destination&gt;<br></code></pre></td></tr></table></figure></li><li><p>git 會到 remote 上的 foo branch，抓下所有不在 local 上的 commit，然後將它們放到 local 的 o&#x2F;foo branch。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin foo<br></code></pre></td></tr></table></figure></li><li><p>git pull 表示 fetch 之後再 merge 所 fetch 的 commit，當使用 git fetch 時使用一樣的參數，之後再從 fetch 下來的 commit 所放置的位置做 merge。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin foo<br><span class="hljs-comment"># 等价于</span><br>git fetch origin foo; git merge o/foo<br><br>git pull origin bar~1:bugFix<br><span class="hljs-comment"># 等价于</span><br>git fetch origin bar~1:bugFix; git merge bugFix<br></code></pre></td></tr></table></figure></li></ol><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="reset-vs-revert"><a href="#reset-vs-revert" class="headerlink" title="reset vs revert"></a>reset vs revert</h3><ol><li><code>reset</code>参数指针为当前指针所在branch需要回退到的位置；而<code>revert</code>参数指针为需要修改的那个指针</li><li><code>reset</code>可以往回退很多个commit；而<code>revert</code>只能取消修改一个commit（后面跟的参数是指针）</li><li><code>reset</code>相当于只把指针往回移动若干步，别人无法看到这个变化；而<code>revert</code>是把当前commit的前一个commit接到当前commit后面，对其他人也可见。</li></ol><h3 id="rebase-vs-merge"><a href="#rebase-vs-merge" class="headerlink" title="rebase vs merge"></a>rebase vs merge</h3><p><code>rebase</code>优点：rebase 使得你的 commit tree 看起來更為簡潔，因為任何的 commit 都在一條直線上面。</p><p><code>rebase</code>缺点：rebase 修改了 commit tree 的歷史紀錄。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-32. Combine generics and varargs judiciously</title>
    <link href="/posts/ad1c0464.html"/>
    <url>/posts/ad1c0464.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-32-Combine-generics-and-varargs-judiciously"><a href="#Item-32-Combine-generics-and-varargs-judiciously" class="headerlink" title="Item 32: Combine generics and varargs judiciously"></a>Item 32: Combine generics and varargs judiciously</h1><p>Recall from Item 28 that a non-reifiable type is one whose runtime representation has less information than its compile-time representation, and that <strong>nearly all generic and parameterized types are non-reifiable</strong>. </p><p>If <strong>a method declares its varargs parameter to be of a non-reifiable type</strong>, the compiler generates a warning on the declaration. If <strong>the method is invoked on varargs parameters whose inferred type is non-reifiable</strong>, the compiler generates a warning on the invocation too. The warnings look something like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">warning: [unchecked] Possible heap pollution from<br>       parameterized vararg type List&lt;String&gt;<br></code></pre></td></tr></table></figure><blockquote><p><em>Heap pollution</em> occurs when a variable of a parameterized type refers to an object that is not of that type. It can cause the compiler’s automatically generated casts to fail, violating the fundamental guarantee of the generic type system.</p></blockquote><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Mixing generics and varargs can violate type safety! </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dangerous</span><span class="hljs-params">(List&lt;String&gt;... stringLists)</span> &#123;<br>  List&lt;Integer&gt; intList = List.of(<span class="hljs-number">42</span>);<br>  Object[] objects = stringLists;<br>  objects[<span class="hljs-number">0</span>] = intList; <span class="hljs-comment">// Heap pollution </span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> stringLists[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// ClassCastException</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>It is unsafe to store a value in a generic varargs array parameter.</strong></p><blockquote><p>Why is it even legal to declare a method with a generic varargs parameter, when it is illegal to create a generic array explicitly? - Methods with varargs parameters of generic or parameterized types can be very useful in practice, so the language designers opted to live with this inconsistency. In fact, the Java libraries export several such methods, including <code>Arrays.asList(T... a)</code>, <code>Collections.addAll(Collection&lt;? super T&gt; c, T... elements)</code>, and <code>EnumSet.of(E first, E... rest)</code>. Unlike the dangerous method shown earlier, these library methods are typesafe.</p></blockquote><p>In Java 7, the <code>SafeVarargs</code> annotation was added to the platform, to allow the author of a method with a generic varargs parameter to suppress client warnings automatically. <strong>In essence, the <code>SafeVarargs</code> annotation constitutes a promise by the author of a method that it is typesafe.</strong> In exchange for this promise, the compiler agrees not to warn the users of the method that calls may be unsafe.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, varargs and generics do not interact well because the varargs facility is a leaky abstraction built atop arrays, and arrays have different type rules from generics. Though generic varargs parameters are not typesafe, they are legal.</p><p>If you choose to write a method with a generic (or parameterized) varargs parameter, first ensure that the method is typesafe, and then annotate it with <code>@SafeVarargs</code> so it is not unpleasant to use.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-31. Use bounded wildcards to increase API flexibility</title>
    <link href="/posts/17490073.html"/>
    <url>/posts/17490073.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-31-Use-bounded-wildcards-to-increase-API-flexibility"><a href="#Item-31-Use-bounded-wildcards-to-increase-API-flexibility" class="headerlink" title="Item 31: Use bounded wildcards to increase API flexibility"></a>Item 31: Use bounded wildcards to increase API flexibility</h1><h2 id="Get-and-Put-Principle"><a href="#Get-and-Put-Principle" class="headerlink" title="Get and Put Principle"></a>Get and Put Principle</h2><p><strong>For maximum flexibility, use wildcard types on input parameters that represent producers or consumers.</strong></p><p><strong>PECS</strong> stands for <strong>producer-extends, consumer-super</strong>.</p><blockquote><p>In other words, if a parameterized type represents a T producer, use <code>&lt;? extends T&gt;</code>; if it represents a T consumer, use <code>&lt;? super T&gt;</code>.</p></blockquote><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; T <span class="hljs-title function_">max</span><span class="hljs-params">( List&lt;? extends T&gt; list)</span><br></code></pre></td></tr></table></figure><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p><strong>Do not use bounded wildcard types as return types.</strong> </p><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="hljs-title function_">union</span><span class="hljs-params">(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2)</span><br></code></pre></td></tr></table></figure><p>The return type is <code>Set&lt;E&gt;</code>.</p></li><li><p><strong>If a type parameter appears only once in a method declaration, replace it with a wildcard.</strong></p><p>If it’s an unbounded type parameter, replace it with an unbounded wildcard; </p><p>if it’s a bounded type parameter, replace it with a bounded wildcard.</p><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Two possible declarations for the swap method</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(List&lt;E&gt; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(List&lt;?&gt; list, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>In a public API, the second is better because it’s simpler.</p></blockquote></li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, using wildcard types in your APIs, while tricky, makes the APIs far more flexible. </p><blockquote><p>If you write a library that will be widely used, the proper use of wildcard types should be considered mandatory. </p></blockquote><p>Remember the basic rule: <strong>producer-extends, consumer-super (PECS)</strong>. </p><p>Also remember <strong>that all comparables and comparators are consumers</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-30. Favor generic methods</title>
    <link href="/posts/f57ac089.html"/>
    <url>/posts/f57ac089.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-30-Favor-generic-methods"><a href="#Item-30-Favor-generic-methods" class="headerlink" title="Item 30: Favor generic methods"></a>Item 30: Favor generic methods</h1><h2 id="Occasion-1"><a href="#Occasion-1" class="headerlink" title="Occasion 1"></a>Occasion 1</h2><p>On occasion, you will need to create an object that is immutable but applicable to many different types. Because generics are implemented by erasure (Item 28), you can use a single object for all required type parameterizations, but you need to write a <em>static factory method</em> to repeatedly dole out (分发) the object for each requested type parameterization. </p><blockquote><p>This pattern, called the <em>generic singleton factory</em>, is used for function objects (Item 42) such as <code>Collections.reverseOrder</code>, and occasionally for collections such as <code>Collections.emptySet</code>.</p></blockquote><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Suppose that you want to write an identity function dispenser. </p><blockquote><p>The libraries provide Function.identity, so there’s no reason to write your own (Item 59), but it is instructive. </p></blockquote><p>It would be wasteful to create a new identity function object time one is requested, because it’s stateless. If Java’s generics were reified, you would need one identity function per type, but since they’re erased a generic singleton will suffice. Here’s how it looks:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Generic singleton factory pattern</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> UnaryOperator&lt;Object&gt; IDENTITY_FN = (t) -&gt; t;<br><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; UnaryOperator&lt;T&gt; <span class="hljs-title function_">identityFunction</span><span class="hljs-params">()</span> &#123; <br>  <span class="hljs-keyword">return</span> (UnaryOperator&lt;T&gt;) IDENTITY_FN;<br>&#125;<br></code></pre></td></tr></table></figure><p>The cast of <code>IDENTITY_FN</code> to (<code>UnaryFunction&lt;T&gt;</code>) generates an unchecked cast warning, as <code>UnaryOperator&lt;Object&gt;</code> is not a <code>UnaryOperator&lt;T&gt;</code> for every T. But the identity function is special: it returns its argument unmodified, so we know that it is typesafe to use it as a UnaryFunction<T>, whatever the value of T. Therefore, we can confidently suppress the unchecked cast warning generated by this cast.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sample program to exercise generic singleton</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <br>   String[] strings = &#123; <span class="hljs-string">&quot;jute&quot;</span>, <span class="hljs-string">&quot;hemp&quot;</span>, <span class="hljs-string">&quot;nylon&quot;</span> &#125;;<br>   UnaryOperator&lt;String&gt; sameString = identityFunction();<br>   <span class="hljs-keyword">for</span> (String s : strings)<br>       System.out.println(sameString.apply(s));<br>  <br>   Number[] numbers = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3L</span> &#125;;<br>   UnaryOperator&lt;Number&gt; sameNumber = identityFunction();<br>   <span class="hljs-keyword">for</span> (Number n : numbers)<br>       System.out.println(sameNumber.apply(n));<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Occasion-2"><a href="#Occasion-2" class="headerlink" title="Occasion 2"></a>Occasion 2</h2><p>It is permissible, though relatively rare, for a type parameter to be bounded by some expression involving that type parameter itself. This is what’s known as a <em><strong>recursive type bound</strong></em>. </p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>A common use of recursive type bounds is in connection with the <code>Comparable</code> interface, which defines a type’s natural ordering (Item 14). In practice, nearly all types can be compared only to elements of their own type. This interface is shown here:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Many methods take a collection of elements implementing <code>Comparable</code> to sort it, search within it, calculate its minimum or maximum, and the like. To do these things, it is required that every element in the collection be comparable to every other element in it, in other words, that the elements of the list be <em>mutually comparable (互相比较)</em>. Here is how to express that constraint:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Using a recursive type bound to express mutual comparability </span><br><span class="hljs-comment">// Returns max value in a collection - uses recursive type bound</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;E&gt;&gt; E <span class="hljs-title function_">max</span><span class="hljs-params">(Collection&lt;E&gt; c)</span> &#123; <br>  <span class="hljs-keyword">if</span> (c.isEmpty())<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Empty collection&quot;</span>);<br>  <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">for</span> (E e : c) &#123;<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span> || e.compareTo(result) &gt; <span class="hljs-number">0</span>)<br>    result = Objects.requireNonNull(e);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>The type bound <code>&lt;E extends Comparable&lt;E&gt;&gt;</code> may be read as “any type E that can be compared to itself,” which corresponds more or less precisely to the notion of mutual comparability.</p><blockquote><p>Note that this method throws IllegalArgumentException if the list is empty. A better alternative would be to return an <code>Optional&lt;E&gt;</code> (Item 55).</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, generic methods, like generic types, are safer and easier to use than methods requiring their clients to put explicit casts on input parameters and return values. </p><p>Like types, you should make sure that your methods can be used <strong>without casts</strong>, which often means making them generic. </p><p>And like types, you should generify existing methods whose use requires casts. This makes life easier for new users without breaking existing clients (Item 26).</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-29. Favor generic types</title>
    <link href="/posts/ef1fe5d7.html"/>
    <url>/posts/ef1fe5d7.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-29-Favor-generic-types"><a href="#Item-29-Favor-generic-types" class="headerlink" title="Item 29: Favor generic types"></a>Item 29: Favor generic types</h1><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Object-based collection - a prime candidate for generics</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br>  <span class="hljs-keyword">private</span> Object[] elements;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span> &#123;<br>    elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Object e)</span> &#123; <br>    ensureCapacity(); elements[size++] = e;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyStackException</span>();<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> elements[--size];<br>    elements[size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Eliminate obsolete reference </span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">if</span> (elements.length == size)<br>         elements = Arrays.copyOf(elements, <span class="hljs-number">2</span> * size + <span class="hljs-number">1</span>);<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>This class should have been parameterized to begin with, but since it wasn’t, we can <em>generify</em> it after the fact.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Initial attempt to generify Stack - won&#x27;t compile! </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;E&gt; &#123;<br>  <span class="hljs-keyword">private</span> E[] elements;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span> &#123;<br>    elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">E</span>[DEFAULT_INITIAL_CAPACITY];<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E e)</span> &#123; <br>    ensureCapacity(); elements[size++] = e;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyStackException</span>();<br>    <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> elements[--size];<br>    elements[size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Eliminate obsolete reference return result;</span><br>  &#125;<br>  ... <span class="hljs-comment">// no changes in isEmpty or ensureCapacity</span><br>&#125;<br></code></pre></td></tr></table></figure><p>You’ll generally get at least one error or warning:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stack.java:<span class="hljs-number">8</span>: generic array <span class="hljs-type">creation</span><br>  <span class="hljs-variable">elements</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">E</span>[DEFAULT_INITIAL_CAPACITY];<br>   ^<br></code></pre></td></tr></table></figure><p>As explained in Item 28, you can’t create an array of a non-reifiable type, such as E. This problem arises every time you write a generic type that is backed by an array.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>The first way: directly circumvents the prohibition on generic array creation: create an array of <code>Object</code> and cast it to the generic array type. Now in place of an error, the compiler will emit a warning. This usage is legal, but it’s not (in general) typesafe:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Stack.java:<span class="hljs-number">8</span>: warning: [unchecked] unchecked cast<br>found: Object[], required: E[]<br>elements = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];<br>^<br></code></pre></td></tr></table></figure><blockquote><p>The compiler may not be able to prove that your program is typesafe, but you can. You must convince yourself that the unchecked cast will not compromise the type safety of the program. The array in question (elements) is stored in a private field and never returned to the client or passed to any other method. The only elements stored in the array are those passed to the push method, which are of type <code>E</code>, so the unchecked cast can do no harm.</p></blockquote><p>Once you’ve proved that an unchecked cast is safe, suppress the warning in as narrow a scope as possible (Item 27). With the addition of an annotation to do this, Stack compiles cleanly, and you can use it without explicit casts or fear of a <code>ClassCastException</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// The elements array will contain only E instances from push(E). </span><br><span class="hljs-comment">// This is sufficient to ensure type safety, but the runtime</span><br><span class="hljs-comment">// type of the array won&#x27;t be E[]; it will always be Object[]! </span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span> &#123;<br>   elements = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>The second way to eliminate the generic array creation error in Stack is to change the type of the field elements from <code>E[]</code> to <code>Object[]</code>. If you do this, you’ll get a different error:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Stack.java:<span class="hljs-number">19</span>: incompatible types<br>found: Object, required: E<br><span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> elements[--size];<br> ^<br></code></pre></td></tr></table></figure><p>You can change this error into a warning by casting the element retrieved from the array to <code>E</code>, but you will get a warning:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Stack.java:<span class="hljs-number">19</span>: warning: [unchecked] unchecked cast<br>found: Object, required: E<br><span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (E) elements[--size]; <br> ^<br></code></pre></td></tr></table></figure><p>Because <code>E</code> is a non-reifiable type, there’s no way the compiler can check the cast at runtime. Again, you can easily prove to yourself that the unchecked cast is safe, so it’s appropriate to suppress the warning.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Appropriate suppression of unchecked warning</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyStackException</span>();<br><span class="hljs-comment">// push requires elements to be of type E, so cast is correct </span><br>  <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <br>  <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (E) elements[--size];<br>  elements[size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Eliminate obsolete reference</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h2><p>Both techniques for eliminating the generic array creation have their adherents. </p><ul><li><p>The first is more readable: the array is declared to be of type <code>E[]</code>, clearly indicating that it contains only <code>E</code> instances;</p></li><li><p>The first is also more concise: in a typical generic class, you read from the array at many points in the code; </p></li><li><p>The first technique requires only a single cast (where the array is created), while the second requires a separate cast each time an array element is read. </p></li><li><p>However, the first causes <em>heap pollution</em> (Item 32): the runtime type of the array does not match its compile-time type (unless <code>E</code> happens to be <code>Object</code>). </p><blockquote><p>This makes some programmers sufficiently queasy that they opt for the second technique, though the heap pollution is harmless in this situation.</p></blockquote></li></ul><p>Overall, the first technique is preferable and more commonly used in practice. </p><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>The great majority of generic types are like our <code>Stack</code> example in that their type parameters have no restrictions: you can create a <code>Stack&lt;Object&gt;</code>, <code>Stack&lt;int[]&gt;</code>, <code>Stack&lt;List&lt;String&gt;&gt;</code>, or <code>Stack</code> of any other object reference type. </p><p>Note that <strong>you can’t create a <code>Stack</code> of a primitive type</strong>: trying to create a <code>Stack&lt;int&gt;</code> or <code>Stack&lt;double&gt;</code> will result in a compile-time error. This is a fundamental limitation of Java’s generic type system. You can work around this restriction by using boxed primitive types (Item 61).</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, generic types are safer and easier to use than types that require casts in client code. When you design new types, make sure that they can be used without such casts. This will often mean making the types generic. </p><p>If you have any existing types that should be generic but aren’t, generify them. This will make life easier for new users of these types without breaking existing clients (Item 26).</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-28. Prefer lists to arrays</title>
    <link href="/posts/3178c17b.html"/>
    <url>/posts/3178c17b.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-28-Prefer-lists-to-arrays"><a href="#Item-28-Prefer-lists-to-arrays" class="headerlink" title="Item 28: Prefer lists to arrays"></a>Item 28: Prefer lists to arrays</h1><h2 id="Difference-between-arrays-and-generic-types"><a href="#Difference-between-arrays-and-generic-types" class="headerlink" title="Difference between arrays and generic types"></a>Difference between arrays and generic types</h2><ol><li><p><strong>Arrays are <em>covariant</em>, generics are <em>invariant</em>.</strong></p><blockquote><p>If <code>Sub</code> is a subtype of <code>Super</code>, then the array type <code>Sub[]</code> is a subtype of the array type <code>Super[]</code>.</p><p>For any two distinct types <code>Type1</code> and <code>Type2</code>, <code>List&lt;Type1&gt;</code> is neither a subtype nor a supertype of <code>List&lt;Type2&gt;</code>.</p></blockquote></li><li><p><strong>Arrays are <em>reified</em>, generics are implemented by <em>erasure</em>.</strong></p><p>Arrays know and enforce their element type at runtime.</p><p>Generics enforce their type constraints only at compile time and discard (or <em>erase</em>) their element type information at runtime.</p></li></ol><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>Because of the fundamental differences above, arrays and generics do not mix well.</p><p>For example, <strong>it is illegal to create an array of a generic type, a parameterized type, or a type parameter</strong>. Therefore, none of these array creation expressions are legal: <code>new List&lt;E&gt;[]</code>, <code>new List&lt;String&gt;[]</code>, <code>new E[]</code>. All will result in <em>generic array creation</em> errors at compile time.</p><blockquote><p>It is legal, though rarely useful, to create arrays of unbounded wildcard types.</p></blockquote><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>Because it isn’t typesafe. If it were legal, casts generated by the compiler in an otherwise correct program could fail at runtime with a <code>ClassCastException</code>. This would violate the fundamental guarantee provided by the generic type system.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Why generic array creation is illegal - won&#x27;t compile! </span><br>List&lt;String&gt;[] stringLists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&lt;String&gt;[<span class="hljs-number">1</span>]; <span class="hljs-comment">// Compile-time error, but let&#x27;s pretend it is legal</span><br>List&lt;Integer&gt; intList = List.of(<span class="hljs-number">42</span>);<br>Object[] objects = stringLists;<br>objects[<span class="hljs-number">0</span>] = intList;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> stringLists[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// ClassCastException</span><br></code></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>When you get a generic array creation error or an unchecked cast warning on a cast to an array type, the best solution is often to <strong>use the collection type <code>List&lt;E&gt;</code> in preference to the array type <code>E[]</code>.</strong> You might sacrifice some conciseness or performance, but in exchange you get better type safety and interoperability.</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>For example, suppose you want to write a <code>Chooser</code> class with a constructor that takes a collection, and a single method that returns an element of the collection chosen at random.</p><blockquote><p>Depending on what collection you pass to the constructor, you could use a chooser as a game die, a magic 8-ball, or a data source for a Monte Carlo simulation.</p></blockquote><h5 id="Simplistic-implementation-without-generics"><a href="#Simplistic-implementation-without-generics" class="headerlink" title="Simplistic implementation without generics:"></a>Simplistic implementation without generics:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Chooser - a class badly in need of generics!</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Chooser</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] choiceArray;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chooser</span><span class="hljs-params">(Collection choices)</span> &#123;<br>     choiceArray = choices.toArray();<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">choose</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">Random</span> <span class="hljs-variable">rnd</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current();<br>     <span class="hljs-keyword">return</span> choiceArray[rnd.nextInt(choiceArray.length)];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>To use this class, you have to cast the choose method’s return value from Object to the desired type every time you use invoke the method, and the cast will fail at runtime if you get the type wrong.</p><h5 id="We-attempt-to-modify-Chooser-to-make-it-generic-Item-29"><a href="#We-attempt-to-modify-Chooser-to-make-it-generic-Item-29" class="headerlink" title="We attempt to modify Chooser to make it generic (Item 29):"></a>We attempt to modify <code>Chooser</code> to make it generic (Item 29):</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// A first cut at making Chooser generic - won&#x27;t compile </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Chooser</span>&lt;T&gt; &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T[] choiceArray;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chooser</span><span class="hljs-params">(Collection&lt;T&gt; choices)</span> &#123; <br>    choiceArray = (T[]) choices.toArray();<br>  &#125;<br>  <br>  <span class="hljs-comment">// choose method unchanged</span><br>&#125;<br></code></pre></td></tr></table></figure><p>You get a warning: <code>required: T[], found: Object[]</code>. The compiler is telling you that it can’t vouch for the safety of the cast at runtime because the program won’t know what type T represents—remember, element type information is erased from generics at runtime.</p><p>Will the program work? Yes, but the compiler can’t prove it. You could prove it to yourself, put the proof in a comment and suppress the warning with an annotation, but you’re better off eliminating the cause of warning (Item 27).</p><h5 id="To-eliminate-the-unchecked-cast-warning-use-a-list-instead-of-an-array"><a href="#To-eliminate-the-unchecked-cast-warning-use-a-list-instead-of-an-array" class="headerlink" title="To eliminate the unchecked cast warning, use a list instead of an array:"></a>To eliminate the unchecked cast warning, use a list instead of an array:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// List-based Chooser - typesafe</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Chooser</span>&lt;T&gt; &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;T&gt; choiceList;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chooser</span><span class="hljs-params">(Collection&lt;T&gt; choices)</span> &#123; <br>    choiceList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(choices);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> T <span class="hljs-title function_">choose</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Random</span> <span class="hljs-variable">rnd</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current();<br>    <span class="hljs-keyword">return</span> choiceList.get(rnd.nextInt(choiceList.size()));<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>This version is a tad more verbose, and perhaps a tad slower, but it’s worth it for the peace of mind that you won’t get a ClassCastException at runtime.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Arrays and generics have very different type rules. Arrays are covariant and reified; generics are invariant and erased. As a consequence, arrays provide runtime type safety but not compile-time type safety, and vice versa for generics. </p><p>As a rule, arrays and generics don’t mix well. If you find yourself mixing them and getting compile-time errors or warnings, your first impulse should be to replace the arrays with lists.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-27. Eliminate unchecked warnings</title>
    <link href="/posts/7f4caf04.html"/>
    <url>/posts/7f4caf04.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-27-Eliminate-unchecked-warnings"><a href="#Item-27-Eliminate-unchecked-warnings" class="headerlink" title="Item 27: Eliminate unchecked warnings"></a>Item 27: Eliminate unchecked warnings</h1><p>When you program with generics, you will see many compiler warnings: unchecked cast warnings, unchecked method invocation warnings, unchecked parameterized vararg type warnings, and unchecked conversion warnings.</p><h2 id="Rule"><a href="#Rule" class="headerlink" title="Rule"></a>Rule</h2><p><strong>Eliminate every unchecked warning that you can.</strong> If you eliminate all warnings, you are assured that your code is typesafe, which is a very good thing. It means that you won’t get a <code>ClassCastException</code> at runtime.</p><h3 id="Suppress-a-warning"><a href="#Suppress-a-warning" class="headerlink" title="Suppress a warning"></a>Suppress a warning</h3><p><strong>If you can’t eliminate a warning, but you can prove that the code that provoked the warning is typesafe, then (and only then) suppress the warning with an</strong> <strong><code>@SuppressWarnings(&quot;unchecked&quot;)</code></strong> <strong>annotation.</strong></p><blockquote><p>If you suppress warnings without first proving that the code is typesafe, you are giving yourself a false sense of security. The code may compile without emitting any warnings, but it can still throw a <code>ClassCastException</code> at runtime. </p><p>If, however, you ignore unchecked warnings that you know to be safe (instead of suppressing them), you won’t notice when a new warning crops up that represents a real problem. <strong>The new warning will get lost amidst all the false alarms that you didn’t silence.</strong></p></blockquote><p><strong>Always use the</strong> <strong><code>SuppressWarnings</code></strong> <strong>annotation on the smallest scope possible.</strong> Typically this will be a <strong>variable declaration</strong> or a <strong>very short method</strong> or <strong>constructor</strong>. Never use <code>SuppressWarnings</code> on an entire class.</p><blockquote><p>If you find yourself using the <code>SuppressWarnings</code> annotation on a method or constructor that’s more than one line long, you may be able to move it onto <strong>a local variable declaration</strong>. You may have to declare a new local variable, but it’s worth it.</p></blockquote><p>**Every time you use a <code>@SuppressWarnings(&quot;unchecked&quot;)</code> annotation, add a comment saying why it is safe to do so. **This will help others understand the code, and more importantly, it will decrease the odds that someone will modify the code so as to make the computation unsafe.</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>Consider the <code>toArray</code> method, which comes from <code>ArrayList</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<br>  <span class="hljs-keyword">if</span> (a.length &lt; size)<br>  <span class="hljs-keyword">return</span> (T[]) Arrays.copyOf(elements, size, a.getClass()); System.arraycopy(elements, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);<br>  <span class="hljs-keyword">if</span> (a.length &gt; size)<br>    a[size] = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>If you compile <code>ArrayList</code>, the method generates this warning:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList.java:<span class="hljs-number">305</span>: warning: [unchecked] unchecked cast<br>    <span class="hljs-title function_">return</span> <span class="hljs-params">(T[])</span> Arrays.copyOf(elements, size, a.getClass());<br>                               ^<br>    required: T[]<br>    found:    Object[]<br></code></pre></td></tr></table></figure><p><strong>Solution</strong>: declare a local variable to hold the return value and annotate its declaration, like so:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Adding local variable to reduce scope of @SuppressWarnings</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<br>   <span class="hljs-keyword">if</span> (a.length &lt; size) &#123;<br>    <span class="hljs-comment">// This cast is correct because the array we&#x27;re creating // is of the same type as the one passed in, which is T[]. </span><br>      <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> T[] result =<br>         (T[]) Arrays.copyOf(elements, size, a.getClass());<br>      <span class="hljs-keyword">return</span> result;<br>   &#125;<br>   System.arraycopy(elements, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);<br>   <span class="hljs-keyword">if</span> (a.length &gt; size)<br>       a[size] = <span class="hljs-literal">null</span>;<br>   <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, unchecked warnings are important. Don’t ignore them. Every unchecked warning represents the potential for a <code>ClassCastException</code> at runtime. Do your best to eliminate these warnings. </p><p>If you can’t eliminate an unchecked warning and you can prove that the code that provoked it is typesafe, suppress the warning with a <code>@SuppressWarnings(&quot;unchecked&quot;)</code> annotation in the narrowest possible scope. Record the rationale for your decision to suppress the warning in a comment.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式0-OOP Basic</title>
    <link href="/posts/fff55931.html"/>
    <url>/posts/fff55931.html</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程基础"><a href="#面向对象编程基础" class="headerlink" title="面向对象编程基础"></a>面向对象编程基础</h1><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h4 id="1-封装"><a href="#1-封装" class="headerlink" title="1. 封装"></a>1. 封装</h4><p>每个对象都包含<strong>它能进行操作所需要的所有信息</strong>，这个特性称为封装，因此对象不必依赖其他对象来完成自己的操作。</p><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><ul><li>良好的封装能够减少耦合（让某类和调用该类方法的其他类分离）</li><li>类内部的实现可以自由地修改（不影响其他的类）</li><li>类具有清晰的对外接口（其他类只需要关心这些接口，不用管内部实现）</li></ul><h4 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h4><p>继承定义了类如何<strong>相互关联，共享特性</strong>（is-a, not has-a）。继承的工作方式是，定义父类和子类，或叫作基类和派生类，其中子类继承父类的所有特性。子类不但继承了父类的所有特性，还可以定义新的特性。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>子类拥有父类非private的属性和功能</li><li>子类具有自己的属性和功能，即子类可以扩展父类没有的属性和功能</li><li>子类还可以以自己的方式实现父类的功能（方法重写）</li></ul><p>protected表示继承时子类可以对基类有完全访问权。</p><p>不用继承的话，如果要修改功能，就必须在<strong>所有重复的方法中修改</strong>（枚举类同理），代码越多，出错的可能就越大，而继承的优点是，继承使得所有子类公共的部分都放在了父类，使得代码得到了共享，这就避免了重复，另外，继承可使得修改或扩展继承而来的实现都较为容易。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>父类变，则子类不得不变</li><li>继承会破坏包装，父类实现细节暴露给子类，这其实是增大了两个类之间的耦合性（继承是一种类与类之间<strong>强耦合</strong>的关系）</li></ul><h4 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h4><p>多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行。</p><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul><li>子类以父类的身份出现</li><li>子类在工作时以<strong>自己的方式</strong>来实现（子类可以选择使用override关键字，将父类实现替换为它自己的实现，这就是方法重写Override）</li><li>子类以父类的身份出现时，子类<strong>特有的属性和方法不可以使用</strong></li></ul><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h4 id="抽象类-方法"><a href="#抽象类-方法" class="headerlink" title="抽象类&#x2F;方法"></a>抽象类&#x2F;方法</h4><p>考虑把实例化没有任何意义的父类改成抽象类；把方法体没有意义的方法改成抽象方法。</p><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><ul><li>抽象类不能被实例化（没有意义）</li><li>抽象方法是必须被子类重写的方法（重写之前肯定没有意义）</li><li>如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法</li></ul><h5 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h5><ul><li>应该考虑让抽象类拥有<strong>尽可能多的共同代码</strong>，拥有<strong>尽可能少的数据</strong></li></ul><h5 id="什么时候应该用抽象类？"><a href="#什么时候应该用抽象类？" class="headerlink" title="什么时候应该用抽象类？"></a>什么时候应该用抽象类？</h5><p>抽象类通常代表一个抽象概念，它提供一个<strong>继承的出发点</strong>，当设计一个新的抽象类时，一定是用来继承的。所以，在一个以继承关系形成的等级结构里面，<strong>树叶节点</strong>应当是<strong>具体类</strong>，而<strong>树枝节点</strong>均应当是<strong>抽象类</strong></p><img src="https://s2.loli.net/2023/09/13/VhwuR9FrsnI1SdE.jpg" alt="抽象类和具体类.jpg" style="zoom:40%;" /><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口是把隐式公共方法和属性组合起来，以封装特定功能的一个集合。一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。</p><p>声明接口在语法上与声明抽象类完全相同，但不允许提供接口中任何成员的执行方式。</p><p>实现接口的类就必须要实现接口中的所有方法和属性。</p><p>一个类可以支持多个接口，多个类也可以支持相同的接口。</p><p>接口中的方法或属性前面不能有修饰符、方法没有方法体。</p><h4 id="抽象类vs接口"><a href="#抽象类vs接口" class="headerlink" title="抽象类vs接口"></a>抽象类vs接口</h4><ol><li>抽象类可以给出一些成员的实现，接口却不包含成员的实现</li><li>抽象类的抽象成员可被子类<strong>部分实现</strong>，接口的成员需要实现类<strong>完全实现</strong></li><li>一个类只能继承<strong>一个抽象类</strong>，但可以实现<strong>多个接口</strong></li><li>类是对对象的抽象，<strong>抽象类</strong>是对<strong>类</strong>的抽象，接口是对<strong>行为</strong>的抽象</li><li>如果行为跨越<strong>不同类的对象</strong>，可使用接口；对于一些<strong>相似的类对象</strong>，用继承抽象类<ul><li>接口类似一个功能（如：飞行），实现某接口的不同类之间也许并没有什么关系；而继承抽象类的不同类之间一般关系紧密</li></ul></li><li>从设计角度讲，抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类；而接口是根本不知子类的存在，方法如何实现还不确认，预先定义</li></ol><h2 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h2><p>SOLID 原则是面向对象 class 设计的五条原则。它们是设计 class 结构时应该遵守的准则和最佳实践。</p><h4 id="1-Single-Responsibility-Principle，单一职责原则"><a href="#1-Single-Responsibility-Principle，单一职责原则" class="headerlink" title="1. Single Responsibility Principle，单一职责原则"></a>1. <strong>S</strong>ingle Responsibility Principle，单一职责原则</h4><p>一个 class 应该只做一件事，一个 class 应该只有一个变化的原因。</p><p>应该只有一个软件定义的潜在改变（数据库逻辑、日志逻辑等）能够影响 class 的定义。</p><p>单一职责适用于<strong>接口、类</strong>，同时也适用于<strong>方法</strong>。例如我们需要修改用户密码，有两种方式可以实现，一种是用「修改用户信息接口」实现修改密码，一种是新起一个接口来实现修改密码功能。在单一职责原则的指导下，一个方法只承担一个职能，所以我们应该新起一个接口来实现修改密码的功能。</p><p>在设计一个类的时候，可以先从粗粒度的类开始设计，等到业务发展到一定规模，我们发现这个粗粒度的类方法和属性太多，且经常修改的时候，我们就可以对这个类进行重构了，将这个类拆分成粒度更细的类，这就是所谓的持续重构。</p><h4 id="2-Open-Close-Principle，开闭原则"><a href="#2-Open-Close-Principle，开闭原则" class="headerlink" title="2. Open Close Principle，开闭原则"></a>2. <strong>O</strong>pen Close Principle，开闭原则</h4><p>一个软件实体，如类、模块和函数应该<strong>对扩展开放</strong>，<strong>对修改关闭</strong>。</p><p>当别人要修改软件功能的时候，使他不能修改我们原有代码，只能新增代码实现软件功能修改的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/*反例*/</span><br><span class="hljs-keyword">if</span>(type == apple)&#123;<br>    <span class="hljs-comment">//deal with apple </span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == banana)&#123;<br>    <span class="hljs-comment">//deal with banana</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == ......)&#123;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*正例*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PeelOff</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">peelOff</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplePeelOff</span> implement PeelOff&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">peelOff</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">//deal with apple</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BananaPeelOff</span> implement PeelOff&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">peelOff</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">//deal with banan</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PeelOffFactory</span>&#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String, PeelOff&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//init all the Class that implements PeelOff interface </span><br>   &#125;<br>&#125;<br><br>.....<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;apple&quot;</span>;<br>    <span class="hljs-type">PeelOff</span> <span class="hljs-variable">peelOff</span> <span class="hljs-operator">=</span> PeelOffFactory.getPeelOff(type);  <span class="hljs-comment">//get ApplePeelOff Class Instance.</span><br>    peelOff.pealOff();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-Liskov-Substitution-Principle，里氏替换原则"><a href="#3-Liskov-Substitution-Principle，里氏替换原则" class="headerlink" title="3. Liskov Substitution Principle，里氏替换原则"></a>3. <strong>L</strong>iskov Substitution Principle，里氏替换原则</h4><p>所有引用基类的地方必须能透明地使用其子类的对象。</p><p>所有父类能出现的地方，子类就可以出现，并且替换了也不会出现任何错误。对使用者来说，能够使用父类的地方，一定可以使用其子类，并且预期结果是一致的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Parent</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-type">Son</span> <span class="hljs-variable">son</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br></code></pre></td></tr></table></figure><p>父类的约定，不仅仅指的是语法层面上的约定，还包括实现上的约定。有时候父类会在类注释、方法注释里做了相关约定的说明，当你要覆写父类的方法时，需要弄懂这些约定，否则可能会出现问题。例如子类违背父类声明要实现的功能。比如父类某个排序方法是从小到大来排序，你子类的方法竟然写成了从大到小来排序。</p><h4 id="4-Interface-Segregation-Principle，接口隔离原则"><a href="#4-Interface-Segregation-Principle，接口隔离原则" class="headerlink" title="4. Interface Segregation Principle，接口隔离原则"></a>4. <strong>I</strong>nterface Segregation Principle，接口隔离原则</h4><p>类间的依赖关系应该建立在最小的接口上。简单地说：<strong>接口的内容一定要尽可能地小，能有多小就多小。</strong></p><p>很多客户端特定的接口优于一个多用途接口。客户端不应该强制实现他们不需要的函数。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>减少改动导致的变化风险</li><li>减少无用功能的理解成本</li></ul><h4 id="5-Dependency-Inversion-Principle，依赖倒置原则"><a href="#5-Dependency-Inversion-Principle，依赖倒置原则" class="headerlink" title="5. Dependency Inversion Principle，依赖倒置原则"></a>5. <strong>D</strong>ependency Inversion Principle，依赖倒置原则</h4><p>高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节，即接口或抽象类不依赖于实现类。细节应该依赖抽象，即实现类不应该依赖于接口或抽象类。<strong>简单地说，我们应该面向接口编程。通过抽象成接口，使各个类的实现彼此独立，实现类之间的松耦合。</strong></p><h4 id="各原则间的联系"><a href="#各原则间的联系" class="headerlink" title="各原则间的联系"></a>各原则间的联系</h4><ul><li>单一职责是所有设计原则的基础，开闭原则是设计的终极目标。</li><li>里氏替换原则强调的是子类替换父类后程序运行时的正确性，它用来帮助实现开闭原则。</li><li>而接口隔离原则用来帮助实现里氏替换原则，同时它也体现了单一职责。</li><li>依赖倒置原则是过程式编程与面向对象编程的分水岭，同时它也被用来指导接口隔离原则。</li></ul><p>依赖倒置原则告诉我们要面向接口编程。当我们面向接口编程之后，接口隔离原则和单一职责原则又告诉我们要注意职责的划分，不要什么东西都塞在一起。当我们职责捋得差不多的时候，里氏替换原则告诉我们在使用继承的时候，要注意遵守父类的约定。而上面说的这四个原则，它们的最终目标都是为了实现开闭原则。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li><a href="https://www.freecodecamp.org/chinese/news/solid-principles/">https://www.freecodecamp.org/chinese/news/solid-principles/</a></li><li><a href="https://zhuanlan.zhihu.com/p/350291336">https://zhuanlan.zhihu.com/p/350291336</a></li><li><a href="https://insights.thoughtworks.cn/understand-solid-principles/">https://insights.thoughtworks.cn/understand-solid-principles/</a></li></ol><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="1-识别应用中变化的方面，把它们和不变的方面分开。"><a href="#1-识别应用中变化的方面，把它们和不变的方面分开。" class="headerlink" title="1. 识别应用中变化的方面，把它们和不变的方面分开。"></a>1. 识别应用中变化的方面，把它们和不变的方面分开。</h3><p>如果每次有新需求，某方面的代码就要变，那么这个行为需要抽出来，与其他不变的代码分离。</p><p>把会变化的部分取出并封装，这样以后就可以修改或扩展这个部分，而不会影响其他不需要变化的部分。</p><h3 id="2-针对接口编程，而不是针对实现编程。"><a href="#2-针对接口编程，而不是针对实现编程。" class="headerlink" title="2. 针对接口编程，而不是针对实现编程。"></a>2. 针对接口编程，而不是针对实现编程。</h3><p>这里的接口指的是广义的超类型，包括接口和抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> getAnimal(); <span class="hljs-comment">// 抽象类</span><br>a.makeSound(); <span class="hljs-comment">// 抽象方法</span><br></code></pre></td></tr></table></figure><h3 id="3-优先使用组合而非继承。"><a href="#3-优先使用组合而非继承。" class="headerlink" title="3. 优先使用组合而非继承。"></a>3. 优先使用组合而非继承。</h3><p>例：策略模式中的算法族引用就是使用了组合。</p><h3 id="4-尽量做到交互的对象之间的松耦合设计。"><a href="#4-尽量做到交互的对象之间的松耦合设计。" class="headerlink" title="4. 尽量做到交互的对象之间的松耦合设计。"></a>4. 尽量做到交互的对象之间的松耦合设计。</h3><p>当两个对象之间松耦合时，它们可以交互，但是通常对彼此所知甚少。松耦合设计经常给我们带来很多弹性。</p><p>例：观察者模式</p><h3 id="5-类应该对扩展开发，但对修改关闭。"><a href="#5-类应该对扩展开发，但对修改关闭。" class="headerlink" title="5. 类应该对扩展开发，但对修改关闭。"></a>5. 类应该对扩展开发，但对修改关闭。</h3><p>即开放-封闭原则。</p><p>例：装饰者模式</p><h3 id="6-依赖抽象，不依赖具体类。"><a href="#6-依赖抽象，不依赖具体类。" class="headerlink" title="6. 依赖抽象，不依赖具体类。"></a>6. 依赖抽象，不依赖具体类。</h3><p>高层组件（如PizzaStore）不应该依赖于低层组件（如具体Pizza），而应该依赖于抽象（如抽象Pizza）。</p><p>例：工厂方法模式。</p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="https://s2.loli.net/2023/09/14/lLdVpOa35Z1YWDm.jpg" alt="UML类图图示样例.jpg"></p><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><h4 id="矩形框表示"><a href="#矩形框表示" class="headerlink" title="矩形框表示"></a>矩形框表示</h4><ul><li>第一层：类的名称<ul><li>抽象类用斜体显示</li></ul></li><li>第二层：类的特性（字段和属性）</li><li>第三层：类的操作（方法和行为）<ul><li><code>+</code>表示public</li><li><code>-</code>表示private</li><li><code>#</code>表示protected</li></ul></li></ul><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><h4 id="矩形框表示-1"><a href="#矩形框表示-1" class="headerlink" title="矩形框表示"></a>矩形框表示</h4><p>顶端有&lt;&lt;interface&gt;&gt;显示</p><ul><li>第一层：接口名称</li><li>第二层：接口方法</li></ul><h4 id="棒棒糖表示"><a href="#棒棒糖表示" class="headerlink" title="棒棒糖表示"></a>棒棒糖表示</h4><p>如图中唐老鸭类实现“讲人话”接口</p><h3 id="类与类、类与接口的关系"><a href="#类与类、类与接口的关系" class="headerlink" title="类与类、类与接口的关系"></a>类与类、类与接口的关系</h3><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><ul><li>用<strong>空心三角形+实线</strong>表示</li></ul><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><ul><li>用<strong>空心三角形+虚线</strong>表示</li></ul><h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><ul><li>用<strong>实线箭头</strong>表示</li><li>表示一个类<em>知道</em>另一个类（如企鹅需要知道气候的变化）</li><li>可以有基数</li></ul><h4 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h4><ul><li>用<strong>空心菱形+实线箭头</strong>表示</li><li>表示一种弱的<em>拥有</em>关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分（如雁群拥有大雁）</li><li>可以有基数</li></ul><h4 id="合成关系"><a href="#合成关系" class="headerlink" title="合成关系"></a>合成关系</h4><ul><li><p>用<strong>实心菱形+实线箭头</strong>表示</p></li><li><p>表示一种强的<em>拥有</em>关系，体现了严格的部分和整体的关系（如鸟拥有翅膀）</p></li><li><p>部分和整体的生命周期一样</p></li><li><p>合成关系的连线两端还有一个数字’1’和数字’2’，这被称为基数</p></li></ul><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><ul><li>用<strong>虚线箭头</strong>表示</li><li>比如动物依赖氧气和水</li></ul>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 8-Date-Time API</title>
    <link href="/posts/6ed8718.html"/>
    <url>/posts/6ed8718.html</url>
    
    <content type="html"><![CDATA[<h1 id="Java-8-新特性-Date-Time-API"><a href="#Java-8-新特性-Date-Time-API" class="headerlink" title="Java 8 新特性 - Date-Time API"></a>Java 8 新特性 - Date-Time API</h1><p>Java 8 在 <code>java.time</code> 包下包含一个全新的日期和时间 API。</p><h2 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime.class <span class="hljs-comment">//日期+时间 format: yyyy-MM-ddTHH:mm:ss.SSS</span><br>LocalDate.class <span class="hljs-comment">//日期 format: yyyy-MM-dd</span><br>LocalTime.class <span class="hljs-comment">//时间 format: HH:mm:ss</span><br></code></pre></td></tr></table></figure><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Format</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//format yyyy-MM-dd</span><br>    <span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.now();<br>    System.out.println(String.format(<span class="hljs-string">&quot;date format : %s&quot;</span>, date));<br><br>    <span class="hljs-comment">//format HH:mm:ss</span><br>    <span class="hljs-type">LocalTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalTime.now().withNano(<span class="hljs-number">0</span>);<br>    System.out.println(String.format(<span class="hljs-string">&quot;time format : %s&quot;</span>, time));<br><br>    <span class="hljs-comment">//format yyyy-MM-dd HH:mm:ss</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">dateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dateTimeFormatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">dateTimeStr</span> <span class="hljs-operator">=</span> dateTime.format(dateTimeFormatter);<br>    System.out.println(String.format(<span class="hljs-string">&quot;dateTime format : %s&quot;</span>, dateTimeStr));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串转日期格式"><a href="#字符串转日期格式" class="headerlink" title="字符串转日期格式"></a>字符串转日期格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2021</span>, <span class="hljs-number">1</span>, <span class="hljs-number">26</span>);<br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> LocalDate.parse(<span class="hljs-string">&quot;2021-01-26&quot;</span>);<br><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">dateTime1</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2021</span>, <span class="hljs-number">1</span>, <span class="hljs-number">26</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>);<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">dateTime2</span> <span class="hljs-operator">=</span> LocalDateTime.parse(<span class="hljs-string">&quot;2021-01-26 12:12:22&quot;</span>);<br><br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">time1</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">12</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>);<br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">time2</span> <span class="hljs-operator">=</span> LocalTime.parse(<span class="hljs-string">&quot;12:12:22&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>Java 8 之前</strong> 转换都需要借助 <code>SimpleDateFormat</code> 类，而<strong>Java 8 之后</strong>只需要 <code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>的 <code>of</code> 或 <code>parse</code> 方法。</p><h2 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushWeek</span><span class="hljs-params">()</span>&#123;<br>     <span class="hljs-comment">//一周后的日期</span><br>     <span class="hljs-type">LocalDate</span> <span class="hljs-variable">localDate</span> <span class="hljs-operator">=</span> LocalDate.now();<br>     <span class="hljs-comment">//方法1</span><br>     <span class="hljs-type">LocalDate</span> <span class="hljs-variable">after</span> <span class="hljs-operator">=</span> localDate.plus(<span class="hljs-number">1</span>, ChronoUnit.WEEKS);<br>     <span class="hljs-comment">//方法2</span><br>     <span class="hljs-type">LocalDate</span> <span class="hljs-variable">after2</span> <span class="hljs-operator">=</span> localDate.plusWeeks(<span class="hljs-number">1</span>);<br>     System.out.println(<span class="hljs-string">&quot;一周后日期：&quot;</span> + after);<br><br>     <span class="hljs-comment">//算两个日期间隔多少天，计算间隔多少年，多少月</span><br>     <span class="hljs-type">LocalDate</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> LocalDate.parse(<span class="hljs-string">&quot;2021-02-26&quot;</span>);<br>     <span class="hljs-type">LocalDate</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> LocalDate.parse(<span class="hljs-string">&quot;2021-12-23&quot;</span>);<br>     <span class="hljs-type">Period</span> <span class="hljs-variable">period</span> <span class="hljs-operator">=</span> Period.between(date1, date2);<br>     System.out.println(<span class="hljs-string">&quot;date1 到 date2 相隔：&quot;</span><br>                + period.getYears() + <span class="hljs-string">&quot;年&quot;</span><br>                + period.getMonths() + <span class="hljs-string">&quot;月&quot;</span><br>                + period.getDays() + <span class="hljs-string">&quot;天&quot;</span>);<br> <span class="hljs-comment">//打印结果是 “date1 到 date2 相隔：0年9月27天”</span><br>     <span class="hljs-comment">//这里period.getDays()得到的天是抛去年月以外的天数，并不是总天数</span><br>  <br>     <span class="hljs-comment">//如果要获取纯粹的总天数应该用下面的方法</span><br>     <span class="hljs-type">long</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> date2.toEpochDay() - date1.toEpochDay();<br>     System.out.println(date1 + <span class="hljs-string">&quot;和&quot;</span> + date2 + <span class="hljs-string">&quot;相差&quot;</span> + day + <span class="hljs-string">&quot;天&quot;</span>);<br>     <span class="hljs-comment">//打印结果：2021-02-26和2021-12-23相差300天</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="获取指定日期"><a href="#获取指定日期" class="headerlink" title="获取指定日期"></a>获取指定日期</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getDayNew</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">LocalDate</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDate.now();<br>    <span class="hljs-comment">//获取当前月第一天：</span><br>    <span class="hljs-type">LocalDate</span> <span class="hljs-variable">firstDayOfThisMonth</span> <span class="hljs-operator">=</span> today.with(TemporalAdjusters.firstDayOfMonth());<br>    <span class="hljs-comment">// 取本月最后一天</span><br>    <span class="hljs-type">LocalDate</span> <span class="hljs-variable">lastDayOfThisMonth</span> <span class="hljs-operator">=</span> today.with(TemporalAdjusters.lastDayOfMonth());<br>    <span class="hljs-comment">//取下一天：</span><br>    <span class="hljs-type">LocalDate</span> <span class="hljs-variable">nextDay</span> <span class="hljs-operator">=</span> lastDayOfThisMonth.plusDays(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//当年最后一天</span><br>    <span class="hljs-type">LocalDate</span> <span class="hljs-variable">lastday</span> <span class="hljs-operator">=</span> today.with(TemporalAdjusters.lastDayOfYear());<br>    <span class="hljs-comment">//2021年最后一个周日，如果用Calendar是不得烦死。</span><br>    <span class="hljs-type">LocalDate</span> <span class="hljs-variable">lastMondayOf2021</span> <span class="hljs-operator">=</span> LocalDate.parse(<span class="hljs-string">&quot;2021-12-31&quot;</span>).with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>modern-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 8-other new features</title>
    <link href="/posts/c1b2512c.html"/>
    <url>/posts/c1b2512c.html</url>
    
    <content type="html"><![CDATA[<h1 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h1><h2 id="Method-and-Constructor-References"><a href="#Method-and-Constructor-References" class="headerlink" title="Method and Constructor References"></a>Method and Constructor References</h2><p>Java 8 支持用<code>::</code>关键字传递方法（静态方法或对象方法都可以）或构造函数的引用。</p><h3 id="构造函数引用例子"><a href="#构造函数引用例子" class="headerlink" title="构造函数引用例子"></a>构造函数引用例子</h3><p>定义一个包含多个构造函数的简单类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String firstName;<br>    String lastName;<br><br>    Person() &#123;&#125;<br><br>    Person(String firstName, String lastName) &#123;<br>        <span class="hljs-built_in">this</span>.firstName = firstName;<br>        <span class="hljs-built_in">this</span>.lastName = lastName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们指定一个用来创建 Person 对象的对象工厂接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PersonFactory</span>&lt;P <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&gt; &#123;<br>  P <span class="hljs-title function_">create</span><span class="hljs-params">(String firstName, String LastName)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用构造函数引用来将他们关联起来，而不是手动实现一个完整的工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">PersonFactory&lt;Person&gt; personFactory = Person::<span class="hljs-keyword">new</span>;<br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> personFactory.create(<span class="hljs-string">&quot;Peter&quot;</span>, <span class="hljs-string">&quot;Parker&quot;</span>);<br></code></pre></td></tr></table></figure><p>只需要使用 <code>Person::new</code> 来获取 Person 类构造函数的引用，Java 编译器会自动根据<code>PersonFactory.create</code>方法的参数类型来选择合适的构造函数。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map 类型不支持 streams，不过 Map 提供了一些新的有用的方法来处理一些日常任务。</p><p>Map 接口本身没有可用的 <code>stream()</code>方法，但是你可以在键，值上创建专门的流或者通过 <code>map.keySet().stream()</code>,<code>map.values().stream()</code>和<code>map.entrySet().stream()</code>。</p><p>此外,Maps 支持各种新的和有用的方法来执行常见任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    map.putIfAbsent(i, <span class="hljs-string">&quot;val&quot;</span> + i);<br>&#125;<br><br>map.forEach((id, val) -&gt; System.out.println(val));<span class="hljs-comment">//val0 val1 val2 val3 val4 val5 val6 val7 val8 val9</span><br></code></pre></td></tr></table></figure><p><code>putIfAbsent</code> 阻止我们在 null 检查时写入额外的代码;<code>forEach</code>接受一个 consumer 来对 map 中的每个元素操作。</p><p>此示例显示如何使用函数在 map 上计算代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">map.computeIfPresent(<span class="hljs-number">3</span>, (num, val) -&gt; val + num);<br>map.get(<span class="hljs-number">3</span>);             <span class="hljs-comment">// val33</span><br><br>map.computeIfPresent(<span class="hljs-number">9</span>, (num, val) -&gt; <span class="hljs-literal">null</span>);<br>map.containsKey(<span class="hljs-number">9</span>);     <span class="hljs-comment">// false</span><br><br>map.computeIfAbsent(<span class="hljs-number">23</span>, num -&gt; <span class="hljs-string">&quot;val&quot;</span> + num);<br>map.containsKey(<span class="hljs-number">23</span>);    <span class="hljs-comment">// true</span><br><br>map.computeIfAbsent(<span class="hljs-number">3</span>, num -&gt; <span class="hljs-string">&quot;bam&quot;</span>);<br>map.get(<span class="hljs-number">3</span>);             <span class="hljs-comment">// val33</span><br></code></pre></td></tr></table></figure><p>接下来展示如何在 Map 里删除一个键值全都匹配的项：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">map.remove(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;val3&quot;</span>);<br>map.get(<span class="hljs-number">3</span>);             <span class="hljs-comment">// val33</span><br>map.remove(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;val33&quot;</span>);<br>map.get(<span class="hljs-number">3</span>);             <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p>另外一个有用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">map.getOrDefault(<span class="hljs-number">42</span>, <span class="hljs-string">&quot;not found&quot;</span>);  <span class="hljs-comment">// not found</span><br></code></pre></td></tr></table></figure><p>对 Map 的元素做合并也变得很容易了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">map.merge(<span class="hljs-number">9</span>, <span class="hljs-string">&quot;val9&quot;</span>, (value, newValue) -&gt; value.concat(newValue));<br>map.get(<span class="hljs-number">9</span>);             <span class="hljs-comment">// val9</span><br>map.merge(<span class="hljs-number">9</span>, <span class="hljs-string">&quot;concat&quot;</span>, (value, newValue) -&gt; value.concat(newValue));<br>map.get(<span class="hljs-number">9</span>);             <span class="hljs-comment">// val9concat</span><br></code></pre></td></tr></table></figure><p>Merge 做的事情是如果键名不存在则插入，否则对原键对应的值做合并操作并重新插入到 map 中。</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>modern-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 8-interface and lambda</title>
    <link href="/posts/5de7105f.html"/>
    <url>/posts/5de7105f.html</url>
    
    <content type="html"><![CDATA[<h1 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h1><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><h3 id="Default-methods-for-Interfaces"><a href="#Default-methods-for-Interfaces" class="headerlink" title="Default methods for Interfaces"></a>Default methods for Interfaces</h3><p>Java 8 支持通过<code>default</code>关键字向接口添加非抽象方法实现。</p><p>目的：解决接口的修改与现有的实现不兼容的问题。</p><blockquote><p>Java 8 之前，<code>Interface</code> 修改的时候，实现它的类也必须跟着改。因为必须override所有抽象方法。</p></blockquote><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Formula</span>&#123;<br><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">double</span> <span class="hljs-title function_">sqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.sqrt(a);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实现<code>Formula</code>接口的类无需override sqrt方法。</p><h3 id="Funtional-Interfaces"><a href="#Funtional-Interfaces" class="headerlink" title="Funtional Interfaces"></a>Funtional Interfaces</h3><p>定义：<strong>仅仅只包含一个抽象方法,但是可以有多个非抽象方法(也就是上面提到的默认方法)的接口。</strong></p><p>目的：为了友好支持Lambda。函数式接口可以被隐式转换为 lambda 表达式。</p><blockquote><p><code>java.lang.Runnable</code> 与 <code>java.util.concurrent.Callable</code> 是函数式接口最典型的两个例子。</p></blockquote><p>Java 8 增加了一种特殊的注解<code>@FunctionalInterface</code>，但是这个注解通常不是必须的(某些情况建议使用)，只要接口只包含一个抽象方法，虚拟机会自动判断该接口为函数式接口。一般建议在接口上使用<code>@FunctionalInterface</code> 注解进行声明，这样的话，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错。</p><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在老版本的 Java 中是这样给字符串列表排序的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;peter&quot;</span>, <span class="hljs-string">&quot;anna&quot;</span>, <span class="hljs-string">&quot;mike&quot;</span>, <span class="hljs-string">&quot;xenia&quot;</span>);<br><br>Collections.sort(names, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String a, String b)</span> &#123;<br>        <span class="hljs-keyword">return</span> b.compareTo(a);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>只需要给静态方法<code>Collections.sort</code> 传入一个 List 对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给 <code>sort</code> 方法。</p><p>在 Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8 提供了更简洁的语法，lambda 表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(names, (String a, String b) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> b.compareTo(a);<br>&#125;);<br></code></pre></td></tr></table></figure><p>对于函数体只有一行代码的，你可以去掉大括号{}以及 return 关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));<br></code></pre></td></tr></table></figure><p>但是你还可以写得更短点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">names.sort((a, b) -&gt; b.compareTo(a));<br></code></pre></td></tr></table></figure><p>List 类本身就有一个 <code>sort</code> 方法。并且 Java 编译器可以自动推导出参数类型，所以你可以不用再写一次类型。</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>modern-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 8-optional and stream</title>
    <link href="/posts/982e6807.html"/>
    <url>/posts/982e6807.html</url>
    
    <content type="html"><![CDATA[<h1 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h1><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Optional 是一个简单的容器，其值可能是 null 或者不是 null。它是用于防止 NullPointerException 的工具。</p><p>有了Optional，我们可以安心地进行链式调用，而不是一层层判断是否为空。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// of()：为非null的值创建一个Optional</span><br>Optional&lt;String&gt; optional = Optional.of(<span class="hljs-string">&quot;bam&quot;</span>); <span class="hljs-comment">// ofNullable(): 为可为空的值创建一个Optional</span><br><span class="hljs-comment">// isPresent()：如果值存在返回true，否则返回false</span><br>optional.isPresent();           <span class="hljs-comment">// true</span><br><span class="hljs-comment">// get()：如果Optional有值则将其返回，否则抛出NoSuchElementException</span><br>optional.get();                 <span class="hljs-comment">// &quot;bam&quot;</span><br><span class="hljs-comment">// orElse()：如果有值则将其返回，否则返回指定的其它值</span><br>optional.orElse(<span class="hljs-string">&quot;fallback&quot;</span>);    <span class="hljs-comment">// &quot;bam&quot;</span><br><span class="hljs-comment">// ifPresent()：如果Optional实例有值则为其调用consumer，否则不做处理</span><br>optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="hljs-number">0</span>)));     <span class="hljs-comment">// &quot;b&quot;</span><br></code></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getChampionName</span><span class="hljs-params">(Competition comp)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException &#123;<br>    <span class="hljs-keyword">if</span> (comp != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">CompResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> comp.getResult();<br>        <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">champion</span> <span class="hljs-operator">=</span> result.getChampion();<br>            <span class="hljs-keyword">if</span> (champion != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> champion.getName();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;The value of param comp isn&#x27;t available.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>用 Optional 改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getChampionName</span><span class="hljs-params">(Competition comp)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException &#123;<br>    <span class="hljs-keyword">return</span> Optional.ofNullable(comp)<br>            .map(Competition::getResult)  <span class="hljs-comment">// 相当于c -&gt; c.getResult()，下同</span><br>            .map(CompResult::getChampion)<br>            .map(User::getName)<br>            .orElseThrow(()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;The value of param comp isn&#x27;t available.&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Java 8 扩展了集合类，可以通过 <code>Collection.stream()</code> 或者 <code>Collection.parallelStream()</code> 来创建一个 Stream。</p><blockquote><p>跟Spark写法很像</p></blockquote><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>intermediate operation</p><blockquote><p>foreach is a terminal operation</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">stringCollection<br>  .stream()<br>  .filter((s) -&gt; s.startsWith(<span class="hljs-string">&quot;a&quot;</span>))<br>  .forEach(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>intermediate operation</p><p>可以指定自定义的 Comparator。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">stringList<br>  .stream()<br>  .sorted()<br>  .forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>排序只创建了一个排列好后的 Stream，而不会影响原有的数据源，排序之后原数据 stringList 是不会被修改的。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>intermediate operation</p><p>将元素根据指定的 Function 接口来依次将元素转成另外的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">stringList<br>  .stream()<br>  .map(String::toUpperCase)<br>  .sorted((a, b) -&gt; b.compareTo(a))<br>  .forEach(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>terminal operation</p><p>Stream 提供了多种匹配操作(anyMatch, allMatch, nonMatch)，允许检测指定的 Predicate 是否匹配整个 Stream。返回一个 boolean 类型的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">anyStartsWithA</span> <span class="hljs-operator">=</span><br>  stringList<br>    .stream()<br>    .anyMatch((s) -&gt; s.startsWith(<span class="hljs-string">&quot;a&quot;</span>));<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">allStartsWithA</span> <span class="hljs-operator">=</span><br>  stringList<br>    .stream()<br>    .allMatch((s) -&gt; s.startsWith(<span class="hljs-string">&quot;a&quot;</span>));<br><br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">noneStartsWithZ</span> <span class="hljs-operator">=</span><br>  stringList<br>    .stream()<br>    .noneMatch((s) -&gt; s.startsWith(<span class="hljs-string">&quot;z&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>terminal operation</p><p>返回 Stream 中元素的个数，<strong>返回值类型是 long</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">startsWithB</span> <span class="hljs-operator">=</span><br>  stringList<br>    .stream()<br>    .filter((s) -&gt; s.startsWith(<span class="hljs-string">&quot;b&quot;</span>))<br>    .count();<br></code></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>terminal operation</p><p>允许通过指定的函数来将 stream 中的多个元素规约为一个元素，规约后的结果是通过 Optional 接口表示的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; reduced =<br>  stringList<br>    .stream()<br>    .sorted()<br>    .reduce((s1, s2) -&gt; s1 + <span class="hljs-string">&quot;#&quot;</span> + s2);<br><br>reduced.ifPresent(System.out::println);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>modern-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-26. Don’t use raw types</title>
    <link href="/posts/c1b69db8.html"/>
    <url>/posts/c1b69db8.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-26-Don’t-use-raw-types"><a href="#Item-26-Don’t-use-raw-types" class="headerlink" title="Item 26: Don’t use raw types"></a>Item 26: Don’t use raw types</h1><p>It is legal to use raw types (generic types without their type parameters), but you should never do it. <strong>If you use raw types, you lose all the safety and expressiveness benefits of generics.</strong></p><blockquote><p>For compatibility, Java designers permit raw types in the first place.</p></blockquote><h2 id="Terms"><a href="#Terms" class="headerlink" title="Terms"></a>Terms</h2><ul><li><p>A class or interface whose declaration has one or more <em>type parameters</em> is a <strong><em>generic</em> class</strong> or <strong>interface</strong>.</p><blockquote><p>For example, the <code>List</code> interface has a single type parameter, E, representing its element type. The full name of the interface is <code>List&lt;E&gt;</code> (read “list of E”), but people often call it <code>List</code> for short.</p></blockquote></li><li><p>Generic classes and interfaces are collectively known as <em><strong>generic types</strong></em>.</p></li><li><p>Each generic type defines a set of <em><strong>parameterized types</strong></em>, which consist of the class or interface name followed by an angle-bracketed list of <em>actual type parameters</em> corresponding to the generic type’s formal type parameters.</p><blockquote><p>For example, <code>List&lt;String&gt;</code> (read “list of string”) is a parameterized type representing a list whose elements are of type String. (String is the actual type parameter corresponding to the formal type parameter E.)</p></blockquote></li><li><p>Each generic type defines a <em><strong>raw type</strong></em>, which is the name of the generic type used without any accompanying type parameters.</p><blockquote><p>They exist primarily for compatibility with pre-generics code.</p></blockquote></li></ul><h2 id="Raw-types-vs-Object-parameterized-types"><a href="#Raw-types-vs-Object-parameterized-types" class="headerlink" title="Raw types vs Object parameterized types"></a>Raw types vs <em>Object</em> parameterized types</h2><p><strong>You lose type safety if you use a raw type such as <code>List</code>, but not if you use a parameterized type such as <code>List&lt;Object&gt;</code>.</strong></p><p>While you shouldn’t use raw types such as <code>List</code>, it is fine to use types that are parameterized to allow insertion of arbitrary objects, such as <code>List&lt;Object&gt;</code>. What is the difference between the raw type <code>List</code> and the parameterized type <code>List&lt;Object&gt;</code>? Loosely speaking, <code>List</code> has <strong>opted out of the generic type system</strong>, while <code>List&lt;Object&gt;</code> has explicitly told the compiler that it is capable of <strong>holding objects of any type</strong>.</p><p>While you can pass a <code>List&lt;String&gt;</code> to a parameter of type <code>List</code>, you can’t pass it to a parameter of type <code>List&lt;Object&gt;</code>. There are <strong>subtyping rules</strong> for generics, and <strong><code>List&lt;String&gt;</code> is a subtype of the raw type <code>List</code>, but not of the parameterized type <code>List&lt;Object&gt;</code></strong> (Item 28).</p><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  List&lt;String&gt; strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); unsafeAdd(strings, Integer.valueOf(<span class="hljs-number">42</span>));<br>  <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> strings.get(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Test.java:10: warning: [unchecked] unchecked call to add(E) as a member of the raw type List</span><br><span class="hljs-comment">       list.add(o);</span><br><span class="hljs-comment">               ^</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unsafeAdd1</span><span class="hljs-params">(List list, Object o)</span> &#123; <br>  list.add(o);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Test.java:5: error: incompatible types: List&lt;String&gt; cannot be converted to List&lt;Object&gt;</span><br><span class="hljs-comment">   unsafeAdd(strings, Integer.valueOf(42));</span><br><span class="hljs-comment">       ^</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unsafeAdd2</span><span class="hljs-params">(List&lt;Object&gt; list, Object o)</span> &#123; <br>  list.add(o);<br>&#125;<br></code></pre></td></tr></table></figure><p>If you run <code>unsafeAdd1</code> version of the program, you get a <code>ClassCastException</code> when the program tries to cast the result of the invocation <code>strings.get(0)</code>, which is an Integer, to a String.</p><p>If you run <code>unsafeAdd2</code> version of the program, and try to recompile the program, you’ll find that it no longer compiles but emits an <em>incompatible types</em> error message.</p><h2 id="Unbounded-wildcard-types"><a href="#Unbounded-wildcard-types" class="headerlink" title="Unbounded wildcard types &lt;?&gt;"></a>Unbounded wildcard types &lt;?&gt;</h2><p>If you want to use a generic type but you don’t know or care what the actual type parameter is, you can use a <strong>question mark</strong> instead.</p><blockquote><p>For example, the unbounded wildcard type for the generic type <code>Set&lt;E&gt;</code> is <code>Set&lt;?&gt;</code> (read “set of some type”). It is the most general parameterized <code>Set</code> type, capable of holding <em>any</em> set.</p></blockquote><blockquote><p><code>List&lt;Integer&gt;</code> and <code>List&lt;String&gt;</code> are not subtypes of <code>List&lt;Object&gt;</code>. So use <code>List&lt;?&gt;</code> as an alternative.</p></blockquote><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Use of raw type for unknown element type - don&#x27;t do this! </span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numElementsInCommon</span><span class="hljs-params">(Set s1, Set s2)</span> &#123;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span> (Object o1 : s1)<br>       <span class="hljs-keyword">if</span> (s2.contains(o1))<br>           result++;<br>   <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// Uses unbounded wildcard type - typesafe and flexible </span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numElementsInCommon</span><span class="hljs-params">(Set&lt;?&gt; s1, Set&lt;?&gt; s2)</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p><strong>You can’t put any element (other than null) into a <code>Collection&lt;?&gt;</code>.</strong></p><h2 id="Exceptions-to-not-using-raw-types"><a href="#Exceptions-to-not-using-raw-types" class="headerlink" title="Exceptions to not using raw types"></a>Exceptions to not using raw types</h2><ol><li><p><strong>You must use raw types in class literals.</strong> The specification does not permit the use of parameterized types (though it does permit array types and primitive types). </p><p>In other words, <code>List.class</code>, <code>String[].class</code>, and <code>int.class</code> are all legal, but <code>List&lt;String&gt;.class</code> and <code>List&lt;?&gt;.class</code> are not.</p></li><li><p><strong>Use the <code>instanceof</code> operator on raw types.</strong> Because generic type information is erased at runtime, it is illegal to use the instanceof operator on parameterized types.</p><blockquote><p>Unbounded wildcard types is permitted when using <code>instanceof</code> operator, but in this case, the angle brackets and question marks are just noise.</p></blockquote><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Ligitimate use of raw type - instanceof operator</span><br><span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Set) &#123; <span class="hljs-comment">// Raw type</span><br>  Set&lt;?&gt; s = (Set&lt;?&gt;) o; <span class="hljs-comment">// Wildcard type</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>This is the preferred way to use the</strong> <strong>instanceof</strong> <strong>operator with generic types:</strong></p><p>Note that once you’ve determined that o is a Set, you must cast it to the wildcard type Set&lt;?&gt;, not the raw type Set. This is a checked cast, so it will not cause a compiler warning.</p></li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, using raw types can lead to exceptions at runtime, so don’t use them. They are provided only for compatibility and interoperability with legacy code that predates the introduction of generics.</p><p>As a quick review:</p><ul><li><code>Set&lt;Object&gt;</code> is a parameterized type representing a set that can contain objects of <strong>any type</strong>; </li><li><code>Set&lt;?&gt;</code> is a wildcard type representing a set that can contain only objects of some <strong>unknown type</strong>;</li><li><code>Set</code> is a raw type, which opts out of the generic type system.</li></ul><p>The first two are safe, and the last is not.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-25. Limit source files to a single top-level class</title>
    <link href="/posts/85ddc290.html"/>
    <url>/posts/85ddc290.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item25-Limit-source-files-to-a-single-top-level-class"><a href="#Item25-Limit-source-files-to-a-single-top-level-class" class="headerlink" title="Item25: Limit source files to a single top-level class"></a>Item25: Limit source files to a single top-level class</h1><p>While the Java compiler lets you define <strong>multiple top-level classes in a single source file,</strong> there are no benefits associated with doing so, and there are significant risks. The risks stem from the fact that defining multiple top-level classes in a source file makes it possible to provide <strong>multiple definitions for a class</strong>.</p><blockquote><p>Which definition gets used is affected by the order in which the source files are passed to the compiler.</p></blockquote><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Main.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  System.out.println(Utensil.NAME + Dessert.NAME);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Utensil.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Two classes defined in one file. Don&#x27;t ever do this!</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Utensil</span> &#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pan&quot;</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dessert</span> &#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cake&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Dessert.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Two classes defined in one file. Don&#x27;t ever do this!</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Utensil</span> &#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pot&quot;</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dessert</span> &#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pie&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Compile the program with the command <code>javac Main.java Dessert.java</code>, the compilation will fail, and the compiler will tell you that you’ve multiply defined the classes <code>Utensil</code> and <code>Dessert</code>.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ol><li><p>Splitting the top-level classes (Utensil and Dessert, in the case of our example) into <strong>separate source files</strong>.</p></li><li><p>If you are tempted to put multiple top-level classes into a single source file, consider using <strong>static member classes</strong> (Item 24) as an alternative.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Static member classes instead of multiple top-level classes</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       System.out.println(Utensil.NAME + Dessert.NAME);<br>   &#125;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Utensil</span> &#123;<br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pan&quot;</span>;<br>   &#125;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dessert</span> &#123;<br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cake&quot;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>If the classes are subservient to another class, making them into static member classes is generally the better alternative, because it enhances readability and makes it possible to reduce the accessibility of the classes by declaring them private (Item 15).</p></li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p><strong>Never put multiple top-level classes or interfaces in a single source file.</strong> </p><p>Following this rule guarantees that you can’t have <strong>multiple definitions</strong> for a single class at compile time. </p><p>This in turn guarantees that the class files generated by compilation, and the behavior of the resulting program, are <strong>independent of the order</strong> in which the source files are passed to the compiler.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式8-工厂方法模式</title>
    <link href="/posts/53b40b98.html"/>
    <url>/posts/53b40b98.html</url>
    
    <content type="html"><![CDATA[<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>工厂方法模式（Factory Method），定义一个用于创建对象的接口，让子类决定实例化哪一个类。</p><p>工厂方法使一个类的实例化<strong>延迟到其子类</strong>。</p><p>工厂方法处理对象的创建，并将对象创建封装在子类中，使得超类中的客户代码从子类的对象创建代码中解耦。</p><h2 id="工厂方法模式结构图"><a href="#工厂方法模式结构图" class="headerlink" title="工厂方法模式结构图"></a>工厂方法模式结构图</h2><p><img src="https://s2.loli.net/2023/09/25/ECs5PaBurW7kmyZ.jpg" alt="工厂方法模式结构图.jpg"></p><p>相比于简单工厂（工厂类只有一个），工厂方法模式中有<strong>多个工厂类</strong>继承于工厂抽象类&#x2F;实现工厂接口，增加新工厂不会影响原有工厂。此外，产品的实例化延迟到工厂子类中，而不是最外层的工厂类（如计算器中的 <code>OperationFactory</code>）。</p><h1 id="例1：计算器"><a href="#例1：计算器" class="headerlink" title="例1：计算器"></a>例1：计算器</h1><h2 id="计算器V1"><a href="#计算器V1" class="headerlink" title="计算器V1"></a>计算器V1</h2><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://s2.loli.net/2023/09/25/5gty3FUwSMIWdv9.jpg" alt="工厂方法结构图.jpg"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>工厂接口 <code>IFactory</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>每种运算各建立一个具体工厂实现 <code>IFactory</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 加法工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Add</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 其余运算类似</span><br></code></pre></td></tr></table></figure><p>运算工厂类 <code>OperationFactory</code> ：根据用户输入的运算符号，决定返回哪一个运算子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperate</span><span class="hljs-params">(String operate)</span> &#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">IFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (operate) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddFactory</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubFactory</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulFactory</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DivFactory</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        oper = factory.createOperation();<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> OperationFactory.createOperate(strOperate);<br><span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> oper.getResult(numberA, numberB);<br></code></pre></td></tr></table></figure><h3 id="简单工厂vs工厂方法"><a href="#简单工厂vs工厂方法" class="headerlink" title="简单工厂vs工厂方法"></a>简单工厂vs工厂方法</h3><h4 id="假如要增加一个指数运算？"><a href="#假如要增加一个指数运算？" class="headerlink" title="假如要增加一个指数运算？"></a>假如要增加一个指数运算？</h4><h5 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h5><p>先增加指数运算的运算类，再更改 <code>OperationFactory</code> 类的 <code>switch</code> 语句。</p><h5 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h5><p>先增加指数运算的运算类，再更改 <code>OperationFactory</code> 类的 <code>switch</code> 语句，还要额外增加一个指数运算工厂类实现 <code>IFacotry</code> 接口。增加了复杂性。</p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><ul><li><p><strong>简单工厂模式</strong>：最大优点在于工厂类中包含必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</p><ul><li>例如计算器，客户端不用管该用哪个类的实例，只需要把’+’给工厂，工厂自动就给出了相应的实例，客户端只要去做运算就可以了，不同的实例会实现不同的运算。但问题也就在这里，如你所说，如果要加一个’求x的n次方（x^n）’的功能，我们需要给OperationFactory类的方法里加’Case’的分支条件。目前来看，这个OperationFactory类，承载了太多功能，这可不是好办法。这就等于说，我们不但对扩展开放了，对修改也开放了，违背了开放-封闭原则。</li></ul></li><li><p><strong>工厂方法模式</strong>：将长的代码切割成小段，再将每一小段’封装’起来，减少每段代码之间的耦合，这样风险就分散了，需要修改或扩展的难度就降低了。</p><ul><li>比如计算器：加减乘除运算统一设计成 <code>基础运算工厂</code> 的产品。增加指数、对数运算类，新开一个工厂 <code>高级运算工厂</code> 类，不需要对 <code>基础运算工厂</code> 做改动。</li></ul></li></ul><h2 id="计算器V2"><a href="#计算器V2" class="headerlink" title="计算器V2"></a>计算器V2</h2><h3 id="结构图-1"><a href="#结构图-1" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://s2.loli.net/2023/09/25/pij2CroZTRvWfIQ.jpg" alt="工厂方法结构图2.jpg"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>增加指数运算类，继承 <code>Operation</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> numberA, <span class="hljs-type">double</span> numberB)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.pow(numberA, numberB);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将加减乘除运算封装到基础运算工厂类 <code>FactoryBasic</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryBasic</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">(String operateType)</span> &#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (operateType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Add</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mul</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Div</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将新运算封装到高级运算工厂类 <code>FactoryAdvanced</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryAdvanced</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">(String operateType)</span> &#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (operateType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pow&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pow</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;log&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 还可扩展其他高级运算类的实例化，但修改当前工厂类不会影响到基础运算工厂类</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>新的 <code>OperationFactory</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperate</span><span class="hljs-params">(String operate)</span> &#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">IFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (operate) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                <span class="hljs-comment">// 基础运算工厂实例</span><br>                factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FactoryBasic</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pow&quot;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;log&quot;</span>:<br>                <span class="hljs-comment">// 高级运算工厂实例</span><br>                factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FactoryAdvanced</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 利用多态返回实际的运算类实例</span><br>        oper = factory.createOperation(operate);<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对比简单工厂模式中的 <code>OperationFactory</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperate</span><span class="hljs-params">(String operate)</span> &#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (operate) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Add</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mul</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Div</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，新的 <code>OperationFactory</code> 类已经不存在运算子类实例化的代码了。也就是说，在这个代码里，全部是接口与具体工厂类，并不存在具体的实现，与原来的 <code>OperationFactory</code> 类对比，实例化的过程延迟到了工厂子类中。</p><p>遵循<code>依赖倒置原则</code>：针对接口（<code>IFactory</code>）编程，而不是针对实现（<code>Operation</code>）编程。</p><h1 id="例2：再升级商场收银程序"><a href="#例2：再升级商场收银程序" class="headerlink" title="例2：再升级商场收银程序"></a>例2：再升级商场收银程序</h1><blockquote><p>简单工厂+策略+装饰+工厂方法</p></blockquote><p>之前的<code>简单工厂+策略+装饰</code> 版本中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashContext</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> ISale cs;<br>    <br>    <span class="hljs-comment">// 在构造函数中传入type，根据type来实例化具体的收费策略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashContext</span><span class="hljs-params">(<span class="hljs-type">int</span> cashType)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (cashType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-built_in">this</span>.cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>();<br>                <span class="hljs-keyword">break</span>;<br>            ...<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                <span class="hljs-comment">// 先打8折，再满300返100</span><br>                <span class="hljs-type">CashNormal</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>();<br>                <span class="hljs-type">CashReturn</span> <span class="hljs-variable">crt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashReturn</span>(<span class="hljs-number">300d</span>, <span class="hljs-number">100d</span>);<br>                <span class="hljs-type">CashRebate</span> <span class="hljs-variable">crb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.8d</span>);<br>                <br>                crt.decorate(cn); <span class="hljs-comment">// 用 满300返100算法 包装原价算法</span><br>                crb.decorate(crt); <span class="hljs-comment">// 用 打8折算法 装饰 满300返100算法</span><br>                <span class="hljs-built_in">this</span>.cs = crb;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 根据收费策略的不同，获得计算结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.cs.acceptCash(price, num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>case 5</code>中new的对象太多，应该将其封装成一个工厂。</p><p>所有的case可以抽象成两个工厂类：<code>先打折后满减</code>和<code>先满减后打折</code>。有<code>先打折后满减</code>类存在，那它应该有三个初始化参数：<em>折扣值、满减条件、满减返利值</em>，那么：</p><ul><li>打折类：其实就是满减返利值条件为0的情况</li><li>满减类：就相当于折扣参数为1的情况</li></ul><h2 id="结构图-2"><a href="#结构图-2" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/09/25/uPfSU2R5J7bxM39.jpg" alt="工厂方法结构图3.jpg"></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><p>增加 <code>IFactory</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> ISale <span class="hljs-title function_">createSalesModel</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 创建销售模式</span><br>&#125;<br></code></pre></td></tr></table></figure><p>增加实现 <code>IFactory</code> 接口的两个类：<code>先打折后满减</code>和<code>先满减后打折</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先打折后满减类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashRebateReturnFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyRebate</span> <span class="hljs-operator">=</span> <span class="hljs-number">1d</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyCondition</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyReturn</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashRebateReturnFactory</span><span class="hljs-params">(<span class="hljs-type">double</span> moneyRebate, <span class="hljs-type">double</span> moneyCondition, <span class="hljs-type">double</span> moneyReturn)</span> &#123;<br>        <span class="hljs-built_in">this</span>.moneyRebate = moneyRebate;<br>        <span class="hljs-built_in">this</span>.moneyCondition = moneyCondition;<br>        <span class="hljs-built_in">this</span>.moneyReturn = moneyReturn;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 重写接口方法，先打折后满减</span><br>    <span class="hljs-keyword">public</span> ISale <span class="hljs-title function_">createSalesModel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CashNormal</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>();<br>        <span class="hljs-type">CashReturn</span> <span class="hljs-variable">cr1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashReturn</span>(<span class="hljs-built_in">this</span>.moneyCondition, <span class="hljs-built_in">this</span>.moneyReturn);<br>        <span class="hljs-type">CashRebate</span> <span class="hljs-variable">cr2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-built_in">this</span>.moneyRebate);<br>        <br>        cr1.decorate(cn);<br>        cr2.decorate(cr1);<br>        <span class="hljs-keyword">return</span> cr2;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 先满减后打折类类似。。</span><br></code></pre></td></tr></table></figure><p><code>CashContext</code> 类：针对 <code>ISale</code> 和 <code>IFactory</code> 接口和两个工厂类编程， 对于各个打折满减算法CashSuper、CashNormal、CashReturn、CashRebate等具体类一无所知。实现了松耦合的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashContext</span> &#123;<br>    <span class="hljs-keyword">private</span> ISale cs;<br>    <br>    <span class="hljs-comment">// 构造函数传入收费策略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashContext</span><span class="hljs-params">(<span class="hljs-type">int</span> cashType)</span> &#123;<br>        <span class="hljs-type">IFactory</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (cashType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// 原价</span><br>                fs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebateReturnFactory</span>(<span class="hljs-number">1d</span>, <span class="hljs-number">0d</span>, <span class="hljs-number">0d</span>); <span class="hljs-comment">// 不打折，不满减</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// 打8折</span><br>                fs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebateReturnFactory</span>(<span class="hljs-number">0.8d</span>, <span class="hljs-number">0d</span>, <span class="hljs-number">0d</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-comment">// 满300返100</span><br>                fs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebateReturnFactory</span>(<span class="hljs-number">1d</span>, <span class="hljs-number">300d</span>, <span class="hljs-number">100d</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-comment">// 先打8折，再满300返100</span><br>                fs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebateReturnFactory</span>(<span class="hljs-number">0.8d</span>, <span class="hljs-number">300d</span>, <span class="hljs-number">100d</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-comment">// 先满200返50，再打7折</span><br>                fs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashReturnRebateFactory</span>(<span class="hljs-number">0.7d</span>, <span class="hljs-number">200d</span>, <span class="hljs-number">50d</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.cs = fs.createSalesModel();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.cs.acceptCash(price, num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>工厂方法模式是简单工厂模式的进一步抽象和推广：当只有一个工厂时，就是简单工厂模式；当有多个工厂时，就是工厂方法模式（当然外层还有一个总的工厂来决定具体选择哪一个工厂）。类似由一维进化成了二维。</p><p>工厂方法本质就是对获取对象过程的抽象，它克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。</p><h2 id="工厂方法模式的好处"><a href="#工厂方法模式的好处" class="headerlink" title="工厂方法模式的好处"></a>工厂方法模式的好处</h2><ul><li><strong>对于复杂的参数的构造对象，可以很好地对外层屏蔽代码的复杂性</strong>，注意是指创建新实例的构造对象。比如说我们用了’先打折再满减’类工厂，其实就屏蔽了装饰模式的一部分代码，让CashContext不再需要了解装饰的过程。</li><li><strong>有很好的解耦能力。</strong>也就是针对接口在编程。当我们要修改具体实现层的代码时，上层代码完全不了解实现层的情况，因此并不会影响到上层代码的调用，这就达到了解耦的目的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-24. Favor static member classes over nonstatic</title>
    <link href="/posts/e624fb1b.html"/>
    <url>/posts/e624fb1b.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-24-Favor-static-member-classes-over-nonstatic"><a href="#Item-24-Favor-static-member-classes-over-nonstatic" class="headerlink" title="Item 24: Favor static member classes over nonstatic"></a>Item 24: Favor static member classes over nonstatic</h1><p>A <em>nested class</em> is a class defined <strong>within</strong> another class.</p><blockquote><p>A nested class should exist only to serve its enclosing class. If a nested class would be useful in some other context, then it should be a top-level class.</p></blockquote><p>There are four kinds of nested classes: <em>static member classes</em>, <em>nonstatic member classes</em>, <em>anonymous classes</em>, and <em>local classes</em>. All but the first kind are known as <em>inner classes</em>.</p><h2 id="Static-member-class"><a href="#Static-member-class" class="headerlink" title="Static member class"></a>Static member class</h2><p>A static member class is the simplest kind of nested class. It is best thought of as an ordinary class that happens to be declared inside another class and has access to all of the enclosing class’s members, even those declared private.</p><p>A static member class is a static member of its enclosing class and obeys the same accessibility rules as other static members. If it is declared private, it is accessible only within the enclosing class, and so forth.</p><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>One common use of a static member class is as a <strong>public helper class</strong>, useful only in conjunction with its outer class.</p><blockquote><p>For example, consider an enum describing the operations supported by a calculator (Item 34). The Operation enum should be a public static member class of the Calculator class. Clients of Calculator could then refer to operations using names like Calculator.Operation.PLUS and Calculator.Operation.MINUS.</p></blockquote><p>A common use of private static member classes is to <strong>represent components</strong> of the object represented by their enclosing class.</p><blockquote><p>For example, consider a <code>Map</code> instance, which associates <code>keys</code> with <code>values</code>. Many <code>Map</code> implementations have an internal <code>Entry</code> object for each key-value pair in the map.</p><p>While each entry is associated with a map, the methods on an entry (<code>getKey</code>, <code>getValue</code>, and <code>setValue</code>) do not need access to the map.</p><p>Therefore, it would be wasteful to use a nonstatic member class to represent entries: <strong>a private static member class is best.</strong></p></blockquote><h2 id="Nonstatic-member-class"><a href="#Nonstatic-member-class" class="headerlink" title="Nonstatic member class"></a>Nonstatic member class</h2><p>Each instance of a nonstatic member class is implicitly associated with an <em>enclosing instance</em> of its containing class. Within instance methods of a nonstatic member class, you can invoke methods on the enclosing instance or obtain a reference to the enclosing instance using the <em>qualified this</em> construct.</p><h3 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h3><p>One common use of a nonstatic member class is to define an <em>Adapter</em> that allows an instance of the outer class to be viewed as an instance of some unrelated class.</p><blockquote><p>For example, implementations of the collection interfaces, such as <code>Set</code> and <code>List</code>, typically use nonstatic member classes to implement their iterators:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Typical use of a nonstatic member class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySet</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;E&gt; &#123;<br>   ... <span class="hljs-comment">// Bulk of the class omitted</span><br>     <br>  <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyIterator</span>();<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="Anonymous-class"><a href="#Anonymous-class" class="headerlink" title="Anonymous class"></a>Anonymous class</h2><p>An anonymous class has no name. It is not a member of its enclosing class. Rather than being declared along with other members, it is simultaneously declared and instantiated at the point of use.</p><p>Anonymous classes are permitted at any point in the code where an expression is legal. Anonymous classes have enclosing instances if and only if they occur in a nonstatic context.</p><blockquote><p>But even if they occur in a static context, they <strong>cannot have any static members</strong> other than <em>constant variables</em>, which are final primitive or string fields initialized to constant expressions.</p></blockquote><h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><ul><li>You can’t instantiate them except at the point they’re declared. </li><li>You can’t perform <code>instanceof</code> tests or do anything else that requires you to name the class. </li><li>You can’t declare an anonymous class to implement multiple interfaces or to extend a class and implement an interface at the same time. </li><li>Clients of an anonymous class can’t invoke any members except those it inherits from its supertype. </li><li>Because anonymous classes occur in the midst of expressions, they must be kept short— about ten lines or fewer—or readability will suffer.</li></ul><h3 id="Usage-2"><a href="#Usage-2" class="headerlink" title="Usage"></a>Usage</h3><ul><li>Before lambdas were added to Java (Chapter 6), anonymous classes were the preferred means of <strong>creating small <em>function objects</em> and <em>process objects</em> on the fly</strong>, but lambdas are now preferred (Item 42). </li><li>Another common use of anonymous classes is in the <strong>implementation of static factory methods</strong> (see <code>intArrayAsList</code> in Item 20).</li></ul><h2 id="Local-class"><a href="#Local-class" class="headerlink" title="Local class"></a>Local class</h2><blockquote><p>Local classes are the least frequently used of the four kinds of nested classes. </p></blockquote><p>A local class can be declared practically anywhere a <strong>local variable</strong> can be declared and obeys the same scoping rules. </p><p>Local classes have attributes in common with each of the other kinds of nested classes. </p><ul><li>Like member classes, they have names and can be used repeatedly. </li><li>Like anonymous classes, they have enclosing instances only if they are defined in a nonstatic context, and they cannot contain static members. </li><li>And like anonymous classes, they should be kept short so as not to harm readability.</li></ul><h2 id="Static-member-class-vs-nonstatic-member-class"><a href="#Static-member-class-vs-nonstatic-member-class" class="headerlink" title="Static member class vs nonstatic member class"></a>Static member class vs nonstatic member class</h2><p>If an instance of a nested class can <strong>exist in isolation</strong> from an instance of its enclosing class, then the nested class <em>must</em> be a static member class: it is impossible to create an instance of a nonstatic member class without an enclosing instance.</p><h3 id="Rule"><a href="#Rule" class="headerlink" title="Rule"></a>Rule</h3><p>If you declare a member class that <strong>does not require access to an enclosing instance</strong>, always put the <strong><code>static</code></strong> modifier in its declaration, making it a <strong>static</strong> rather than a nonstatic member class.</p><blockquote><p>If you omit this modifier, each instance will have a hidden extraneous reference to its enclosing instance.</p><ul><li>Storing this reference takes time and space.</li><li>More seriously, it can result in the enclosing instance being retained when it would otherwise be eligible for garbage collection (Item 7). The resulting memory leak can be catastrophic.</li></ul></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To recap, there are four different kinds of nested classes, and each has its place. </p><p>If a nested class needs to be visible outside of a single method or is too long to fit comfortably inside a method, use a member class. </p><p>If each instance of a member class needs a reference to its enclosing instance, make it nonstatic; otherwise, make it static. </p><p>Assuming the class belongs inside a method, if you need to create instances from only one location and there is a preexisting type that characterizes the class, make it an anonymous class; otherwise, make it a local class.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-23. Prefer class hierarchies to tagged classes</title>
    <link href="/posts/6992b2f.html"/>
    <url>/posts/6992b2f.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-23-Prefer-class-hierarchies-to-tagged-classes"><a href="#Item-23-Prefer-class-hierarchies-to-tagged-classes" class="headerlink" title="Item 23: Prefer class hierarchies to tagged classes"></a>Item 23: Prefer class hierarchies to tagged classes</h1><h2 id="Tagged-class"><a href="#Tagged-class" class="headerlink" title="Tagged class"></a>Tagged class</h2><p>Occasionally you may run across a class whose instances come in two or more flavors and contain a <em>tag</em> field (enum type) indicating the flavor of the instance. For example, consider this class, which is capable of representing a circle or a rectangle:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Tagged class - vastly inferior to a class hierarchy!</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Figure</span> &#123;<br>   <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Shape</span> &#123; RECTANGLE, CIRCLE &#125;;<br>  <br>   <span class="hljs-comment">// Tag field - the shape of this figure</span><br>   <span class="hljs-keyword">final</span> Shape shape;<br>  <br>   <span class="hljs-comment">// These fields are used only if shape is RECTANGLE</span><br>   <span class="hljs-type">double</span> length;<br>   <span class="hljs-type">double</span> width;<br>  <br>   <span class="hljs-comment">// This field is used only if shape is CIRCLE</span><br>   <span class="hljs-type">double</span> radius;<br>  <br>   <span class="hljs-comment">// Constructor for circle</span><br>   Figure(<span class="hljs-type">double</span> radius) &#123;<br>       shape = Shape.CIRCLE;<br>       <span class="hljs-built_in">this</span>.radius = radius;<br>   &#125;<br>  <br>   <span class="hljs-comment">// Constructor for rectangle</span><br>   Figure(<span class="hljs-type">double</span> length, <span class="hljs-type">double</span> width) &#123;<br>       shape = Shape.RECTANGLE;<br>       <span class="hljs-built_in">this</span>.length = length;<br>       <span class="hljs-built_in">this</span>.width = width;<br>   &#125;<br>  <br>   <span class="hljs-type">double</span> <span class="hljs-title function_">area</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">switch</span>(shape) &#123;<br>         <span class="hljs-keyword">case</span> RECTANGLE:<br>           <span class="hljs-keyword">return</span> length * width;<br>         <span class="hljs-keyword">case</span> CIRCLE:<br>           <span class="hljs-keyword">return</span> Math.PI * (radius * radius);<br>         <span class="hljs-keyword">default</span>:<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(shape);<br>       &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Tagged classes are verbose, error-prone, and inefficient.</strong></p><ul><li><p>They are cluttered with boilerplate, including enum declarations, tag fields, and switch statements. Readability is further harmed because multiple implementations are jumbled together in a single class. The data type of an instance gives no clue as to its flavor.</p></li><li><p>Fields can’t be made <em>final</em> unless constructors initialize irrelevant fields, resulting in more boilerplate.</p><p>Constructors must set the tag field and initialize the right data fields with no help from the compiler: if you initialize the wrong fields, the program will fail at runtime.</p><p>You can’t add a flavor to a tagged class unless you can modify its source file. If you do add a flavor, you must remember to add a case to every switch statement, or the class will fail at runtime.</p></li><li><p>Memory footprint is increased because instances are burdened with irrelevant fields belonging to other flavors.</p></li></ul><h2 id="Solution-Subtyping"><a href="#Solution-Subtyping" class="headerlink" title="Solution: Subtyping"></a>Solution: Subtyping</h2><blockquote><p>Example: make a abstract class: Figure, let Circle and Rectangle extend it.</p></blockquote><p>To transform a tagged class into a class hierarchy, first define an abstract class containing an abstract method for each method in the tagged class whose behavior depends on the tag value. In the <code>Figure</code> class, there is only one such method, which is area. This abstract class is the root of the class hierarchy. If there are any methods whose behavior does not depend on the value of the tag, put them in this class. Similarly, if there are any data fields used by all the flavors, put them in this class. There are no such flavor-independent methods or fields in the Figure class.</p><p>Next, define a concrete subclass of the root class for each flavor of the original tagged class. In our example, there are two: <code>circle</code> and <code>rectangle</code>. Include in each subclass the data fields particular to its flavor. In our example, radius is particular to circle, and length and width are particular to rectangle. Also include in each subclass the appropriate implementation of each abstract method in the root class.</p><h3 id="Pros"><a href="#Pros" class="headerlink" title="Pros"></a>Pros</h3><ul><li><p>Class hierarchy corrects every shortcoming of tagged classes noted previously.</p><ul><li>The code is simple and clear, containing none of the boilerplate found in the original.</li><li>The implementation of each flavor is allotted its own class, and none of these classes is encumbered by irrelevant data fields.</li><li>All fields are final.</li><li>The compiler ensures that each class’s constructor initializes its data fields and that each class has an implementation for every abstract method declared in the root class. This eliminates the possibility of a runtime failure due to a missing switch case.</li><li>Multiple programmers can extend the hierarchy independently and interoperably without access to the source for the root class. There is a separate data type associated with each flavor, allowing programmers to indicate the flavor of a variable and to restrict variables and input parameters to a particular flavor.</li></ul></li><li><p>Another advantage of class hierarchies is that they can be made to reflect <strong>natural hierarchical relationships among types</strong>, allowing for increased flexibility and better compile-time type checking.</p><blockquote><p>Suppose the tagged class in the original example also allowed for <code>squares</code>. The class hierarchy could be made to reflect the fact that a square is a special kind of rectangle (assuming both are immutable)</p></blockquote></li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, tagged classes are seldom appropriate. If you’re tempted to write a class with an explicit tag field, think about whether the tag could be eliminated and the class replaced by a hierarchy. When you encounter an existing class with a tag field, consider refactoring it into a hierarchy.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-22. Use interfaces only to define types</title>
    <link href="/posts/f7d80670.html"/>
    <url>/posts/f7d80670.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-22-Use-interfaces-only-to-define-types"><a href="#Item-22-Use-interfaces-only-to-define-types" class="headerlink" title="Item 22: Use interfaces only to define types"></a>Item 22: Use interfaces only to define types</h1><p>When a class implements an interface, the interface serves as a <strong><em>type</em> that can be used to refer to instances of the class</strong>. That a class implements an interface should therefore say something about what a client can do with instances of the class. It is inappropriate to define an interface for any other purpose. </p><h2 id="Inappropriate-example-export-constants"><a href="#Inappropriate-example-export-constants" class="headerlink" title="Inappropriate example - export constants"></a>Inappropriate example - export constants</h2><p>One kind of interface that fails this test is the so-called <em>constant interface</em>. Such an interface contains no methods; it consists solely of static final fields, each exporting a constant. Classes using these constants implement the interface to avoid the need to qualify constant names with a class name.</p><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Constant interface antipattern - do not use!</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PhysicalConstants</span> &#123;<br>   <span class="hljs-comment">// Avogadro&#x27;s number (1/mol)</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">AVOGADROS_NUMBER</span>   <span class="hljs-operator">=</span> <span class="hljs-number">6.022_140_857e23</span>;<br>   <span class="hljs-comment">// Boltzmann constant (J/K)</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">BOLTZMANN_CONSTANT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.380_648_52e-23</span>;<br>   <span class="hljs-comment">// Mass of the electron (kg)</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">ELECTRON_MASS</span>      <span class="hljs-operator">=</span> <span class="hljs-number">9.109_383_56e-31</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>The constant interface pattern is a poor use of interfaces.</strong></p><ul><li><p>That a class uses some constants internally is an implementation detail. Implementing a constant interface causes this implementation detail to leak into the class’s exported API.</p></li><li><p>Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility.</p></li><li><p>If a nonfinal class implements a constant interface, all of its subclasses will have their namespaces polluted by the constants in the interface.</p></li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ol><li><p>If the constants are <strong>strongly tied</strong> to an existing class or interface, you should <strong>add them to the class or interface</strong>.</p><blockquote><p>For example, all of the boxed numerical primitive classes, such as Integer and Double, export MIN_VALUE and MAX_VALUE constants.</p></blockquote></li><li><p>If the constants are best viewed as members of an enumerated type, you should export them with an <em><strong>enum type</strong></em> (Item 34).</p></li><li><p>Otherwise, you should export the constants with a noninstantiable <em><strong>utility class</strong></em> (Item 4).</p><p>Utility class version of the <code>PhysicalConstants</code> example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Constant utility class</span><br><span class="hljs-keyword">package</span> com.effectivejava.science;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhysicalConstants</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">PhysicalConstants</span><span class="hljs-params">()</span> &#123; &#125;  <span class="hljs-comment">// Prevents instantiation</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">AVOGADROS_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">6.022_140_857e23</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">BOLTZMANN_CONST</span> <span class="hljs-operator">=</span><span class="hljs-number">1.380_648_52e-23</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">ELECTRON_MASS</span> <span class="hljs-operator">=</span> <span class="hljs-number">9.109_383_56e-31</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, interfaces should be used only to define types. They should not be used merely to export constants.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-21. Design interfaces for posterity</title>
    <link href="/posts/b9f3ba79.html"/>
    <url>/posts/b9f3ba79.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-21-Design-interfaces-for-posterity"><a href="#Item-21-Design-interfaces-for-posterity" class="headerlink" title="Item 21: Design interfaces for posterity"></a>Item 21: Design interfaces for posterity</h1><p>Prior to Java 8, it was impossible to add methods to interfaces without breaking existing implementations. If you added a new method to an interface, existing implementations would, in general, lack the method, resulting in a compile-time error.</p><p>In Java 8, the <em>default method</em> construct was added, with the intent of allowing the <strong>addition of methods to existing interfaces</strong>. But adding new methods to existing interfaces is fraught with risk.</p><p>The declaration for a default method includes a <em>default implementation</em> that is used by all classes that implement the interface but do not implement the default method. While the addition of default methods to Java makes it possible to add methods to an existing interface, <strong>there is no guarantee that these methods will work in all preexisting implementations.</strong> Default methods are “injected” into existing implementations without the knowledge or consent of their implementors. Before Java 8, these implementations were written with the tacit understanding that their interfaces would <em>never</em> acquire any new methods.</p><blockquote><p>Many new default methods were added to the core collection interfaces in Java 8, primarily to facilitate the use of <em>lambdas</em> (Chapter 6). The Java libraries’ default methods are high-quality general-purpose implementations, and in most cases, they work fine. But <strong>it is not always possible to write a default method that maintains all invariants of every conceivable implementation.</strong></p></blockquote><blockquote><p>Preexisting collection implementations that were not part of the Java platform did not have the opportunity to make analogous changes in lockstep with the interface change, and some have yet to do so.</p></blockquote><p><strong>In the presence of default methods, existing implementations of an interface may compile without error or warning but fail at runtime.</strong> A handful of the methods added to the collections interfaces in Java 8 are known to be susceptible, and a handful of existing implementations are known to be affected.</p><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p>Using default methods to <strong>add new methods to existing interfaces</strong> should be avoided unless the need is critical, in which case you should think long and hard about whether an existing interface implementation might be broken by your default method implementation.</p><p>Default methods are, however, extremely useful for <strong>providing standard method implementations when an interface is created</strong>, to ease the task of implementing the interface (Item 20).</p></li><li><p>It is also worth noting that default methods were <strong>not</strong> designed to support <strong>removing methods from interfaces or changing the signatures of existing methods</strong>. Neither of these interface changes is possible without breaking existing clients.</p></li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Even though default methods are now a part of the Java platform, <strong>it is still of the utmost importance to design interfaces with great care.</strong> While default methods make it <em>possible</em> to add methods to existing interfaces, there is great risk in doing so.</p><blockquote><p>If an interface contains a minor flaw, it may irritate its users <strong>forever</strong>; if an interface is severely deficient, it may doom the API that contains it.</p></blockquote><p>Therefore, it is critically important to <strong>test each new interface before you release it</strong>. Multiple programmers should implement each interface in different ways.</p><blockquote><p>At a minimum, you should aim for <strong>three diverse implementations</strong>. Equally important is to write <strong>multiple client programs</strong> that use instances of each new interface to perform various tasks.</p><ul><li><p>This will go a long way toward ensuring that each interface <strong>satisfies all of its intended uses</strong>.</p></li><li><p>These steps will allow you to <strong>discover flaws</strong> in interfaces <strong>before</strong> they are released, when you can still correct them easily.</p></li></ul><p>While it may be possible to correct some interface flaws <strong>after</strong> an interface is released, <strong>you cannot count on it</strong>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-20. Prefer interfaces to abstract classes</title>
    <link href="/posts/bffccc77.html"/>
    <url>/posts/bffccc77.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-20-Prefer-interfaces-to-abstract-classes"><a href="#Item-20-Prefer-interfaces-to-abstract-classes" class="headerlink" title="Item 20: Prefer interfaces to abstract classes"></a>Item 20: Prefer interfaces to abstract classes</h1><p>Java has two mechanisms to define a type that permits multiple implementations: <strong>interfaces</strong> and <strong>abstract classes</strong>. Since the introduction of <em>default methods</em> for interfaces in Java 8, both mechanisms allow you to provide implementations for some instance methods. </p><p>A major difference is that to implement the type defined by an abstract class, a class must be a subclass of the abstract class. Because Java permits only <strong>single inheritance</strong>, this restriction on abstract classes severely <strong>constrains their use as type definitions</strong>. Any class that defines all the required methods and obeys the general contract is permitted to implement an interface, regardless of where the class resides in the class hierarchy.</p><h2 id="Advantages-of-interfaces"><a href="#Advantages-of-interfaces" class="headerlink" title="Advantages of interfaces"></a>Advantages of interfaces</h2><h3 id="1-Easy-to-retrofit"><a href="#1-Easy-to-retrofit" class="headerlink" title="1. Easy to retrofit"></a>1. Easy to retrofit</h3><p><strong>Existing classes can easily be retrofitted to implement a new interface.</strong> All you have to do is to add the required methods, if they don’t yet exist, and to add an implements clause to the class declaration.</p><blockquote><p>Existing classes <strong>cannot</strong>, in general, be retrofitted to extend a new <strong>abstract class</strong>. If you want to have two classes extend the same abstract class, you have to place it high up in the type hierarchy where it is an ancestor of both classes. Unfortunately, this can cause great collateral damage to the type hierarchy, forcing all descendants of the new abstract class to subclass it, whether or not it is appropriate.</p></blockquote><h3 id="2-Ideal-for-defining-mixins"><a href="#2-Ideal-for-defining-mixins" class="headerlink" title="2. Ideal for defining mixins"></a>2. Ideal for defining mixins</h3><p><strong>Interfaces are ideal for defining mixins.</strong> An interface is called a mixin because it allows the optional functionality to be “mixed in” to the type’s primary functionality.</p><blockquote><p>Loosely speaking, a <em>mixin</em> is a type that a class can implement in addition to its “primary type,” to declare that it provides some optional behavior.</p></blockquote><blockquote><p>Abstract classes can’t be used to define mixins for the same reason that they can’t be retrofitted onto existing classes: a class cannot have more than one parent, and there is no reasonable place in the class hierarchy to insert a mixin.</p></blockquote><h3 id="3-Nonhierarchical"><a href="#3-Nonhierarchical" class="headerlink" title="3. Nonhierarchical"></a>3. Nonhierarchical</h3><p><strong>Interfaces allow for the construction of nonhierarchical type frameworks.</strong></p><p><em>Type</em> hierarchies are great for organizing some things, but other things don’t fall neatly into a rigid hierarchy.</p><p>You don’t always need this level of flexibility, but when you do, interfaces are a lifesaver.</p><blockquote><p>The alternative is a bloated class hierarchy containing a separate class for every supported combination of attributes. If there are $n$ attributes in the type system, there are $2^n$ possible combinations that you might have to support. This is what’s known as a <em>combinatorial explosion</em>. Bloated class hierarchies can lead to bloated classes with many methods that differ only in the type of their arguments because there are no types in the class hierarchy to capture common behaviors.</p></blockquote><h3 id="4-Safe-and-powerful-to-enhance-functionality"><a href="#4-Safe-and-powerful-to-enhance-functionality" class="headerlink" title="4. Safe and powerful to enhance functionality"></a>4. Safe and powerful to enhance functionality</h3><p><strong>Interfaces enable safe, powerful functionality enhancements</strong> via the <em>wrapper class</em> idiom (Item 18). If you use abstract classes to define types, you leave the programmer who wants to add functionality with no alternative but inheritance. The resulting classes are less powerful and more fragile than wrapper classes.</p><h2 id="Skeletal-implementation"><a href="#Skeletal-implementation" class="headerlink" title="Skeletal implementation"></a>Skeletal implementation</h2><p>When there is an <strong>obvious implementation</strong> of an interface method in terms of other interface methods, consider providing implementation assistance to programmers in the form of a <strong>default method</strong>.</p><h3 id="Limits-of-default-methods"><a href="#Limits-of-default-methods" class="headerlink" title="Limits of default methods"></a>Limits of default methods</h3><ol><li><p>Although many interfaces specify the behavior of <strong><em>Object</em> methods</strong> such as <code>equals</code> and <code>hashCode</code>, you are not permitted to provide default methods for them.</p></li><li><p>Also, interfaces are not permitted to contain <strong>instance fields or nonpublic static members</strong> (with the exception of private static methods).</p></li><li><p>Finally, you can’t add default methods to an interface that <strong>you don’t control</strong>.</p></li></ol><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>You can, however, combine the advantages of interfaces and abstract classes by providing an abstract <em><strong>skeletal implementation class</strong></em> to go with an interface.</p><ul><li><p>The <em>interface</em> defines the <strong>type</strong>, perhaps providing some <strong>default methods</strong>;</p></li><li><p>The <em>skeletal implementation class</em> implements the <strong>remaining non-primitive interface methods</strong> atop the primitive interface methods.</p><blockquote><p>This is the <em>Template Method</em> pattern.</p></blockquote></li></ul><p>Extending a skeletal implementation takes most of the work out of implementing an interface.</p><p>By convention, skeletal implementation classes are called <strong>Abstract<em>Interface</em></strong>, where <em>Interface</em> is the name of the interface they implement. For example, the Collections Framework provides a skeletal implementation to go along with each main collection interface: <code>AbstractCollection</code>, <code>AbstractSet</code>, <code>AbstractList</code>, and <code>AbstractMap</code>.</p><h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><p>The beauty of skeletal implementation classes is that they provide all of the implementation assistance of abstract classes without imposing the severe constraints that abstract classes impose when they serve as type definitions. For most implementors of an interface with a skeletal implementation class, extending this class is the obvious choice, but it is strictly optional. If a class cannot be made to extend the skeletal implementation, the class can always implement the interface directly. The class still benefits from any default methods present on the interface itself.</p><p>Furthermore, the skeletal implementation can still aid the implementor’s task. <strong>The class implementing the interface</strong> can <strong>forward invocations of interface methods</strong> to a <strong>contained instance of a private inner class that extends the skeletal implementation</strong>. This technique, known as <em>simulated multiple inheritance</em>, is closely related to the wrapper class idiom (Item 18). It provides many of the benefits of multiple inheritance, while avoiding the pitfalls.</p><h3 id="How-to-write-a-skeletal-implementation"><a href="#How-to-write-a-skeletal-implementation" class="headerlink" title="How to write a skeletal implementation"></a>How to write a skeletal implementation</h3><ul><li><p>First, study the interface and decide which methods are the <strong>primitives</strong> in terms of which the others can be implemented. These primitives will be the <strong>abstract methods in your skeletal implementation</strong>.</p></li><li><p>Next, provide <strong>default methods</strong> in the interface for all of the methods that <strong>can be implemented directly atop the primitives</strong>, but recall that you may not provide default methods for <em>Object</em> methods such as <code>equals</code> and <code>hashCode</code>.</p><ul><li>If the primitives and default methods cover the interface, you’re done, and have no need for a skeletal implementation class.</li><li>Otherwise, write a class declared to implement the interface, with <strong>implementations of all of the remaining interface methods</strong>. The class may contain any nonpublic fields ands methods appropriate to the task.</li></ul></li></ul><p>Example: <code>Map.Entry</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Skeletal implementation class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractMapEntry</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>  <span class="hljs-comment">// Entries in a modifiable map must override this method</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span> &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>  &#125;<br>  <br>  <span class="hljs-comment">// Implements the general contract of Map.Entry.equals</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>)<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    Map.Entry&lt;?, ?&gt; e = (Map.Entry) o;<br>    <span class="hljs-keyword">return</span> Objects.equals(e.getKey(), getKey())<br>      &amp;&amp; Objects.equals(e.getValue(), getValue());<br>  &#125;<br>  <br>  <span class="hljs-comment">// Implements the general contract of Map.Entry.hashCode</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());<br>  &#125;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getKey() + <span class="hljs-string">&quot;=&quot;</span> + getValue();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The obvious primitives are <code>getKey</code>, <code>getValue</code>, and (optionally) <code>setValue</code>. The interface specifies the behavior of <code>equals</code> and <code>hashCode</code>, and there is an obvious implementation of <code>toString</code> in terms of the <strong>primitives</strong>.</p><p>Since you are not allowed to provide default implementations for the <em>Object</em> methods, all implementations are placed in the skeletal implementation class.</p><blockquote><p>Note that this skeletal implementation could not be implemented in the <code>Map.Entry</code> <strong>interface</strong> or as a <strong>subinterface</strong> because <strong>default methods are not permitted to override <em>Object</em> methods</strong> such as <code>equals</code>, <code>hashCode</code>, and <code>toString</code>.</p></blockquote><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ol><li>Because skeletal implementations are designed for inheritance, <strong>good documentation is absolutely essential in a skeletal implementation,</strong> whether it consists of default methods on an interface or a separate abstract class.</li><li>A minor variant on the skeletal implementation is the <em>simple implementation,</em> exemplified by <code>AbstractMap.SimpleEntry</code>. It differs in that it isn’t abstract: it is the simplest possible working implementation.</li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To summarize, an interface is generally the best way to define a type that permits multiple implementations. If you export a nontrivial interface, you should strongly consider providing a <strong>skeletal implementation</strong> to go with it.</p><p>To the extent possible, you should provide the skeletal implementation via <strong>default methods</strong> on the interface so that all implementors of the interface can make use of it. That said, restrictions on interfaces typically mandate that a skeletal implementation take the form of an abstract class (not a subinterface).</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-19. Design and document for inheritance or else prohibit it</title>
    <link href="/posts/1e2fe51a.html"/>
    <url>/posts/1e2fe51a.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-19-Design-and-document-for-inheritance-or-else-prohibit-it"><a href="#Item-19-Design-and-document-for-inheritance-or-else-prohibit-it" class="headerlink" title="Item 19: Design and document for inheritance or else prohibit it"></a>Item 19: Design and document for inheritance or else prohibit it</h1><p>A class to be designed and documented for inheritance must document precisely the effects of overriding any method. In other words, <strong>the class must document its</strong> <em><strong>self-use</strong></em> <strong>of overridable methods.</strong></p><p>For each <strong>public or protected method</strong> (including constructor), the documentation must indicate which overridable methods the method invokes, in what sequence, and how the results of each invocation affect subsequent processing. (By <em>overridable</em>, we mean nonfinal and either public or protected.)</p><blockquote><p>More generally, a class must document any circumstances under which it might invoke an overridable method. For example, invocations might come from background threads or static initializers.</p></blockquote><h2 id="Example-of-the-document"><a href="#Example-of-the-document" class="headerlink" title="Example of the document"></a>Example of the document</h2><p><strong>A method that invokes overridable methods</strong> contains a description of these invocations at the end of its documentation comment. The description is in a special section of the specification, labeled “<strong>Implementation Requirements</strong>,” which is generated by the Javadoc tag <code>@implSpec</code>. This section describes the inner workings of the method.</p><p>Example from <code>java.util.AbstractCollection</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span><br></code></pre></td></tr></table></figure><p>Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that Objects.equals(o, e), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).</p><p><strong>Implementation Requirements:</strong> This implementation iterates over the col- lection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator’s remove method. Note that this implementation throws an <code>UnsupportedOperationException</code> if the iterator returned by this collection’s iterator method does not implement the remove method and this collection contains the specified object.</p><blockquote><p>This documentation leaves no doubt that overriding the <code>iterator</code> method will affect the behavior of the <code>remove</code> method. It also describes exactly how the behavior of the <code>Iterator</code> returned by the <code>iterator</code> method will affect the behavior of the <code>remove</code> method.</p></blockquote><p>But this violate the dictum that <strong>good API documentation should describe <em>what</em> a given method does and not <em>how</em> it does it</strong>.</p><p>This is an unfortunate consequence of the fact that <strong>inheritance violates encapsulation</strong>. To document a class so that it can be safely subclassed, you must describe implementation details that should otherwise be left unspecified.</p><h2 id="Restrictions-of-classes-for-inheritance"><a href="#Restrictions-of-classes-for-inheritance" class="headerlink" title="Restrictions of classes for inheritance"></a>Restrictions of classes for inheritance</h2><p>Designing a class for inheritance requires great effort and places substantial limitations on the class.</p><ol><li><p><strong>Constructors must not invoke overridable methods,</strong> directly or indirectly.</p><p>Because the superclass constructor runs before the subclass constructor, so the overriding method in the subclass will get invoked before the subclass constructor has run.</p><blockquote><p>Note that it <em>is</em> safe to invoke private methods, final methods, and static meth- ods, none of which are overridable, from a constructor.</p></blockquote></li><li><p>For classes that implement <code>Cloneable</code>:</p><p><strong><code>Clone</code> method must not invoke overridable methods,</strong> directly or indirectly.</p><blockquote><p>Because the overriding method will run before the subclass’s clone method has a chance to fix the clone’s state.</p></blockquote></li><li><p>For classes that implement <code>Serializable</code>:</p><p><strong><code>readObject</code> method must not invoke overridable methods,</strong> directly or indirectly.</p><blockquote><p>Because the overriding method will run before the subclass’s state has been deserialized.</p></blockquote><p>If the class has a <code>readResolve</code> or <code>writeReplace</code> method, you must make the <code>readResolve</code> or <code>writeReplace</code> method <strong>protected</strong> rather than private. If these methods are private, they will be silently ignored by subclasses.</p></li></ol><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="Provide-hooks"><a href="#Provide-hooks" class="headerlink" title="Provide hooks"></a>Provide hooks</h3><p>To allow programmers to write efficient subclasses without undue pain, <strong>a class may have to provide hooks into its internal workings in the form of judiciously chosen protected methods</strong> or, in rare instances, protected fields.</p><p>Example: <code>removeRange</code> method from <code>java.util.AbstractList</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span><br></code></pre></td></tr></table></figure><p>Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex &#x3D;&#x3D; fromIndex, this operation has no effect.)</p><p>This method is called by the clear operation on this list and its sublists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the <code>clear</code> operation on this list and its sublists.</p><p><strong>Implementation Requirements:</strong> This implementation gets a list iterator positioned before fromIndex and repeatedly calls <code>ListIterator.next</code> followed by <code>ListIterator.remove</code>, until the entire range has been removed. Note: If <code>ListIterator.remove</code> requires linear time, this implementation requires quadratic time.</p><h3 id="Write-subclasses-to-test"><a href="#Write-subclasses-to-test" class="headerlink" title="Write subclasses to test"></a>Write subclasses to test</h3><p>So how do you decide what protected members to expose when you design a class for inheritance? You should expose as few protected members as possible because each one represents a commitment to an implementation detail. On the other hand, you must not expose too few because a missing protected member can render a class practically unusable for inheritance.</p><p><strong>The only way to test a class designed for inheritance is to write subclasses.</strong> If you omit a crucial protected member, trying to write a subclass will make the omission painfully obvious. Conversely, if several subclasses are written and none uses a protected member, you should probably make it private.</p><blockquote><p>Experience shows that three subclasses are usually sufficient to test an extendable class. One or more of these subclasses should be written by someone other than the superclass author.</p></blockquote><p>When you design for inheritance a class that is likely to achieve wide use, realize that you are <strong>committing <em>forever</em></strong> to the self-use patterns that you document and to the implementation decisions implicit in its protected methods and fields. These commitments can make it difficult or impossible to improve the performance or functionality of the class in a subsequent release. Therefore, <strong>you must test your class by writing subclasses</strong> <strong>before</strong> <strong>you release it.</strong></p><h3 id="For-ordinary-concrete-classes"><a href="#For-ordinary-concrete-classes" class="headerlink" title="For ordinary concrete classes"></a>For ordinary concrete classes</h3><p><strong>The best solution is to prohibit subclassing in classes that are not designed and documented to be safely subclassed.</strong> </p><p>There are two ways to prohibit subclassing.</p><ol><li><p>Declare the class final.</p></li><li><p>Make all the constructors private or package-private and to add public static factories in place of the constructors.</p><blockquote><p>This way provides the flexibility to use subclasses internally (Item 17)</p></blockquote></li></ol><h3 id="For-classes-have-to-allow-inheritance"><a href="#For-classes-have-to-allow-inheritance" class="headerlink" title="For classes have to allow inheritance"></a>For classes have to allow inheritance</h3><p>If a concrete class does not implement a standard interface, then you may inconvenience some programmers by prohibiting inheritance. If you must allow inheritance from such a class, one reasonable approach is <strong>to ensure that the class never invokes any of its overridable methods and to document this fact</strong>. In other words, eliminate the class’s self-use of overridable methods entirely. In doing so, you’ll create a class that is reasonably safe to subclass. Overriding a method will never affect the behavior of any other method.</p><blockquote><p>You can eliminate a class’s self-use of overridable methods mechanically, without changing its behavior. Move the body of each overridable method to a private “helper method” and have each overridable method invoke its private helper method. Then replace each self-use of an overridable method with a direct invocation of the overridable method’s private helper method.</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Designing a class for inheritance is hard work. You must <strong>document all of its self-use patterns</strong>, and once you’ve documented them, you must commit to them for the life of the class. If you fail to do this, subclasses may become dependent on implementation details of the superclass and may break if the implementation of the superclass changes.</p><p>To allow others to write <em>efficient</em> subclasses, you may also have to <strong>export one or more protected methods</strong> (to be the hooks).</p><p>Unless you know there is a real need for subclasses, you are probably <strong>better off prohibiting inheritance</strong> by declaring your class final or ensuring that there are no accessible constructors.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-18. Favor composition over inheritance</title>
    <link href="/posts/85caa9e3.html"/>
    <url>/posts/85caa9e3.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-18-Favor-composition-over-inheritance"><a href="#Item-18-Favor-composition-over-inheritance" class="headerlink" title="Item 18: Favor composition over inheritance"></a>Item 18: Favor <em>composition</em> over <em>inheritance</em></h1><p>Inheritance is a powerful way to achieve code reuse, but it is not always the best tool for the job. Used inappropriately, it leads to fragile software. It is safe to use inheritance within a package, where the subclass and the superclass implementations are under the control of the same programmers. It is also safe to use inheritance when extending classes specifically designed and documented for extension (Item 19). Inheriting from ordinary concrete classes across package boundaries, however, is dangerous.</p><p><strong>Unlike method invocation, inheritance violates encapsulation.</strong> In other words, a subclass depends on the implementation details of its superclass for its proper function. The superclass’s implementation may change from release to release, and if it does, the subclass may break, even though its code has not been touched. As a consequence, a subclass must evolve in tandem with its superclass, unless the superclass’s authors have designed and documented it specifically for the purpose of being extended.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Forwarding-class"><a href="#Forwarding-class" class="headerlink" title="Forwarding  class"></a>Forwarding  class</h3><p>Instead of extending an existing class, give your new class <strong>a private field that references an instance of the existing class</strong>. This design is called <em><strong>composition</strong></em> because the existing class becomes a component of the new one.</p><p>Each instance method in the new class invokes the corresponding method on the contained instance of the existing class and returns the results. This is known as <em><strong>forwarding</strong></em>, and the methods in the new class are known as <em>forwarding methods</em>.</p><blockquote><p>The resulting class will be rock solid, with no dependencies on the implementation details of the existing class. Even adding new methods to the existing class will have no impact on the new class.</p></blockquote><h3 id="Wrapper-class"><a href="#Wrapper-class" class="headerlink" title="Wrapper class"></a>Wrapper class</h3><p>A class that “wraps” another forwarding class instance and adds some new function is known as a <em>wrapper</em> class, This is also known as the <em>Decorator</em> pattern. </p><blockquote><p>Sometimes the combination of composition and forwarding is loosely referred to as <em>delegation.</em> Technically it’s not delegation unless the wrapper object passes itself to the wrapped object.</p></blockquote><p>The disadvantages of wrapper classes are few. One caveat is that <em><strong>wrapper* classes are not suited for use in *callback frameworks</strong></em>, wherein objects pass self-references to other objects for subsequent invocations (“callbacks”). Because a wrapped object doesn’t know of its wrapper, it passes a reference to itself (this) and callbacks elude the wrapper. This is known as the <em>SELF problem</em>.</p><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>Inheritance is appropriate only in circumstances where the subclass really is a <em>subtype</em> of the superclass. In other words, a class <em>B</em> should extend a class <em>A</em> only if an <strong>“is-a”</strong> relationship exists between the two classes.</p><p>If you are tempted to have a class <em>B</em> extend a class <em>A</em>, ask yourself the question: <strong>Is every <em>B</em> really an <em>A</em>?</strong> If you cannot truthfully answer yes to this question, <em>B</em> should not extend <em>A</em>. If the answer is no, it is often the case that <em>B</em> should contain a private instance of <em>A</em> and expose a different API: <em>A</em> is not an essential part of <em>B</em>, merely a detail of its implementation.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-17. Minimize mutability</title>
    <link href="/posts/df659f85.html"/>
    <url>/posts/df659f85.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-17-Minimize-mutability"><a href="#Item-17-Minimize-mutability" class="headerlink" title="Item 17: Minimize mutability"></a>Item 17: Minimize mutability</h1><p>An immutable class is simply a class whose instances cannot be modified. All of the information contained in each instance is <strong>fixed</strong> for the lifetime of the object, so no changes can ever be observed.</p><blockquote><p>The Java platform libraries contain many immutable classes, including <em>String</em>, the <em>boxed primitive classes</em>, and <em>BigInteger</em> and <em>BigDecimal</em>.</p></blockquote><h2 id="Rules-for-making-a-class-immutable"><a href="#Rules-for-making-a-class-immutable" class="headerlink" title="Rules for making a class immutable"></a>Rules for making a class immutable</h2><ol><li><p><strong>Don’t provide methods that modify the object’s state</strong> (known as <em>mutators</em>).</p></li><li><p><strong>Ensure that the class can’t be extended.</strong> This prevents careless or malicious subclasses from compromising the immutable behavior of the class by behaving as if the object’s state has changed.</p><p>Preventing subclassing is generally accomplished by:</p><ol><li><p>Making the class final;</p></li><li><p>Or making all of its constructors private or package-private and add public static factories in place of the public constructors (Item 1), which is more flexible.</p><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Immutable class with static factories instead of constructors</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> re;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> im;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Complex</span><span class="hljs-params">(<span class="hljs-type">double</span> re, <span class="hljs-type">double</span> im)</span> &#123;<br>    <span class="hljs-built_in">this</span>.re = re;<br><span class="hljs-built_in">this</span>.im = im;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Complex <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">double</span> re, <span class="hljs-type">double</span> im)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Complex</span>(re, im);<br>  &#125;<br>   ... <span class="hljs-comment">// Remainder unchanged</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p><strong>Make all fields final.</strong> This clearly expresses your intent in a manner that is enforced by the system. Also, it is necessary to ensure correct behavior if a reference to a newly created instance is passed from one thread to another without synchronization, as spelled out in the <em>memory model</em>.</p></li><li><p><strong>Make all fields private, use <em>accessor</em> to access them.</strong> This prevents clients from obtaining access to mutable objects referred to by fields and modifying these objects directly.</p><blockquote><p>While it is technically permissible for immutable classes to have public final fields containing primitive values or references to immutable objects, it is not recommended because it precludes changing the internal representation in a later release (Items 15 and 16).</p></blockquote></li><li><p><strong>Ensure exclusive access to any mutable components.</strong> If your class has any fields that refer to <strong>mutable objects</strong>, ensure that clients of the class <em>cannot</em> obtain references to these objects. Never initialize such a field to a client-provided object reference or return the field from an accessor.</p><blockquote><p>Make <em>defensive copies</em> (Item 50) in constructors, accessors, and <code>readObject</code> methods (Item 88).</p></blockquote></li></ol><h2 id="Pros-cons-of-immutable-objects"><a href="#Pros-cons-of-immutable-objects" class="headerlink" title="Pros &amp; cons of immutable objects"></a>Pros &amp; cons of immutable objects</h2><h3 id="Pros"><a href="#Pros" class="headerlink" title="Pros"></a>Pros</h3><ol><li><p><strong>Immutable objects are simple.</strong> An immutable object can be in exactly one state, the state in which it was created. If you make sure that all constructors establish class invariants, then it is guaranteed that these invariants will remain true for all time, with no further effort on your part or on the part of the programmer who uses the class.</p><blockquote><p>Mutable objects, on the other hand, can have arbitrarily complex state spaces. If the documentation does not provide a precise description of the state transitions performed by <em>mutator</em> methods, it can be difficult or impossible to use a mutable class reliably.</p></blockquote></li><li><p><strong>Immutable objects are inherently thread-safe; they require no synchronization.</strong> They cannot be corrupted by multiple threads accessing them concurrently. This is far and away the easiest approach to achieve thread safety.</p><blockquote><p>Since no thread can ever observe any effect of another thread on an immutable object, <strong>immutable objects can be shared freely.</strong> Immutable classes should therefore encourage clients to reuse existing instances wherever possible. One easy way to do this is to <strong>provide public static final constants for commonly used values</strong>. For example, the <code>Complex</code> class might provide these constants:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Complex</span> <span class="hljs-variable">ZERO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Complex</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Complex</span> <span class="hljs-variable">ONE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Complex</span> <span class="hljs-variable">I</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Complex</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>An immutable class can provide <strong>static factories</strong> (Item 1) that cache frequently requested instances to avoid creating new instances when existing ones would do.</p></blockquote></li><li><p><strong>Not only can you share immutable objects, but they can share their internals.</strong> </p><blockquote><p>For example, the <code>BigInteger</code> class uses a sign-magnitude representation internally. The sign is represented by an int, and the magnitude is represented by an int array. The negate method produces a new BigInteger of like magnitude and opposite sign. It does not need to copy the array even though it is mutable; the newly created <code>BigInteger</code> <strong>points to the same internal array as the original</strong>.</p></blockquote></li><li><p><strong>Immutable objects make great building blocks for other objects,</strong> whether mutable or immutable. It’s much easier to maintain the invariants of a complex object if you know that its component objects will not change underneath it.</p><blockquote><p>A special case of this principle is that immutable objects make great map keys and set elements: you don’t have to worry about their values changing once they’re in the map or set, which would destroy the map or set’s invariants.</p></blockquote></li><li><p><strong>Immutable objects provide failure atomicity for free</strong> (Item 76). Their state never changes, so there is no possibility of a temporary inconsistency.</p></li></ol><h3 id="Cons"><a href="#Cons" class="headerlink" title="Cons"></a>Cons</h3><p><strong>The major disadvantage of immutable classes is that they require a separate object for each distinct value.</strong> Creating these objects can be costly, especially if they are large.</p><p>The package-private mutable companion class approach works fine if you can accurately predict which complex operations clients will want to perform on your immutable class. If not, then your best bet is to provide a <em>public</em> mutable companion class.</p><blockquote><p>The main example of this approach in the Java platform libraries is the String class, whose mutable companion is <code>StringBuilder</code> (and its obsolete predecessor, <code>StringBuffer</code>).</p></blockquote><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li>If you choose to have your immutable class implement <code>Serializable</code> and it contains one or more fields that refer to mutable objects, you must provide an explicit <code>readObject</code> or <code>readResolve</code> method, or use the <code>ObjectOutputStream.writeUnshared</code> and <code>ObjectInputStream.readUnshared</code> methods, even if the default serialized form is acceptable. <strong>Otherwise an attacker could create a mutable instance of your class.</strong> This topic is covered in detail in Item 88.</li><li><strong>Constructors should create fully initialized objects with all of their invari- ants established.</strong> Don’t provide a public initialization method separate from the constructor or static factory unless there is a <em>compelling</em> reason to do so. Similarly, don’t provide a “reinitialize” method that enables an object to be reused as if it had been constructed with a different initial state. Such methods generally provide little if any performance benefit at the expense of increased complexity.</li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To summarize, resist the urge to write a setter for every getter. <strong>Classes should be immutable unless there’s a very good reason to make them mutable.</strong> Immutable classes provide many advantages, and their only disadvantage is the potential for performance problems under certain circumstances. You should provide a public mutable companion class for your immutable class <em>only</em> once you’ve confirmed that it’s necessary to achieve satisfactory performance (Item 67).</p><blockquote><p>You should always make small value objects, such as <code>PhoneNumber</code> and Complex, immutable. (There are several classes in the Java platform libraries, such as <code>java.util.Date</code> and <code>java.awt.Point</code>, that should have been immutable but aren’t.) You should seriously consider making larger value objects, such as <code>String</code> and <code>BigInteger</code>, immutable as well.</p></blockquote><p>There are some classes for which immutability is impractical. <strong>If a class cannot be made immutable, limit its mutability as much as possible.</strong> Reducing the number of states in which an object can exist makes it easier to reason about the object and reduces the likelihood of errors. Therefore, make every field final unless there is a compelling reason to make it nonfinal. Combining the advice of this item with that of Item 15, your natural inclination should be to <strong>declare every field <code>private final</code> unless there’s a good reason to do otherwise.</strong></p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-16. In public classes, use accessor methods, not public fields</title>
    <link href="/posts/a84e8e69.html"/>
    <url>/posts/a84e8e69.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-16-In-public-classes-use-accessor-methods-not-public-fields"><a href="#Item-16-In-public-classes-use-accessor-methods-not-public-fields" class="headerlink" title="Item 16: In public classes, use accessor methods, not public fields"></a>Item 16: In public classes, use accessor methods, not public fields</h1><h2 id="Public-class"><a href="#Public-class" class="headerlink" title="Public class"></a>Public class</h2><p><strong>If a class is accessible outside its package, provide accessor methods</strong> to preserve the flexibility to change the class’s internal representation. If a public class exposes its data fields, all hope of changing its representation is lost because client code can be distributed far and wide.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Encapsulation of data by accessor methods and mutators</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> y;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>    <span class="hljs-built_in">this</span>.x = x;<br>    <span class="hljs-built_in">this</span>.y = y;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getX</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> x; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getY</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> y; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setX</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> &#123; <span class="hljs-built_in">this</span>.x = x; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setY</span><span class="hljs-params">(<span class="hljs-type">double</span> y)</span> &#123; <span class="hljs-built_in">this</span>.y = y; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>If <strong>a class has no access control identifier</strong>, it has default access control characteristics. This default access control stipulates that <strong>the class can only be accessed and referenced by classes in the same package</strong>, and cannot be used by classes in other packages, even if there are subclasses of this class in other packages. This access feature is also called package access (package private).</p></blockquote><p>While it’s never a good idea for a public class to expose fields directly, it is less harmful if the fields are <strong>immutable</strong>. You can’t change the representation of such a class without changing its API, and you can’t take auxiliary actions when a field is read, but you can enforce invariants.</p><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Public class with exposed immutable fields - questionable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HOURS_PER_DAY</span>    <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MINUTES_PER_HOUR</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hour;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> minute;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Time</span><span class="hljs-params">(<span class="hljs-type">int</span> hour, <span class="hljs-type">int</span> minute)</span> &#123;<br>    <span class="hljs-keyword">if</span> (hour &lt; <span class="hljs-number">0</span> || hour &gt;= HOURS_PER_DAY)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Hour: &quot;</span> + hour);<br>    <span class="hljs-keyword">if</span> (minute &lt; <span class="hljs-number">0</span> || minute &gt;= MINUTES_PER_HOUR)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Min: &quot;</span> + minute);<br>    <span class="hljs-built_in">this</span>.hour = hour;<br>    <span class="hljs-built_in">this</span>.minute = minute;<br>&#125;<br>   ... <span class="hljs-comment">// Remainder omitted</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Package-private-private-nested-class"><a href="#Package-private-private-nested-class" class="headerlink" title="Package-private &#x2F; private nested class"></a>Package-private &#x2F; private nested class</h2><p>However, <strong>if a class is package-private or is a private nested class, there is nothing inherently wrong with exposing its data fields</strong>—assuming they do an adequate job of describing the abstraction provided by the class.</p><p>This approach generates less visual clutter than the accessor-method approach, both in the class definition and in the client code that uses it.</p><blockquote><p>While the client code is tied to the class’s internal representation, this code is <strong>confined to the package</strong> containing the class. If a change in representation becomes desirable, you can make the change without touching any code outside the package. In the case of a private nested class, the scope of the change is further restricted to the enclosing class.</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, <strong>public classes should never expose mutable fields</strong>. It is less harmful, though still questionable, for public classes to expose immutable fields.</p><p>It is, however, sometimes desirable for <strong>package-private or private nested classes</strong> to <strong>expose fields</strong>, whether mutable or immutable.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-14. Consider implmenting Comparable</title>
    <link href="/posts/604275cf.html"/>
    <url>/posts/604275cf.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-14-Consider-implementing-Comparable"><a href="#Item-14-Consider-implementing-Comparable" class="headerlink" title="Item 14: Consider implementing Comparable"></a>Item 14: Consider implementing <em>Comparable</em></h1><p>If you are writing <strong>a value class with an obvious natural ordering</strong>, such as alphabetical order, numerical order, or chronological order, you should implement the <code>Comparable</code> interface:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt; &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(T t)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="General-contract-of-compareTo-method"><a href="#General-contract-of-compareTo-method" class="headerlink" title="General contract of compareTo method"></a>General contract of <em>compareTo</em> method</h2><p>Compares this object with the specified object for order.</p><p>Returns a <strong>negative integer, zero, or a positive integer</strong> as this object is <strong>less than, equal to, or greater than</strong> the specified object.</p><p>Throws <code>ClassCastException</code> if the specified object’s type prevents it from being compared to this object.</p><ul><li><p>The implementor must ensure that <code>sgn(x.compareTo(y)) == -sgn(y. compareTo(x))</code> for all x and y.</p></li><li><p>The implementor must also ensure that the relation is transitive: <code>(x. compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0)</code> implies <code>x.compareTo(z) &gt; 0</code>.</p></li><li><p>Finally, the implementor must ensure that <code>x.compareTo(y) == 0</code> implies that <code>sgn(x.compareTo(z)) == sgn(y.compareTo(z))</code>, for all z.</p></li><li><p>It is strongly recommended, but not required, that <code>(x.compareTo(y) == 0) == (x.equals(y))</code>.</p><p>Generally speaking, any class that implements the <code>Comparable</code> interface and violates this condition should <strong>clearly indicate this fact</strong>. The recommended language is “Note: This class has a natural ordering that is inconsistent with equals.”</p></li></ul><h2 id="compareTo-and-equals"><a href="#compareTo-and-equals" class="headerlink" title="compareTo and equals"></a><em>compareTo</em> and <em>equals</em></h2><p>Unlike the <code>equals</code> method, which imposes a global equivalence relation on all objects, <code>compareTo</code> <strong>doesn’t have to work across objects of different types</strong>: when confronted with objects of different types, <code>compareTo</code> is permitted to throw <code>ClassCastException</code>.</p><p>Writing a <code>compareTo</code> method is similar to writing an <code>equals</code> method, but there are a few key differences. Because the <code>Comparable</code> interface is parameterized, the <code>compareTo</code> method is statically typed, so you <strong>don’t need to type check or cast its argument</strong>. If the argument is of the wrong type, the invocation won’t even compile. If the argument is null, the invocation should throw a <code>NullPointerException</code>, and it will, as soon as the method attempts to access its members.</p><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>If a class has <strong>multiple significant fields</strong>, the order in which you compare them is critical. Start with <strong>the most significant field</strong> and work your way down.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Multiple-field Comparable with primitive fields</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(PhoneNumber pn)</span> &#123;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Short.compare(areaCode, pn.areaCode);<br>   <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>)  &#123;<br>       result = Short.compare(prefix, pn.prefix);<br>       <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>)<br>           result = Short.compare(lineNum, pn.lineNum);<br>&#125;<br>   <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>In Java 8, the <code>Comparator</code> interface was outfitted with a set of <em>comparator construction methods</em>, which enable fluent construction of comparators. These comparators can then be used to implement a <code>compareTo</code> method, as required by the <code>Comparable</code> interface.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Comparable with comparator construction methods</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR =<br>       comparingInt((PhoneNumber pn) -&gt; pn.areaCode)<br>         .thenComparingInt(pn -&gt; pn.prefix)<br>         .thenComparingInt(pn -&gt; pn.lineNum);<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(PhoneNumber pn)</span> &#123;<br>   <span class="hljs-keyword">return</span> COMPARATOR.compare(<span class="hljs-built_in">this</span>, pn);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>There are also comparator construction methods for object reference types. The static method, named <code>comparing</code>.</p></blockquote><h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a><em>Comparator</em></h2><p>If a class does not implement <code>Comparable</code> or you need a nonstandard ordering, use a <code>Comparator</code> instead.</p><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Comparator based on static compare method</span><br> <span class="hljs-keyword">static</span> Comparator&lt;Object&gt; hashCodeOrder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;&gt;() &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;<br>     <span class="hljs-keyword">return</span> Integer.compare(o1.hashCode(), o2.hashCode());<br>   &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, whenever you implement a value class that has a sensible ordering, you should have the class implement the <code>Comparable</code> interface so that <strong>its instances can be easily sorted, searched, and used in comparison-based collections.</strong> </p><p>When comparing field values in the implementations of the <code>compareTo</code> methods, avoid the use of the &lt; and &gt; operators. Instead, use the <strong>static <code>compare</code> methods</strong> in the boxed primitive classes or the <strong>comparator construction methods</strong> in the <code>Comparator</code> interface.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式6-装饰模式</title>
    <link href="/posts/53fc494a.html"/>
    <url>/posts/53fc494a.html</url>
    
    <content type="html"><![CDATA[<p>需求：需要把所需的功能按正确的顺序串联起来进行控制</p><h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>装饰模式（Decorator），动态地给一个对象添加一些额外的职责，就增加&#x2F;扩展功能来说，装饰模式比生成子类更为灵活。</p><h2 id="装饰模式结构图"><a href="#装饰模式结构图" class="headerlink" title="装饰模式结构图"></a>装饰模式结构图</h2><p><img src="https://s2.loli.net/2023/09/20/YdCDAhkco9ETLF6.jpg" alt="装饰模式结构图.jpg"></p><ul><li><p>Component是定义一个对象接口，可以给这些对象动态地添加职责。</p></li><li><p>ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。</p></li><li><p>Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无须知道Decorator的存在的。</p></li><li><p>ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。</p></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Component类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ConcreteComponent类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;具体对象的实际操作&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Decorator类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>    <br>    <span class="hljs-keyword">protected</span> Component component;<br>    <br>    <span class="hljs-comment">// 装饰一个Component对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setComponent</span><span class="hljs-params">(Component component)</span> &#123;<br>        <span class="hljs-built_in">this</span>.component = component;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 重写operation()，实际调用component的operation方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (component != <span class="hljs-literal">null</span>) &#123;<br>            component.operation();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ConcreteDecorator类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConcreteDecoratorA类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreateDecoratorA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> String addedState;  <span class="hljs-comment">// 本类独有属性</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.operation();  <span class="hljs-comment">// 首先执行原有Component的operation()</span><br>        <br>        <span class="hljs-built_in">this</span>.addedState = <span class="hljs-string">&quot;具体装饰对象A的独有操作&quot;</span>;  <span class="hljs-comment">// 再执行本类独有功能</span><br>        System.out.println(<span class="hljs-built_in">this</span>.addedState);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ConcreteDecoratorB类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecoratorB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.operation();  <span class="hljs-comment">// 首先执行原有Component的operation()</span><br>        <span class="hljs-built_in">this</span>.addedBehavior(); <span class="hljs-comment">// 再执行本类独有功能</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addedBehavior</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;具体装饰对象B的独有操作&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ConcreteComponent</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteComponent</span>();<br><span class="hljs-type">ConcreteDecoratorA</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteDecoratorA</span>();<br><span class="hljs-type">ConcreteDecoratorB</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteDecoratorB</span>();<br><br>d1.setComponent(c); <span class="hljs-comment">// 首先用d1来包装c</span><br>d2.setComponent(d1); <span class="hljs-comment">// 再用d2来包装d1</span><br>d2.operation(); <span class="hljs-comment">// 最终执行d2的operation()</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/09/20/Gx6ynzCtlqogS5F.jpg" alt="装饰模式对象链.jpg"></p><p>装饰模式是利用<code>setComponent</code>来对对象进行包装的。<br>这样每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。</p><h2 id="例1：穿不同的服饰"><a href="#例1：穿不同的服饰" class="headerlink" title="例1：穿不同的服饰"></a>例1：穿不同的服饰</h2><p><img src="https://s2.loli.net/2023/09/20/U2GwI9iXWxH3mTJ.jpg" alt="装饰模式例子.jpg"></p><p><code>ICharacter</code>人物形象接口（<code>Component</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICharacter</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Person</code>类（<code>ConcreteComponent</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICharacter</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;装扮的&quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Finery</code>类（<code>Decorater</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Q: Finery不是一个实际存在的事物，为什么不设计成抽象类？</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">abstract</span><span class="hljs-params">(?)</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Finery</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICharacter</span> &#123;<br>    <br>    <span class="hljs-keyword">protected</span> ICharacter component;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decorate</span><span class="hljs-params">(ICharacter component)</span> &#123;<br>        <span class="hljs-built_in">this</span>.component = component;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.component != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.component.show();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体服饰类（<code>ConcreteDecorator</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tshirt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Finery</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;T恤&quot;</span>);<br>        <br>        <span class="hljs-built_in">super</span>.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他服饰同理。</p><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br><br><span class="hljs-type">Sneakers</span> <span class="hljs-variable">sneakers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sneakers</span>();<br>sneakers.decorate(p);<br><br><span class="hljs-type">Trousers</span> <span class="hljs-variable">trousers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trousers</span>();<br>trousers.decorate(sneakers);<br><br><span class="hljs-type">Tshirt</span> <span class="hljs-variable">tshirt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tshirt</span>();<br>tshirt.decorate(trousers);<br><br>tshirt.show(); <span class="hljs-comment">// 打印:&quot;T恤裤子运动鞋装扮的Alice&quot;</span><br></code></pre></td></tr></table></figure><h2 id="例2：升级商场收银程序"><a href="#例2：升级商场收银程序" class="headerlink" title="例2：升级商场收银程序"></a>例2：升级商场收银程序</h2><p>如果需要在打折基础上又返现，不需要添加新的<code>CashReturnRebate</code>子类，依然是<code>CashNormal </code>、<code>CashReturn</code>、<code>CashRebate</code>三种基本算法子类。增加一个接口<code>ISale</code>，用作装饰模式里的<code>Component</code>。</p><p><img src="https://s2.loli.net/2023/09/20/HthTDI9Zpz61acq.jpg" alt="装饰模式例子2.jpg"></p><p>装饰模式有一个重要的优点，把类中的装饰功能从类中搬移去除，这样可以简化原有的类。</p><p><code>CashNormal</code>是最基础的类，可以把它作为<code>ConcreteComponent</code>。</p><p><img src="https://s2.loli.net/2023/09/20/Oq4yoQVPExWRgeD.jpg" alt="装饰模式例子2-改进.jpg"></p><p><code>ISale </code>接口（<code>Component</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISale</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CashSuper</code> 实现 <code>ISale </code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">abstract</span><span class="hljs-params">(?)</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashSuper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISale</span> &#123;<br>    <br>    <span class="hljs-keyword">protected</span> ISale component;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decorate</span><span class="hljs-params">(ISale component)</span> &#123;<br>        <span class="hljs-built_in">this</span>.component = component;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.component != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 若装饰对象存在，则执行装饰的算法运算</span><br>            result = <span class="hljs-built_in">this</span>.component.acceptCash(price, num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CashNormal</code> 类（<code>ConcreteComponent</code>），最基本的原价算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashNormal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISale</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">return</span> price * num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打折和返现的算法都继承自 <code>CashSuper</code> ，都为 <code>ConcreteDecorator</code>。</p><p>从外层向里层依次执行 <code>acceptCash</code> 方法。先执行自己的<code>acceptCash</code>方法，再调用 <code>super(CashSuper).acceptCash()</code> ，会执行 <code>this.component</code> （里层的装饰器）的 <code>acceptCash</code> ，将计算结果 <code>result</code> 传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashRebate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CashSuper</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyRebate</span> <span class="hljs-operator">=</span> <span class="hljs-number">1d</span>; <span class="hljs-comment">// 折扣率</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashRebate</span><span class="hljs-params">(<span class="hljs-type">double</span> moneyRebate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.moneyRebate = moneyRebate;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> price * num * <span class="hljs-built_in">this</span>.moneyRebate;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.acceptCash(result, <span class="hljs-number">1</span>); <span class="hljs-comment">// result作为price传入，数量为1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashReturn</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CashSuper</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyCondition</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>; <span class="hljs-comment">// 返利条件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyReturn</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>; <span class="hljs-comment">// 返利值</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashReturn</span><span class="hljs-params">(<span class="hljs-type">double</span> moneyCondition, <span class="hljs-type">double</span> moneyReturn)</span> &#123;<br>        <span class="hljs-built_in">this</span>.moneyCondition = moneyCondition;<br>        <span class="hljs-built_in">this</span>.moneyReturn = moneyReturn;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> price * num;<br>        <span class="hljs-keyword">if</span> (moneyCondition &gt; <span class="hljs-number">0</span> &amp;&amp; result &gt;= moneyCondition) &#123;<br>            result -= Math.floor(result / moneyCondition) * moneyReturn;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.acceptCash(result, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点在 <code>CashContext</code> 类，因为涉及组合算法，所以用装饰模式的方式进行包装，这里需要注意包装的顺序，先打折后满多少返多少，与先满多少返多少，再打折会得到完全不同的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashContext</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> ISale cs;<br>    <br>    <span class="hljs-comment">// 在构造函数中传入type，根据type来实例化具体的收费策略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashContext</span><span class="hljs-params">(<span class="hljs-type">int</span> cashType)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (cashType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-built_in">this</span>.cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>();<br>                <span class="hljs-keyword">break</span>;<br>            ...<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                <span class="hljs-comment">// 先打8折，再满300返100</span><br>                <span class="hljs-type">CashNormal</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>();<br>                <span class="hljs-type">CashReturn</span> <span class="hljs-variable">crt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashReturn</span>(<span class="hljs-number">300d</span>, <span class="hljs-number">100d</span>);<br>                <span class="hljs-type">CashRebate</span> <span class="hljs-variable">crb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.8d</span>);<br>                <br>                crt.decorate(cn); <span class="hljs-comment">// 用 满300返100算法 包装原价算法</span><br>                crb.decorate(crt); <span class="hljs-comment">// 用 打8折算法 装饰 满300返100算法</span><br>                <span class="hljs-built_in">this</span>.cs = crb;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 根据收费策略的不同，获得计算结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.cs.acceptCash(price, num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在无论如何组合算法，哪怕是先打折再返现，再打折再返现，都只需要更改<code>CashContext</code>类，很好地做到了开放封闭。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>装饰模式是为已有功能<strong>动态地添加更多功能</strong>的一种方式。</p><ul><li>装饰者有和所装饰对象同样的超类型。</li><li>可以用任意多个装饰者包裹一个对象。</li><li><strong>装饰者在委托给所装饰对象之前或（与）之后添加自己的行为，来做剩下的工作。</strong></li></ul><p>缺点：带来了大量的小类，对使用者来说没那么直白（如Java I&#x2F;O库中的一系列InpurStream）。</p><h3 id="用装饰模式前"><a href="#用装饰模式前" class="headerlink" title="用装饰模式前"></a>用装饰模式前</h3><p>当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为（如：给Person添加新服饰）。</p><p><strong>问题</strong>：它们在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度。而这些新加入的东西仅仅是为了满足一些只在某种<strong>特定情况</strong>下才会执行的特殊行为的需要。</p><h3 id="用装饰模式后"><a href="#用装饰模式后" class="headerlink" title="用装饰模式后"></a>用装饰模式后</h3><p>它把每个要装饰的功能放在<strong>单独的类</strong>中，并让这个类<strong>包装</strong>它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。</p><p><strong>优点</strong>：</p><ul><li>把类中的装饰功能从类中搬移去除，这样可以简化原有的类（如：原价算法）。</li><li>有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑（如：无需重复编写 先打折后返现 &amp; 先返现后打折）。对于装饰模式来说，只是多几种组合而已。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>装饰顺序很重要。</strong></p><p>比如加密数据和过滤词汇都可以是数据持久化前的装饰功能，但若先加密了数据再用过滤功能就会出问题了。</p><p>最理想的情况，是保证装饰类之间彼此独立，这样它们就可以以任意的顺序进行组合了。</p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式14-观察者模式</title>
    <link href="/posts/7855650c.html"/>
    <url>/posts/7855650c.html</url>
    
    <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式（Observer）定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/10/LCoseQJmfYubWig.jpg" alt="观察者模式结构图.jpg"></p><h3 id="Subject类"><a href="#Subject类" class="headerlink" title="Subject类"></a>Subject类</h3><p>即主题或抽象通知者，一般用一个抽象类或者一个接口实现。</p><p>它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</p><h3 id="Observer类"><a href="#Observer类" class="headerlink" title="Observer类"></a>Observer类</h3><p>抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫作更新接口。更新接口通常包含一个update()方法，这个方法叫作更新方法。</p><p>抽象观察者一般用一个抽象类或者一个接口实现。</p><h3 id="ConcreteSubject类"><a href="#ConcreteSubject类" class="headerlink" title="ConcreteSubject类"></a>ConcreteSubject类</h3><p>具体主题或具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。</p><p>具体主题角色通常用一个具体子类实现。</p><h3 id="ConcreteObserver类"><a href="#ConcreteObserver类" class="headerlink" title="ConcreteObserver类"></a>ConcreteObserver类</h3><p>具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。具体观察者角色可以保存一个<strong>指向具体主题对象的引用</strong>。</p><p>具体观察者角色通常用一个具体子类实现。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>Subject类：通知者抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>  <span class="hljs-keyword">private</span> ArrayList&lt;Observer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;(); <span class="hljs-comment">// 针对抽象的Observer编程</span><br>  <br>  <span class="hljs-comment">// 增加观察者</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span> &#123;<br>    list.add(observer);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 减少观察者</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span> &#123;<br>    list.remove(observer);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 通知观察者</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObserver</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (Observer item : list) &#123;<br>      item.update();<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">protected</span> String subjectState;<br>  <br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSubjectState</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.subjectState;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSubjectState</span><span class="hljs-params">(String value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.subjectState = value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Observer类：抽象观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ConcreteSubject类：具体通知者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span> &#123;<br>  <span class="hljs-comment">// 具体通知者的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ConcreteObserver类：具体观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> Subject sub;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteObserver</span><span class="hljs-params">(String name, Subject sub)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.sub = sub;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;观察者&quot;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;的新状态是&quot;</span> + <span class="hljs-built_in">this</span>.sub.getSubjectState());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Subject</span> <span class="hljs-variable">subject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteSubject</span>();<br>subject.attach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserver</span>(<span class="hljs-string">&quot;NameX&quot;</span>, subject));<br>subject.attach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserver</span>(<span class="hljs-string">&quot;NameY&quot;</span>, subject));<br>subject.attach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteObserver</span>(<span class="hljs-string">&quot;NameZ&quot;</span>, subject));<br><br>subject <span class="hljs-title function_">setSubjectState</span><span class="hljs-params">(<span class="hljs-string">&quot;ABC&quot;</span>)</span>;<br>subject.notifyObserver();<br></code></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。</p><h3 id="何时使用观察者模式？"><a href="#何时使用观察者模式？" class="headerlink" title="何时使用观察者模式？"></a>何时使用观察者模式？</h3><ol><li>当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象有待改变时</li><li>当一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。</p><h2 id="Java内置接口实现"><a href="#Java内置接口实现" class="headerlink" title="Java内置接口实现"></a>Java内置接口实现</h2><p>现实编程中，具体的观察者完全有可能是风马牛不相及的类，但它们都需要根据通知者的通知来做出update()的操作，此时不适合使用继承，要用接口来实现。</p><p>Java已经为观察者模式准备好了相关的接口和抽象类了：<strong>观察者接口java.util.Observer</strong> 和 <strong>通知者类java.util.Observable</strong> 。</p><p>Java内置的Observable是一个类，这样设计是有问题的。一个类，就只能继承它，但我们自己的类可能本身就需要继承其他抽象类，这就产生了麻烦。Java不支持多重继承，这就严重限制了Observable的复用潜力。所以，当你这段代码用javac编译时，会给出提示： <code>警告：［deprecation］ java.util中的Observable已过时。</code> 系统其实是建议你不要复用这样的方法。所以真实编程中，我们也要考虑怎么取舍，如何修改的问题。</p><h3 id="Java其他内建支持"><a href="#Java其他内建支持" class="headerlink" title="Java其他内建支持"></a>Java其他内建支持</h3><p>JavaBean通过<code>PropertyChangeEvent</code>提供内建的支持。当一个Bean改变特定种类的属性时，该事件产生，并发送通知给<code>PropertyChangeListener</code>。</p><p>在处理异步流的Flow API中，也有相关的出版者&#x2F;订阅者组件。</p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-13. Override clone judiciously</title>
    <link href="/posts/a0ec037.html"/>
    <url>/posts/a0ec037.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-13-Override-clone-judiciously"><a href="#Item-13-Override-clone-judiciously" class="headerlink" title="Item 13: Override clone judiciously"></a>Item 13: Override <em>clone</em> judiciously</h1><p>The <code>Cloneable</code> interface was intended as a <em>mixin interface</em> (Item 20) for classes to advertise that they permit cloning. Unfortunately, it fails to serve this purpose. Its primary flaw is that it lacks a <code>clone</code> method, and <em>Object</em>’s <code>clone</code> method is protected.</p><blockquote><p>You cannot, without resorting to <em>reflection</em> (Item 65), invoke clone on an object merely  because it implements <code>Cloneable</code>. Even a reflective invocation may fail, because there is no guarantee that the object has an accessible <code>clone</code> method.</p></blockquote><h2 id="Effect-of-Cloneable"><a href="#Effect-of-Cloneable" class="headerlink" title="Effect of Cloneable"></a>Effect of <em>Cloneable</em></h2><p>It determines the behavior of <em>Object</em>’s protected <code>clone</code> implementation: if a class implements <code>Cloneable</code>, <em>Object</em>’s <code>clone</code> method returns a <strong>field-by-field copy of the object</strong>; otherwise it throws <code>CloneNotSupportedException</code>.</p><blockquote><p>This is a highly atypical use of interfaces and not one to be emulated. Normally, implementing an interface says something about what a class can do for its clients. In this case, it modifies the behavior of a protected method on a superclass.</p></blockquote><p><strong>In practice, a class implementing</strong> <strong><code>Cloneable</code></strong> <strong>is expected to provide a properly functioning public</strong> <strong><code>clone</code></strong> <strong>method.</strong></p><h2 id="General-contract-of-clone"><a href="#General-contract-of-clone" class="headerlink" title="General contract of clone"></a>General contract of <em>clone</em></h2><p>Creates and returns a copy of this object. The precise meaning of “copy” may depend on the class of the object.</p><ul><li><code>x.clone() != x</code> will be true</li><li><code>x.clone().getclass() == x.getclass()</code> will be true</li><li><code>x.clone().equals(x)</code> will be true</li><li>By convention, the object returned by this method should be obtained by calling <code>super.clone()</code>.</li><li>By convention, <strong>the returned object should be independent of the object being cloned</strong>. To achieve this independence, it may be necessary to modify one or more fields of the object returned by super.clone before returning it.</li></ul><blockquote><p>If a class’s clone method returns an instance that is <em>not</em> obtained by calling <code>super.clone</code> but by calling a constructor, the compiler won’t complain, but if a subclass of that class calls <code>super.clone</code>, the resulting object will have the wrong class.</p></blockquote><h2 id="How-to-implment-clone-method"><a href="#How-to-implment-clone-method" class="headerlink" title="How to implment clone method"></a>How to implment <em>clone</em> method</h2><h3 id="1-Immutable-class"><a href="#1-Immutable-class" class="headerlink" title="1. Immutable class"></a>1. Immutable class</h3><p><strong>Immutable classes should never provide a</strong> <strong><code>clone</code></strong> <strong>method</strong> because it would merely encourage wasteful copying.</p><h3 id="2-Class-with-no-references-to-mutable-state"><a href="#2-Class-with-no-references-to-mutable-state" class="headerlink" title="2. Class with no references to mutable state"></a>2. Class with no references to mutable state</h3><p>First impelement <code>Cloneable</code> interface.</p><p>The <code>clone</code> method would look like:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Clone method for class with no references to mutable state</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PhoneNumber <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> (PhoneNumber) <span class="hljs-built_in">super</span>.clone();<br>  &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(); <span class="hljs-comment">// Can&#x27;t happen</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Class-with-fields-that-refer-to-mutable-objects"><a href="#3-Class-with-fields-that-refer-to-mutable-objects" class="headerlink" title="3. Class with fields that refer to mutable objects"></a>3. Class with fields that refer to mutable objects</h3><p>Example: the <em>Stack</em> class in Item 7</p><p>If simply call <code>super.clone()</code>, its <em>elements</em> field will refer to the <strong>same array</strong> as the original <em>Stack</em> instance.</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>Call <code>clone</code> recursively on the <em>elements</em> array:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Clone method for class with no references to mutable state</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Stack <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Stack</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (Stack) <span class="hljs-built_in">super</span>.clone();<br>    result.elements = elements.clone();<br>    <span class="hljs-keyword">return</span> result;<br>  &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>Note that we do not have to cast the result of elements.clone to Object[]. Calling clone on an array returns an array whose runtime and compile-time types are identical to those of the array being cloned. This is the preferred idiom to duplicate an array. In fact, <strong>arrays are the sole compelling use of the clone facility</strong>.</li><li>Note also that the earlier solution would not work if the elements field were <strong>final</strong> because clone would be prohibited from assigning a new value to the field. This is a fundamental problem: like serialization, <strong>the</strong> <strong><code>Cloneable</code></strong> <strong>architecture is incompatible with normal use of final fields referring to mutable objects</strong>. In order to make a class cloneable, it may be necessary to remove final modifiers from some fields.</li></ol></blockquote><h3 id="4-Class-with-inner-class"><a href="#4-Class-with-inner-class" class="headerlink" title="4. Class with inner class"></a>4. Class with inner class</h3><p>Example: HashTable implemented using its own linked list</p><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>Add a <code>deepCopy</code> method to the inner class.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Iteratively copy the linked list headed by this Entry</span><br>Entry <span class="hljs-title function_">deepCopy</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">Entry</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value, next);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> result; p.next != <span class="hljs-literal">null</span>; p = p.next)<br>    p.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(p.next.key, p.next.value, p.next.next);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>clone</code> method of <em>HashTable</em> class:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> HashTable <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">HashTable</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (HashTable) <span class="hljs-built_in">super</span>.clone();<br>    result.buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[buckets.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; buckets.length; i ++)<br>      <span class="hljs-keyword">if</span> (buckets[i] != <span class="hljs-literal">null</span>)<br>        result.buckets[i] = buckets[i].deepCopy();<br>    <span class="hljs-keyword">return</span> result;<br>  &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>Call <code>super.clone</code>, set all of the fields in the resulting object to their <strong>initial state</strong>, and then call higher-level methods to regenerate the state of the original object.</p><p>In the case of our HashTable example, the buckets field would be initialized to a new bucket array, and the put(key, value) method would be invoked for each key-value mapping in the hash table being cloned.</p><blockquote><p>It is antithetical to the whole Cloneable architecture because it blindly overwrites the field-by-field object copy that forms the basis of the architecture.</p></blockquote><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p>Like a constructor, a <code>clone</code> method must <strong>never invoke an overridable method on the clone</strong> under construction (Item 19). If clone invokes a method that is overridden in a subclass, this method will execute before the subclass has had a chance to fix its state in the clone, quite possibly leading to corruption in the clone and the original.</p><blockquote><p>Therefore, the put(key, value) method discussed in the previous paragraph should be either final or private. (If it is private, it is presumably the “helper method” for a nonfinal public method.)</p></blockquote></li><li><p><em>Object</em>’s <code>clone</code> method is declared to throw <code>CloneNotSupportedException</code>, but overriding methods need not. <strong>Public</strong> <strong><code>clone</code></strong> <strong>methods should omit the</strong> <strong>throws</strong> <strong>clause</strong>, as methods that don’t throw checked exceptions are easier to use (Item 71).</p></li><li><p>You have two choices when designing a <strong>class for inheritance</strong> (Item 19), but whichever one you choose, the class <strong>should <em>not</em> implement <code>Cloneable</code>.</strong></p><ul><li><p>You may choose to mimic the behavior of <em>Object</em> by <strong>implementing a properly functioning protected <code>clone</code> method that is declared to throw <code>CloneNotSupportedException</code>.</strong> This gives subclasses the freedom to implement Cloneable or not, just as if  dthey extended <em>Object</em> directly.</p></li><li><p>Alternatively, you may choose <strong><em>not</em> to implement a working <code>clone</code> method</strong>, and to <strong>prevent subclasses from implementing</strong> one, by providing the following <strong>degenerate <code>clone</code></strong> implementation:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// clone method for extendable class not supporting Cloneable</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CloneNotSupportedException</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>If you write a <strong>thread-safe class</strong> that implements Cloneable, remember that its <strong><code>clone</code> method must be properly synchronized</strong>, just like any other method (Item 78). <em>Object</em>’s clone method is not synchronized.</p></li></ol><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>To recap, all classes that implement <code>Cloneable</code> should override <code>clone</code> with a public method whose <strong>return type is the class itself</strong>. This method should first <strong>call <code>super.clone</code></strong>, then <strong>fix any fields</strong> that need fixing.</p><p>Typically, this means copying any mutable objects that comprise the internal “deep structure” of the object and replacing the clone’s references to these objects with references to their copies.</p><p>If the class contains only primitive fields or references to immutable objects, then it is likely the case that no fields need to be fixed. There are exceptions to this rule. For example, a field representing a serial number or other unique ID will need to be fixed even if it is primitive or immutable.</p><h2 id="Better-approaches-to-object-copying"><a href="#Better-approaches-to-object-copying" class="headerlink" title="Better approaches to object copying"></a>Better approaches to object copying</h2><p><strong>A better approach to object copying is to provide a <em>copy constructor</em> or <em>copy factory</em>.</strong></p><p>A copy constructor is simply a constructor that takes a single argument whose type is the class containing the constructor, for example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Copy constructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Yum</span><span class="hljs-params">(Yum yum)</span> &#123; ... &#125;;<br></code></pre></td></tr></table></figure><p>A copy factory is the static factory (Item 1) analogue of a copy constructor:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Copy factory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Yum <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Yum yum)</span> &#123; ... &#125;;<br></code></pre></td></tr></table></figure><h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><ul><li><p>they don’t rely on a risk-prone extralinguistic object creation mechanism;</p></li><li><p>they don’t demand unenforceable adherence to thinly documented conventions;</p></li><li><p>they don’t conflict with the proper use of <strong>final fields</strong>;</p></li><li><p>they don’t throw unnecessary <strong>checked exceptions</strong>;</p></li><li><p>they don’t require <strong>type casts</strong>.</p></li><li><p>a copy constructor or factory can take <strong>an argument</strong> whose type is <strong>an interface implemented by the class</strong>.</p><blockquote><p>For example, suppose you have a HashSet, s, and you want to copy it as a TreeSet. The clone method can’t offer this functionality, but it’s easy with a conversion constructor: new TreeSet&lt;&gt;(s).</p></blockquote></li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Given all the problems associated with <code>Cloneable</code>, new <strong>interfaces</strong> should not extend it, and new <strong>extendable classes</strong> should not implement it.</p><p>While it’s less harmful for <strong>final classes</strong> to implement <code>Cloneable</code>, this should be viewed as a performance optimization, reserved for the rare cases where it is justified (Item 67).</p><p>As a rule, <em>copy</em> functionality is best provided by <strong>constructors or factories</strong>.</p><blockquote><p>A notable exception to this rule is <strong>arrays</strong>, which are best copied with the <code>clone</code> method.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AOP原理、术语和AspectJ示例</title>
    <link href="/posts/2d05403.html"/>
    <url>/posts/2d05403.html</url>
    
    <content type="html"><![CDATA[<h1 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h1><p>在Java平台上，对于AOP的织入，有3种方式：</p><ol><li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li><li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li><li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li></ol><p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理，应用了代理模式。</p><p>AOP让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。</p><blockquote><p>AOP对于解决特定问题，例如事务管理非常有用，这是因为分散在各处的事务代码几乎是完全相同的，并且它们需要的参数（JDBC的Connection）也是固定的。</p><p>另一些特定问题，如日志，就不那么容易实现，因为日志虽然简单，但打印日志的时候，经常需要捕获局部变量，如果使用AOP实现日志，我们只能输出固定格式的日志，</p><p>因此，使用AOP时，必须适合特定的场景。</p></blockquote><h1 id="Terminologies"><a href="#Terminologies" class="headerlink" title="Terminologies"></a>Terminologies</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ul><li>Aspect：切面，即一个横跨多个核心逻辑的功能，或者称之为系统关注点；</li><li>Joinpoint：连接点，即定义在应用程序流程的何处插入切面的执行；</li><li>Pointcut：切入点，即一组连接点的集合；</li><li>Advice：增强，指特定连接点上执行的动作；</li><li>Introduction：引介，指为一个已有的Java对象动态地增加新的接口；</li><li>Weaving：织入，指将切面整合到程序的执行流程中；</li><li>Interceptor：拦截器，是一种实现增强的方式；</li><li>Target Object：目标对象，即真正执行业务的核心逻辑对象；</li><li>AOP Proxy：AOP代理，是客户端持有的增强后的对象引用。</li></ul><h2 id="Static-Compile-Time"><a href="#Static-Compile-Time" class="headerlink" title="Static - Compile Time"></a>Static - Compile Time</h2><h3 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h3><p>Aspect is the concern that we are trying to implement generically.  The functionality you want to implement. What you want to achieve.</p><h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><ul><li>Transaction Management</li><li>Logging (e.g. Every method of business layer called, log the input and output parameters)</li><li>Performance metrics (how much time a method took to execute)</li></ul><h3 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h3><p>A regular expression which determines what are the methods are to be intercepted.</p><p>e.g. execution(* com.example.spring.business.aop.HiByeService.*(..))</p><h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><p>Action taken by an aspect at a particular join point. What is to be done when the Pointcut is met.</p><h2 id="Dynamic-Runtime"><a href="#Dynamic-Runtime" class="headerlink" title="Dynamic - Runtime"></a>Dynamic - Runtime</h2><h3 id="Join-point"><a href="#Join-point" class="headerlink" title="Join point"></a>Join point</h3><p>A point during the execution of a program. Execution of a specific AOP method.</p><p>All the runtime information about the method call.</p><p>Input parameters of the Advice?</p><h3 id="Weaving"><a href="#Weaving" class="headerlink" title="Weaving"></a>Weaving</h3><p>The entire process of executing the Advice.</p><h1 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h1><h2 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h2><h3 id="Aspect类"><a href="#Aspect类" class="headerlink" title="Aspect类"></a>Aspect类</h3><ul><li>@Order(3)，值越小优先级越高</li><li>@Aspect</li></ul><h3 id="AspectJ-Advice-Types"><a href="#AspectJ-Advice-Types" class="headerlink" title="AspectJ Advice Types"></a>AspectJ Advice Types</h3><ul><li><p><strong>@Before</strong>（前置通知）：先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；</p></li><li><p><strong>@After</strong> （后置通知）：先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；</p></li><li><p><strong>@AfterReturning</strong>（返回通知）：和@After不同的是，只有当目标代码正常返回时，才执行拦截器代码；</p></li><li><p><strong>@AfterThrowing</strong>（异常通知）：和@After不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；</p><blockquote><p>AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</p></blockquote></li><li><p><strong>@Around</strong> （环绕通知）：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能</p></li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// AspectJ annotation</span><br><span class="hljs-meta">@Component</span> <span class="hljs-comment">// Managed by Spring</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(* com.example.spring.business.aop.HiByeService.*(..))&quot;)</span> <span class="hljs-comment">// 默认等价于pointcut=&quot;execution...&quot;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;Before &quot;</span>);<br>        System.out.println(joinPoint.getSignature().getName());<br>    &#125;<br>    <br>    <span class="hljs-meta">@AfterReturning(pointcut=&quot;execution(* com.example.spring.business.aop.HiByeService.*(..))&quot;, returning=&quot;result&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(JoinPoint joinPoint, Object result)</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;After &quot;</span>);<br>        System.out.print(joinPoint.getSignature().getName());<br>        System.out.println(<span class="hljs-string">&quot;, result is &quot;</span> + result);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(classes = SpringContextAOP.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AOPExampleTest</span> &#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> HiByeService service;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSomething</span><span class="hljs-params">()</span> &#123;<br>        service.sayHi();<br>        service.sayBye();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用注解装配AOP"><a href="#使用注解装配AOP" class="headerlink" title="使用注解装配AOP"></a>使用注解装配AOP</h3><p>例：监控应用程序的性能</p><h4 id="1-定义一个性能监控的注解"><a href="#1-定义一个性能监控的注解" class="headerlink" title="1. 定义一个性能监控的注解"></a>1. 定义一个性能监控的注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(METHOD)</span><br><span class="hljs-meta">@Retention(RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MetricTime &#123;<br>  String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-在需要被监控的关键方法上标注该注解"><a href="#2-在需要被监控的关键方法上标注该注解" class="headerlink" title="2. 在需要被监控的关键方法上标注该注解"></a>2. 在需要被监控的关键方法上标注该注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>  <span class="hljs-comment">// 监控register()方法性能</span><br>  <span class="hljs-meta">@MetricTime(&quot;register&quot;)</span><br>  <span class="hljs-keyword">public</span> User <span class="hljs-title function_">register</span><span class="hljs-params">(String email, String password, String name)</span> &#123;<br>    ...<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-定义MetricAspect"><a href="#3-定义MetricAspect" class="headerlink" title="3. 定义MetricAspect"></a>3. 定义<code>MetricAspect</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MetricAspect</span> &#123;<br>  <span class="hljs-meta">@Around(&quot;@annotation(metricTime)&quot;)</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">metric</span><span class="hljs-params">(ProceedingJoinPoint joinPoint, MetricTime metricTime)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> metricTime.value();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">return</span> joinPoint.proceed();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - start;<br>      System.err.println(<span class="hljs-string">&quot;[Metrics] &quot;</span> + name + <span class="hljs-string">&quot;: &quot;</span> + t + <span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>metric()</code>方法标注了<code>@Around(&quot;@annotation(metricTime)&quot;)</code>，它的意思是，符合条件的目标方法是带有<code>@MetricTime</code>注解的方法，因为<code>metric()</code>方法<strong>参数类型</strong>是<code>MetricTime</code>（注意参数名是<code>metricTime</code>不是<code>MetricTime</code>），我们通过它获取性能监控的名称。</p><blockquote><p>Aspect织入的地方取决于<code>metric</code>方法的第二个入参类型</p></blockquote><p>有了<code>@MetricTime</code>注解，再配合<code>MetricAspect</code>，任何Bean，只要方法标注了<code>@MetricTime</code>注解，就可以自动实现性能监控。运行代码，输出结果如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">Welcome, Bob!<br><span class="hljs-selector-attr">[Metrics]</span> register: <span class="hljs-number">16ms</span><br></code></pre></td></tr></table></figure><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>定义执行方法，并在方法上通过AspectJ的注解告诉Spring应该在何处调用此方法；</li><li>标记<code>@Component</code>和<code>@Aspect</code>；</li><li>在<code>@Configuration</code>类上标注<code>@EnableAspectJAutoProxy</code>。</li></ol><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><ol><li>访问被注入的Bean时，总是调用方法而非直接访问字段<ul><li>因为CGLIB代理类不会调用super()，也就是父类即原始类的构造函数，所以自己继承来的该字段不会被初始化</li><li>但调用方法会委托给<strong>引用的原始类的实例</strong>的该方法（跟父类就没关系了）</li></ul></li><li>编写Bean时，如果可能会被代理，就不要编写<code>public final</code>方法。</li></ol><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li>Spring doc for AspectJ: <a href="https://docs.spring.io/spring-framework/reference/core/aop/ataspectj.html">https://docs.spring.io/spring-framework/reference/core/aop/ataspectj.html</a></li><li>注解装配AOP：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1310052317134882">https://www.liaoxuefeng.com/wiki/1252599548343744/1310052317134882</a></li><li>AOP注意事项：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1339039378571298">https://www.liaoxuefeng.com/wiki/1252599548343744/1339039378571298</a></li><li>Spring AOP Tutorial - with AspectJ Examples: <a href="https://www.youtube.com/watch?v=Og9Fyew8ltQ">https://www.youtube.com/watch?v=Og9Fyew8ltQ</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>backend</category>
      
      <category>Spring</category>
      
      <category>Spring AOP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浪潮之巅读书笔记5-英特尔与摩托罗拉</title>
    <link href="/posts/1ff84ba1.html"/>
    <url>/posts/1ff84ba1.html</url>
    
    <content type="html"><![CDATA[<h1 id="Intel"><a href="#Intel" class="headerlink" title="Intel"></a>Intel</h1><p>50多年来，英特尔公司成功的关键首先是赶上了个人电脑革命的浪潮，尤其是有微软这个强势的伙伴，IT业者甚至将整个PC时代称为WinTel时代，即微软的Windows操作系统加上Intel的处理器;其次，英特尔公司50多年来严格按照其创始人预言的惊人速度（摩尔定律）在为全世界PC提高着处理器的性能，用英特尔的宣传语来说，它给了每台PC一颗奔腾的芯。</p><h2 id="大事记"><a href="#大事记" class="headerlink" title="大事记"></a>大事记</h2><p>1968 英特尔成立。</p><p>1971 开发出英特尔第一个商用处理器Intel 4004。</p><p>197x 英特尔遭遇前所未有的发展困境，摩尔接替诺伊斯担任英特尔CEO，但是实际负责运营该公司的是他的学生格鲁夫，从此英特尔开始快速发展。</p><p>1978 英特尔开发出8086微处理器，后被用作IBM PC的CPU。</p><p>1982 80286处理器问世。</p><p>1985 32位80386处理器问世。</p><p>1986 英特尔公司上市。</p><p>1987 安迪·格鲁夫正式担任英特尔CEO，英特尔开始了快速发展的10年，并且成为全球最大的半导体公司。</p><p>1989 定点和浮点处理合一的80486处理器问世。</p><p>1993 奔腾系列处理器问世，在随后的十年里，英特尔推出了很多代的奔腾处理器。</p><p>2000 英特尔的手机处理器XScale问世。</p><p>2001 英特尔的64位服务器处理器Itanium问世，英特尔在服务器市场彻底超越RISC处理器的代表太阳公司。</p><p>2005 基于ARM的处理器占到了智能手机处理器市场的98%，英特尔在这个市场明显落后于高通公司和德州仪器公司。</p><p>2006 双核处理器问世。同年，英特尔将通信及移动处理器业务卖给了Marvell公司，从此退出手机处理器市场。</p><p>2009 四核处理器问世，英特尔继续在服务器处理器市场上占优势。</p><p>2012 英特尔宣布重返移动终端市场，但是效果不佳。</p><p>2017 英特尔公司以153亿美元的高价收购了开发图像识别和无人驾驶技术的Mobileye公司。</p><h2 id="英特尔的发展"><a href="#英特尔的发展" class="headerlink" title="英特尔的发展"></a>英特尔的发展</h2><h3 id="80x86系列"><a href="#80x86系列" class="headerlink" title="80x86系列"></a>80x86系列</h3><p>上个世纪70年代末，英特尔公司生产出了著名的16位8086处理器。但由于性能不如IBM、DEC和惠普等公司，在很长时间里，英特尔的处理器被认为是低性能、低价格的产品。英特尔的芯片性价比很高，但并不是尖端产品。</p><p>1981年，IBM为了短平快地搞出PC，也懒得自己设计处理器，拿来英特尔的8086就直接用上了。结果，英特尔一举成名。1982年，英特尔搞出了和8086完全兼容的第二代PC处理器 80286，用在了IBM PC&#x2F;AT上。由于IBM无法阻止别人制造兼容机，随着1985年康柏造出了世界上第一台IBM PC兼容机，兼容机厂商就像雨后春笋般在世界各地冒了出来。这些兼容机硬件不尽相同，但是为了兼容IBM PC，都选用了英特尔公司的处理器。</p><p>20世纪80年代，英特尔果断停掉传统的内存业务，将这个市场拱手让给了日本人，从此专心做处理器。1985年，英特尔公司继摩托罗拉之后，第二个研制出32位微处理器80386，开始扩大它在整个半导体工业的市场份额。这款芯片的研制费用超过3亿美元，在当时确实是一场豪赌，这笔研制费用超过中国当时在五年计划中对半导体科研全部投人的好几倍。英特尔靠80386完成了对IBM PC兼容机市场一统江湖的伟业。</p><p>到了1989年，英特尔推出了从80386到奔腾处理器的过渡产品80486，简单来说，这款CPU就是80386加一个浮点处理器80387及缓存。依靠80486的销售，英特尔一举超过所有的日本半导体公司，坐上了半导体行业的头把交椅。</p><h3 id="奔腾处理器"><a href="#奔腾处理器" class="headerlink" title="奔腾处理器"></a>奔腾处理器</h3><p>1993年，英特尔公司推出奔腾处理器。奔腾处理器的诞生，使英特尔甩掉了只会做低性能处理器的帽子。由于奔腾处理器的速度已经达到工作站处理器的水平，因此从那时起，高端的个人电脑开始取代低性能的图形工作站。</p><p>到今天，即使是最早生产工作站的太阳公司 (已被甲骨文公司收购)和世界上最大的计算机公司IBM，以及以前从不使用英特尔处理器的苹果公司，都开始在产品中使用英特尔的或与之兼容的处理器了。现在，英特尔已经垄断了个人电脑和服务器处理器市场。</p><h3 id="错失移动时代"><a href="#错失移动时代" class="headerlink" title="错失移动时代"></a>错失移动时代</h3><p>Google研究院院长、美国经典教科书《人工智能》的作者彼得·诺威格 (PeterNorvig)博士有一句话非常经典，在业界广为流传:一家公司的市场份额超过50%以后，就不用再想去将市场份额翻番了。言下之意，这家公司就必须去挖掘新的成长点了。在2000年后，英特尔公司就是处于这样一个地位。</p><p>但它在PC的外围芯片和手机Atom处理器上的尝试都失败了。原因如下：</p><ol><li>英特尔公司的商业模式历来是靠<strong>大投入、大批量</strong>来挣钱的，同一代的芯片，英特尔的销量可能是太阳公司的10倍，甚至更多，因此，它可以比其他公司多花几倍的经费来开发一种芯片。但是，当一种芯片市场较小时，英特尔公司便很难做到盈利，而很多新的市场一开始规模总是很小的，这是英特尔面临的一个根本问题。</li><li>CISC的<strong>高功耗</strong>问题。高功耗低性能的Atom处理器在移动终端上无法和高性能的ARM处理器竞争。</li></ol><p>不过，随着云计算的兴起，基于服务器端的软件和服务对新处理器的需求弥补了个人电脑销售的疲软，因此安迪–比尔定律对英特尔的正面影响还会持续较长的时间。</p><h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>2017年，英特尔公司以153亿美元的高价收购了开发图像识别和无人驾驶技术的Mobileye公司，并与欧美的一些汽车厂商成立了合资企业，开发无人驾驶技术。但是，做芯片出身的英特尔公司是否具有人工智能技术和系统集成技术的基因，大家对此依然颇有疑问。</p><h2 id="英特尔的战争"><a href="#英特尔的战争" class="headerlink" title="英特尔的战争"></a>英特尔的战争</h2><h3 id="英特尔与摩托罗拉"><a href="#英特尔与摩托罗拉" class="headerlink" title="英特尔与摩托罗拉"></a>英特尔与摩托罗拉</h3><p>在个人电脑时代，英特尔公司遇到的唯一重量级对手只有上个世纪80年代的摩托罗拉。正如罗马帝国的崛起是通过在部落战争中打败原有的霸主迦太基而完成的，英特尔的崛起是靠击败老牌半导体公司摩托罗拉而实现的。</p><p>摩托罗拉并没有败在技术和资金上，20世纪80年代以前，摩托罗拉在资金、技术等各方面都明显强于英特尔。在很长时间里，摩托罗拉处理器的性能要优于英特尔的同类产品。摩托罗拉之败，首先是微软的因素，即英特尔有了微软这个没有签约的同盟军。此外，摩托罗拉自身在商业、管理和市场诸方面也有很多失误。假如经营得当，摩托罗拉今天应该能通过RISC处理器守住工作站和苹果的市场。</p><p><strong>英特尔胜利的原因：</strong></p><h4 id="1-这是两家不同时代的公司"><a href="#1-这是两家不同时代的公司" class="headerlink" title="1. 这是两家不同时代的公司"></a>1. 这是两家不同时代的公司</h4><p>总部在美国中部伊利诺伊州的摩托罗拉虽然也是一家高科技公司，也经历了20世纪80年代的信息革命，但是它完全还是20世纪五六十年代的传统公司。</p><p>摩托罗拉的员工在工资和福利待遇上不错，但是公司和员工，基本上还是传统的雇佣关系，公司内部管理层级较多，大部分员工没有多少<strong>股票期权</strong>。因此，<strong>公司的业绩和员工的利益关系不大</strong>。英特尔公司则是一家典型的硅谷公司，每个员工的<strong>工作强度</strong>比摩托罗拉要大很多，但是每个人平均的股票期权也多很多。</p><blockquote><p>硅谷几个比较好的学区，不少房子都被英特尔公司的早期员工买走了，而这些房子只靠工资一辈子也买不起。</p></blockquote><blockquote><p>几年前，美国历史频道(History Channel)在节目中评论了中日甲午战争。美国的历史学家认为，这是两个不同时代军队之间的战争，虽然双方武器相差不多，战争的结果不会有任何悬念，因为处在专制的农业时代后期的军队很难打赢一支新兴的工业化国家的军队。英特尔和摩托罗拉之间的竞争也是如此。</p></blockquote><h4 id="2-两家公司的统帅水平相去甚远"><a href="#2-两家公司的统帅水平相去甚远" class="headerlink" title="2. 两家公司的统帅水平相去甚远"></a>2. 两家公司的统帅水平相去甚远</h4><p>英特尔公司上个世纪八九十年代的 CEO格鲁夫虽然是工程师出身，但他同时也是个人电脑时代最优秀的领导者和管理者，几次被评为世界上最好的CEO。上个世纪70年代初，英特尔公司发展遇到瓶颈，当时的CEO诺伊斯甚至一度想出售公司。这时格鲁夫临危受命，和摩尔一道将英特尔公司扭亏为盈，并目将该公司打造成连续三十年发展速度超过半导体行业平均水平的明星公司。</p><p>摩托罗拉公司由高尔文(Galvin)兄弟创办，上个世纪60年代传到了儿子手里，上个世纪八九十年代传到了孙子手里，是个典型的家族公司。俗话说“富不过三代”，这话果然应验在高尔文家族上，三代人可以说是一代不如一代。孙子辈的克里斯托弗·高尔文虽然是被“选成”CEO的，但是如果他不姓高尔文，他可能永远都当不了摩托罗拉的CEO，甚至进不了工业界的高层。</p><h4 id="3-英特尔比摩托罗拉更专注"><a href="#3-英特尔比摩托罗拉更专注" class="headerlink" title="3. 英特尔比摩托罗拉更专注"></a>3. 英特尔比摩托罗拉更专注</h4><p>在业务上，半导体只是摩托罗拉的一个部门，而处理器又只是其半导体部门的一项业务，对于英特尔来讲处理器芯片却是全部。因此，摩托罗拉即使完全退出计算机处理器市场也不过是损失一些地盘，而英特尔一旦失败，则会面临灭顶之灾。</p><p>一般来讲，华尔街总是希望上市公司有尽可能多的而不是单一的收人来源，摩托罗拉确实是这么做的，它曾经在计算机的处理器、通信的数字信号处理器、对讲机、BP机、手机和电视接收器等很多领域发展。结果每个领域都很难做大。英特尔公司从一开始就非常专注。虽然它早期的主要产品是计算机的动态存储器，但是后来为了专注于个人电脑的处理器，主动放弃了动态存储器的业务。英特尔在每一代处理器的研发过程中，都集中了大量的人力和资金，每一次都是只能成功不能失败。这就像一把散线和一股绳，散线很容易被绳扯断。因此，专注的英特尔最终把计算机处理器的业务做大做强，而业务多元化的摩托罗拉最后除了在计算机处理器上败给了英特尔，在手机上碰到了诺基亚，在信号处理器(DSP)上又败给了德州仪器。</p><blockquote><p>有时候，一家好的公司不能完全按华尔街的意愿办事。</p></blockquote><h3 id="CISC-vs-RISC"><a href="#CISC-vs-RISC" class="headerlink" title="CISC vs RISC"></a>CISC vs RISC</h3><p>当今的计算机系统结构可以根据指令集分成复杂指令集(CISC)和精简指令集(RISC)两种。一个计算机程序最终要变成一系列指令才能在处理器上运行。每种处理器的指令集不一定相同。</p><h4 id="CISC处理器"><a href="#CISC处理器" class="headerlink" title="CISC处理器"></a>CISC处理器</h4><p>CISC处理器在设计的时候，尽可能地实现各种各样、功能齐全的指令，这包括早期IBM和DEC的全部处理器，今天的英特尔和AMD的处理器等。</p><p>CISC处理器的优势：可以实现很复杂的指令。</p><p>CISC处理器的问题：</p><ol><li>设计复杂，实现同样的性能需要很高的集成度;</li><li>每个指令执行时间不一样长，处理器内部各个部分很难流水作业，处理器会出现不必要的等待</li><li>CISC处理器芯片高集成度的高功耗。</li></ol><h4 id="RISC处理器"><a href="#RISC处理器" class="headerlink" title="RISC处理器"></a>RISC处理器</h4><p>上个世纪80年代，计算机科学家们提出了RISC处理器设计思想。精简指令集只保留很少的常用指令，一条复杂的指令会用几条简单的指令代替。RISC处理器每条指令的执行时间相同，处理器内各部分可以很好地流水作业，处理器速度比同时期的CISC处理器要来得快。</p><p>使用精简指令集设计的处理器，过去主要是很多工作站的处理器。现在低端的主要是手机中的处理器，高端的则是专门处理图形和图像的GPU(Graphics Processing Unit)。</p><h4 id="英特尔的表现"><a href="#英特尔的表现" class="headerlink" title="英特尔的表现"></a>英特尔的表现</h4><ol><li><strong>英特尔坚持自己系列产品的兼容性</strong>，即保证以往的软件程序能在新款处理器上运行。这样时间一长，用户便积累了很多在英特尔处理器上运行的软件。每次处理器升级，用户原来的软件都能使用，非常方便。因此大家就不愿意轻易换用其他厂商的处理器，即使那些处理器更快。而其他处理器厂商这点做得都没有英特尔好，它们常常每过几年就重起炉灶，害得用户以前很多软件都不能用了，必须花钱买新的。时间一长，用户就换烦了。</li><li><strong>英特尔利用规模经济的优势，大力投入研发，让业界普遍看衰的CISC处理器一代代更新。</strong>在上个世纪90年代初，英特尔的x86系列和RISC处理器相比在实数运算上要略逊一筹。但是，英特尔十几年来坚持不懈地努力，后来居上，而其他厂商因为各自市场不够大，每一款单独的处理器芯片的投人远远不如英特尔，因此反倒落在了后面。</li><li><strong>英特尔并没有拒绝新技术</strong>，它也曾经研制出两款不错的RISC处理器，只是看到它们前途不好时，立即停掉了。市场的倾向说明了用户对兼容性的要求比性能更重要。</li><li>英特尔运气很好，在RISC处理器阵营中，群龙无首。这一战，看似英特尔单挑诸多处理器领域的老大。但是，这几家做RISC处理器的公司因为彼此在工作站方面是竞争对手，自然不会用对手的产品，而目各自为战，互相拆台打价格战。</li></ol><h3 id="英特尔与AMD"><a href="#英特尔与AMD" class="headerlink" title="英特尔与AMD"></a>英特尔与AMD</h3><p>AMD不同于英特尔以往的对手，它从来没有另起炉灶做一种和英特尔不同的芯片，而是不断推出和英特尔兼容的、更便宜的替代品。AMD的这种做法和它的基因有很大关系。从血缘上讲，AMD算是英特尔的族弟，也是从仙童半导体公司分出来的，也在硅谷，只比英特尔晚几年，而且也和英特尔一样，从半导体存储器做起。</p><p>AMD的创始人是搞销售出身的，AMD的这种基因决定了它不是自己会做什么就做什么，而是市场导向的，市场需要什么就做什么。在AMD创建不久，它就成功地解剖了英特尔的一款8位处理器芯片。上个世纪80年代，IBM的采购原则是必须有两家以上的公司参加竞标，所以在很长时间里，英特尔主动让AMD将它生产的芯片卖给IBM等公司。</p><p>在整个20世纪90年代，英特尔和AMD易然总是打打闹闹，但是它们在开拓x86市场，对抗精简指令集的工作站芯片方面利益是一致的。因此，它们在市场上的依存要多于竞争。</p><p>英特尔并不想把AMD彻底打死，因为留着AMD对它利大于弊。首先，它避免了反垄断的很多麻烦。2012年6月，AMD的市值只有英特尔的3%左右，后者靠手中的现金就足以买下前者。但是，英特尔不能这么做，否则会有反垄断的大麻烦。其次，留着AMD这个对手对英特尔自身的技术进步有好处。</p><blockquote><p>柳宗元在他的“敌戒”一文中指出，“秦有六国，兢兢以强;六国既除，訑訑乃亡”。这条规律对于英特尔也适用。</p></blockquote><h2 id="摘抄与思考"><a href="#摘抄与思考" class="headerlink" title="摘抄与思考"></a>摘抄与思考</h2><p>在PC工业生态链中，只有作为<strong>操作系统开发商的Microsoft</strong>和作为<strong>处理器制造商的Intel</strong>处于不可替代的地位。因此，Intel的崛起就成为历史的必然，正所谓时势造英雄。（初期英特尔的成功有一定运气成分，IBM由于时间原因没有自己开发处理器，而是让IBM PC直接用了英特尔的8086，大量兼容机也跟着选用，使得英特尔占了很大的市场份额）</p><p>从英特尔和AMD的关系可以看出，一个公司只是一味仿制，靠更低的利润率来竞争，从长远来看，命运还是掌握在别人手里。</p>]]></content>
    
    
    <categories>
      
      <category>book notes</category>
      
      <category>浪潮之巅</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-2. Consider a builder when faced with many constructor parameters</title>
    <link href="/posts/21ffdb30.html"/>
    <url>/posts/21ffdb30.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters"><a href="#Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters" class="headerlink" title="Item 2: Consider a builder when faced with many constructor parameters"></a>Item 2: Consider a builder when faced with many constructor parameters</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Consider the case of a class representing the Nutrition Facts label that appears on packaged foods. These labels have a few required fields—serving size, servings per container, and calories per serving— and more than twenty optional fields—total fat, saturated fat, trans fat, cholesterol, sodium, and so on. Most products have nonzero values for only a few of these optional fields.</p><h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><h3 id="1-Telescoping-Constructor"><a href="#1-Telescoping-Constructor" class="headerlink" title="1. Telescoping Constructor"></a>1. Telescoping Constructor</h3><p>Provide a constructor with only the required parameters, another with a single optional parameter, a third with two optional parameters, and so on, culminating in a constructor with all the optional parameters.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Telescoping constructor pattern - does not scale well!</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NutritionFacts</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servingSize;  <span class="hljs-comment">// required</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servings;<span class="hljs-comment">// required</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> calories; <span class="hljs-comment">// optional</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> fat; <span class="hljs-comment">// optional</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> sodium; <span class="hljs-comment">// optional</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> carbohydrate; <span class="hljs-comment">// optional</span><br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings)</span> &#123;<br>      <span class="hljs-built_in">this</span>(servingSize, servings, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings,</span><br><span class="hljs-params">          <span class="hljs-type">int</span> calories)</span> &#123;<br>      <span class="hljs-built_in">this</span>(servingSize, servings, calories, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings,</span><br><span class="hljs-params">          <span class="hljs-type">int</span> calories, <span class="hljs-type">int</span> fat)</span> &#123;<br>      <span class="hljs-built_in">this</span>(servingSize, servings, calories, fat, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings,</span><br><span class="hljs-params">          <span class="hljs-type">int</span> calories, <span class="hljs-type">int</span> fat, <span class="hljs-type">int</span> sodium)</span> &#123;<br>      <span class="hljs-built_in">this</span>(servingSize, servings, calories, fat, sodium, <span class="hljs-number">0</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings, <span class="hljs-type">int</span> calories, <span class="hljs-type">int</span> fat, <span class="hljs-type">int</span> sodium, <span class="hljs-type">int</span> carbohydrate)</span> &#123;<br>    <span class="hljs-built_in">this</span>.servingSize = servingSize;<br>    <span class="hljs-built_in">this</span>.servings = servings;<br>    <span class="hljs-built_in">this</span>.calories = calories;<br>    <span class="hljs-built_in">this</span>.fat = fat;<br>    <span class="hljs-built_in">this</span>.sodium = sodium;<br>    <span class="hljs-built_in">this</span>.carbohydrate = carbohydrate;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// create an instance</span><br><span class="hljs-type">NutritionFacts</span> <span class="hljs-variable">cocaCola</span> <span class="hljs-operator">=</span><br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">NutritionFacts</span>(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">35</span>, <span class="hljs-number">27</span>);<br></code></pre></td></tr></table></figure><p><strong>The telescoping constructor pattern works, but it is hard to write client code when there are many parameters, and harder still to read it.</strong></p><h3 id="2-JavaBeans"><a href="#2-JavaBeans" class="headerlink" title="2. JavaBeans"></a>2. JavaBeans</h3><p>Call a parameterless constructor to create the object and then call setter methods to set each required parameter and each optional parameter of interest.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JavaBeans Pattern - allows inconsistency, mandates mutability</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NutritionFacts</span> &#123;<br>  <span class="hljs-comment">// Parameters initialized to default values (if any)</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">servingSize</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//Required; no default value</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">servings</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//Required; no default value</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">calories</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">fat</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sodium</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">carbohydrate</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">()</span> &#123; &#125;<br>  <br>  <span class="hljs-comment">// Setters</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServingSize</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123; servingSize = val; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServings</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123; servings = val; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCalories</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123; calories = val; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFat</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;fat = val;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSodium</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123; sodium = val; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCarbohydrate</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123; carbohydrate = val; &#125;<br><br>&#125;<br><br><span class="hljs-comment">// a bit wordy to create an instance</span><br><span class="hljs-type">NutritionFacts</span> <span class="hljs-variable">cocaCola</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NutritionFacts</span>();<br>cocaCola.setServingSize(<span class="hljs-number">240</span>);<br>cocaCola.setServings(<span class="hljs-number">8</span>);<br>cocaCola.setCalories(<span class="hljs-number">100</span>);<br>cocaCola.setSodium(<span class="hljs-number">35</span>);<br>cocaCola.setCarbohydrate(<span class="hljs-number">27</span>);<br></code></pre></td></tr></table></figure><p>Disadvantages:</p><ul><li>a JavaBean may be in an inconsistent state partway through its construction.</li><li>the JavaBeans pattern precludes the possibility of making a class immutable.</li></ul><h3 id="3-Builder"><a href="#3-Builder" class="headerlink" title="3. Builder"></a>3. Builder</h3><p>Instead of making the desired object directly, the client calls a constructor (or static factory) with all of the required parameters and gets a <em>builder object</em>. Then the client calls setter-like methods on the builder object to set each optional parameter of interest. Finally, the client calls a parameterless build method to generate the object, which is typically immutable.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Builder Pattern</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NutritionFacts</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servingSize;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servings;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> calories;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> fat;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> sodium;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> carbohydrate;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-comment">// Required parameters</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servingSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servings;<br>    <span class="hljs-comment">// Optional parameters - initialized to default values</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">calories</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">fat</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sodium</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">carbohydrate</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings)</span> &#123;<br>      <span class="hljs-built_in">this</span>.servingSize = servingSize;<br>      <span class="hljs-built_in">this</span>.servings    = servings;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">calories</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>        &#123; calories = val;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">fat</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>        &#123; fat = val;           <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">sodium</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>        &#123; sodium = val;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>    <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">carbohydrate</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>        &#123; carbohydrate = val;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>    <span class="hljs-keyword">public</span> NutritionFacts <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NutritionFacts</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(Builder builder)</span> &#123;<br>    servingSize = builder.servingSize;<br>    servings = builder.servings;<br>    calories = builder.calories;<br>    fat = builder.fat;<br>    sodium = builder.sodium;<br>    carbohydrate = builder.carbohydrate;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// using a fluent API (chained) to create an instance</span><br><span class="hljs-type">NutritionFacts</span> <span class="hljs-variable">cocaCola</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NutritionFacts</span>.Builder(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>)<br>           .calories(<span class="hljs-number">100</span>).sodium(<span class="hljs-number">35</span>).carbohydrate(<span class="hljs-number">27</span>).build();<br></code></pre></td></tr></table></figure><p>Disadvantages:</p><ul><li>In order to create an object, you must <strong>first create its builder</strong>. While the cost of creating this builder is unlikely to be noticeable in practice, it could be a <strong>problem in performance-critical situations</strong>.</li><li>Also, the Builder pattern is more verbose than the telescoping constructor pattern, so it should be used only if there are enough parameters to make it worthwhile, say four or more.</li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>The Builder pattern is a good choice when designing classes whose constructors or static factories would have <strong>more than a handful of parameters</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-5. Prefer dependency injection to hardwiring resources</title>
    <link href="/posts/23b97aa.html"/>
    <url>/posts/23b97aa.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-5-Prefer-dependency-injection-to-hardwiring-resources"><a href="#Item-5-Prefer-dependency-injection-to-hardwiring-resources" class="headerlink" title="Item 5: Prefer dependency injection to hardwiring resources"></a>Item 5: Prefer dependency injection to hardwiring resources</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Many classes depend on one or more underlying resources. For example, a spell checker depends on a dictionary.</p><p>It is not uncommon to see such classes implemented as static utility classes (Item 4):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Inappropriate use of static utility - inflexible &amp; untestable!</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpellChecker</span> &#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lexicon</span> <span class="hljs-variable">dictionary</span> <span class="hljs-operator">=</span> ...;<br>     <span class="hljs-keyword">private</span> <span class="hljs-title function_">SpellChecker</span><span class="hljs-params">()</span> &#123;&#125; <span class="hljs-comment">// Noninstantiable</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String word)</span> &#123; ... &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">suggestions</span><span class="hljs-params">(String typo)</span> &#123; ... &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>Similarly, it’s not uncommon to see them implemented as singletons (Item 3):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Inappropriate use of singleton - inflexible &amp; untestable!</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpellChecker</span> &#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lexicon</span> <span class="hljs-variable">dictionary</span> <span class="hljs-operator">=</span> ...;<br>     <span class="hljs-keyword">private</span> <span class="hljs-title function_">SpellChecker</span><span class="hljs-params">(...)</span> &#123;&#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpellChecker</span>(...);<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String word)</span> &#123; ... &#125;<br>     <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">suggestions</span><span class="hljs-params">(String typo)</span> &#123; ... &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>Neither of these approaches is satisfactory, because they assume that there is only <strong>one dictionary</strong> worth using. In practice, each language has its own dictionary, and special dictionaries are used for special vocabularies. Also, it may be desirable to use a special dictionary for <strong>testing</strong>.</p><blockquote><p>You could try to have SpellChecker support multiple dictionaries by making the dictionary field <strong>nonfinal</strong> and <strong>adding a method to change the dictionary in an existing spell checker</strong>, would be awkward, error-prone, and unworkable in a concurrent setting.</p></blockquote><p><strong>Static utility classes and singletons are inappropriate for classes whose behavior is parameterized by an underlying resource.</strong></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>What is required is the ability to support <strong>multiple instances of the class</strong> (in our example, SpellChecker), each of which uses the <strong>specific type of resource</strong> desired by the client (in our example, the dictionary). </p><h3 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a>Dependency Injection</h3><p><strong>Dependency Injection pattern:</strong> pass the resource into the constructor when creating a new instance.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Dependency injection provides flexibility and testability</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpellChecker</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lexicon dictionary;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SpellChecker</span><span class="hljs-params">(Lexicon dictionary)</span> &#123;<br>    <span class="hljs-built_in">this</span>.dictionary = Objects.requireNonNull(dictionary);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String word)</span> &#123; ... &#125;<br>  <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">suggestions</span><span class="hljs-params">(String typo)</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>It preserves <strong>immutability</strong> (Item 17), so multiple clients can share dependent objects (assuming the clients desire the same underlying resources).</p><p>Dependency injection is equally applicable to <strong>constructors</strong>, <strong>static factories</strong> (Item 1), and <strong>builders</strong> (Item 2).</p><h4 id="Variant"><a href="#Variant" class="headerlink" title="Variant"></a>Variant</h4><p>A useful variant of the pattern is to pass a resource <em>factory</em> to the constructor. A factory is an object that can be called repeatedly to create instances of a type. Such factories embody the <em>Factory Method</em> pattern.</p><p>For example, here is a method that makes a mosaic using a client-provided factory to produce each tile:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Mosaic <span class="hljs-title function_">create</span><span class="hljs-params">(Supplier&lt;? extends Tile&gt; tileFactory)</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><blockquote><p>The <code>Supplier&lt;T&gt;</code> interface, introduced in Java 8, is perfect for representing factories.</p><p>Methods that take a <code>Supplier&lt;T&gt;</code> on input should typically constrain the factory’s type parameter using a <em>bounded wildcard type</em> (Item 31) to allow the client to pass in a factory that creates any <strong>subtype of a specified type.</strong></p></blockquote><h4 id="Pros-Cons"><a href="#Pros-Cons" class="headerlink" title="Pros &amp; Cons"></a>Pros &amp; Cons</h4><p>Dependency injection greatly improves <strong>flexibility</strong> and <strong>testability</strong>.</p><p>But it can <strong>clutter up large projects</strong>, which typically contain <strong>thousands of dependencies</strong>.</p><blockquote><p>This clutter can be all but eliminated by using a <em>dependency injection framework</em>, such as Dagger, Guice, or Spring.</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Do not use a singleton or static utility class to implement a class that depends on one or more underlying resources whose behavior affects that of the class, and do not have the class create these resources directly.</p><p>Instead, pass the resources, or factories to create them, into the constructor (or static factory or builder). This practice, known as dependency injection, will greatly enhance the <strong>flexibility, reusability, and testability of a class</strong>.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-8. Avoid finalizers and cleaners</title>
    <link href="/posts/23cfb57b.html"/>
    <url>/posts/23cfb57b.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-8-Avoid-finalizers-and-cleaners"><a href="#Item-8-Avoid-finalizers-and-cleaners" class="headerlink" title="Item 8: Avoid finalizers and cleaners"></a>Item 8: Avoid finalizers and cleaners</h1><p><strong>Finalizers are unpredictable, often dangerous, and generally unnecessary.</strong></p><p><strong>Cleaners (Java 9) are less dangerous than finalizers, but still unpredictable, slow, and generally unnecessary.</strong></p><h2 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h2><h3 id="1-There-is-no-guarantee-they’ll-be-executed-promptly"><a href="#1-There-is-no-guarantee-they’ll-be-executed-promptly" class="headerlink" title="1. There is no guarantee they’ll be executed (promptly)"></a>1. There is no guarantee they’ll be executed (promptly)</h3><h4 id="never-do-anything-time-critical-in-a-finalizer-or-cleaner"><a href="#never-do-anything-time-critical-in-a-finalizer-or-cleaner" class="headerlink" title="never do anything time-critical in a finalizer or cleaner"></a>never do anything time-critical in a finalizer or cleaner</h4><p>It can take arbitrarily long between the time that an object becomes unreachable and the time its finalizer or cleaner runs. This means that you should <strong>never do anything time-critical in a finalizer or cleaner.</strong></p><blockquote><p>For example, it is a grave error to depend on a finalizer or cleaner to close files because open file descriptors are a limited resource. If many files are left open as a result of the system’s tardiness in running finalizers or cleaners, a program may fail because it can no longer open files.</p></blockquote><p>The promptness with which finalizers and cleaners are executed is primarily a function of the <em>garbage collection algorithm</em>, which varies widely across implementations. The behavior of a program that depends on the promptness of finalizer or cleaner execution may likewise vary.</p><blockquote><p>It is entirely possible that such a program will run perfectly on the JVM on which you test it and then fail miserably on the one favored by your most important customer.</p></blockquote><h4 id="never-depend-on-a-finalizer-or-cleaner-to-update-persistent-state"><a href="#never-depend-on-a-finalizer-or-cleaner-to-update-persistent-state" class="headerlink" title="never depend on a finalizer or cleaner to update persistent state"></a>never depend on a finalizer or cleaner to update persistent state</h4><p>Not only does the specification provide no guarantee that finalizers or cleaners will run promptly; it provides <strong>no guarantee that they’ll run at all</strong>. It is entirely possible, even likely, that a program terminates without running finalizer or cleaner on some objects that are no longer reachable. As a consequence, you should <strong>never depend on a finalizer or cleaner to update persistent state.</strong></p><blockquote><p>For example, depending on a finalizer or cleaner to release a persistent lock on a shared resource such as a database is a good way to bring your entire distributed system to a grinding halt.</p></blockquote><h3 id="2-An-uncaught-exception-thrown-during-finalization-is-ignored"><a href="#2-An-uncaught-exception-thrown-during-finalization-is-ignored" class="headerlink" title="2. An uncaught exception thrown during finalization is ignored"></a>2. An uncaught exception thrown during finalization is ignored</h3><p>Another problem with finalizers is that an uncaught exception thrown during finalization is ignored, and finalization of that object terminates. Uncaught exceptions can leave other objects in a corrupt state.</p><p>If another thread attempts to use such a corrupted object, arbitrary nondeterministic behavior may result. Normally, an uncaught exception will terminate the thread and print a stack trace, but not if it occurs in a finalizer—it won’t even print a warning.</p><blockquote><p>Cleaners do not have this problem because a library using a cleaner has control over its thread.</p></blockquote><h3 id="3-There-is-a-severe-performance-penalty-for-using-finalizers-and-cleaners"><a href="#3-There-is-a-severe-performance-penalty-for-using-finalizers-and-cleaners" class="headerlink" title="3. There is a severe performance penalty for using finalizers and cleaners"></a>3. There is a severe performance penalty for using finalizers and cleaners</h3><p>It is about 50 times slower to create and destroy objects with finalizers compared to using <em>try-with-resources</em>. This is primarily because finalizers inhibit efficient garbage collection.</p><p>Cleaners are comparable in speed to finalizers if you use them to clean all instances of the class, but cleaners are much faster if you use them only as a <strong>safety net</strong>.</p><h3 id="4-Security-problem-finalizers-open-your-class-up-to-finalizer-attacks"><a href="#4-Security-problem-finalizers-open-your-class-up-to-finalizer-attacks" class="headerlink" title="4. Security problem: finalizers open your class up to finalizer attacks"></a>4. Security problem: finalizers <strong>open your class up to</strong> <em>finalizer attacks</em></h3><blockquote><p>The idea behind a finalizer attack is simple: If an exception is thrown from a constructor or its serialization equivalents—the <em>readObject</em> and <em>readResolve</em> methods (Chapter 12)—the finalizer of a malicious subclass can run on the partially constructed object that should have “died on the vine.”(半途夭折) This finalizer can record a reference to the object in a static field, preventing it from being garbage collected. Once the malformed object has been recorded, it is a simple matter to invoke arbitrary methods on this object that should never have been allowed to exist in the first place. <strong>Throwing an exception from a constructor should be sufficient to prevent an object from coming into existence; in the presence of finalizers, it is not.</strong> </p></blockquote><p>Final classes are immune to finalizer attacks because no one can write a malicious subclass of a final class. <strong>To protect nonfinal classes from finalizer attacks, write a final</strong> <strong>finalize</strong> <strong>method that does nothing.</strong></p><h2 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h2><h3 id="1-Can-act-as-a-safety-net-in-case-the-owner-of-a-resource-neglects-to-call-its-close-method"><a href="#1-Can-act-as-a-safety-net-in-case-the-owner-of-a-resource-neglects-to-call-its-close-method" class="headerlink" title="1. Can act as a safety net in case the owner of a resource neglects to call its close method"></a>1. Can act as a safety net in case the owner of a resource neglects to call its close method</h3><p>While there’s no guarantee that the cleaner or finalizer will run promptly (or at all), it is better to free the resource late than never if the client fails to do so. If you’re considering writing such a safety-net finalizer, think long and hard about whether the protection is <strong>worth the cost</strong>.</p><blockquote><p>Some Java library classes, such as FileInputStream, FileOutputStream, ThreadPoolExecutor, and java.sql.Connection, have finalizers that serve as safety nets.</p></blockquote><h3 id="2-Concerns-objects-with-native-peers"><a href="#2-Concerns-objects-with-native-peers" class="headerlink" title="2. Concerns objects with native peers"></a>2. Concerns objects with <em>native peers</em></h3><blockquote><p>A native peer is a native (non-Java) object to which a normal object delegates via native methods. </p></blockquote><p>Because a native peer is not a normal object, the garbage collector doesn’t know about it and can’t reclaim it when its Java peer is reclaimed.</p><p>A cleaner or finalizer may be an appropriate vehicle for this task, assuming the performance is acceptable and the native peer holds no critical resources. If the performance is unacceptable or the native peer holds resources that must be reclaimed promptly, the class should have a <em>close</em> method, as described earlier.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>What should you do instead of writing a finalizer or cleaner for a class whose objects encapsulate resources that require termination, such as files or threads?</p><p>Just <strong>have your class implement</strong> <strong>AutoCloseable</strong>, and require its clients to invoke the close method on each instance when it is no longer needed, typically using try-with-resources to ensure termination even in the face of exceptions (Item 9).</p><blockquote><p>One detail worth mentioning is that the instance must keep track of whether it has been closed: <strong>the close method must record in a field that the object is no longer valid</strong>, and other methods must check this field and throw an <strong>IllegalStateException</strong> if they are called after the object has been closed.</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, don’t use cleaners, or in releases prior to Java 9, finalizers, except as a safety net or to terminate noncritical native resources. Even then, beware the indeterminacy and performance consequences.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-9. Prefer try-with-resources to try-finally</title>
    <link href="/posts/22bb60a3.html"/>
    <url>/posts/22bb60a3.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-9-Prefer-try-with-resources-to-try-finally"><a href="#Item-9-Prefer-try-with-resources-to-try-finally" class="headerlink" title="Item 9: Prefer try-with-resources to try-finally"></a>Item 9: Prefer <em>try-with-resources</em> to <em>try-finally</em></h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>The Java libraries include many resources that must be closed manually by invok- ing a close method. Examples include InputStream, OutputStream, and java.sql.Connection.</p><p>Closing resources is often overlooked by clients, with predictably dire performance consequences. While many of these resources use finalizers as a safety net, finalizers don’t work very well (Item 8).</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="1-try-finally"><a href="#1-try-finally" class="headerlink" title="1. try-finally"></a>1. try-finally</h3><p>Historically, a try-finally statement was the best way to guarantee that a resource would be closed properly, even in the face of an exception or return.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// try-finally - No longer the best way to close resources!</span><br><span class="hljs-keyword">static</span> String <span class="hljs-title function_">firstLineOfFile</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path));<br>  <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-keyword">return</span> br.readLine();<br>   &#125; <span class="hljs-keyword">finally</span> &#123;<br>       br.close();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>But it gets worse when you add a second resource:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// try-finally is ugly when used with more than one resource!</span><br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(String src, String dst)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>     <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dst);<br>         <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[BUFFER_SIZE];<br>             <span class="hljs-type">int</span> n;<br>             <span class="hljs-keyword">while</span> ((n = in.read(buf)) &gt;= <span class="hljs-number">0</span>)<br>                 out.write(buf, <span class="hljs-number">0</span>, n);<br>         &#125; <span class="hljs-keyword">finally</span> &#123;<br>             out.close();<br>         &#125;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         in.close();<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h4><ul><li><p>It’s complicated when dealing with multiple resources. It may be hard to believe, but even good programmers got this wrong most of the time.</p></li><li><p>The code in both the try block and the finally block is capable of throwing exceptions. There is no record of the first exception in the exception stack trace, which can greatly complicate debugging in real systems—usually it’s the first exception that you want to see in order to diagnose the problem.</p><blockquote><p>For example, in the <em>firstLineOfFile</em> method, the call to readLine could throw an exception due to a failure in the underlying physical device, and the call to close could then fail for the same reason. Under these circumstances, the second exception completely obliterates the first one.</p></blockquote></li></ul><h3 id="2-try-with-resources"><a href="#2-try-with-resources" class="headerlink" title="2. try-with-resources"></a>2. try-with-resources</h3><p>All of these problems were solved in one fell swoop when Java 7 introduced the try-with-resources statement.</p><p>To be usable with this construct, a resource must implement the <strong>AutoCloseable</strong> interface, which consists of a single void-returning close method.</p><blockquote><p>Many classes and interfaces in the Java libraries and in third-party libraries now implement or extend AutoCloseable. If you write a class that represents a resource that must be closed, your class should implement AutoCloseable too.</p></blockquote><p>Examples:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// try-with-resources - the the best way to close resources!</span><br> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">firstLineOfFile</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>     <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path))) &#123;<br>         <span class="hljs-keyword">return</span> br.readLine();<br>     &#125;<br> &#125;<br><br><span class="hljs-comment">// try-with-resources on multiple resources - short and sweet</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(String src, String dst)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(src);<br>      <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(dst)) &#123;<br>    <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[BUFFER_SIZE];<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> ((n = in.read(buf)) &gt;= <span class="hljs-number">0</span>)<br>      out.write(buf, <span class="hljs-number">0</span>, n);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Not only are the try-with-resources versions shorter and more <strong>readable</strong> than the originals, but they provide far better <strong>diagnostics</strong>.</p><blockquote><p>Consider the <em>firstLineOfFile</em> method. If exceptions are thrown by both the readLine call and the (invisible) close, <strong>the latter exception is <em>suppressed</em> in favor of the former</strong>. In fact, multiple exceptions may be suppressed in order to preserve the exception that you actually want to see.</p><p>These suppressed exceptions are not merely discarded; they are printed in the stack trace with a notation saying that they were suppressed. You can also <strong>access</strong> them programmatically with the <strong>getSuppressed</strong> method, which was added to Throwable in Java 7.</p></blockquote><h4 id="catch-clauses"><a href="#catch-clauses" class="headerlink" title="catch clauses"></a>catch clauses</h4><p>You can put catch clauses on try-with-resources statements, just as you can on regular try-finally statements. This allows you to handle exceptions without sullying your code with another layer of nesting.</p><p>Here’s a version our firstLineOfFile method that does not throw exceptions, but takes a default value to return if it can’t open the file or read from it:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// try-with-resources with a catch clause</span><br><span class="hljs-keyword">static</span> String <span class="hljs-title function_">firstLineOfFile</span><span class="hljs-params">(String path, String defaultVal)</span> &#123;<br>   <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path))) &#123;<br>       <span class="hljs-keyword">return</span> br.readLine();<br>   &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>       <span class="hljs-keyword">return</span> defaultVal;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p><strong>Always use try-with-resources</strong> in preference to try-finally when working with <strong>resources that must be closed</strong>.</p><p>The resulting code is shorter and clearer, and the exceptions that it generates are more useful. The try-with-resources statement makes it easy to write correct code using resources that must be closed, which was practically impossible using try-finally.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-10. Obey the general contract when overriding equals</title>
    <link href="/posts/2a49d2f.html"/>
    <url>/posts/2a49d2f.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-10-Obey-the-general-contract-when-overriding-equals"><a href="#Item-10-Obey-the-general-contract-when-overriding-equals" class="headerlink" title="Item 10: Obey the general contract when overriding equals"></a>Item 10: Obey the general contract when overriding <em>equals</em></h1><h2 id="Conditions-for-not-overriding-the-equals-method"><a href="#Conditions-for-not-overriding-the-equals-method" class="headerlink" title="Conditions for not overriding the equals method"></a>Conditions for <strong>not</strong> overriding the <em>equals</em> method</h2><ul><li><p><strong>Each instance of the class is inherently unique.</strong> This is true for classes such as <strong>Thread</strong> that represent active entities rather than values. The equals implementation provided by Object has exactly the right behavior for these classes.</p></li><li><p><strong>There is no need for the class to provide a “logical equality” test.</strong> For example, java.util.regex.Pattern could have overridden equals to check whether two Pattern instances represented exactly the same regular expression, but the designers didn’t think that clients would need or want this functionality. Under these circumstances, the <em>equals</em> implementation inherited from <em>Object</em> is ideal.</p></li><li><p><strong>A super class has already overridden <em>equals</em>, and the superclass behavior is appropriate for this class.</strong> For example, most <em>Set</em> implementations inherit their equals implementation from <em>AbstractSet</em>, <em>List</em> implementations from <em>AbstractList</em>, and <em>Map</em> implementations from <em>AbstractMap</em>.</p></li><li><p><strong>The class is private or package-private,and you are certain that its <em>equals</em> method will never be invoked.</strong> If you are extremely risk-averse, you can override the equals method to ensure that it isn’t invoked accidentally:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(); <span class="hljs-comment">// Method is never called</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Overriding-the-equals-method"><a href="#Overriding-the-equals-method" class="headerlink" title="Overriding the equals method"></a>Overriding the <em>equals</em> method</h2><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Adds a value component without violating the equals contract</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ColorPoint</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Point point;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Color color;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ColorPoint</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, Color color)</span> &#123;<br>     point = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(x, y);<br>     <span class="hljs-built_in">this</span>.color = Objects.requireNonNull(color);<br>  &#125;<br>  <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Returns the point-view of this color point.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> Point <span class="hljs-title function_">asPoint</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> point;<br>  &#125;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>   <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> ColorPoint))<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   <span class="hljs-type">ColorPoint</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> (ColorPoint) o;<br>   <span class="hljs-keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);<br>&#125;<br>  ...  <span class="hljs-comment">// Remainder omitted</span><br>&#125;<br></code></pre></td></tr></table></figure><p>“Favor composition over inheritance.”</p><h3 id="When"><a href="#When" class="headerlink" title="When?"></a>When?</h3><p>When a class has a notion of <em>logical equality</em> that differs from mere object identity and a superclass has not already overridden equals. This is generally the case for <em>value classes.</em></p><blockquote><p>A value class is simply a class that represents a value, such as Integer or String.</p></blockquote><p>A programmer who compares references to value objects using the <em>equals</em> method expects to find out whether they are <strong>logically equivalent</strong>, not whether they refer to the same object.</p><p>Not only is overriding the equals method necessary to satisfy programmer expectations, it enables instances to serve as <strong>map keys or set elements</strong> with predictable, desirable behavior.</p><blockquote><p>One kind of value class that does <em>not</em> require the <em>equals</em> method to be overridden is a class that uses <strong>instance control</strong> (Item 1) to ensure that <strong>at most one object exists with each value</strong>. <em>Enum</em> types (Item 34) fall into this category. For these classes, logical equality is the same as object identity, so Object’s <em>equals</em> method functions as a logical equals method.</p></blockquote><h3 id="General-contract-of-overriding-equals"><a href="#General-contract-of-overriding-equals" class="headerlink" title="General contract of overriding equals"></a>General contract of overriding <em>equals</em></h3><ul><li><p><em><strong>Reflexivity</strong></em>: For any non-null reference value x, <strong>x.equals(x)</strong> must return <strong>true</strong>.</p></li><li><p><em><strong>Symmetry</strong></em>: For any non-null reference values x and  y, <strong>x.equals(y)</strong> must return true if and only if <strong>y.equals(x)</strong> returns true.</p></li><li><p><em><strong>Transitivity</strong></em>: For any non-null reference values x, y, z, if <strong>x.equals(y)</strong>  returns true and <strong>y.equals(z)</strong> returns true, then <strong>x.equals(z)</strong> must return true.</p></li><li><p><em><strong>Consistency</strong></em>: For any non-null reference values x and y, <strong>multiple invocations</strong> of x.equals(y) must consistently return true or consistently return false, provided no information used in equals comparisons is modified.</p></li><li><p><em><strong>Non-nullity</strong></em>: For any non-null reference value x, <strong>x.equals(null) must return false.</strong></p><p>Type check is enough, no need to test “if o &#x3D;&#x3D; null”. The <em>instanceof</em> operator is specified to return false if its first operand is null, regardless of what type appears in the second operand.</p></li></ul><h3 id="Recipe-for-a-high-quality-equals-method"><a href="#Recipe-for-a-high-quality-equals-method" class="headerlink" title="Recipe for a high-quality equals method"></a>Recipe for a high-quality <em>equals</em> method</h3><ol><li><p><strong>Use the</strong> <strong>&#x3D;&#x3D;</strong> <strong>operator to check if the argument is a reference to this object.</strong> If so, return true. This is just a performance optimization but one that is worth doing if the <strong>comparison is potentially expensive</strong>.</p></li><li><p><strong>Use the <em>instanceof</em> operator to check if the argument has the correct type.</strong> If not, return false. Typically, the correct type is the <strong>class</strong> in which the method occurs.</p><blockquote><p>Occasionally, it is some interface implemented by this class. Use an interface if the class implements an interface that refines the equals contract to permit comparisons across classes that implement the interface. Collection interfaces such as Set, List, Map, and Map.Entry have this property.</p></blockquote></li><li><p><strong>Cast the argument to the correct type.</strong> Because this cast was preceded by an instanceof test, it is guaranteed to succeed.</p></li><li><p><strong>For each “significant” field in the class, check if that field of the argument matches the corresponding field of this object.</strong> If all these tests succeed, return true; otherwise, return false. If the type in Step 2 is an interface, you must access the argument’s fields via interface methods; if the type is a class, you may be able to access the fields directly, depending on their accessibility.</p><p>For primitive fields whose type is not float or double, use the &#x3D;&#x3D; operator for comparisons.</p><p>For object reference fields, call the equals method recursively.</p><p>For float fields, use the static <em>Float.compare(float, float)</em> method; and for double fields, use <em>Double.compare(double, double)</em>. The special treatment of float and double fields is made necessary by the existence of Float.NaN, -0.0f and the analogous double values.</p><p>For array fields, apply these guidelines to each element. If every element in an array field is significant, use one of the Arrays.equals methods.</p><blockquote><p>Some object reference fields may <strong>legitimately contain null</strong>. To avoid the possibility of a NullPointerException, check such fields for equality using the static method <strong>Objects.equals(Object, Object)</strong>.</p></blockquote></li><li><p>The performance of the equals method may be affected by the <strong>order</strong> in which fields are compared. For best performance, you should first compare fields that are <strong>more likely to differ, less expensive to compare</strong>, or, ideally, both.</p><p>You must <strong>not compare fields that are not part of an object’s logical state</strong>, such as lock fields used to synchronize operations.</p><p>You need <strong>not compare <em>derived fields</em></strong>, which can be calculated from “significant fields,” but doing so may improve the performance of the equals method. If a derived field amounts to a summary description of the entire object, comparing this field will save you the expense of comparing the actual data if the comparison fails.</p></li><li><p>Write unit tests to check, unless you used <em>AutoValue</em> to generate your equals method, in which case you can safely omit the tests.</p></li></ol><h3 id="Final-caveats"><a href="#Final-caveats" class="headerlink" title="Final caveats"></a>Final caveats</h3><ul><li><p><strong>Always override hashCode when you override <em>equals</em></strong>(Item11).</p></li><li><p><strong>Don’t try to be too clever.</strong> If you simply test fields for equality, it’s not hard to adhere to the equals contract. If you are overly aggressive in searching for equivalence, it’s easy to get into trouble. It is generally a bad idea to take any form of aliasing into account. For example, the File class shouldn’t attempt to equate symbolic links referring to the same file. Thankfully, it doesn’t.</p></li><li><p>**Don’t substitute another type for <em>Object</em> in the <em>equals</em> declaration.**Itisnot uncommon for a programmer to write an equals method that looks like this and then spend hours puzzling over why it doesn’t work properly:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Broken - parameter type must be Object!</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(MyClass o)</span> &#123;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><p>The problem is that this method does not <em>override</em> Object.equals, whose argument is of type Object, but <em>overloads</em> it instead (Item 52).</p><p>Consistent use of the <em>@Override</em> annotation, will prevent you from making this mistake (Item 40), it won’t compile and the error message will tell you exactly what is wrong.</p></li></ul><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><p>Writing and testing equals (and hashCode) methods is tedious, and the resulting code is mundane. An excellent alternative to writing and testing these methods manually is to use <strong>Google’s open source AutoValue framework</strong>, which automatically generates these methods for you, triggered by a single annotation on the class . In most cases, the methods generated by AutoValue are essentially identical to those you’d write yourself.</p><p><strong>IDEs</strong>, too, have facilities to generate equals and hashCode methods, but the resulting source code is more verbose and less readable than code that uses AutoValue, does not track changes in the class automatically, and therefore requires testing. That said, having IDEs generate equals (and hashCode) methods is generally preferable to implementing them manually because IDEs do not make careless mistakes, and humans do.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, don’t override the <em>equals</em> method unless you have to: <strong>in many cases, the implementation inherited from Object does exactly what you want.</strong></p><p>If you do override equals, make sure to compare all of the class’s significant fields and to compare them in a manner that preserves all **five provisions of the equals contract.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-11. Always override hashCode when you override equals</title>
    <link href="/posts/ab4afd12.html"/>
    <url>/posts/ab4afd12.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-11-Always-override-hashCode-when-you-override-equals"><a href="#Item-11-Always-override-hashCode-when-you-override-equals" class="headerlink" title="Item 11: Always override hashCode when you override equals"></a>Item 11: Always override <em>hashCode</em> when you override <em>equals</em></h1><h2 id="General-contract-for-hashCode"><a href="#General-contract-for-hashCode" class="headerlink" title="General contract for hashCode"></a>General contract for <em>hashCode</em></h2><ul><li>When the <em>hashCode</em> method is invoked on an object repeatedly during <strong>an execution of an application</strong>, it <strong>must consistently return the same value</strong>, provided no information used in equals comparisons is modified. This value need not remain consistent from one execution of an application to another.</li><li>If two objects are <strong>equal</strong> according to the <em>equals(Object)</em> method,then calling <em><strong>hashCode</strong></em> on the two objects must produce the <strong>same integer result</strong>.</li><li>If two objects are unequal according to the <em>equals(Object)</em> method,it is <em>not</em> required that calling hashCode on each of the objects must produce distinct results. However, the programmer should be aware that producing distinct results for unequal objects may improve the performance of hash tables.</li></ul><p><strong>The key provision that is violated when you fail to override</strong> <em><strong>hashCode</strong></em> <strong>is the second one: equal objects must have equal hash codes.</strong> Two distinct instances may be logically equal according to a class’s equals method, but to Object’s <em>hashCode</em> method, they’re just two objects with nothing much in common. Therefore, Object’s <em>hashCode</em> method returns two seemingly random numbers instead of two equal numbers as required by the contract.</p><h2 id="The-recipe-to-implement-a-good-hashCode-method"><a href="#The-recipe-to-implement-a-good-hashCode-method" class="headerlink" title="The recipe to implement a good hashCode method"></a>The recipe to implement a good <em>hashCode</em> method</h2><ol><li><p>Declare an int variable named <code>result</code>, and initialize it to the hash code <code>c</code> for the <strong>first significant field</strong> in your object, as computed in step 2.a. (Recall from Item 10 that a significant field is a field that affects equals comparisons.)</p></li><li><p>For every <strong>remaining significant field</strong> <code>f</code> in your object, do the following: </p><p>a. Compute an int hash code <code>c</code> for the field:</p><ol><li><p>If the field is of a primitive type, compute <code>Type.hashCode(f)</code>, where Type is the boxed primitive class corresponding to <code>f</code>’ s type.</p></li><li><p>If the field is an <strong>object reference</strong> and this class’s <em>equals</em> method compares the field by recursively invoking <em>equals</em>, <strong>recursively invoke hashCode on the field</strong>.</p><p>If a more complex comparison is required, compute a “canonical representation” for this field and invoke hashCode on the canonical representation. If the value of the field is null, use 0 (or some other constant, but 0 is traditional).</p></li><li><p>If the field is an array, treat it as if each significant element were a separate field. That is, compute a hash code for each significant element by applying these rules recursively, and combine the values per step 2.b. If the array has no significant elements, use a constant, preferably not 0. If all elements are significant, use <code>Arrays.hashCode</code>.</p></li></ol><p>b. Combine the hash code c computed in step 2.a into result as follows: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">result = <span class="hljs-number">31</span> * result + c;<br></code></pre></td></tr></table></figure><blockquote><p>Makes the result depend on the <strong>order</strong> of the fields, yielding a much better hash function if the class has multiple similar fields.</p></blockquote></li><li><p>Return result.</p></li></ol><p>Example for the <code>PhoneNumber</code> class:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Typical hashCode method</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Short.hashCode(areaCode);<br>  result = <span class="hljs-number">31</span> * result + Short.hashCode(prefix);<br>  result = <span class="hljs-number">31</span> * result + Short.hashCOde(lineNum);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Exclude <em>derived fields</em> from the hash code computation.</p></blockquote><blockquote><p>While the recipe in this item yields reasonably good hash functions, they are not state-of-the-art. They are comparable in quality to the hash functions found in the Java platform libraries’ value types and are adequate for most uses. If you have a bona fide need for hash functions <strong>less likely to produce collisions</strong>, see Guava’s <code>com.google.common.hash.Hashing</code> [Guava].</p></blockquote><h3 id="Objects-hash-static-method"><a href="#Objects-hash-static-method" class="headerlink" title="Objects.hash static method"></a>Objects.hash static method</h3><p>The <em>Objects</em> class has a static method that takes an arbitrary number of objects and returns a hash code for them. This method, named <code>hash</code>, lets you write <strong>one-line</strong> hashCode methods whose quality is comparable to those written according to the recipe in this item.</p><p>Unfortunately, they <strong>run more slowly</strong> because they entail array creation to pass a variable number of arguments, as well as boxing and unboxing if any of the arguments are of primitive type. This style of hash function is recommended for use only in situations where <strong>performance is not critical</strong>. </p><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// One-line hashCode method - mediocre performance</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> Objects.hash(lineNum, prefix, areaCode);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Cache-hashCode"><a href="#Cache-hashCode" class="headerlink" title="Cache hashCode"></a>Cache hashCode</h3><p>If a class is <strong>immutable</strong> and the <strong>cost of computing the hash code is significant</strong>, you might consider <strong>caching</strong> the hash code in the object rather than recalculating it each time it is requested.</p><p>If you believe that most objects of this type will be used as <strong>hash keys</strong>, then you should calculate the hash code <strong>when the instance is created</strong>. Otherwise, you might choose to <em><strong>lazily initialize</strong></em> the hash code the first time <em>hashCode</em> is invoked. Some care is required to ensure that the class remains thread-safe in the presence of a lazily initialized field (Item 83).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// hashCode method with lazily initialized cached hash Code</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hashCode; <span class="hljs-comment">// Automatically initialized to 0</span><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> hashCode;<br>  <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>    result = Short.hashCode(areaCode);<br>    result = <span class="hljs-number">31</span> * result + Short.hashCode(prefix);<br>    result = <span class="hljs-number">31</span> * result + Short.hashCOde(lineNum);<br>    hashCode = result;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Note that the initial value for the hashCode field (in this case, 0) should not be the hash code of a commonly created instance:</p></blockquote><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p><strong>Do not be tempted to exclude significant fields from the hash code computation to improve performance.</strong> While the resulting hash function may run faster, its poor quality may degrade hash tables’ performance to the point where they become unusable.</p><p>In particular, the hash function may be confronted with a large collection of instances that differ mainly in regions you’ve chosen to ignore. If this happens, the hash function will map all these instances to a few hash codes, and programs that should run in linear time will instead run in quadratic time.</p></li><li><p><strong>Don’t provide a detailed specification for the value returned by <em>hashCode</em>, so clients can’t reasonably depend on it; this gives you the flexibility to change it.</strong> Many classes in the Java libraries, such as <em>String</em> and <em>Integer</em>, specify the exact value returned by their <em>hashCode</em> method as <em>a function of the instance value</em>. This is <em>not</em> a good idea but a mistake that we’re forced to live with: It impedes the ability to improve the hash function in future releases. If you leave the details unspecified and a flaw is found in the hash function or a better hash function is discovered, you can change it in a subsequent release.</p></li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In summary, you <em>must</em> override <em>hashCode</em> every time you override <em>equals</em>, or your program will not run correctly. Your <em>hashCode</em> method must obey the <strong>general contract specified in <em>Object</em></strong> and must do a reasonable job assigning unequal hash codes to unequal instances. This is easy to achieve, if slightly tedious, using the <strong>recipe</strong>.</p><p>As mentioned in Item 10, the <em><strong>AutoValue</strong></em> framework provides a fine alternative to writing <em>equals</em> and <em>hashCode</em> methods manually, and <em><strong>IDEs</strong></em> also provide some of this functionality.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-12. Always override toString</title>
    <link href="/posts/b017352e.html"/>
    <url>/posts/b017352e.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-12-Always-override-toString"><a href="#Item-12-Always-override-toString" class="headerlink" title="Item 12: Always override toString"></a>Item 12: Always override <em>toString</em></h1><p>While <em>Object</em> provides an implementation of the <em>toString</em> method, the string that it returns is generally not what the user of your class wants to see. It consists of <strong>the class name</strong> followed by an “at” sign (<strong>@</strong>) and the unsigned hexadecimal representation of the <strong>hash code</strong>, for example, <code>PhoneNumber@163b91</code>.</p><p>The general contract for <em>toString</em> says:</p><ul><li>The returned string should be “a <strong>concise but informative</strong> representation that is easy for a person to read.”</li><li>It is recommended that <strong>all subclasses</strong> override this method.</li></ul><p>While it isn’t as critical as obeying the equals and hashCode contracts (Items 10 and 11), <strong>providing a good</strong> <strong>toString</strong> <strong>implementation makes your class much more pleasant to use and makes systems using the class easier to debug</strong>.</p><blockquote><p>The toString method is automatically invoked when an object is passed to <strong>println</strong>, <strong>printf</strong>, the string concatenation operator (<strong>+</strong>), or <em><strong>assert</strong></em>, or is printed by a debugger. </p></blockquote><h2 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h2><p><strong>When practical, the</strong> <strong>toString</strong> <strong>method should return</strong> <strong>all</strong> <strong>of the interesting information contained in the object</strong>. Ideally, the string should be self-explanatory.</p><blockquote><p>It is impractical if the object is large or if it contains state that is not conducive to string representation. Under these circumstances, <em>toString</em> should return a <strong>summary</strong>.</p></blockquote><h2 id="Important-decision"><a href="#Important-decision" class="headerlink" title="Important decision"></a>Important decision</h2><p>One important decision you’ll have to make when implementing a <em>toString</em> method is <strong>whether to specify the format of the return value in the documentation</strong>.</p><p>It is recommended that you do this for <em><strong>value classes</strong></em>, such as phone number or matrix.</p><blockquote><p>If you specify the format, it’s usually a good idea to provide a matching <strong>static factory</strong> or <strong>constructor</strong>, so programmers can easily translate back and forth between the <strong>object</strong> and <strong>its string representation</strong>.</p></blockquote><h3 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h3><p>It serves as a standard, unambiguous, human-readable representation of the object. This representation can be used for input and output and in persistent human-readable data objects, such as CSV files.</p><h3 id="Disadvantage"><a href="#Disadvantage" class="headerlink" title="Disadvantage"></a>Disadvantage</h3><p>Once you’ve specified it, you’re stuck with it for life, assuming your class is widely used. Programmers will write code to parse the representation, to generate it, and to embed it into persistent data. If you change the representation in a future release, you’ll break their code and data, and they will yowl.</p><p>By choosing not to specify a format, you preserve the flexibility to add information or improve the format in a subsequent release.</p><h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><ol><li><p>Whether or not you decide to specify the format, <strong>you should clearly document your intentions.</strong></p><p>If you specify the format, you should do so precisely. Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Returns the string representation of this phone number.</span><br><span class="hljs-comment">* The string consists of twelve characters whose format is</span><br><span class="hljs-comment">* &quot;XXX-YYY-ZZZZ&quot;, where XXX is the area code, YYY is the</span><br><span class="hljs-comment">* prefix, and ZZZZ is the line number. Each of the capital</span><br><span class="hljs-comment">* letters represents a single decimal digit.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* If any of the three parts of this phone number is too small</span><br><span class="hljs-comment">* to fill up its field, the field is padded with leading zeros.</span><br><span class="hljs-comment">* For example, if the value of the line number is 123, the last * four characters of the string representation will be &quot;0123&quot;.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%03d-%03d-%04d&quot;</span>, areaCode, prefix, lineNum);<br>&#125;<br></code></pre></td></tr></table></figure><p>If you decide not to specify a format, the documentation comment should read something like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Returns a brief description of this potion. The exact details * of the representation are unspecified and subject to change, * but the following may be regarded as typical:</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &quot;[Potion #9: type=love, smell=turpentine, look=india ink]&quot;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure></li><li><p>Whether or not you specify the format, <strong>provide programmatic access to the information contained in the value returned by <em>toString</em>.</strong> </p><blockquote><p>For example, the PhoneNumber class should contain accessors for the area code, prefix, and line number.</p></blockquote><p>If you fail to do this, you <em>force</em> programmers who need this information to parse the string. Besides reducing performance and making unnecessary work for programmers, this process is error-prone and results in fragile systems that break if you change the format.</p></li></ol><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><ol><li><p>It <strong>makes no sense</strong> to write a <em>toString</em> method in a <strong>static utility class</strong> (Item 4). Nor should you write a <em>toString</em> method in most <strong>enum types</strong> (Item 34) because Java provides a perfectly good one for you. </p></li><li><p>You <strong>should</strong> write a <em>toString</em> method in <strong>any abstract class whose subclasses share a common string representation</strong>.</p><blockquote><p>For example, the toString methods on most collection implemen- tations are inherited from the abstract collection classes.</p></blockquote></li></ol><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To recap, override <em>Object</em>’s <em>toString</em> implementation in <strong>every instantiable class you write</strong>, unless a superclass has already done so. It makes classes much more pleasant to use and aids in debugging. The <em>toString</em> method should return a concise, useful description of the object, in an aesthetically pleasing format.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-15. Minimize the accessibility of classes and members</title>
    <link href="/posts/7e171cef.html"/>
    <url>/posts/7e171cef.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-15-Minimize-the-accessibility-of-classes-and-members"><a href="#Item-15-Minimize-the-accessibility-of-classes-and-members" class="headerlink" title="Item 15: Minimize the accessibility of classes and members"></a>Item 15: Minimize the accessibility of classes and members</h1><p>The single most important factor that distinguishes a well-designed component from a poorly designed one is the degree to which <strong>the component hides its internal data and other implementation details from other components</strong>.</p><p>A well-designed component <strong>hides all its implementation details, cleanly separating its API from its implementation</strong>. Components then <strong>communicate only through their APIs</strong> and are oblivious to each others’ inner workings. This concept, known as <em>information hiding</em> or <em><strong>encapsulation</strong></em>, is a fundamental tenet of software design.</p><h2 id="The-importance-of-information-hiding"><a href="#The-importance-of-information-hiding" class="headerlink" title="The importance of information hiding"></a>The importance of <em>information hiding</em></h2><ul><li><p>It <em><strong>decouples</strong></em> the components that comprise a system, allowing them to be developed, tested, optimized, used, understood, and modified <strong>in isolation</strong>. This speeds up system development because components can be developed in parallel.</p></li><li><p>It eases the burden of <strong>maintenance</strong> because components can be understood more quickly and debugged or replaced with little fear of harming other components.</p><blockquote><p>Once a system is complete and profiling has determined which components are causing performance problems (Item 67), those components can be optimized without affecting the correctness of others.</p></blockquote></li><li><p>It increases software <strong>reuse</strong> because components that aren’t tightly coupled often prove useful in other contexts besides the ones for which they were developed.</p></li><li><p>It decreases the risk in building large systems because individual components may prove successful even if the system does not.</p></li></ul><h2 id="Approach-to-aid-in-information-hiding-access-control"><a href="#Approach-to-aid-in-information-hiding-access-control" class="headerlink" title="Approach to aid in information hiding - access control"></a>Approach to aid in information hiding - <em>access control</em></h2><p>The <em>access control</em> mechanism specifies the <em>accessibility</em> of classes, interfaces, and members. The accessibility of an entity is determined by the <strong>location of its declaration</strong> and by which, if any, of the <strong>access modifiers</strong> (<code>private</code>, <code>protected</code>, and <code>public</code>) is present on the declaration. Proper use of these modifiers is essential to information hiding.</p><h3 id="Specific-rules-for-classes"><a href="#Specific-rules-for-classes" class="headerlink" title="Specific rules for classes"></a>Specific rules for classes</h3><p>The rule of thumb is simple: <strong>make each class or member as inaccessible as possible.</strong> In other words, <strong>use the lowest possible access level</strong> consistent with the proper functioning of the software that you are writing.</p><p>If a top-level class or interface can be made package-private, it should be. By making it <strong>package-private</strong>, you make it part of the implementation rather than the exported API, and <strong>you can modify it, replace it, or eliminate it in a subsequent release without fear of harming existing clients</strong>. If you make it public, you are obligated to support it forever to maintain compatibility.</p><p>If a package-private top-level class or interface is used by <strong>only one class</strong>, consider making the top-level class <strong>a private static nested class</strong> of the sole class that uses it (Item 24).</p><blockquote><p>But it is far more important to reduce the accessibility of a <strong>gratuitously public class</strong> than of a package-private top-level class: the public class is part of the package’s API, while the package-private top- level class is already part of its implementation.</p></blockquote><h3 id="Specific-rules-for-members"><a href="#Specific-rules-for-members" class="headerlink" title="Specific rules for members"></a>Specific rules for members</h3><p>For members (fields, methods, nested classes, and nested interfaces), there are four possible access levels, listed here in order of increasing accessibility:</p><ul><li><strong>private</strong>—The member is accessible only from the top-level class where it is declared.</li><li><strong>package-private</strong>—The member is accessible from any class in the package where it is declared. Technically known as <em>default</em> access, this is the access level you get if no access modifier is specified (except for interface members, which are public by default).</li><li><strong>protected</strong>—The member is accessible from subclasses of the class where it is declared (subject to a few restrictions [JLS, 6.6.2]) and from any class in the package where it is declared.</li><li><strong>public</strong>—The member is accessible from anywhere.</li></ul><p>After carefully designing your class’s <strong>public API</strong>, your reflex should be to make all other members <strong>private</strong>. Only if another class in the same package really needs to access a member should you remove the private modifier, making the member package-private.</p><blockquote><p>These fields can, however, “leak” into the exported API if the class implements <code>Serializable</code> (Items 86 and 87).</p></blockquote><h4 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h4><p>If a method <strong>overrides a superclass method</strong>, it <strong>cannot</strong> have a <strong>more restrictive access level</strong> in the subclass than in the superclass. This is necessary to ensure that an instance of the subclass is usable anywhere that an instance of the superclass is usable (the <em>Liskov substitution principle</em>).</p><h4 id="Members-of-public-classes"><a href="#Members-of-public-classes" class="headerlink" title="Members of public classes"></a>Members of public classes</h4><p>For members of public classes, a huge increase in accessibility occurs when the access level goes from <strong>package-private</strong> to <strong>protected</strong>. A protected member is part of the class’s exported API and must be supported forever. Also, a protected member of an exported class represents a public commitment to an implementa- tion detail (Item 19). <strong>The need for protected members should be relatively rare.</strong></p><p><strong>Instance fields of public classes should rarely be public</strong> (Item 16). If an instance field is <strong>nonfinal</strong> or is a reference to a mutable object, then by making it public, you <strong>give up the ability to limit the values</strong> that can be stored in the field. Also, you <strong>give up the ability to take any action when the field is modified</strong>, so classes with public mutable fields are <strong>not</strong> generally <strong>thread-safe</strong>.</p><blockquote><p>Even if a field is <strong>final</strong> and refers to an immutable object, by making it public you <strong>give up the flexibility to switch to a new internal data representation</strong> in which the field does not exist.</p></blockquote><h4 id="Array-field"><a href="#Array-field" class="headerlink" title="Array field"></a>Array field</h4><p>Note that a nonzero-length array is always mutable, so <strong>it is wrong for a class to have a public static final array field, or an accessor that returns such a field.</strong> If a class has such a field or accessor, clients will be able to modify the contents of the array. This is a frequent source of security holes:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Potential security hole!</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Things[] VALUES = &#123; ... &#125;;<br></code></pre></td></tr></table></figure><p>Beware of the fact that some IDEs generate accessors that return references to pri- vate array fields, resulting in exactly this problem.</p><h5 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h5><p>You can make the public array private and add a public immutable list:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;Thing&gt; VALUES =<br>    Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));<br></code></pre></td></tr></table></figure><h5 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h5><p>Alternatively, you can make the array private and add a public method that returns a copy of a private array:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Thing[] values() &#123;<br>   <span class="hljs-keyword">return</span> PRIVATE_VALUES.clone();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>As of Java 9, there are two additional, implicit access levels introduced as part of the <em>module system</em>.</p><p>A module may explicitly export some of its packages via <em>export declarations</em> in its <em>module declaration</em> (which is by convention contained in a source file named <code>module-info.java</code>).</p><p>Public and protected members of unexported packages in a module are inaccessible outside the module; within the module, accessibility is unaffected by export declarations. Using the module system allows you to <strong>share classes among packages within a module without making them visible to the entire world</strong>.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>To summarize, you should reduce accessibility of program elements as much as possible (within reason).</p><p>After carefully designing a <strong>minimal public API</strong>, you should prevent any stray classes, interfaces, or members from becoming part of the API.</p><p>With the exception of public static final fields (which serve as constants), <strong>public classes should have no public fields</strong>. Ensure that objects referenced by public static final fields are immutable.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IoC容器</title>
    <link href="/posts/d653de15.html"/>
    <url>/posts/d653de15.html</url>
    
    <content type="html"><![CDATA[<h1 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h1><h2 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h2><p>容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。</p><p>Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。</p><h2 id="IoC原理"><a href="#IoC原理" class="headerlink" title="IoC原理"></a>IoC原理</h2><p>IoC全称Inversion of Control，直译为控制反转。</p><p>如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。</p><p>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。</p><p>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制。</p><p>不直接<code>new</code>一个<code>DataSource</code>，而是注入一个<code>DataSource</code>，这个小小的改动虽然简单，却带来了一系列好处：</p><ol><li><code>BookService</code>不再关心如何创建<code>DataSource</code>，因此，不必编写读取数据库配置之类的代码；</li><li><code>DataSource</code>实例被注入到<code>BookService</code>，同样也可以注入到<code>UserService</code>，因此，共享一个组件非常简单；</li><li>测试<code>BookService</code>更容易，因为注入的是<code>DataSource</code>，可以使用内存数据库，而不是真实的MySQL配置。</li></ol><blockquote><p>因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。</p></blockquote><p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;HikariDataSource&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;BookService&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;UserService&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为<code>dataSource</code>的组件通过属性<code>dataSource</code>（即调用<code>setDataSource()</code>方法）注入到另外两个组件中。</p><p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</p><h2 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h2><p>Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。</p><h3 id="1-set"><a href="#1-set" class="headerlink" title="1. set()"></a>1. set()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookService</span> &#123;<br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDataSource</span><span class="hljs-params">(DataSource dataSource)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dataSource = dataSource;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookService</span> &#123;<br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BookService</span><span class="hljs-params">(DataSource dataSource)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dataSource = dataSource;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无侵入容器"><a href="#无侵入容器" class="headerlink" title="无侵入容器"></a>无侵入容器</h2><p>在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：</p><ol><li>应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；</li><li>测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1282381977747489">https://www.liaoxuefeng.com/wiki/1252599548343744/1282381977747489</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>backend</category>
      
      <category>Spring</category>
      
      <category>IoC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浪潮之巅读书笔记3-苹果与微软</title>
    <link href="/posts/3250a264.html"/>
    <url>/posts/3250a264.html</url>
    
    <content type="html"><![CDATA[<h1 id="Apple"><a href="#Apple" class="headerlink" title="Apple"></a>Apple</h1><h2 id="大事记"><a href="#大事记" class="headerlink" title="大事记"></a>大事记</h2><p>1976 苹果计算机公司成立，推出Apple I个人电脑。</p><p>1977 推出第一款系列个人电脑Apple II。</p><p>1984 推出采用图像视窗界面操作系统的麦金托什(Macintosh)电脑。</p><p>1985 乔布斯和新CEO斯卡利开始权力斗争，前者失败离开苹果公司。</p><p>1994 苹果告微软的视窗操作系统抄袭麦金托什操作系统，官司最终和解。</p><p>1997 乔布斯以顾问的身份回到苹果公司，经过权力斗争，1997年9月接管了多年亏损的公司;同年，与微软的官司以微软注资苹果而得到和解。</p><p>1998 iMac诞生，苹果重新盈利。</p><p>2001 iPod诞生，颠覆了音乐产业。</p><p>2007 iPhone诞生，颠覆了整个手机行业。</p><p>2010 iPad诞生，同年苹果公司的市值再次超过微软，成为全球最值钱的IT公司。</p><p>2011 苹果创始人乔布斯去世，此前，他将CEO一职交给了蒂姆·库克，同年苹果超过埃克森美孚石油公司，成为全球市值最高的公司。</p><p>2015 苹果公司推出智能手表Apple Watch。</p><p>2018 苹果公司的市值一度突破1万亿美元，成为有史以来第一个达到这个市值规模的西方公司。</p><h2 id="苹果的发展"><a href="#苹果的发展" class="headerlink" title="苹果的发展"></a>苹果的发展</h2><h3 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h3><p>麦金托什是世界上第一款普通老百姓买得起、拥有交互式图形界面并且使用鼠标的个人电脑。</p><p>但苹果走了一条封闭的道路，不允许别人制造兼容机，后来导致市场越来越小。但苹果将计就计，走高端产品路线，避免了与微软、戴尔和惠普的正面竞争。慢慢地，苹果的产品成了时尚的象征。</p><blockquote><p>不过乔布斯后来在苹果电脑中逐渐采用了英特尔的通用处理器，同时采用FreeBSD作为新的苹果操作系统内核。用相对开放的体系吸引全社会大量有兴趣的开源工程师，让他们能很容易地为苹果开发软件。</p></blockquote><h3 id="iPod"><a href="#iPod" class="headerlink" title="iPod"></a>iPod</h3><p>上个世纪最后10年，以互联网和多媒体技术为核心的一场技术革命开始了。随着声音和图像压缩技术的出现，数字化了的音乐和录像很容易在互联网上传播。同时，市场上出现了一些小型音乐播放器。</p><p>乔布斯看到了两点最重要的事实:</p><ul><li><p>第一，虽然已经有了不少音乐播放器，但是做得都不好，尤其是在音乐数量多了以后，查找和管理都很难。从一千首歌里面顺序找到自己想听的可能要花几分钟时间。另外，要将几十张CD上的歌曲导到播放器上更是麻烦。</p><p>解决：</p><ul><li>2000年3月，苹果公司收购SoundJam，在此基础上开发了iTunes软件，并于2001年1月发布。</li><li>2001年10月，苹果公司又推出了iPod音乐播放器，并在次年发布的第二代iPod上采用了手转圈划动查找音乐的方法，用户很快就能找到自己要听的歌曲。</li><li>同时，iTunes可与iPod无缝对接，自动将电脑和光盘上的音乐传到iPod中。</li><li>另外，iPod充电一次，播放时长可达10小时，比以往的各种播放器都要长得多。苹果iPod的外观设计非常漂亮，一经推出，就俘获了大批爱听音乐的年轻人。</li></ul></li><li><p>第二，广大用户已经习惯戴着耳机从播放器中听歌而不是随身带着便携的CD唱机和几十张光盘。因此，它不需要花钱和时间培养出一个市场。</p></li></ul><h3 id="iPhone"><a href="#iPhone" class="headerlink" title="iPhone"></a>iPhone</h3><p>iPod彻底改变了音乐市场，而iPhone继而颠覆了通信行业。制造手机本来是摩托罗拉和诺基亚这些公司的事情，和计算机公司似乎无关。但是随着手机中信号处理的重要性逐渐下降，或者说这些技术难点已经不存在了，打电话的功能在逐渐淡化；性能的要求、上网的需求在上升，智能手机制造商开始崛起。最早的智能手机代表是黑莓手机(Blackberry)，制造该手机的RIM公司一度垄断了智能手机市场，接下来是诺基亚。它们的智能手机基本上还没有摆脱传统手机的框框，手机加上E-mail的功能，只是比传统的手机好用些。</p><p>但是，智能手机到了乔布斯的手里，就完全不同了。它已经超出一个普通手机加iPod播放器，它还具有一个完整的、联网的计算机和一般电视机的主要功能。</p><h3 id="iPad"><a href="#iPad" class="headerlink" title="iPad"></a>iPad</h3><p>2010年，苹果公司又推出了极具人气的iPad触摸型平板电脑，可以通过触摸输入文字和指令来上网或使用各种应用软件，对PC产业同样具有颠覆性，是颠覆整个PC工业生态链(WinTel体系)的重要一环。</p><p>从功能上讲，iPad可以替代90%，甚至更多我们对个人电脑的需求。而且，iPad方便易用，在大多数场合，我们更倾向于使用iPad，而不是台式计算机甚至笔记本电脑。</p><h3 id="最近"><a href="#最近" class="headerlink" title="最近"></a>最近</h3><p>乔布斯去世后苹果真正自主发布的第一款产品新 iPad(即iPad 3)的销路并不是很好，2012年，苹果公司在美国以半价回购iPad 2，希望对新版iPad销售有所提振。iPad 3的优点不如大家想象的明显，但是使用起来明显烫手这个产品缺陷，乔布斯还在世的话是一定不会允许出现的。</p><p>从2010年开始，外界就在期待苹果公司能推出可穿戴式设备—一智能手表，竞争对手也都先后推出了各种各样的智能手表。直到2015年，苹果才推出市场反应并不算良好的Apple Watch，但至今它都没有能够成为该公司主要的收入增长点。</p><p>此后，苹果一直在靠每年翻新一次苹果手机挣老用户的钱。今天，苹果依然是全球市值最高的公司之一，但是它不断推出新产品的黄金期已经过去了。</p><h2 id="乔布斯与盛田昭夫"><a href="#乔布斯与盛田昭夫" class="headerlink" title="乔布斯与盛田昭夫"></a>乔布斯与盛田昭夫</h2><p>乔布斯退学后，继续在学校旁听自己感兴趣的课，比如书法课。事实证明，乔布斯的艺术修养使得苹果公司所有的产品都设计得非常漂亮。比如 Macintosh 计算机漂亮的界面和字体。</p><p>上个世纪八九十年代，工作站很红火，乔布斯在被逐出苹果公司后创立了一家设计制造工作站的公司NeXT，不是很成功。1986年，乔布斯用500万美元买下了电影《星球大战》导演卢卡斯创办的一个极不成功的动画制作室，将它重构成一个用图形工作站做动画的工作室Pixar公司，这是今天世界上最好的动画工作室，后来被迪士尼公司以74亿美元的高价收购。乔布斯从Pixar挣到的钱比他从苹果挣到的还多。</p><p>苹果的每一款产品都非它的原创，但是，苹果把每一款产品做到了极致，这很大程度上是因为乔布斯达到了一个将技术和艺术结合得炉火纯青的境界。</p><p>“当键盘越变越好用的时候，乔布斯想要的却是另一个东西:只有屏幕，没有键盘的电脑”。这些想法导致了后来的麦金托什和iPad。可见乔布斯这些改变世界的发明绝非一时的灵感所致，而是数十年的深思熟虑和经验的积累。</p><p>当第一次看到CD的时候，乔布斯拿起一张，里面也就只存5首歌。他把CD插进硕大的播放器，回来后穿过董事会的桌子，对大家说，看，这个东西会成为未来！那个年代，他已经在琢磨里面的内容(音乐)意味着什么。<strong>他的远见，经常穿透时间，直接看到他想象中的结果。</strong>从现在看，也是乔布斯，通过他的产品iPod，一手把CD送往终点。从见到CD到iPod问世，又是20年的时间，看似是灵机一动，岂不知已经孕育了两个十年。</p><p>乔布斯安在洛斯加托斯的家，是一座很大的西班牙式建筑。院子里停着一辆黑色的宝马自行车(他极少碰那辆车，只是喜欢它的设计)，偌大的房间里，只有餐桌和旁边的两把椅子，加上客厅里的一架白色的Bösendorfer三角钢琴。房间里面空空荡荡，因为对产品品质格外偏执的乔布斯几乎看不上任何家具。这就是他生活的样子，简单，少量，专注。</p><p>而盛田昭夫是上个世纪70年代的乔布斯。或者说乔布斯是21世纪初期的盛田昭夫。</p><p>在苹果进入i十年以前，索尼公司在电子产品上的地位和今天的苹果相当，这在很大程度上是盛田昭夫的功劳。作为优秀的产品设计者，盛田昭夫直接领导了Walkman随声听的设计和开发，这款听音乐的产品当时在世界上的轰动效应完全抵得上后来的iPod。</p><p>作为领导者的盛田昭夫，是少有的能够和西方人无隔阂沟通的东方人，兼具东方式的文雅谦和与西方式的坦诚直白，打动了许多西方的企业家和政治家。在盛田昭夫的努力下，索尼不仅成为日本第一个被全球认可，同时在美国上市的公司，而且把索尼从一个简单的日本制造的公司变成引领全球电子产品时尚的跨国公司。</p><p>乔布斯和盛田昭夫有很多相似之处。首先，两个人都有着<strong>通过产品改变人们生活</strong>的远大抱负。两个人又都有着无穷的好奇心和与凡人不同的新思维，导致两家公司不断推出出众而广为人知的新产品。两个人都将品牌视为生命，乔布斯对产品品质的执著和苛刻自不必说，而盛田昭夫一生为“让索尼享誉全球”而工作。</p><p>盛田昭夫和乔布斯另一个有趣的相似之处是都不看重学历。乔布斯自己辍学不必说了，盛田昭夫虽然是大阪大学的毕业生，但是在用人上一直强调注重个人能力而非学业背景。他还为此写了一本《学历无用论》的书，从上个世纪60年代起多次再版，成为畅销书。</p><p>另一方面，乔布斯和盛田昭夫的经历和为人又有很大的不同。盛田昭夫作为家族企业盛田酒业原本的继承人，虽然经历了二战后的贫困，但作为社会上层人士，给人留下的总是积极向上的活力和可亲品行。乔布斯是个被遗弃的孤儿，从小品行乖张，同时对别人缺乏信任。盛田昭夫和他的合作伙伴、索尼的另一位创始人井深大一辈子兄弟般的友谊一直被业界誉为美谈。</p><h2 id="摘抄与思考"><a href="#摘抄与思考" class="headerlink" title="摘抄与思考"></a>摘抄与思考</h2><p>关于股票期权制度：在传统的公司里，一个员工的薪酬福利包括奖金和退休金等现金。一般员工并不拥有公司的一部分。很多高科技公司为了将员工的利益和公司的前途绑在一起，发给员工一些股票的期权。所谓期权(Option)就是在一定时间，比如十年内，按一定价格，比如当前市场价购买股票的权利。获得期权的员工，会对公司有主人翁般的责任感。如果公司股价上涨，那么拥有股票期权的人可以以过去较低的价格买进股票，即所谓的行权(Exercise)，然后以现在较高的价格卖出，从中赚到差价。当然，期权只有在公司股价不断上涨时才有意义。</p><p>在乔布斯做的大多数“改变世界”的事情中，原创并非他自己，但是拿着魔术棒“点石成金”的人却是他。如果我们承认乔布斯的创作力，那么创新就远不止是原创，而更多的是发现价值，点石成金。</p><p>大多数产品经理之所以做不出改变世界的产品，是因为他们只看见了成功者最后的临门一脚，而忽视了别人的长期思考。</p><p>永远渴望，大智若愚。 Stay Hungry, Stay Foolish.</p>]]></content>
    
    
    <categories>
      
      <category>book notes</category>
      
      <category>浪潮之巅</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浪潮之巅读书笔记4-信息产业的发展规律</title>
    <link href="/posts/ca3ef48c.html"/>
    <url>/posts/ca3ef48c.html</url>
    
    <content type="html"><![CDATA[<h1 id="信息产业的生态链"><a href="#信息产业的生态链" class="headerlink" title="信息产业的生态链"></a>信息产业的生态链</h1><h2 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h2><p>计算机和整个IT行业的发展比传统工业要快得多。比尔·盖茨说，如果汽车工业能够像计算机领域一样发展，那么今天，买一辆汽车只需要25美元，一升汽油能跑400公里。</p><p>英特尔公司的创始人戈登·摩尔(Gordon Moore) 博士最早看到了这个现象。在1965年，他就提出，至多在10年内，集成电路的集成度会每两年翻一番。后来，大家把这个周期缩短到18个月。</p><p>当今世界经济的前五大行业，即<strong>金融、IT(包括电信)、医疗和制药、能源及日用消费品</strong>，只有IT一个行业能够以持续翻番的速度进步。在人类文明史上，还没有任何其他行业能够做到这一点。</p><p>和任何其他商品相比，制造IT产品所需的原材料非常少，成本几乎是零。IT行业硬件的成本主要是<strong>制造设备的成本和研发成本</strong>。</p><h3 id="摩尔定律主导着IT行业的发展"><a href="#摩尔定律主导着IT行业的发展" class="headerlink" title="摩尔定律主导着IT行业的发展"></a>摩尔定律主导着IT行业的发展</h3><p><strong>首先，为了不断提升芯片性能，IT公司必须在比较短的时间内完成下一代产品的开发。这</strong>就要求IT公司在研发上必须投入大量的资金，这使得每个产品的市场都不会有太多的竞争者。</p><blockquote><p>在美国，主要IT市场大都只有一大一小两个主要竞争者。比如，在计算机处理器芯片方面，只有英特尔和AMD两家;在高性能图形处理器(GPU)方面，只有英伟达一家;在手机处理器方面，只有高通(Qualcomm)、三星、苹果和华为旗下的海思这几家(后两家只自用，不外卖)，而它们使用的都还是ARM公司设计好的系统结构。</p></blockquote><p><strong>其次，由于有了强有力的硬件支持，以前想都不敢想的应用会不断涌现。</strong></p><blockquote><p>比如，20多年前，将高清晰度电影(1920×1080分辨率)数字化的计算量连IBM的大型机也无法胜任;现在，一台笔记本大小的索尼游戏机就可以做到，而新的一代电视机则能播放4K(即4000线的分辨率)的视频节目了。</p><p>这就为一些新兴公司的诞生创造了条件。比如，在2000年以前，不会有人想办一家YouTube这样的公司，因为那时候网络的速度无法满足在网上看录像的要求，而现在YouTube已经融入了许多人的生活。</p></blockquote><p><strong>第三，摩尔定律使得各个公司现在的研发必须针对多年后的市场。</strong></p><blockquote><p>在 Google内部，每一次基础架构(Infrastructure)的升级，都要按照目前计算能力和存储量的10倍来设计，因为达到那个水平，不过是三四年的时间，这在传统行业是无法想象的。</p></blockquote><p>从1965年到2019年，摩尔定律历经了半个多世纪的时光。在未来的20年里，工程师们考虑的将是在<strong>单位能耗</strong>的基础上争取让处理器的性能和容量翻番，而不是简单地追求每一颗芯片本身性能的翻番。</p><blockquote><p>英伟达和Google的人工智能芯片就是很好的例子，它们在机器学习等领域可以将单位能耗的计算能力提高近千倍。与50年前不同的是，今天各种处理器无所不在，它们消耗了大量的能源，而在50年前，半导体芯片耗能总量在全球能源消耗中的占比非常低。因此，在未来我们依然能看到摩尔定律给我们带来的惊喜。</p></blockquote><h2 id="安迪-比尔定律"><a href="#安迪-比尔定律" class="headerlink" title="安迪 - 比尔定律"></a>安迪 - 比尔定律</h2><p>摩尔定律给所有的计算机消费者带来一个希望，即如果我今天嫌计算机太贵买不起，那么我等18个月就可以用一半的价钱来买。要真是这么简单的话，计算机的销售量就上不去了。想要买计算机的人会多等几个月，已经有计算机的人也没有动力更新计算机。其他的IT产品也将是如此。IT行业也就成了传统行业，没有什么发展了。</p><p>是什么动力促使人们不断地主动更新自己的硬件呢？IT界把它总结成安迪–比尔定律，它的原话是“比尔要拿走安迪所给的 (<strong>What Andy gives， Bill takes away.</strong>)。”</p><blockquote><p>安迪是英特尔公司已故的带有传奇色彩的CEO安迪·格鲁夫 (Andy Grove)，而比尔是微软公司创始人比尔·盖茨。</p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在过去的40多年里，英特尔处理器的处理速度每18个月翻一番，计算机内存和硬盘的容量则以更快的速度增长。但是，微软的操作系统和应用软件却越来越慢，也越做越大。所以，现在的计算机虽然比10年前快了100倍，软件的运行速度感觉上还是和以前差不多。</p><p>为什么操作系统和应用软件越做越大？是因为现在的软件开发人员不再像二三十年前那样精打细算了。用汇编语言编程，工作效率是极低的，而且写出来的程序可读性很差，不符合软件工程的要求，也无法完成越来越复杂的功能。今天，有了足够的硬件资源，软件工程师做事情更讲究开发效率、程序的规范化和可读性，等等。</p><blockquote><p>另外，由于人工成本的提高，为了节省软件工程师编写和调试程序的时间，编程语言越来越好用，同时执行效率却越来越低。比如，今天的那些脚本语言比十年前用的Java效率低得多，Java则比C++效率低得多，C++又比30多年前的C效率低。因此，即使是同样功能的软件，今天的比昨天的占用硬件资源多就在所难免。</p></blockquote><h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p>虽然用户很是反感新的软件把硬件提升所带来的好处几乎全部用光了，但是在IT领域，各个硬件厂商恰恰是靠软件开发商用光自己提供的硬件资源得以生存的。</p><h4 id="PC时代产业格局：WinTel"><a href="#PC时代产业格局：WinTel" class="headerlink" title="PC时代产业格局：WinTel"></a>PC时代产业格局：WinTel</h4><p><strong>个人电脑工业的整个生态链</strong>：以微软为首的软件开发商吃掉硬件提升带来的全部好处，迫使用户更新机器，让惠普和戴尔等公司受益，而这些PC厂商再向英特尔等半导体公司订购新的芯片，同时向希捷等外设厂商购买新的外设。</p><blockquote><p>软件开发商-&gt;PC厂商-&gt;芯片厂商&amp;外设厂商</p></blockquote><p>在安迪–比尔定律中，“安迪”像是个天使，他总在不断给用户更多的东西，而“比尔”则像是个魔鬼，总和大家做对。但是，如果比尔这个魔鬼消失了，安迪就不复存在了。</p><p>从2011年开始，由于个人电脑产业受到移动智能设备的冲击而不再景气，软件厂商在PC上更新旧软件和开发新软件的动力就不足。在人们通常的想象中，如果软件不再占用更多的资源，硬件还在进步，我们应该感到计算机越来越快，越来越好用才对，但这件事情并没有发生。</p><p>个人电脑进步慢，是因为它性能的提升压力减小了。在Windows 7之后，微软在PC上也没有做出什么新产品，用了几十年的 Office功能和过去还是差不多。这样一来，英特尔就不再重视个人电脑处理器性能的提升了，它在这方面主要是做改进工作，然后将科研的重点转到了服务器的处理器以及其他产品上了。</p><blockquote><p>在IT工业的产业链中，处于上游的是“看不见摸不着”的软件和IT服务业，而下游才是“看得见摸得着”的硬件和半导体。因此，从事IT业，<strong>要想获得高额利润，就得从上游入手</strong>。从微软，到Google，再到Facebook，无不如此。唯一的例外是苹果公司，它是通过硬件实现软件的价值，因为在过去10多年里它的产品已经成为了一种时尚和潮流。</p></blockquote><h4 id="智能手机时代产业格局：Android-ARM"><a href="#智能手机时代产业格局：Android-ARM" class="headerlink" title="智能手机时代产业格局：Android-ARM"></a>智能手机时代产业格局：Android-ARM</h4><p>有趣的是，在手机领域，魔鬼比尔还存在，天使安迪不得不努力工作，于是十多年下来此消彼长，今天手机的很多功能，特别是图像处理功能，已经超过了PC。</p><p>2007年，Google成立了安卓(Android)联盟，它包括世界上一大半处理器芯片制造商、手机厂商和移动运营商，其核心是围绕开源的安卓手机操作系统，打造一个开放而兼容的移动通信产业。</p><p>很快一个类似于当年WinTel的格局就形成了。只不过起到当年微软 Windows作用的是Google的<strong>Android</strong>，而高通、博通和美满电子这一大两小的基于 <strong>ARM</strong> (Advanced RISC Machine)的手机芯片公司起到了当年英特尔和AMD的作用。这个格局可以描述成 Android-ARM，甚至可以简单地把它看成是2.0版的安迪–比尔定律。</p><blockquote><p>随后三星和海思(华为的半导体子公司)取代了博通和美满电子，小米、华为和OPPO &#x2F;vivo在手机市场分到了一杯羹。</p></blockquote><h2 id="反摩尔定律"><a href="#反摩尔定律" class="headerlink" title="反摩尔定律"></a>反摩尔定律</h2><p>Google前CEO埃里克·施密特(Eric Schmidt)在一次采访中指出，如果你反过来看摩尔定律，<strong>一个IT公司如果今天和18个月前卖掉同样多的、同样的产品，它的营业额就要降一半</strong>。</p><h3 id="消极影响"><a href="#消极影响" class="headerlink" title="消极影响"></a>消极影响</h3><p>对于IT公司而言，反摩尔定律是非常可怕的，因为一个IT公司付出同样的劳动，却只得到以前一半的收入。<strong>反摩尔定律逼着所有的硬件设备公司都必须赶上摩尔定律规定的更新速度</strong>。事实上，所有的硬件和设备生产商活得都非常辛苦。</p><h3 id="积极影响"><a href="#积极影响" class="headerlink" title="积极影响"></a>积极影响</h3><p><strong>它促成了科技领域质的进步，并为新兴公司提供生存和发展的可能。</strong></p><p>和所有事物的发展一样，IT领域的技术进步也有量变和质变两种。比如说，同一种处理器在系统结构上没有太大变化，而只是主频提高了，这种进步就是量变的进步。当处理器由16位上升到32位，再到64位时，就有了小的质变。如果哪一天能用到纳米技术或生物技术，那么就做到了质的飞跃，半导体的集成度会有上百倍的提高。为了赶上摩尔定律预测的发展速度，光靠量变是不够的。每一种技术，过不了多少年，量变的潜力就会被挖掘光，这时就必须要有革命性的创造发明诞生。</p><p>在科技进步<strong>量变的过程中，新的小公司是无法和老的大公司竞争的</strong>，因为后者在老的技术方面拥有无与伦比的优势。</p><blockquote><p>比如，木工厂出身的诺基亚在老式模拟手机上是无法和传统的通信设备老大摩托罗拉竞争的。</p></blockquote><p>但是，在<strong>抓住质变的机遇上，有些小公司会做得比大公司更好而后来居上</strong>，因为它们没有包袱，也比大公司灵活。</p><blockquote><p>2015年后，当3G手机逐步取代2G手机时，PC时代不起眼的三星公司一跃成为全球最大的智能手机厂商，而过去没有做过手机的华为，以前默默无闻的小米和OPPO&#x2F;vivo也及时踏上安卓的快船。苹果和众多安卓手机厂商把诺基亚这个2G时代的龙头老大逼上了当年摩托罗拉的老路。这也是硅谷等新兴地区出现了众多新技术公司的原因。</p></blockquote><blockquote><p>数字电话传输率本身限制在64kbit&#x2F;s，因此调制解调器的传输率最大到56kbit&#x2F;s就到顶了。但是，到了上个世纪90年代后期，出现了DSL技术，可以将电话线上的数据传输速度提高近200倍，斯坦福大学的约翰·查菲教授带着自己的几个学生，办起了一家做DSL的小公司Amati，之后以4亿美元的高价把Amati公司卖给了德州仪器。在调制解调器发展的量变阶段，不会出现Amati这样的小公司，即使出现了，也无法和德州仪器竞争。但是，一旦调制解调器速度接近原有的极限，能够突破这个极限的新兴公司就有机会登上历史的舞台。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>book notes</category>
      
      <category>浪潮之巅</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浪潮之巅读书笔记2-硅谷</title>
    <link href="/posts/e4aa2245.html"/>
    <url>/posts/e4aa2245.html</url>
    
    <content type="html"><![CDATA[<h1 id="“八叛徒”与硅谷"><a href="#“八叛徒”与硅谷" class="headerlink" title="“八叛徒”与硅谷"></a>“八叛徒”与硅谷</h1><h2 id="肖克利半导体公司"><a href="#肖克利半导体公司" class="headerlink" title="肖克利半导体公司"></a>肖克利半导体公司</h2><p>1947年，肖克利发现了半导体P-N结的单向导电等诸多特性，并利用这一原理发明了晶体管。同 时巴丁和布拉顿也发现了一种三极管。从此，人类进人半导体时代。这三名科学家后来获得了诺贝尔物理学奖，那也是贝尔实验室所获得的众多诺贝尔奖中的第一个。</p><p>1956年，肖克利搬到加州的山景城，以便照顾住在帕洛阿尔托乡下的母亲。他的朋友贝克曼出资，肖克利在加州办起了自己的实验室一一肖克利半导体实验室(Shockley Semiconductor Laboratory)，专门研制和生产肖克利所发明的半导体。</p><p>他主动打电话邀请了诺伊斯和摩尔等英才加入，而大家愿意追随他，完全是出于对这位大发明家的崇拜，对这一点，后来发明集成电路的诺伊斯讲得很清楚。</p><p>肖克利是个非常有个性的科学家，很难共事，贝尔实验室的同事都知道他的这一不足之处，以至于大家不愿意跟随他创业。公司办到第二年，摩尔等七人实在忍受不了肖克利的独裁作风，打算集体“叛逃”，在“叛逃”之前他们去劝说公司的二号人物诺伊斯和他们一起走。出乎他们的意料，诺伊斯马上爽快地答应了，因为他也在肖克利手底下受够了。</p><h2 id="仙童公司"><a href="#仙童公司" class="headerlink" title="仙童公司"></a>仙童公司</h2><h3 id="“八叛徒”"><a href="#“八叛徒”" class="headerlink" title="“八叛徒”"></a>“八叛徒”</h3><p>诺伊斯和摩尔等人准备离开肖克利的公司另起炉灶单干，但是却没有资金。如果放在今天，以他们八个人的水平，很容易找到风险投资。但是在1957年，今天意义上的风险投资并不存在，融资并不容易。</p><p>阿瑟·洛克(Arthur Rock)和老板科伊尔(Alfred Coyle)对新兴的半导体很有兴趣，于是说服了自己的，两人一起来到旧金山和诺伊斯等人会面。在听了这八个人对未来将要开始的一场电子工业革命的描述后，洛克和科伊尔动了心。</p><blockquote><p>不过，由于来得匆忙，洛克和科伊尔根本没有准备合同，甚至没有带办公用纸，所幸的是科伊尔脑子转得很快，当即掏出10张一美元的钞票，放在桌子上。”接下来，信息行业伟大的时刻来到了，诺伊斯、摩尔、洛克和科伊尔等10人分别在这10张钞票上签了名。这10张钞票后来很多已经丢失，但其中的一张保存在斯坦福大学图书馆里，成为硅谷诞生的历史见证。</p></blockquote><p>IBM当时最大的股东菲尔柴尔德家族愿意投资半导体技术。在说服菲尔柴尔德的过程中，诺伊斯是这样形容未来的半导体产业的一一这些本质上是沙子和金属导线的基本物质将使未来晶体管材料的成本趋近于零，于是竞争将转向制造工艺，如果菲尔柴尔德投资，他将赢得这场竞争。届时，廉价的晶体管将使得消费电子产品的成本急剧下降，以至于制造它们比修理它们更便宜。</p><p>八个人委托洛克设计了未来公司的股权结构：公司分为1325股，诺伊斯等人每人100股，洛克和科伊尔所在的海登–斯通投资公司(Hayden， Stone &amp; Co.)占225股，剩下300股留给公司日后的管理层和员工。菲尔柴尔德给即将成立的公司一笔138万美元的18个月贷款，作为回报条件，他虽然不占股，但是拥有对公司的决策权(投票权)，并目有权在8年内的任何时间以300万美元的价格收购所有股份。</p><p>1957年9月18日，他们八人向肖克利提交了辞职报告，这一天后来被《纽约时报》称为人类历史上10个最重要的日子之一，因为他们将创办一个伟大的公司，开创一个巨大的产业。但是，这对肖克利来讲却是无法忍受的。肖克利当时大怒，称他们为“八叛徒”(Traitorous Eight) ，因为在肖克利这位旧式科学家看来，他们的行为不同于一般的辞职，而是学生背叛老师。在加入公司之前，这八个人除了诺伊斯有一些晶体管的研究经验外，其他人都是在他的指导下才掌握了晶体管技术，因此在他看来这如同欺师灭祖。</p><h3 id="蒸蒸日上"><a href="#蒸蒸日上" class="headerlink" title="蒸蒸日上"></a>蒸蒸日上</h3><p>由于技术先进以及菲尔柴尔德和IBM的关系，仙童拿到了大量晶体管合同，确立了它在世界半导体行业的领先地位。</p><p>1959年，菲尔柴尔德根据协议回购了全部的股份。诺伊斯等每人大约获得了25万美元，这在当时是相当大的一笔钱，抵得上他们半辈子的工资。</p><blockquote><p>不过没有了公司股权，诺伊斯等人最终是要和菲尔柴尔德分手的，只不过当时公司快速发展，业绩掩盖了一切潜在的矛盾。</p></blockquote><h3 id="集成电路"><a href="#集成电路" class="headerlink" title="集成电路"></a>集成电路</h3><p>当时用来制造晶体管的半导体锗容易破碎，而目热稳定性较差。为了解决这个问题，诺伊斯等人就尝试用非常结实的硅来取代锗。相比锗，硅太硬，不好加工。最后霍尔尼的小组发明了一种平面工艺，可以将硅加工成晶体管。使用这种工艺，仙童公司制造出很可靠的硅三极管，而且成本下降很多。</p><blockquote><p>步骤：</p><ol><li>将设计好的晶体管内部的电路拍照</li><li>复制很多份，铺在一个平面上</li><li>把硅片放到底版(阻光膜)下面，用光照在上面进行光刻。这样就在硅片上一次刻出很多个三极管</li><li>把刻好的一个个三极管切割下来进行封装</li></ol></blockquote><p>1958年，诺伊斯从霍尔尼的平面工艺中受到启发。他在想，与其把一个个晶体管的硅片切割下来，让生产线上的女工们用细小的镊子在放大镜下装上导线，封装成一个个晶体管成品，最后等到制造电子设备时再将一个个晶体管焊到电路板上，还不如将电子设备的所有电路和一个个元件都制成底版，然后刻在一个硅片上。就这样，诺伊斯发明了集成电路。</p><p>集成电路的发明改变了世界。和过去的分立元件电路相比，集成电路不仅体积小，重量轻，可靠性高，而目它的性能可以呈指数提升(即摩尔定律)。</p><h3 id="不断拆分"><a href="#不断拆分" class="headerlink" title="不断拆分"></a>不断拆分</h3><p>早在1959年，当仙童公司的投资人菲尔柴尔德收回公司股权之后，总经理(当时还不习惯于使用CEO一词)爱德华·鲍德温(Edward Baldwin) 就带领八名员工创办了自己的半导体公司Rheem，Rheem也成为仙童公司下出的第一枚“金蛋”。</p><p>当鲍德温等人离开仙童后，不断有人也离开仙童出去创业，而诺伊斯也不断吸引新的人才加入，这种进出的平衡维持了一段时间，终于随着一位重量级创始人的离开而打破，这个人就是“八叛徒”之一的拉斯特。不过，拉斯特等人的离开虽然让仙童公司损失巨大，却也促成了该公司所在的旧金山湾区整个地区半导体产业的发展。后来这个地区便成长为今天人们熟知的硅谷。</p><p>在诺伊斯等人发明了集成电路之后的头两年里，集成电路的制造成本比较高，以至于放弃掉原有的晶体管业务单独发展集成电路是无法挣钱的。仙童的老板菲尔柴尔德和公司内的高管在公司的业务上就发生了严重的分歧。以“八叛徒”之一的拉斯特为代表的一部分经理认为应该优先发展集成电路，并且在做新的一年的预算时，提出应该优先建一个制造集成电路的工厂。而菲尔柴尔德则认为应该优先制造当时技术成熟市场需求更大的晶体管，并且首先将钱用于扩大晶体管的产能。1961年，拉斯特拉上“八叛徒”中的霍尔尼和罗伯茨在洛克和Teledyne公司的支持下创办了Amelco半导体公司。Amelco和它的母公司Teledyne很快成为了美国军方(包括航天工业)重要的半导体器件提供商，并且直接和仙童公司竞争。</p><p>1968年，诺伊斯和摩尔希望发展超大规模集成电路，即将过去很多小规模的集成电路集成到一个芯片中，这样对顾客有很大的好处，而作为公司老板的菲尔柴尔德则希望多卖芯片。如果将十个芯片减少为一个芯片，仙童公司短期内的收入必然会减少。最终，诺伊斯和摩尔发现在这家他们创办的公司中，两人已经没有发言权了，就干脆离开仙童，创办了一家新的半导体公司——英特尔公司。</p><p>就在诺伊斯和摩尔离开仙童之后，“八叛徒”中的另外两个人格里尼克和布兰克也陆续离开了，至此，仙童公司的传奇画上了句号。它对世界半导体产业的影响力就此结束，一个时代终结了。</p><p>仙童公司成就半导体产业的做法听起来匪夷所思，它并非靠自身发明了多少产品，创造了多大的市场，而是靠不断地分离出子公司和孙公司，让半导体公司在旧金山湾区遍地开花。截止到2017年，从仙童公司直接和间接分离出去的大中型公司多达近百家，它们包括英特尔、AMD等知名公司。另外，苹果公司第三位创始人、公司第一任董事长马库拉也来自于仙童公司。这些公司的市值加起来接近30000亿美元。可以说，旧金山湾区之所以能成为硅谷，很大程度上是因为有了仙童公司。（区域经济）</p><h2 id="摘抄与思考"><a href="#摘抄与思考" class="headerlink" title="摘抄与思考"></a>摘抄与思考</h2><p>肖克利以及诺伊斯等八个人一起创造了“八叛徒”这个词。此后，“叛徒”这个词在硅谷的文化中成了褒义词，它代表着一种叛逆传统的创业精神。这种精神不仅缔造了硅谷的传奇，而目激励着硅谷的几代人不断调整传统，勇于开拓未来。</p><p>诺伊斯在正式成为仙童公司的总经理之后，吸取了肖克利的教训，努力营造一种轻松的工作氛围和没有等级差异的公司文化。在这样的氛围里，上下级之间只是分工不同而已，没有传统公司里那种发号施令和服从的关系，而是可以自由争论的合作关系。员工之间可以充分信任，对现有的员工来讲可以激励他们工作的主动性，对于外部的人才则可以将他们吸引进公司。（对硅谷工作氛围的影响）</p><p>仙童公司股权结构的问题（菲尔柴尔德将股权全部收走）直接导致了鲍德温等人的离职创业。当创始团队和管理团队不拥有公司的股份时，他们除了在经济利益上与公司老板会有冲突外，在管理上出现矛盾时，没有股权的前者也缺乏话语权。</p><p>信息时代企业的一个重要特征：一家公司很难也没有必要像工业时代那样通过拥有生产资料来把大家组织到一起了，另立门户的成本非常低。这也促成了硅谷的另一种文化——从现有的著名公司中离职，直接创业。（信息产业生产资料的可获得性造成了它与传统工业的本质区别）</p><h1 id="硅谷的出现"><a href="#硅谷的出现" class="headerlink" title="硅谷的出现"></a>硅谷的出现</h1><p>硅谷为什么出现在旧金山湾区，这里面有很多巧合的因素，而那些巧合的背后，又有着必然的联系。在诸多因素中，有三个因素具有决定性。</p><ol><li>1951年，斯坦福大学的特曼教授为了帮助大学解决财政问题，提议大学拿出2.7平方公里(600多英亩)土地创立了斯坦福工业园(今天叫做斯坦福研究园)，吸引来很多高科技公司。</li><li>1952年，IBM在旧金山南部100公里的圣荷西市建立了西海岸研究实验室，即今天的IBM爱曼登研究中心(Almanden Research Center)，让远离东部科技中心的北加州地区有机会站在了科技产业前沿。</li><li>有能够不断生出“金蛋”的仙童公司，在当地孕育出完整的半导体产业，当然这同时也伴随着仙童公司最终的解体。在这个过程中，拉斯特等创始人的离开使得半导体技术的扩散和仙童公司的解体变得无法逆转。</li></ol>]]></content>
    
    
    <categories>
      
      <category>book notes</category>
      
      <category>浪潮之巅</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浪潮之巅读书笔记1-AT&amp;T与IBM</title>
    <link href="/posts/24c6c64a.html"/>
    <url>/posts/24c6c64a.html</url>
    
    <content type="html"><![CDATA[<h1 id="AT-T"><a href="#AT-T" class="headerlink" title="AT&amp;T"></a>AT&amp;T</h1><h2 id="大事记"><a href="#大事记" class="headerlink" title="大事记"></a>大事记</h2><p>1875 贝尔和沃森发明电话。</p><p>1877 美国贝尔电话公司成立。</p><p>1880 贝尔长途电话业务开通。</p><p>1892 长途电话业务进入美国中部芝加哥地区。</p><p>1913 和美国政府达成第一次反垄断协议。</p><p>1915 电话业务进入美国西部旧金山地区。</p><p>1925 贝尔实验室成立。</p><p>1972 UNIX操作系统和C语言诞生于贝尔实验室。</p><p>1982 美国司法部打赢了长达8年的针对贝尔电话公司的反垄断官司。</p><p>1984 美国贝尔电话公司被拆成AT&amp;T和8家地区性贝尔公司。</p><p>1996 AT&amp;T主动地一分为三，包括新AT&amp;T、朗讯和NCR。</p><p>2000 朗讯的移动部门Avaya单独上市。</p><p>2001 AT&amp;T再次主动拆分，变为独立的AT&amp;T(含企业服务和个人业务)、AT&amp;T移动和AT&amp;T宽带等公司。</p><p>2004 AT&amp;T被<em>道琼斯指数</em>除名，从地区性贝尔公司发展起来的SBC替代了它在该指数中的位置。</p><p>2005 AT&amp;T被SBC并购，成为新AT&amp;T。此前，从AT&amp;T分出的几家独立公司均被竞争对手或业界同行收购。</p><p>2006 朗讯被法国的阿尔卡特并购，原来的美国贝尔电话公司(AT&amp;T)从此消亡。</p><blockquote><p>道琼斯工业指数在20世纪初包括20家上市公司，后来扩大到30家。这30家公司是美国支柱产业的大公司。因此道琼斯又称为蓝筹股(blue chips)，因为蓝色的筹码是赌局中面值最大的筹码。</p></blockquote><h3 id="详细的时间点事件"><a href="#详细的时间点事件" class="headerlink" title="详细的时间点事件"></a>详细的时间点事件</h3><p>1996年，如日中天的AT&amp;T公司重组，分离成AT&amp;T、朗讯 (Lucent Technologies)和NCR三家公司。AT&amp;T旗下举世闻名的科研机构贝尔实验室也被一分为二。朗讯公司获得了一半的科研机构和贝尔实验室的名称。划归AT&amp;T的一半研究室组成了AT&amp;T实验室(后来更名为香农实验室，Shannon Labs)。2005年，AT&amp;T被SBC公司并购，而朗讯则于2006年被法国阿尔卡特(Alcatel)公司并购。2016年，阿尔卡特–朗讯又被诺基亚收购。</p><p>1995年可以说是AT&amp;T公司的顶峰，接下来短短的10年里，它便分崩离析，不复存在了。AT&amp;T不紧不慢地向上走过了百年，才爬到顶点，走下坡路却只是短短的10年。今天我们看到的AT&amp;T实际上是由当年小贝尔公司之一的西南贝尔公司(SBC)几次以小吃大合并出的类似于水电公司的设施服务公司，这类公司在美国统称为资源服务公司，毫无技术可言。</p><p>2014年，贝尔实验室推倒了它的第一栋实验大楼，虽然目的是不再想维护那栋没有太多人使用的老楼，但是外界把这解读成一个时代的终结。有媒体评论道:“非常遗憾它被推倒了，但是更遗憾的是居然没有人觉得这算是一回事。”</p><h2 id="贝尔实验室"><a href="#贝尔实验室" class="headerlink" title="贝尔实验室"></a>贝尔实验室</h2><p>1925年，AT&amp;T公司成立了研发机构——贝尔实验室(Bell Laboratories，简称Bell Labs)。贝尔实验室是历史上最大、最成功的私有实验室。AT&amp;T公司从电信业获得了巨额的垄断利润，将**销售额的3%**用于贝尔实验室的研发工作。</p><p>在很长一段时间里，贝尔实验室总是用<strong>“无须为经费发愁”</strong>这一条理由来吸引优秀的科学家到该实验室工作，这使得贝尔实验室不仅在通信领域长期执牛耳，而且在射电天文学、晶体管和半导体、计算机科学等领域也都领先于世界，其闻名于世的发明包括<strong>射电天文望远镜、晶体管、数字交换机、计算机的UNIX操作系统和C语言</strong>等。此外，贝尔实验室还发现了电子的波动性，提出了信息论，组织发射了第一颗商用通信卫星，铺设了第一条商用光纤。</p><p>在相当长的时间内，贝尔实验室不仅仅是信息领域科学家最向往的地方，也是基础研究领域学者梦寐以求的地方。那个时代，能进入贝尔实验室的人是很幸运的。如果确有才华，他可以成为业界的领袖，甚至得到诺贝尔奖、香农奖或图灵奖。即使是一般的研究员和工程师，也会有很好的收入、可靠的退休保障及受人尊重的社会地位。</p><h2 id="AT-T衰落的原因"><a href="#AT-T衰落的原因" class="headerlink" title="AT&amp;T衰落的原因"></a>AT&amp;T衰落的原因</h2><p>不是反垄断。AT&amp;T 100年来发展得非常健康。虽然它一直受反垄断法的约束，但是美国政府司法部并没有真正要过它的命，每一次反垄断其实是帮助 AT&amp;T 修枝剪叶，让它发展得更好。</p><p>真正的原因是<strong>AT&amp;T的设备制造部门的执行官们短视地提出分家的建议</strong>。</p><h3 id="内因：华尔街和AT-T自身的贪婪和短视"><a href="#内因：华尔街和AT-T自身的贪婪和短视" class="headerlink" title="内因：华尔街和AT&amp;T自身的贪婪和短视"></a>内因：华尔街和AT&amp;T自身的贪婪和短视</h3><p>AT&amp;T几个执行官的股票远不如华尔街投资银行控制的多。事实上，AT&amp;T的总裁们非但不真正拥有公司，而且一些人的个人利益还和公司的利益有冲突。即使他们之中不乏有远见者，但是根本左右不了董事会。正是因为公司的长期利益和这些高管们没有太大关系，所以他们如果能在任期内狠狠捞一把，何乐而不为呢?至于华尔街的投资公司，关心的是手中的股票何时能翻番，关注的是时机，而1995年正是一个机会。整个股市形势很好，在这时将设备制造部门和电信服务部门分开，那么前者的股票一定会飞涨，毕竟短期内将获得Sprint和MCI的订单。华尔街看到了这一点，公司的老总们懂得这一点，公司大量拥有股权的员工也明白这一点。</p><p>随着移动通信业务的兴起，已经日渐衰落的朗讯居然再一次杀鸡取卵，将公司由那个后来在惠普做得很糟糕的女总裁卡莉·菲奥莉娜(Carly Fiorina)经手再次拆分，主要是将它的无线设备部门Avaya分出去单独上市。当然，华尔街的投资银行和朗讯的一些高管，尤其是菲奥莉娜又在已经鼓鼓的钱包中赚到了一大笔钱。</p><blockquote><p>看重短期利益而不是公司的长远发展</p></blockquote><h4 id="放弃贝尔实验室的核心竞争力"><a href="#放弃贝尔实验室的核心竞争力" class="headerlink" title="放弃贝尔实验室的核心竞争力"></a>放弃贝尔实验室的核心竞争力</h4><p>原来的贝尔实验室因为有AT&amp;T这座大靠山，从来不为经费发愁。后来，朗讯的利润已不足以养活有两万人的巨型实验室，于是开始要求那里的科学家和工程师将重心转移到<strong>能尽快赚钱的研究</strong>上来(我在以后会谈到AT&amp;T这种大实验室的弊端)。贝尔实验室此时已不是过去以研究为主的地方了，它的<strong>创新能力不复存在</strong>，从1995年起，贝尔实验室没有再搞出轰动世界的发明。</p><p>我们今天最通用的高速上网方式<strong>DSL</strong>最初诞生于贝尔实验室，但是AT&amp;T并没有把它作为今后可持续发展的利器，而是扔到了某个无人注意的角落。而曾经在贝尔实验室工作过的美国通信领域著名科学家约翰·查菲(John Cioffi)教授后来在斯坦福大学将它实用化，成为“DSL之父”。在科技发展最快的20世纪90年代，AT&amp;T浪费掉的技术和机会远不止这些。</p><h4 id="借钱给小公司买自己的设备当作销售额"><a href="#借钱给小公司买自己的设备当作销售额" class="headerlink" title="借钱给小公司买自己的设备当作销售额"></a>借钱给小公司买自己的设备当作销售额</h4><p>从MCI和Sprint带来的销售额增长几乎是一次性的。华尔街在预测朗讯盈利时，已经把这笔收入计算进去了。朗讯的股票要继续增长，它的销售额和利润就必须不断超过华尔街的预期。可是，朗讯其实根本做不到这一点。为了能支撑高股价，朗讯走了一步后来被证明是败笔的险棋。在互联网泡沫时代，有无数的中小公司在兴起，大公司在膨胀，朗讯决定“促销”自家电信设备。具体做法是由朗讯借钱给各公司来买朗讯的设备。<strong>只要设备运离公司，朗讯就在每季度的财务报表中，计入销售额。</strong>仔细读朗讯的财报，人们可以发现朗讯总有一笔很大的“应收款项”，这笔钱其实从未进到朗讯公司。2000年互联网泡沫破裂后，借钱购买设备的公司纷纷倒闭，朗讯的这笔“应收款项”一下子变成了净亏损。</p><h3 id="外因：互联网的兴起"><a href="#外因：互联网的兴起" class="headerlink" title="外因：互联网的兴起"></a>外因：互联网的兴起</h3><p>在互联网兴起以前，固定电话几乎是人类唯一的交互通信手段。互联网兴起，当人们有了一种不要钱的实时通信方式后，就没人为一分钟3美元的国际长途电话买单了。为了促销，所有的长途电话公司都不得不通过降价来维持生计。到了2004年，由于AT&amp;T公司的影响力越来越小，终于被道琼斯工业指数除名。</p><blockquote><p>取代它的SBC公司正是1984年从AT&amp;T分出去的8家小贝尔公司中最小的西南贝尔公司，经过几轮小吃大，接连兼并兄弟贝尔公司，SBC成为美国第二大电信公司。一年后，SBC再次上演蛇吞象的一幕，不过这一次它吞下了老祖母AT&amp;T，只不过SBC考虑到AT&amp;T的名气更大，新公司采用了AT&amp;T的名称。因此，今天的这个AT&amp;T已经不是当年的那个AT&amp;T了。</p></blockquote><p>互联网对朗讯的冲击也是同样的。在互联网时代，全球对<strong>数据交换设备</strong>的需求渐渐超过对语音交换设备的需求。前者是新兴公司思科的长项，而后者才是朗讯的强项。后来，像<strong>思科、华为</strong>这样的新一代电信设备公司战胜朗讯，又成为一股不可阻挡的潮流。</p><h2 id="摘抄和思考"><a href="#摘抄和思考" class="headerlink" title="摘抄和思考"></a>摘抄和思考</h2><p>在第二次世界大战期间，贝尔实验室的天才青年科学家香农提出了信息论。信息论是整个现代通信的基础，并与控制论、系统论一道，成为信息时代的科学基础。</p><p>为什么美国小公司能很快成为跨国公司？其中一个原因是<strong>反垄断法逼着公司追求技术进步</strong>。当一家公司开始垄断一个行业时，它会更多地倾向于利用自己的垄断资源，而不是靠技术进步获得更多的利润，毕竟前者比后者容易得多。</p><p>在2000年前后，短线投资者发现<strong>最快的挣钱方法不是把一家企业搞好，而是炒作和包装上市</strong>。将公司的一部分拆了卖无疑挣钱最快。（但拆分之后业务种类单一，抗风险能力降低，对公司本身或许不利）</p><p>随着AT&amp;T的没落，很多优秀的科学家和工程师，包括UNIX操作系统和C语言的发明人之一肯·汤普森(Ken Thompson)，都来到了新兴的Google公司，他们成为了Google技术的中坚。<strong>评价一家上市公司的好坏，其实只要看那些最优秀的人是流进这家公司，还是流出这家公司即可。</strong></p><p>互联网的崛起，对原贝尔实验室研究的影响也是巨大的。比如，语音的自动识别曾经被认为是人类最伟大的梦想之一，现在随着电话时代的过去也变得不重要了。今天，世界上主要的语<strong>音识别公司</strong>只剩下<strong>Nuance</strong>一家，2012年美国整个语音识别市场的规模一年只有15亿美元，不及Google半个月的收入。而同时，<strong>对文字处理、图像处理技术的需求则随着互联网的普及不断增加</strong>。（2023年是否依然如此？）</p><p>在工业史上，新技术代替旧的技术是不以人的意志为转移的。<strong>互联网对传统电话业务的冲击，就如同数码相机对胶卷制造业的冲击一样，是从根本上断绝了它的生存基础。</strong>今天，互联网虽然还不能完全代替固定电话，但是前者已经大大挤压了后者的发展空间，因为它可以提供更灵活、更丰富，而且更便宜的通信手段。</p><h1 id="IBM"><a href="#IBM" class="headerlink" title="IBM"></a>IBM</h1><p>IBM公司可能是世界上为数不多的成功逃过历次经济危机，并且在历次技术革命中实现成功转型的公司之一。在很多人的印象中，IBM仅仅是一个大型计算机制造商，并且在个人电脑和互联网越来越普及的今天，它已经过气了。其实，IBM并没有这么简单，它至今仍然是<strong>世界上最大的服务公司、第二大软件和IT服务公司、第三大数据库公司</strong>。IBM拥有当今<strong>工业界最大的实验室IBM Research</strong>(虽然规模只有贝尔实验室全盛时期的1&#x2F;10)，是<strong>世界第一的专利申请大户</strong>，另外，它还是<strong>全球最大的RISC服务器制造商</strong>。</p><h2 id="大事记-1"><a href="#大事记-1" class="headerlink" title="大事记"></a>大事记</h2><p>1924 老沃森控股原制表机公司，改名IBM。</p><p>1925 进人日本市场，此前制表机公司已经开始逐渐进人欧洲市场。</p><p>1933 IBM工程实验室成立。</p><p>1936 在罗斯福新政时，IBM获得美国政府大订单。</p><p>1940 20世纪40年代进入亚洲市场。</p><p>1943 IBM研制出真空管放大器。</p><p>1945 沃森实验室成立。</p><p>1952 小沃森成为IBM总裁，开始了快速发展的20年计算机时代。</p><p>1953 研制出使用磁鼓的计算器。</p><p>1962 IBM开始最早期的语音识别研究，是识别10个数字和加、减、乘、除等六个单词。</p><p>1964 IBM S&#x2F;360大型计算机问世。</p><p>1969 开始从事语音识别的研究。司法部对IBM展开反垄断调查。</p><p>1971 小沃森退休。</p><p>1973 江崎玲于奈(Leo Esaki)博士因在电子隧道效应上的研究为IBM获得第一个诺贝尔奖。</p><p>1981 IBM PC诞生。</p><p>1993 郭士纳执掌IBM，开创IBM的黄金十年。</p><p>1997 计算机深蓝战胜国际象棋世界冠军卡斯帕罗夫。</p><p>2005 IBM将PC业务卖给联想，从此退出PC市场。</p><p>2006 IBM和Google、亚马逊一道，成为最早提出今天云计算概念的公司。</p><p>2014 IBM将x86服务器业务卖给联想，表明它进军云计算市场的决心。</p><p>2016 IBM宣布它的Watson医疗服务机器人在癌症诊断方面达到了和人类医生99%的一致性。</p><h2 id="IBM的发展历程"><a href="#IBM的发展历程" class="headerlink" title="IBM的发展历程"></a>IBM的发展历程</h2><h3 id="机械革命"><a href="#机械革命" class="headerlink" title="机械革命"></a>机械革命</h3><p>IBM的前身：CTR公司。1911年，国际时间记录公司、计算尺公司和霍勒里斯的制表机器公司这三家公司合并，成立了计算–制表–记录公司 (Computing-Tabulating-Recording Company)。</p><p>早期的IBM，产品主要是一些办公管理用的机械，诸如打孔机、制表机等，服务对象是政府部门和企业。IBM从那时起，就锁定了政府部门和企事业单位为它的主要客户，直到今天。很多人奇怪为什么最早推出主流PC(即以英特尔处理器和微软操作系统为核心的PC)的IBM没有成为PC之王。实际上，IBM的基因决定了它不可能领导以个人用户为核心的PC产业。</p><p>1929-1933大萧条后，随着经济的恢复，办公机械的市场开始复苏。尤其是罗斯福推行新政，雇用了大量政府工作人员。政府对制表机的需求大大增加。除了正常的生意，IBM还将大量打孔机、制表机等设备卖给了德国纳粹政府。不过，IBM从未回避这段不光彩的历史。</p><p>二战中IBM还将其生产线民用转军用。IBM为军方研制了世界上第一台继电器式计算机。此外，IBM还间接地参与了研制原子弹的曼哈顿计划。</p><p>二战后，整个世界都在重建之中，对各种工业品的需求都在增加。尤其是杜鲁门总统完成了美国的社会保障制度后，有大量的统计工作需要用到制表机等机械。这一切都对IBM的核心业务给予了强有力的支持。IBM很轻易地再将生产线军用转民用。</p><h3 id="电子革命"><a href="#电子革命" class="headerlink" title="电子革命"></a>电子革命</h3><p>二战后，IBM的情况和日本类似，它显然面临着两种选择，是继续发展它的电动机械制表机，还是发展新兴的电子工业。这两派争执不下，而代表人物恰恰是沃森父子。老沃森认为电子的东西不可靠，世界上至今还有不少人持老沃森的观点。而小沃森则坚持认为电子工业是今后的发展趋势。这场争论以小沃森的胜利而告终。1952年，小沃森成为IBM的新总裁。IBM从此开始领导电子技术革命的浪潮。</p><p>IBM的小沃森认为计算机在今后的社会生活中将会扮演一个非常重要的角色，便决定投资发展计算机，并请来冯·诺伊曼做顾问。IBM还请来了很多工程师，并且把麻省理工学院作为它强大的技术支撑。小沃森将IBM的研发经费从他父亲时代公司营业额的3%增加到9%。到20世纪60年代，IBM生产出著名的 IBM System&#x2F;360 (S&#x2F;360，下文简称IBM 360)为止，IBM在计算机研制和生产上的总投入高达50亿美元，相当于整个马歇尔计划的1&#x2F;3。</p><blockquote><p>马歇尔计划，又称为欧洲复兴计划，是二战结束后美国对被战争破坏的西欧各国进行经济援助、协助重建的计划，对欧洲国家的发展和世界政治格局产生了深远的影响。该计划于1948年4月正式启动，并整整持续了4个财政年度之久。在这段时期内，西欧各国通过参加当时的欧洲经济合作组织(OECD)，总共接受了美国包括金融、技术、设备等各种形式的援助合计131.5亿美元。</p></blockquote><p>小沃森上台后短短5年，就将IBM的营业额提高了3倍。在小沃森执掌IBM的20年里，IBM的平均年增长率高达30%，这在世界上可能是绝无仅有的，他的父亲也没有做到这一点。</p><p>从20世纪70年代初到80年代初，美国司法部和IBM打了10年的<strong>反垄断</strong>官司，最终于1982年和解。一般认为，这是IBM的胜利。但是，IBM也为此付出了很大的代价。主要有两方面：</p><ol><li>IBM分出了一部分服务部门，让它们成为独立的公司；</li><li>IBM必须公开一些技术，从而导致了后来无数IBM PC兼容机公司的出现。</li></ol><h3 id="信息革命"><a href="#信息革命" class="headerlink" title="信息革命"></a>信息革命</h3><p>为了应付美国司法部提出的反垄断诉讼，卡里耗费了大量时间，但一直在密切注视着新技术的发展。对于个人电脑，IBM观望了几年。这对IBM这样一家大公司来讲是非常有必要的。IBM成功的秘诀是保守，它基本上是不见兔子不撒鹰。如果苹果公司失败了，IBM无需做任何事情。要是苹果公司成功了，IBM依靠它强大的技术储备完全可以后发制人。</p><p>IBM没有让它力量最强的沃森实验室(T. J. Watson Labs)来做这件事，而是将它交给了IBM在佛罗里达的一个十几人的小组。为了最快地研制出一台PC，这个只有十几人的小组不得不打破以前IBM包办计算机全部软硬件的习惯，而是采用了英特尔公司的 8088 芯片作为该电脑的处理器，同时委托独立软件公司为它配置各种软件。这样，仅一年之后，1981年，IBM PC就问世了。它比苹果公司的Apple系列已经好很多了，足以应付当时的字处理、编程等应用。IBM PC一上市就大受欢迎，当年就卖掉10万台，占领了3&#x2F;4的个人电脑市场。IBM在和苹果的竞争中真可谓是后发制人。直到今天，IBM PC还是个人电脑的代名词。</p><p>当时《时代周刊》评选IBM PC为20世纪最伟大的产品。《华尔街日报》也高度评价了IBM的这一贡献。但是个人电脑时代的最终领导者是微软和英特尔，而不是IBM。随着2005年IBM将个人电脑业务卖给了中国的联想公司，IBM彻底退出了个人电脑的舞台。</p><h4 id="IBM退出PC市场的原因"><a href="#IBM退出PC市场的原因" class="headerlink" title="IBM退出PC市场的原因"></a>IBM退出PC市场的原因</h4><ol><li><p><strong>IBM的基因</strong>。主要客户群基本上是政府部门、军方、银行、大企业和科研院所。IBM都是将计算机和服务绑在一起卖。</p></li><li><p><strong>反垄断的后遗症</strong>。1982年，IBM和美国司法部在反垄断官司中达成和解。和解的一个条件是，IBM得允许竞争对手发展。IBM PC很容易仿制，只好看着康柏(Compaq)、戴尔(Dell)等公司做大了。</p></li><li><p><strong>微软的崛起</strong>。</p><p>对于OS，IBM来不及自己开发，而是招标。盖茨没有让IBM买断DOS，而是从每台IBM PC中收一笔不太起眼的版权费。而且，IBM和微软签的协议中没有指明微软是否可以将DOS再卖给别人。盖茨后来抓住了这个漏洞，到处兜售DOS。</p><p>盖茨明修栈道，暗渡陈仓，一方面和IBM合作开发OS&#x2F;2，挣了一点短期的钱；另一方面下大力气开发Windows操作系统。当Windows 3.1推出时，微软帝国也就形成了。</p><blockquote><p>十几年后，硅谷一位最成功的CEO讲，凡是和微软合作的公司，最后都没有好结果。IBM也许是其中第一个吃亏的。</p></blockquote></li></ol><p>到20世纪80年代末，由于性能每18个月就翻一番，个人电脑慢慢开始胜任一些以前只有大型机才能做的工作。这样，个人电脑开始蚕食大型机的市场。1993年，IBM出现了严重的亏损，有史以来第一次开始大规模裁员。这段时期，是IBM历史上最艰难的时期。</p><h3 id="成功转型"><a href="#成功转型" class="headerlink" title="成功转型"></a>成功转型</h3><p>1993年，从未在IBM工作过的路易斯·郭士纳(Louis Gerstner)临危受命，出任IBM的首席执行官。他领导IBM从一个计算机硬件制造公司成功转变为一家以服务和软件为核心的服务型公司，复兴了这个百年老店，并开创了IBM的10年持续发展局面。</p><blockquote><p>郭士纳原来是一家食品公司的总裁，更早则任职于美国运通信用卡公司，根本不懂计算机。在英语中，计算机的芯片和薯片是一个词一一chip，因此，大家就开他的玩笑说，他也是做(芯)片的，但做的是薯片(He also made chips， but potato chips.)。这句原先是嘲笑他的话，以后成为他传奇的象征。</p></blockquote><p>郭士纳上台后的第一件事就是对IBM进行<strong>大规模改组，开源节流</strong>。他裁掉了一些冗余的部门和一些毫无前途的项目，还卖掉了一些资产。</p><p>接下来，他对公司的一些<strong>机构和制度进行改革</strong>。首先，他不声不响地将分出去的一些服务公司买回来，然后将IBM的硬件制造、软件开发和服务合成一体。在公司内部，他引入竞争机制，一个项目可能有多个组背靠背地开发。为了防止互相拆台，加强合作，郭士纳将每个人的退休金与全公司的而不是之前各部门的效益挂钩。</p><p>在研究方面，郭士纳将研发经费从营业额的9%降到6%。郭士纳砍掉了一些偏重于理论而没有效益 的研究，并且<strong>将研究和开发结合起来</strong>。一旦一个研究项目进入实用阶段，他就将整个研究组从实验室挪到产品部门。到后期，他甚至要求IBM所有的研究员必须从产品项目中挣一定的工资。为了弥补IBM的长线研究和基础研究的损失，IBM加强了和大学的合作，在几十所大学开展科研合作，或者设立奖学金。</p><p>在郭士纳的领导下，IBM很快走出了困境。IBM将自身确立为一个服务型的技术公司，并将用户群定位在企业级，而放弃了自己并不在行的终端消费者市场。</p><h2 id="评价：经营上保守，技术上创新"><a href="#评价：经营上保守，技术上创新" class="headerlink" title="评价：经营上保守，技术上创新"></a>评价：经营上保守，技术上创新</h2><p>IBM在经营上相当的保守，它一直固守自己的核心领域，很谨慎地开拓新的领域。从机械的制表机到大型计算机，到今天的Linux开源服务器，IBM始终牢牢地控制着美国政府部门、军队、大公司和银行的业务。</p><blockquote><p>保守的好处是不容易出错，因为像IBM这样服务于美国乃至世界各国核心部门的公司，产品上出一点错就会造成不可弥补的损失（美国主要银行对计算机系统的要求是一年宕机时间不能超过5分钟）。IBM这种保守的做法让大客户们很放心，因此，即使它的产品和服务比别人贵，政府和企业还是很愿意，或者说不得不用IBM的产品和服务。</p></blockquote><p>从技术上讲，IBM又是一家极富创新精神的公司。几十年来，如果说在工业界哪个实验室有资格和贝尔实验室相提并论，恐怕就只有IBM实验室了。IBM一直是美国专利大户，每年都有几千个专利，IBM用奖金和升职加薪点数来大力鼓励员工申请专利。</p><blockquote><p>但现在，IBM的很多研究员只能从研究项目中拿到一大半而不是全部的工资，另一小半必须通过参加产品项目而获得，有些单纯搞研究的科学家便不得不离开。IBM的目的非常清楚:科研必须和产品相结合。</p></blockquote><h2 id="摘抄和思考-1"><a href="#摘抄和思考-1" class="headerlink" title="摘抄和思考"></a>摘抄和思考</h2><p>IBM能成为科技界的常青树，要归功于它的二字秘诀——<strong>保守</strong>。保守让IBM失去了无数次发展机会，但是也让它能专注于做最重要的事，并因此立于不败之地。</p><p><strong>第二次世界大战可以看作是机械时代和电子时代的分水岭</strong>。英国在二战后很长时间里试图恢复它的机械工业，虽然它做到了，但是也已经落伍了。而一片焦土的日本，已经没有剩下什么工业基础了，因此另起炉灶，发展电子工业，成为世界第二经济大国，直到近几年才被中国超越。</p><p>恩格斯说过，<strong>社会的需求对科技进步的作用要超过10所大学</strong>。计算机就是在这种背景下发明出来的。美国研制计算机的直接目的是在第二次世界大战中为军方计算弹道。在流体力学中，计算量常常大到手工的计算尺无法计算的地步，因此，对通用计算机的需求就产生了。</p><p>小沃森想到将计算机从政府军方推广到民间，这一方面是他的天分，另一方面则源自IBM长期制造表格处理机械，了解这方面的需求。</p><p>从开始做计算机起，IBM基本上遵循<strong>性能优先于价格</strong>和<strong>集中式服务</strong>的原则。高性能、支持多用户的主机一直是IBM硬件制造的重点，直到20世纪90年代才略有转变。IBM的许多大型机，成为计算机系统结构设计的经典之作。</p><p>IBM的<strong>研究水平</strong>很高，还参与制定了很多标准。因此，它在商业竞争中，同时扮演着<strong>运动员和裁判员</strong>的双重角色。从20世纪50年代到80年代初，IBM在计算机领域基本上是独孤求败。（<strong>工程</strong>实验室的实用研究很重要）</p><p>上个世纪90年代，IBM和AT&amp;T走了两条截然相反的路。AT&amp;T是将一家好端端的公司拆散卖掉，IBM则是将分出去的公司整合回来，打造了一艘从硬件到软件到服务一条龙的航空母舰。从IBM和AT&amp;T的不同结果可以看出，一个有远见的经营者和一群贪婪的短期投机者在管理方针和水平上的巨大差别。</p>]]></content>
    
    
    <categories>
      
      <category>book notes</category>
      
      <category>浪潮之巅</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-6. Avoid creating unnecessary objects</title>
    <link href="/posts/38d6a603.html"/>
    <url>/posts/38d6a603.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-6-Avoid-creating-unnecessary-objects"><a href="#Item-6-Avoid-creating-unnecessary-objects" class="headerlink" title="Item 6: Avoid creating unnecessary objects"></a>Item 6: Avoid creating unnecessary objects</h1><h2 id="Reuse-object-instead-of-creating-new-equivalent-object"><a href="#Reuse-object-instead-of-creating-new-equivalent-object" class="headerlink" title="Reuse object instead of creating new equivalent object"></a>Reuse object instead of creating new equivalent object</h2><p>It is often appropriate to reuse a single object instead of creating a new functionally equivalent object each time it is needed. Reuse can be both faster and more stylish. An object can always be reused if it is <strong>immutable</strong> (Item 17). In addition, you can also reuse mutable objects if you know they won’t be modified.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>For example, suppose you want to write a method to determine whether a string is a valid Roman numeral.</p><p>The easiest way:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Performance can be greatly improved</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRomanNumeral</span><span class="hljs-params">(String s)</span> &#123;<br>  <span class="hljs-keyword">return</span> s.matches(<span class="hljs-string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br>+ <span class="hljs-string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>While</strong> <strong>String.matches</strong> <strong>is the easiest way to check if a string matches a regular expression, it’s not suitable for repeated use in performance-critical situations.</strong> The problem is that it internally creates a Pattern instance for the regular expression and uses it only once, after which it becomes eligible for garbage collection.</p><p>To improve the performance, explicitly compile the regular expression into a Pattern instance (which is immutable) as part of class initialization, cache it, and reuse the same instance for every invocation of the isRomanNumeral method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Reusing expensive object for improved performance</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RomanNumerals</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">ROMAN</span> <span class="hljs-operator">=</span> Pattern.compile(<br>           <span class="hljs-string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span><br>           + <span class="hljs-string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);<br>  <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRomanNumeral</span><span class="hljs-params">(String s)</span> &#123;<br>      <span class="hljs-keyword">return</span> ROMAN.matcher(s).matches();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Use-static-factory-methods-in-preference-to-constructors-on-immutable-classes"><a href="#Use-static-factory-methods-in-preference-to-constructors-on-immutable-classes" class="headerlink" title="Use static factory methods in preference to constructors on immutable classes"></a>Use <em>static factory methods</em> in preference to <em>constructors</em> on immutable classes</h2><p>You can often avoid creating unnecessary objects by using <em>static factory methods</em> (Item 1) in preference to constructors on <strong>immutable classes</strong> that provide both. The constructor <em>must</em> create a new object each time it’s called, while the factory method is never required to do so and won’t in practice.</p><blockquote><p>For example, the factory method Boolean.valueOf(String) is preferable to the constructor Boolean(String), which was deprecated in Java 9. </p></blockquote><h2 id="Prefer-primitives-to-boxed-primitives-and-watch-out-for-unintentional-autoboxing"><a href="#Prefer-primitives-to-boxed-primitives-and-watch-out-for-unintentional-autoboxing" class="headerlink" title="Prefer primitives to boxed primitives, and watch out for unintentional autoboxing"></a>Prefer primitives to boxed primitives, and watch out for unintentional autoboxing</h2><p><strong>Autoboxing blurs but does not erase the distinction between primitive and boxed primitive types.</strong></p><p>Consider the following method, which calculates the sum of all the positive int values. To do this, the program has to use long arithmetic because an int is not big enough to hold the sum of all the positive int values:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Hideously slow! Can you spot the object creation?</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">Long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= Integer.MAX_VALUE; i++)<br>     sum += i;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>The variable sum is declared as a Long instead of a long, which means that the program constructs about 231 unnecessary Long instances (roughly one for each time the long i is added to the Long sum).</p><p>The lesson is clear: <strong>prefer primitives to boxed primitives, and watch out for unintentional autoboxing.</strong></p><h2 id="Additional-information"><a href="#Additional-information" class="headerlink" title="Additional information"></a>Additional information</h2><p>This item should not be misconstrued to imply that object creation is expensive and should be avoided. On the contrary, the creation and reclamation of small objects whose constructors do little explicit work is cheap, especially on modern JVM implementations. <strong>Creating additional objects to enhance the clarity, simplicity, or power of a program is generally a good thing.</strong></p><p>Conversely, avoiding object creation by maintaining your own <em>object pool</em> is a bad idea unless the objects in the pool are extremely heavyweight. The <strong>classic example</strong> of an object that <em>does</em> justify an object pool is a <strong>database connection</strong>. The cost of establishing the connection is sufficiently high that it makes sense to reuse these objects. </p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-7. Eliminate obsolete object references</title>
    <link href="/posts/fd75d695.html"/>
    <url>/posts/fd75d695.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-7-Eliminate-obsolete-object-references"><a href="#Item-7-Eliminate-obsolete-object-references" class="headerlink" title="Item 7: Eliminate obsolete object references"></a>Item 7: Eliminate obsolete object references</h1><h2 id="Example-of-memory-leak"><a href="#Example-of-memory-leak" class="headerlink" title="Example of memory leak"></a>Example of memory leak</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Can you spot the &quot;memory leak&quot;?</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br>  <span class="hljs-keyword">private</span> Object[] elements;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span> &#123;<br>    elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Object e)</span> &#123;<br>    ensureCapacity();<br>    elements[size++] = e;<br>  &#125;<br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyStackException</span>();<br>    <span class="hljs-keyword">return</span> elements[--size];<br>  &#125;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Ensure space for at least one more element, roughly</span><br><span class="hljs-comment">  * doubling the capacity each time the array needs to grow.</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (elements.length == size)<br>      elements = Arrays.copyOf(elements, <span class="hljs-number">2</span> * size + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Where-is-the-memory-leak"><a href="#Where-is-the-memory-leak" class="headerlink" title="Where is the memory leak?"></a>Where is the memory leak?</h3><p>If a stack grows and then shrinks, the objects that were popped off the stack will not be garbage collected, even if the program using the stack has no more references to them. This is because the stack maintains <strong>obsolete references</strong> to these objects. An obsolete reference is simply a reference that will never be dereferenced again.</p><blockquote><p>The memory leak can silently manifest itself as reduced performance due to increased garbage collector activity or increased memory footprint. In extreme cases, such memory leaks can cause <strong>disk paging</strong> and even program failure with an <strong>OutOfMemoryError</strong>, but such failures are relatively rare.</p></blockquote><h3 id="Fix-for-the-memory-leak"><a href="#Fix-for-the-memory-leak" class="headerlink" title="Fix for the memory leak"></a>Fix for the memory leak</h3><p>Fix: null out references once they become obsolete.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyStackException</span>();<br>  <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> elements[--size];<br>  elements[size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Eliminate obsolete reference</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Nulling-out-obsolete-references"><a href="#Nulling-out-obsolete-references" class="headerlink" title="Nulling out obsolete references"></a>Nulling out obsolete references</h2><h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><ul><li>avoid memory leak</li><li>if they are subsequently dereferenced by mistake, the program will immediately fail with a NullPointerException, rather than quietly doing the wrong thing. It is always beneficial to detect programming errors as quickly as possible.</li></ul><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p><strong>Nulling out object references should be the exception rather than the norm.</strong> The best way to eliminate an obsolete reference is to let the variable that contained the reference fall out of scope. This occurs naturally if you define each variable in the narrowest possible scope (Item 57).</p><h2 id="Sources-of-memory-leaks"><a href="#Sources-of-memory-leaks" class="headerlink" title="Sources of memory leaks"></a>Sources of memory leaks</h2><h3 id="1-A-class-manages-its-own-memory"><a href="#1-A-class-manages-its-own-memory" class="headerlink" title="1. A class manages its own memory"></a>1. A class manages its own memory</h3><p>Whenever a class manages its own memory, the programmer should be alert for memory leaks. Whenever an element is freed, any object references contained in the element should be nulled out.</p><h3 id="2-Caches"><a href="#2-Caches" class="headerlink" title="2. Caches"></a>2. Caches</h3><p>Once you put an object reference into a cache, it’s easy to forget that it’s there and leave it in the cache long after it becomes irrelevant.</p><h4 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h4><ul><li><p>Represent the cache as a <strong>WeakHashMap</strong></p><ul><li><p>Situation: an entry is relevant(有意义) exactly when there are references to its key outside of the cache, entries will be removed automatically after they become obsolete.</p></li><li><p>Remember that <em>WeakHashMap</em> is useful only if the desired lifetime of cache entries is determined by external references to the <strong>key</strong>, not the value.</p></li></ul></li><li><p>Use a background thread (perhaps a <strong>ScheduledThreadPoolExecutor</strong>) to cleanse the cache occasionally, or as a side effect of adding new entries to the cache(method <strong>removeEldestEntry</strong> of <strong>LinkedHashMap</strong>).</p></li><li><p>For more sophisticated caches, you may need to use <strong>java.lang.ref</strong> directly.</p></li></ul><h3 id="3-Listeners-and-callbacks"><a href="#3-Listeners-and-callbacks" class="headerlink" title="3. Listeners and callbacks"></a>3. Listeners and callbacks</h3><p>If you implement an API where clients register callbacks but <strong>don’t deregister them explicitly</strong>, they will accumulate unless you take some action.</p><p>One way to ensure that callbacks are garbage collected promptly is to <strong>store only weak references to them</strong>, for instance, by storing them only as keys in a <em>WeakHashMap</em>.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-1. Consider static factory methods instead of constructors</title>
    <link href="/posts/b9bf3db3.html"/>
    <url>/posts/b9bf3db3.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-1-Consider-static-factory-methods-instead-of-constructors"><a href="#Item-1-Consider-static-factory-methods-instead-of-constructors" class="headerlink" title="Item 1: Consider static factory methods instead of constructors"></a>Item 1: Consider static factory methods instead of constructors</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h3 id="1-静态工厂方法有名称"><a href="#1-静态工厂方法有名称" class="headerlink" title="1. 静态工厂方法有名称"></a>1. 静态工厂方法有名称</h3><p>能够确切描述被返回的对象。</p><h3 id="2-不必在每次调用它们时都创建一个新对象"><a href="#2-不必在每次调用它们时都创建一个新对象" class="headerlink" title="2. 不必在每次调用它们时都创建一个新对象"></a>2. 不必在每次调用它们时都创建一个新对象</h3><p>与享元模式类似。节约资源。</p><h3 id="3-可以返回原返回类型的任何子类型的对象"><a href="#3-可以返回原返回类型的任何子类型的对象" class="headerlink" title="3. 可以返回原返回类型的任何子类型的对象"></a>3. 可以返回原返回类型的任何子类型的对象</h3><p>通过接口来引用被返回的对象，而不是通过它的实现类。</p><h3 id="4-所返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值"><a href="#4-所返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值" class="headerlink" title="4. 所返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值"></a>4. 所返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值</h3><blockquote><p>如：Enumset只有静态工厂方法，它返回两种子类之一的实例，具体取决于底层枚举类型的大小：</p><ul><li>如果它的元素小于等于64个，则像大多数枚举类型一样，返回一个RegularEnumset，用单个long支持；</li><li>如果枚举类型有大于64个元素，工厂返回JumboEnumset，用一个long数组支持</li></ul></blockquote><h3 id="5-方法返回的对象所属的类，在编写包含该静态方法的类时可以不存在"><a href="#5-方法返回的对象所属的类，在编写包含该静态方法的类时可以不存在" class="headerlink" title="5. 方法返回的对象所属的类，在编写包含该静态方法的类时可以不存在"></a>5. 方法返回的对象所属的类，在编写包含该静态方法的类时可以不存在</h3><p>Such flexible static factory methods form the basis of <em>service provider frameworks</em>, like the Java Database Connectivity API (JDBC).</p><blockquote><p>A service provider framework is a system in which providers implement a service, and the system makes the implementations available to clients, decoupling the clients from the implementations.</p></blockquote><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="1-类如果不含public-protected-constructor，就不能被子类化"><a href="#1-类如果不含public-protected-constructor，就不能被子类化" class="headerlink" title="1. 类如果不含public&#x2F;protected constructor，就不能被子类化"></a>1. 类如果不含public&#x2F;protected constructor，就不能被子类化</h3><p>For example, it is impossible to subclass any of the convenience implementation classes in the Collections Framework.</p><h3 id="2-程序员很难发现静态工厂方法"><a href="#2-程序员很难发现静态工厂方法" class="headerlink" title="2. 程序员很难发现静态工厂方法"></a>2. 程序员很难发现静态工厂方法</h3><p>以下是静态工厂方法的一些惯用名称：</p><ul><li>from</li><li>of</li><li>valueOf</li><li>instance &#x2F; getInstance</li><li>create &#x2F; newInstance</li><li>getType: Type表示工厂方法所返回的对象类型</li><li>newType</li><li>type</li></ul>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-3. Enforce the singleton property with a private constructor or an enum type</title>
    <link href="/posts/e779b37f.html"/>
    <url>/posts/e779b37f.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type"><a href="#Item-3-Enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type" class="headerlink" title="Item 3: Enforce the singleton property with a private constructor or an enum type"></a>Item 3: Enforce the singleton property with a private constructor or an enum type</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>A <em>singleton</em> is simply a class that is instantiated exactly once. Singletons typically represent either a stateless object such as a function (Item 24) or a system component that is intrinsically unique.</p><h2 id="Implementations"><a href="#Implementations" class="headerlink" title="Implementations"></a>Implementations</h2><h3 id="Public-field-approach"><a href="#Public-field-approach" class="headerlink" title="Public field approach"></a>Public field approach</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Singleton with public final field</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Elvis</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Elvis</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Elvis</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Elvis</span><span class="hljs-params">()</span> &#123; ... &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leaveTheBuilding</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Advantages:</p><ul><li>the API makes it clear that the class is a singleton: the public static field is final, so it will always contain the same object reference.</li><li>it’s simpler.</li></ul><blockquote><p>A privileged client can <strong>invoke the private constructor reflectively</strong> (Item 65) with the aid of the AccessibleObject.setAccessible method. If you need to defend against this attack, modify the <strong>constructor</strong> to make it <strong>throw an exception</strong> if it’s asked to create a second instance.</p></blockquote><h3 id="Static-factory-approach"><a href="#Static-factory-approach" class="headerlink" title="Static factory approach"></a>Static factory approach</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Singleton with static factory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Elvis</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Elvis</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Elvis</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Elvis</span><span class="hljs-params">()</span> &#123; ... &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Elvis <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> INSTANCE; &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leaveTheBuilding</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Advantages:</p><ul><li>it gives you the flexibility to change your mind about whether the class is a singleton without changing its API.</li><li>you can write a <em>generic singleton factory</em> if your application requires it (Item 30).</li><li>a <em>method reference</em> can be used as a supplier, for example <code>Elvis::instance</code> is a <code>Supplier&lt;Elvis&gt;</code>.</li></ul><blockquote><p>Unless one of these advantages is relevant, the public field approach is preferable.</p></blockquote><h3 id="Single-element-enum-approach"><a href="#Single-element-enum-approach" class="headerlink" title="Single-element enum approach"></a>Single-element enum approach</h3><p><strong>A single-element enum type is often the best way to implement a singleton</strong>.</p><p>This approach is similar to the public field approach, but it is more concise, provides the serialization machinery for free, and provides an <strong>ironclad guarantee against multiple instantiation</strong>, even in the face of <strong>sophisticated serialization</strong> or <strong>reflection attacks</strong>.</p><blockquote><p>Note that you <strong>can’t</strong> use this approach if your singleton must <strong>extend a superclass other than Enum</strong> (though you <em>can</em> declare an enum to implement interfaces).</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Enum singleton - the preferred approach</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Elvis</span> &#123;<br>  INSTANCE;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leaveTheBuilding</span><span class="hljs-params">()</span> &#123; ... &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>To make a singleton class that uses either of <strong>public field &#x2F; static factory approaches</strong> <em>serializable</em> (Chapter 12), it is not sufficient merely to add implements Serializable to its declaration.</p><p>To maintain the singleton guarantee, declare all instance fields transient and provide a <em>readResolve</em> method (Item 89). Otherwise, each time a serialized instance is deserialized, a new instance will be created, leading, in the case of our example, to spurious Elvis sightings.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// readResolve method to preserve singleton property</span><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// Return the one true Elvis and let the garbage collector take care of the Elvis impersonator</span><br>  <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java-4. Enforce noninstantiability with a private constructor</title>
    <link href="/posts/10de1e0.html"/>
    <url>/posts/10de1e0.html</url>
    
    <content type="html"><![CDATA[<h1 id="Item-4-Enforce-noninstantiability-with-a-private-constructor"><a href="#Item-4-Enforce-noninstantiability-with-a-private-constructor" class="headerlink" title="Item 4:  Enforce noninstantiability with a private constructor"></a>Item 4:  Enforce noninstantiability with a private constructor</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Write a class that is just a grouping of static methods and static fields.</p><p>Such <em>utility classes</em> were not designed to be instantiated: an instance would be nonsensical. In the absence of explicit constructors, however, the compiler pro- vides a public, parameterless <em>default constructor</em>. To a user, this constructor is indistinguishable from any other. It is not uncommon to see unintentionally instantiable classes in published APIs.</p><h2 id="Approaches-for-enforcing-noninstantiability"><a href="#Approaches-for-enforcing-noninstantiability" class="headerlink" title="Approaches for enforcing noninstantiability"></a>Approaches for enforcing noninstantiability</h2><h3 id="1-Making-a-class-abstract"><a href="#1-Making-a-class-abstract" class="headerlink" title="1. Making a class abstract"></a>1. Making a class abstract</h3><p><strong>Attempting to enforce noninstantiability by making a class abstract does not work.</strong> </p><p>The class can be subclassed and the subclass instantiated. Furthermore, it misleads the user into thinking the class was designed for inheritance (Item 19).</p><h3 id="2-Including-a-private-constructor"><a href="#2-Including-a-private-constructor" class="headerlink" title="2. Including a private constructor"></a>2. Including a private constructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Noninstantiable utility class</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UtilityClass</span> &#123;<br>  <span class="hljs-comment">// Suppress default constructor for noninstantiablity</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">UtilityClass</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>  &#125;<br>  ... <span class="hljs-comment">// Remainder omitted</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h4><p>Because the explicit constructor is <strong>private</strong>, it is <strong>inaccessible outside the class.</strong></p><p>The <strong>AssertionError</strong> isn’t strictly required, but it provides insurance in case the constructor is accidentally invoked from within the class. It guarantees the class will never be instantiated under any circumstances.</p><p>This idiom is mildly counter- intuitive because the constructor is provided expressly so that it cannot be invoked. It is therefore wise to include a <strong>comment</strong>.</p><h4 id="Disdvantages"><a href="#Disdvantages" class="headerlink" title="Disdvantages"></a>Disdvantages</h4><p>This idiom also prevents the class from being <strong>subclassed</strong>. All constructors must invoke a superclass constructor, explicitly or implicitly, and a subclass would have no accessible superclass constructor to invoke.</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>effective-java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis常用标签</title>
    <link href="/posts/54699746.html"/>
    <url>/posts/54699746.html</url>
    
    <content type="html"><![CDATA[<h1 id="顶级元素"><a href="#顶级元素" class="headerlink" title="顶级元素"></a>顶级元素</h1><p><strong>文档</strong>：<a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html">https://mybatis.org/mybatis-3/zh/sqlmap-xml.html</a></p><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li>cache：该命名空间的缓存配置</li><li>cache-ref：引用其它命名空间的缓存配置</li><li>resultMap：描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素</li><li><del>parameterMap：老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。</del></li><li>sql：可被其它语句引用的可重用语句块</li><li>insert：映射插入语句</li><li>update：映射更新语句</li><li>delete：映射删除语句</li><li>select：映射查询语句</li></ul><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>查询语句是 MyBatis 中最常用的元素之一，光能把数据存到数据库中价值并不大，还要能重新取出来才有用，多数应用也都是查询比修改要频繁。</p><p> MyBatis 的基本原则之一是： 在每个插入、更新或删除操作之间，通常会执行多个查询操作。因此，MyBatis 在查询和结果映射做了相当多的改进。select 元素允许你配置很多属性来配置每条语句的行为细节。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;hashmap&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;personResultMap&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;10&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">fetchSize</span>=<span class="hljs-string">&quot;256&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">resultSetType</span>=<span class="hljs-string">&quot;FORWARD_ONLY&quot;</span>&gt;</span>  <br>  //此处是你的sql语句 例如：<br>  select * from t_user where id = #&#123;id&#125;  <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 与java对象对应的列不是数据库中表的列名，而是查询后结果集的列名</p><h2 id="insert-update-和-delete"><a href="#insert-update-和-delete" class="headerlink" title="insert, update 和 delete"></a>insert, update 和 delete</h2><p>数据变更语句 insert，update 和 delete 的实现非常接近：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAuthor&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;domain.blog.Author&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateAuthor&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;domain.blog.Author&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span></span><br><span class="hljs-tag">  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteAuthor&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;domain.blog.Author&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 带条件的删除语句，不要对表使用别名，否则会报错</p><h3 id="insert，update-和-delete-语句的示例"><a href="#insert，update-和-delete-语句的示例" class="headerlink" title="insert，update 和 delete 语句的示例"></a>insert，update 和 delete 语句的示例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAuthor&quot;</span>&gt;</span><br>  insert into Author (id,username,password,email,bio)<br>  values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateAuthor&quot;</span>&gt;</span><br>  update Author set<br>    username = #&#123;username&#125;,<br>    password = #&#123;password&#125;,<br>    email = #&#123;email&#125;,<br>    bio = #&#123;bio&#125;<br>  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteAuthor&quot;</span>&gt;</span><br>  delete from Author where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="insert语句额外的属性和子元素"><a href="#insert语句额外的属性和子元素" class="headerlink" title="insert语句额外的属性和子元素"></a>insert语句额外的属性和子元素</h3><p>如前所述，插入语句的配置规则更加丰富，在插入语句里面有一些额外的属性和子元素用来处理主键的生成，并且提供了多种生成方式。</p><h4 id="自动生成主键"><a href="#自动生成主键" class="headerlink" title="自动生成主键"></a>自动生成主键</h4><p>首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 <code>useGeneratedKeys=”true”</code>，然后再把 <code>keyProperty</code> 设置为目标属性就 OK 了。例如，如果上面的 Author 表已经在 id 列上使用了自动生成，那么语句可以修改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAuthor&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>  insert into Author (username,password,email,bio)<br>  values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="多行插入"><a href="#多行插入" class="headerlink" title="多行插入"></a>多行插入</h4><p>如果你的数据库还支持多行插入, 你也可以传入一个 <code>Author</code> 数组或集合，并返回自动生成的主键。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAuthor&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>  insert into Author (username, password, email, bio) values<br>  <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>    (#&#123;item.username&#125;, #&#123;item.password&#125;, #&#123;item.email&#125;, #&#123;item.bio&#125;)<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="另外一种方法来生成主键"><a href="#另外一种方法来生成主键" class="headerlink" title="另外一种方法来生成主键"></a>另外一种方法来生成主键</h4><p>对于不支持自动生成主键列的数据库和可能不支持自动生成主键的 JDBC 驱动，MyBatis 有另外一种方法来生成主键。</p><p>这里有一个简单（也很傻）的示例，它可以生成一个随机 ID（不建议实际使用，这里只是为了展示 MyBatis 处理问题的灵活性和宽容度）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAuthor&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span>&gt;</span><br>    select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.SYSDUMMY1<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>  insert into Author<br>    (id, username, password, email, bio, favourite_section)<br>  values<br>    (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;, #&#123;bio&#125;, #&#123;favouriteSection,jdbcType=VARCHAR&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，首先会运行 selectKey 元素中的语句，并设置 Author 的 id，然后才会调用插入语句。这样就实现了数据库自动生成主键类似的行为，同时保持了 Java 代码的简洁。</p><p>selectKey 元素描述如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span></span><br><span class="hljs-tag">  <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>As an irregular case, some databases allow INSERT, UPDATE or DELETE statement to return result set (e.g. <code>RETURNING</code> clause of <em>PostgreSQL</em> and <em>MariaDB</em> or <code>OUTPUT</code> clause of MS SQL Server). This type of statement must be written as <code>&lt;select&gt;</code> to map the returned data.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertAndGetAuthor&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;domain.blog.Author&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">affectData</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>  insert into Author (username, password, email, bio)<br>  values (#&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;, #&#123;bio&#125;)<br>  returning id, username, password, email, bio<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><p>这个元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 <code>include</code> 元素中定义不同的参数值。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userColumns&quot;</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个 SQL 片段可以在其它语句中使用，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsers&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>  select<br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;userColumns&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;alias&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;t1&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>,<br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;userColumns&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;alias&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;t2&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>  from some_table t1<br>    cross join some_table t2<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以在 <code>include</code> 元素的 <code>refid</code> 属性或内部语句中使用属性值，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sometable&quot;</span>&gt;</span><br>  $&#123;prefix&#125;Table<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;someinclude&quot;</span>&gt;</span><br>  from<br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;$&#123;include_target&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>  select<br>    field1, field2, field3<br>  <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;someinclude&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Some&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;include_target&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sometable&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>之前见到的所有语句都使用了简单的参数形式。但实际上，参数是 MyBatis 非常强大的元素。对于大多数简单的使用场景，你都不需要使用复杂的参数，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsers&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>  select id, username, password<br>  from users<br>  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的这个示例说明了一个非常简单的命名参数映射。鉴于参数类型（parameterType）会被自动设置为 <code>int</code>，这个参数可以随意命名。原始类型或简单数据类型（比如 <code>Integer</code> 和 <code>String</code>）因为没有其它属性，会用它们的值来作为参数。 然而，如果传入一个复杂的对象，行为就会有点不一样了。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>  insert into users (id, username, password)<br>  values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果 User 类型的参数对象传递到了语句中，会查找 id、username 和 password 属性，然后将它们的值传入预处理语句的参数中。</p><p>大多时候，你只须简单指定属性名，顶多要为可能为空的列指定 <code>jdbcType</code>，其他的事情交给 MyBatis 自己去推断就行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#&#123;firstName&#125;</span><br><span class="hljs-comment">#&#123;middleInitial,jdbcType=VARCHAR&#125;</span><br><span class="hljs-comment">#&#123;lastName&#125;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong> JDBC 要求，如果一个列允许使用 null 值，并且会使用值为 null 的参数，就必须要指定 JDBC 类型（jdbcType）。阅读 <code>PreparedStatement.setNull()</code>的 JavaDoc 来获取更多信息。</p><h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><p><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC <code>ResultSets</code> 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 <code>resultMap</code> 能够代替实现同等功能的数千行代码。ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</p><h3 id="自动创建resultMap"><a href="#自动创建resultMap" class="headerlink" title="自动创建resultMap"></a>自动创建resultMap</h3><p>你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为领域模型。MyBatis 对两者都提供了支持。看看下面这个 JavaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.someapp.model;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>  <span class="hljs-keyword">private</span> String username;<br>  <span class="hljs-keyword">private</span> String hashedPassword;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> id;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>    <span class="hljs-built_in">this</span>.id = id;<br>  &#125;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> username;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span> &#123;<br>    <span class="hljs-built_in">this</span>.username = username;<br>  &#125;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHashedPassword</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> hashedPassword;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHashedPassword</span><span class="hljs-params">(String hashedPassword)</span> &#123;<br>    <span class="hljs-built_in">this</span>.hashedPassword = hashedPassword;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于 JavaBean 的规范，上面这个类有 3 个属性：id，username 和 hashedPassword。这些属性会对应到 select 语句中的列名。</p><p>这样的一个 JavaBean 可以被映射到 <code>ResultSet</code>，就像映射到 <code>HashMap</code> 一样简单。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsers&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.someapp.model.User&quot;</span>&gt;</span><br>  select id, username, hashedPassword<br>  from some_table<br>  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这些情况下，MyBatis 会在幕后自动创建一个 <code>ResultMap</code>，再根据属性名来映射列到 JavaBean 的属性上。如果列名和属性名不能匹配上，可以在 SELECT 语句中设置列别名（这是一个基本的 SQL 特性）来完成匹配。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsers&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>  select<br>    user_id             as &quot;id&quot;,<br>    user_name           as &quot;userName&quot;,<br>    hashed_password     as &quot;hashedPassword&quot;<br>  from some_table<br>  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="显示配置resultMap"><a href="#显示配置resultMap" class="headerlink" title="显示配置resultMap"></a>显示配置resultMap</h3><p>我们来看看如果在刚刚的示例中，显式使用外部的 <code>resultMap</code> 会怎样，这也是解决列名不匹配的另外一种方式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.someapp.model.User&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;hashed_password&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在引用它的语句中设置 <code>resultMap</code> 属性就行了（注意我们去掉了 <code>resultType</code> 属性）。比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsers&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userResultMap&quot;</span>&gt;</span><br>  select user_id, user_name, hashed_password<br>  from some_table<br>  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="resultMap-元素的概念视图"><a href="#resultMap-元素的概念视图" class="headerlink" title="resultMap 元素的概念视图"></a><code>resultMap</code> 元素的概念视图</h3><ul><li><code>constructor</code>- 用于在实例化类时，注入结果到构造方法中<ul><li><code>idArg</code> - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能</li><li><code>arg</code> - 将被注入到构造方法的一个普通结果</li></ul></li><li><code>id</code> – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能</li><li><code>result</code> – 注入到字段或 JavaBean 属性的普通结果</li><li><code>association</code>– 一个复杂类型的关联；许多结果将包装成这种类型<ul><li>嵌套结果映射 – 关联可以是 <code>resultMap</code> 元素，或是对其它结果映射的引用</li></ul></li><li><code>collection</code>– 一个复杂类型的集合<ul><li>嵌套结果映射 – 集合可以是 <code>resultMap</code> 元素，或是对其它结果映射的引用</li></ul></li><li><code>discriminator</code>– 使用结果值来决定使用哪个<code>resultMap</code><ul><li><code>case</code> – 基于某些值的结果映射<ul><li>嵌套结果映射 – <code>case</code> 也是一个结果映射，因此具有相同的结构和元素；或者引用其它的结果映射</li></ul></li></ul></li></ul><p><strong>最佳实践：</strong> 最好逐步建立结果映射。单元测试可以在这个过程中起到很大帮助。 如果你尝试一次性创建像上面示例那么巨大的结果映射，不仅容易出错，难度也会直线上升。 所以，从最简单的形态开始，逐步迭代。而且别忘了单元测试！ 有时候，框架的行为像是一个黑盒子（无论是否开源）。因此，为了确保实现的行为与你的期望相一致，最好编写单元测试。 并且单元测试在提交 bug 时也能起到很大的作用。</p><h4 id="id-result"><a href="#id-result" class="headerlink" title="id &amp; result"></a>id &amp; result</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;post_id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;subject&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;post_subject&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这些元素是结果映射的基础。<em>id</em> 和 <em>result</em> 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段。</p><p>这两者之间的唯一不同是，<em>id</em> 元素对应的属性会被标记为对象的标识符，在比较对象实例时使用。 这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>通过修改对象属性的方式，可以满足大多数的数据传输对象（Data Transfer Object, DTO）以及绝大部分领域模型的要求。但有些情况下你想使用不可变类。 一般来说，很少改变或基本不变的包含引用或数据的表，很适合使用不可变类。 构造方法注入允许你在初始化时为类设置属性的值，而不用暴露出公有方法。MyBatis 也支持私有属性和私有 JavaBean 属性来完成注入，但有一些人更青睐于通过构造方法进行注入。 <em>constructor</em> 元素就是为此而生的。</p><p>看看下面这个构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>   <span class="hljs-comment">//...</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(Integer id, String username, <span class="hljs-type">int</span> age)</span> &#123;<br>     <span class="hljs-comment">//...</span><br>  &#125;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了将结果注入构造方法，MyBatis 需要通过某种方式定位相应的构造方法。 在下面的例子中，MyBatis 搜索一个声明了三个形参的构造方法，参数类型以 <code>java.lang.Integer</code>, <code>java.lang.String</code> 和 <code>int</code> 的顺序给出。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">constructor</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">idArg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;int&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;String&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;_int&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">constructor</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;blog_author_id&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Author&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_username&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br></code></pre></td></tr></table></figure><p>关联（association）元素处理<strong>“有一个”</strong>类型的关系。 比如，在我们的示例中，一个博客有一个用户。</p><p>关联结果映射和其它类型的映射工作方式差不多。 你需要指定目标属性名以及属性的<code>javaType</code>（很多时候 MyBatis 可以自己推断出来），在必要的情况下你还可以设置 JDBC 类型，如果你想覆盖获取结果值的过程，还可以设置类型处理器。</p><p>关联的不同之处是，你需要告诉 MyBatis 如何加载关联。MyBatis 有两种不同的方式加载关联：</p><ul><li>嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。</li><li>嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。</li></ul><h5 id="关联的嵌套-Select-查询"><a href="#关联的嵌套-Select-查询" class="headerlink" title="关联的嵌套 Select 查询"></a>关联的嵌套 Select 查询</h5><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blogResult&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_id&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Author&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;selectAuthor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBlog&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;blogResult&quot;</span>&gt;</span><br>  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAuthor&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Author&quot;</span>&gt;</span><br>  SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>就是这么简单。我们有两个 select 查询语句：一个用来加载博客（Blog），另外一个用来加载作者（Author），而且博客的结果映射描述了应该使用 <code>selectAuthor</code> 语句加载它的 author 属性。</p><p>其它所有的属性将会被自动加载，只要它们的列名和属性名相匹配。</p><p>这种方式虽然很简单，但在大型数据集或大型数据表上表现不佳。这个问题被称为<strong>“N+1 查询问题”</strong>。 概括地讲，N+1 查询问题是这样子的：</p><ul><li>你执行了一个单独的 SQL 语句来获取结果的一个列表（就是“+1”）。</li><li>对列表返回的每条记录，你执行一个 select 查询语句来为每条记录加载详细信息（就是“N”）。</li></ul><p>这个问题会导致成百上千的 SQL 语句被执行。有时候，我们不希望产生这样的后果。</p><p>好消息是，MyBatis 能够对这样的查询进行延迟加载，因此可以将大量语句同时运行的开销分散开来。 然而，如果你加载记录列表之后立刻就遍历列表以获取嵌套的数据，就会触发所有的延迟加载查询，性能可能会变得很糟糕。</p><h5 id="关联的嵌套结果映射"><a href="#关联的嵌套结果映射" class="headerlink" title="关联的嵌套结果映射"></a>关联的嵌套结果映射</h5><p>下面的例子则是一个非常简单的例子，用于演示嵌套结果映射如何工作。 现在我们将博客表和作者表连接在一起，而不是执行一个独立的查询语句，就像这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBlog&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;blogResult&quot;</span>&gt;</span><br>  select<br>    B.id            as blog_id,<br>    B.title         as blog_title,<br>    B.author_id     as blog_author_id,<br>    A.id            as author_id,<br>    A.username      as author_username,<br>    A.password      as author_password,<br>    A.email         as author_email,<br>    A.bio           as author_bio<br>  from Blog B left outer join Author A on B.author_id = A.id<br>  where B.id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意查询中的连接，以及为确保结果能够拥有唯一且清晰的名字，我们设置的别名。 这使得进行映射非常简单。现在我们可以映射这个结果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blogResult&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;blog_id&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;blog_title&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;blog_author_id&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Author&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;authorResult&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;authorResult&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Author&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_username&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_password&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_email&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;bio&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;author_bio&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，你可以看到，博客（Blog）作者（author）的关联元素委托名为 “authorResult” 的结果映射来加载作者对象的实例。</p><p><strong>非常重要</strong>： id 元素在嵌套结果映射中扮演着非常重要的角色。你应该总是指定一个或多个可以唯一标识结果的属性。 虽然，即使不指定这个属性，MyBatis 仍然可以工作，但是会产生严重的性能问题。 只需要指定可以唯一标识结果的最少属性。显然，你可以选择主键（复合主键也可以）。</p><h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><p>MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 为了使它更加强大而且易于配置，我们对 MyBatis 3 中的缓存实现进行了许多改进。</p><p>默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>基本上就是这样。这个简单语句的效果如下:</p><ul><li>映射语句文件中的所有 <strong>select</strong> 语句的结果将会被缓存。</li><li>映射语句文件中的所有 <strong>insert、update 和 delete</strong> 语句会刷新缓存。</li><li>缓存会使用最近最少使用算法（<strong>LRU</strong>, Least Recently Used）算法来清除不需要的缓存。</li><li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li><li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li><li>缓存会被视为读&#x2F;写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li></ul><h2 id="cache-ref"><a href="#cache-ref" class="headerlink" title="cache-ref"></a>cache-ref</h2><p>回想一下上一节的内容，对某一命名空间的语句，只会使用该命名空间的缓存进行缓存或刷新。 但你可能会想要在多个命名空间中共享相同的缓存配置和实例。要实现这种需求，你可以使用 cache-ref 元素来引用另一个缓存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache-ref</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.someone.application.data.SomeMapper&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><h3 id="一个条件"><a href="#一个条件" class="headerlink" title="一个条件"></a>一个条件</h3><p>使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogWithTitleLike&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  SELECT * FROM BLOG<br>  WHERE state = ‘ACTIVE’<br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>    AND title like #&#123;title&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果（细心的读者可能会发现，“title” 的参数值需要包含查找掩码或通配符字符）。</p><p>这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果（细心的读者可能会发现，“title” 的参数值需要包含查找掩码或通配符字符）。</p><h3 id="多个条件"><a href="#多个条件" class="headerlink" title="多个条件"></a>多个条件</h3><p>如果希望通过 “title” 和 “author” 两个参数进行可选搜索该怎么办呢？首先，我想先将语句名称修改成更名副其实的名称；接下来，只需要加入另一个条件即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  SELECT * FROM BLOG WHERE state = ‘ACTIVE’<br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>    AND title like #&#123;title&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>    AND author_name like #&#123;author.name&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose, when, otherwise"></a>choose, when, otherwise</h2><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><p>还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员精选的 Blog）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  SELECT * FROM BLOG WHERE state = ‘ACTIVE’<br>  <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>      AND title like #&#123;title&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>      AND author_name like #&#123;author.name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>      AND featured = 1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim, where, set"></a>trim, where, set</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>前面几个例子已经方便地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，这次我们将 “state &#x3D; ‘ACTIVE’” 设置成动态条件，看看会发生什么。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  SELECT * FROM BLOG<br>  WHERE<br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;state != null&quot;</span>&gt;</span><br>    state = #&#123;state&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>    AND title like #&#123;title&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>    AND author_name like #&#123;author.name&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> BLOG<br><span class="hljs-keyword">WHERE</span><br></code></pre></td></tr></table></figure><p>这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> BLOG<br><span class="hljs-keyword">WHERE</span><br><span class="hljs-keyword">AND</span> title <span class="hljs-keyword">like</span> ‘someTitle’<br></code></pre></td></tr></table></figure><p>这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。</p><p>MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  SELECT * FROM BLOG<br>  <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;state != null&quot;</span>&gt;</span><br>         state = #&#123;state&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>        AND title like #&#123;title&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>        AND author_name like #&#123;author.name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。</p><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>如果 <em>where</em> 元素与你期望的不太一样，你也可以通过<strong>自定义 trim 元素</strong>来定制 <em>where</em> 元素的功能。比如，和 <em>where</em> 元素等价的自定义 trim 元素为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;WHERE&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;AND |OR &quot;</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>prefixOverrides</em> 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 <em>prefixOverrides</em> 属性中指定的内容，并且插入 <em>prefix</em> 属性中指定的内容。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>用于动态<code>update</code>语句的类似解决方案叫做 <em>set</em>。<em>set</em> 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span><br>  update Author<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>  where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个例子中，<em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p><p>或者，你可以通过使用<em>trim</em>元素来达到同样的效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;SET&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意，我们覆盖了后缀值设置，并且自定义了前缀值。</p><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPostIn&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;domain.blog.Post&quot;</span>&gt;</span><br>  SELECT *<br>  FROM POST P<br>  <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;ID in (&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">nullable</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>          #&#123;item&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>foreach</em> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！</p><p><strong>提示：</strong>你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p><h2 id="script"><a href="#script" class="headerlink" title="script"></a>script</h2><p>要在带注解的映射器接口类中使用动态 SQL，可以使用 <em>script</em> 元素。比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Update(&#123;&quot;&lt;script&gt;&quot;,</span><br><span class="hljs-meta">  &quot;update Author&quot;,</span><br><span class="hljs-meta">  &quot;  &lt;set&gt;&quot;,</span><br><span class="hljs-meta">  &quot;    &lt;if test=&#x27;username != null&#x27;&gt;username=#&#123;username&#125;,&lt;/if&gt;&quot;,</span><br><span class="hljs-meta">  &quot;    &lt;if test=&#x27;password != null&#x27;&gt;password=#&#123;password&#125;,&lt;/if&gt;&quot;,</span><br><span class="hljs-meta">  &quot;    &lt;if test=&#x27;email != null&#x27;&gt;email=#&#123;email&#125;,&lt;/if&gt;&quot;,</span><br><span class="hljs-meta">  &quot;    &lt;if test=&#x27;bio != null&#x27;&gt;bio=#&#123;bio&#125;&lt;/if&gt;&quot;,</span><br><span class="hljs-meta">  &quot;  &lt;/set&gt;&quot;,</span><br><span class="hljs-meta">  &quot;where id=#&#123;id&#125;&quot;,</span><br><span class="hljs-meta">  &quot;&lt;/script&gt;&quot;&#125;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">updateAuthorValues</span><span class="hljs-params">(Author author)</span>;<br></code></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><code>bind</code> 元素允许你在 OGNL (Object Graph Navigation Language) 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectBlogsLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#x27;%&#x27; + _parameter.getTitle() + &#x27;%&#x27;&quot;</span> /&gt;</span><br>  SELECT * FROM BLOG<br>  WHERE title LIKE #&#123;pattern&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>backend</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis中#{}和${}的区别是什么？</title>
    <link href="/posts/86821ae5.html"/>
    <url>/posts/86821ae5.html</url>
    
    <content type="html"><![CDATA[<p>动态 sql 是 MyBatis 的主要特性之一，在 mapper 中定义的参数传到 xml 中之后，在查询之前 MyBatis 会对其进行动态解析。MyBatis 为我们提供了两种支持动态 sql 的语法：#{} 以及 ${}。</p><h2 id="一句话回答"><a href="#一句话回答" class="headerlink" title="一句话回答"></a>一句话回答</h2><p>#{}是预编译处理，${}是字符串替换。</p><h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h2><ul><li><p>MyBatis在处理#{}时，会将SQL中的#{}替换为?号，使用PreparedStatement的set方法来赋值；</p></li><li><p>而MyBatis在处理${}时，直接把${}替换成变量的值。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPerson&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;hashmap&quot;</span>&gt;</span><br>  SELECT * FROM PERSON WHERE ID = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p><p>注意参数符号：#{id}</p><p>这就告诉 MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 近似的 JDBC 代码，非 MyBatis 代码...</span><br><span class="hljs-type">String</span> <span class="hljs-variable">selectPerson</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT * FROM PERSON WHERE ID = ?&quot;</span>;<br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> conn.prepareStatement(selectPerson);<br>ps.setInt(<span class="hljs-number">1</span>,id);<br></code></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="防止恶意SQL注入示例"><a href="#防止恶意SQL注入示例" class="headerlink" title="防止恶意SQL注入示例"></a>防止恶意SQL注入示例</h3><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from tb_name where name = &#x27;&quot;</span> + varname + <span class="hljs-string">&quot;&#x27; and passwd = &#x27;&quot;</span> + varpasswd + <span class="hljs-string">&quot;&#x27; &quot;</span>;<br></code></pre></td></tr></table></figure><p>如果我们把<code>[ &#39; or&#39;1&#39;=&#39;1&#39;]</code>作为<code>varpasswd</code>传入进来.用户名随意,看看会成为什么?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;随意&#x27;</span> <span class="hljs-keyword">and</span> passwd <span class="hljs-operator">=</span> <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span>;<br></code></pre></td></tr></table></figure><p>因为’1’&#x3D;’1’肯定成立,所以可以任何通过验证</p><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> $&#123;tableName&#125; <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> #&#123;name&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，如果${tableName}传入<code>user; delete user; --</code></p><p>则动态解析之后 sql 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>; <span class="hljs-keyword">delete</span> <span class="hljs-keyword">user</span>; <span class="hljs-comment">-- where name = ?;</span><br></code></pre></td></tr></table></figure><p>–之后的语句被注释掉，而原本查询用户的语句变成了查询所有用户信息+删除用户表的语句，会对数据库造成重大损伤，极大可能导致服务器宕机。</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>指的是数据库驱动在发送 sql 语句和参数给 DBMS 之前对 sql 语句进行编译，这样 DBMS 执行 sql 时，就不需要重新编译。</p><h5 id="为什么需要预编译"><a href="#为什么需要预编译" class="headerlink" title="为什么需要预编译?"></a>为什么需要预编译?</h5><p>预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作。而预编译机制则可以很好的防止SQL注入。</p><p>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。</p><ol><li><p><strong>预编译阶段可以优化 sql 的执行</strong>。</p><ul><li>预编译之后的 sql 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的sql，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。</li></ul></li><li><p><strong>预编译语句对象可以重复利用</strong>。</p><ul><li>把一个 sql 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个sql，可以直接使用这个缓存的 PreparedState 对象。</li></ul></li></ol><p>MyBatis 默认情况下，将对所有的 sql 进行预编译。</p><h3 id="MyBatis-sql-动态解析"><a href="#MyBatis-sql-动态解析" class="headerlink" title="MyBatis sql 动态解析"></a>MyBatis sql 动态解析</h3><p>MyBatis 在调用 connection 进行 sql 预编译之前，会对sql语句进行动态解析，动态解析主要包含如下的功能：</p><ul><li><p>占位符的处理</p></li><li><p>动态sql的处理</p></li><li><p>参数类型校验</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>backend</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>码出高效读书笔记2-面向对象</title>
    <link href="/posts/906539fa.html"/>
    <url>/posts/906539fa.html</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p><img src="https://s2.loli.net/2023/10/26/hlvCdauSt7I6NMA.png" alt="访问权限控制及可见范围.png"></p><ul><li>如果不允许外部直接通过 new 创建对象，构造方法必须是 private。</li><li>工具类不允许有 public 或 default 构造方法。</li></ul><h3 id="this和super"><a href="#this和super" class="headerlink" title="this和super"></a>this和super</h3><p><img src="https://s2.loli.net/2023/10/26/Fx2lKfmdSgryw8X.png" alt="this和super的异同点.png"></p><ul><li><p>在一个构造方法中， this 和 super 只能出现一个，且只能出现一次，否则在实例化对象时，会因子类调用到多个父类构造方法而造成混乱。</p></li><li><p>由于 this 和 super都在实例化阶段调用，所以不能在<strong>静态方法</strong>和<strong>静态代码块</strong>申使用 this 和 super 关键字。</p></li></ul><h3 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h3><p>类与类之间的关系可分成两种·有关系与没关系，难点在于确定类与类之间是否存在相互作用。证明类之间没关系是一个涉及业务、架构、模块边界的问 题，往往由于业务模型的抽象角度不同而不同，是一件非常棘手的事情。如果找到了 没有关系的点，就可以如庖丁解牛一样，进行架构隔离、模块解耦等工作。</p><p>类与类有关系的情况，包括以下5种类型：</p><ul><li>【继承】 extends (is-a)。</li><li>【实现】 implements (can-do)。</li><li>【组合】 类是成员变量 (contains-a)。</li><li>【聚合】 类是成员变量(has-a)。</li><li>【依赖】 import类(use-a)。</li></ul><p>随着业务和架构的发展，类与类的关系是会发生变化的，必须用发展的眼光看待类图。</p><p>在业务重构过程中，往往会把原来强组合的关系拆开来，供其他模块调用，这就是类图的一种演变。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>常见的序列化方式有三种：</p><ol><li><strong>Java 原生序列化。</strong>Java类通过实现 Serializable接口来实现该类对象的序列化，这个接口非常特殊，没有任何方法，只起标识作用。<ul><li>实现 Serializable 接口的类要显式设置 serialVersionUID 字段值，否则类源码修改后该值会发生变化。<ul><li>如果是兼容升级，请不要修改 seria!VersionUID 字段 ， 避免反序列化失败。</li><li>如果是不兼容升级，需要修改 serialVersionUID 值，避免反序列化混乱。</li></ul></li><li>Java 反序列化时不会调用类的无参构造方法，而 是调用 native 方法将成员变量赋值为对应类型的初始值。基于性能及兼容性考虑，不 推荐使用 Java 原生序列化。</li></ul></li><li><strong>Hessian 序列化。</strong>压缩编码，比Java原生序列化二进制流小且耗时短。特性：<ul><li>自描述序列化类型。不依赖外部描述文件或接口定义 ， 用一个字节表示常用 基础类型 ， 极大缩短二进制流。</li><li>语言无关，支持脚本语言。</li><li>协议简单，比 Java 原生序列化高效。</li></ul></li><li><strong>JSON 序列化。</strong>JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。JSON 序列化就是将数据对象转换为 JSON 字符串。在序列化过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确地反序列化。相比前两种方式， JSON 可读性比较好，方便调试。</li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="参数预处理"><a href="#参数预处理" class="headerlink" title="参数预处理"></a>参数预处理</h4><h5 id="1-入参保护"><a href="#1-入参保护" class="headerlink" title="1. 入参保护"></a>1. 入参保护</h5><p>人参保护实质上是对服务提供方的保护，常见于批量接口。</p><p>虽然批量接口能处理批数据，但其处理能力并不是无限的，因此需要<strong>对入参的数据量进行判断和控制</strong>，如果超出处理能力，可以直接返回错误给客户端。</p><h5 id="2-参数校验"><a href="#2-参数校验" class="headerlink" title="2. 参数校验"></a>2. 参数校验</h5><p>需要进行参数校验的场景：</p><ul><li>调用频度低的方法。</li><li>执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退或者错误，则得不偿失。</li><li>需要极高稳定性和可用性的方法。 </li><li>对外提供的开放接口。</li><li>敏感权限入口。</li></ul><p>不需要进行参数校验的场景：</p><ul><li>极有可能被<strong>循环调用</strong>的方法。但在方法说明里必须注明外部参数检查。</li><li><strong>底层调用频度较高</strong>的方法。参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同个应用中，部署在同一台服务器中，所以可以省略 DAO 的参数校验。</li><li>声明成 <strong>private</strong> 只会被自己代码调用的方法。如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>单一职责</strong>对于构造方法同样适用，构造方法的使命就是在构造对象时进行传参操作，所以不应该在构造方法中引入业务逻辑。</p><p>如果在一个对象生产中 ，需要完成初始化上下游对象、分配内存、执行静态方法、赋值句柄等繁重的工作，其中某个步骤出错，导致没有完成对象初始化，再将希望寄托于业务逻辑部分来处理异常就是一件不受控制的事情了。故推荐将初始化业务逻辑放在某个方法中，比如<code>init()</code>， 当对象确认完成所有初始化工作之后，再显式调用。</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>OOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Easy Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法模板6-1.数学-数论</title>
    <link href="/posts/16da4355.html"/>
    <url>/posts/16da4355.html</url>
    
    <content type="html"><![CDATA[<h1 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对所有大于1的整数，如果只包含<code>1和本身</code>这两个约数，就被称为质数，或者叫素数。</p><blockquote><p>所有&lt;&#x3D;1的数，既不是质数也不是合数</p></blockquote><h2 id="判定：试除法"><a href="#判定：试除法" class="headerlink" title="判定：试除法"></a>判定：试除法</h2><h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>时间复杂度$O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化做法"><a href="#优化做法" class="headerlink" title="优化做法"></a>优化做法</h3><p>利用性质：如果 $d\ |\ n$，那么也一定有 $\frac{n}{d}\ |\ n$。</p><blockquote><p>$d\ |\ n$ 表示d能被n整除，即n是d的约数。</p></blockquote><p>所以对于每个$d$，只要枚举到 $d &lt;&#x3D; \frac{n}{d}$ 即可，即 $d^2 &lt;&#x3D; n$， 时间复杂度一定为 $O(\sqrt{n})$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i ++)<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分解质因数：试除法"><a href="#分解质因数：试除法" class="headerlink" title="分解质因数：试除法"></a>分解质因数：试除法</h2><h3 id="朴素做法-1"><a href="#朴素做法-1" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>从小到大枚举所有可能的质因数，时间复杂度$O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; x; i ++)<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) <span class="hljs-comment">// i一定是质数</span><br>        &#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;<br>        &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化做法-1"><a href="#优化做法-1" class="headerlink" title="优化做法"></a>优化做法</h3><p>性质：n中最多只包含一个大于 $\sqrt{n}$ 的质因子。</p><p>所以枚举到 $\sqrt{n}$ 即可，时间复杂度最坏为 $O(\sqrt{n})$，因为n在枚举过程中在不断变小，最好时间复杂度仅为 $O(logn)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++)<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl; <span class="hljs-comment">// 单独处理可能大于sqrt(n)的那个质因子</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h2><h3 id="朴素做法-2"><a href="#朴素做法-2" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>从小到大枚举，把每个数所有的倍数删掉。如遍历到2，删除4，6，8，10，12。</p><p>时间复杂度：$O(nlogn)$</p><blockquote><p>总运算次数：</p><p>$\lim_{n\to INF}\frac{n}{2} + \frac{n}{3} + … + \frac{n}{n}$</p><p>$&#x3D;\lim_{n\to INF} n (\frac{1}{2} + \frac{1}{3} + … + \frac{1}{n})$</p><p>$&#x3D;n\ln(n)$</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            prime[cnt ++] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i) st[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化做法：埃式筛法"><a href="#优化做法：埃式筛法" class="headerlink" title="优化做法：埃式筛法"></a>优化做法：埃式筛法</h3><p>只需要把质数的倍数筛掉即可。当一个数不是质数时，它的倍数一定已经被筛过了。</p><h4 id="时间复杂度分析："><a href="#时间复杂度分析：" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h4><p>质数定理：1~n中有$\frac{n}{ln(n)}$个质数</p><p>时间复杂度估计：$O(\frac{n}{ln(n)}\ ln(n)) &#x3D; O(n)$。</p><blockquote><p>实际上是$O(nloglogn)$，不过loglogn很接近常数。</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            prime[cnt ++] = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i) st[j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化做法：线性筛法（实际使用）"><a href="#优化做法：线性筛法（实际使用）" class="headerlink" title="优化做法：线性筛法（实际使用）"></a>优化做法：线性筛法（实际使用）</h3><p>时间复杂度$O(n)$。</p><p>当枚举到<code>i</code>时，把<code>已经筛出来的所有质数与i的乘积</code>筛出去。</p><p>核心思路：每个合数<code>x</code>只会被它的最小质因子筛掉。每个数只有一个最小质因子，所以每个数只会被筛一次，所以算法是线性的。</p><blockquote><ol><li>i % pj &#x3D;&#x3D; 0 &#x3D;&gt; pj一定是i的最小质因子，故pj一定是pj * i的最小质因子</li><li>i % pj !&#x3D; 0 &#x3D;&gt; pj一定小于i的所有质因子（因为pj从小到大枚举，还没break），故pj也一定是pj * i的最小质因子</li></ol></blockquote><p>所有的合数都一定会被筛掉：</p><p>因为对于一个合数x，假设pj是x的最小质因子，i一定先枚举到x &#x2F; pj，这个时候x已经被筛掉了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) prime[cnt ++] = i;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; prime[j] &lt;= n / i; j ++) <span class="hljs-comment">// 不用写j &lt; cnt，因为当i为合数的时候，prime[j]枚举到i的最小质因子时就会停下来；当i为质数的时候，枚举到prime[j]=i时也会停下来</span><br>        &#123;<br>          st[prime[j] * i] = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 保证prime[j]一定是i的最小质因子</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h1>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式28-访问者模式</title>
    <link href="/posts/f95aacf0.html"/>
    <url>/posts/f95aacf0.html</url>
    
    <content type="html"><![CDATA[<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>访问者模式（Visitor），表示一个作用于某对象结构中的各元素的操作。它使你可以在<strong>不改变各元素的类</strong>的前提下<strong>定义作用于这些元素的新操作</strong>。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/11/05/vbx824mMZzaQokf.jpg" alt="访问者模式结构图.jpg"></p><p>访问者模式适用于数据结构相对稳定（Element种类数量不变）的系统。</p><p>它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Visitor</code>类：为该对象结构中<code>ConcreteElement</code>的每一个类声明一个Visit操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Visitor</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitConcreteElementA</span><span class="hljs-params">(ConcreteElementA concreteElementA)</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitConcreteElementB</span><span class="hljs-params">(ConcreteElementB concreteElementB)</span>;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteVisitor1</code>和<code>ConcreteVisitor2</code>类：具体访问者， 实现每个由Visitor声明的操作。每个操作实现算法的一部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitor1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Visitor</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitConcreteElementA</span><span class="hljs-params">(ConcreteElementA concreteElementA)</span> &#123;<br>    System.out.println(concreteElementA.getClass().getSimpleName() + <span class="hljs-string">&quot;被&quot;</span> + <span class="hljs-built_in">this</span>.getClass().getSimpleName() + <span class="hljs-string">&quot;访问&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitConcreteElementB</span><span class="hljs-params">(ConcreteElementB concreteElementB)</span> &#123;<br>    System.out.println(concreteElementB.getClass().getSimpleName() + <span class="hljs-string">&quot;被&quot;</span> + <span class="hljs-built_in">this</span>.getClass().getSimpleName() + <span class="hljs-string">&quot;访问&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitor2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Visitor</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitConcreteElementA</span><span class="hljs-params">(ConcreteElementA concreteElementA)</span> &#123;<br>    System.out.println(concreteElementA.getClass().getSimpleName() + <span class="hljs-string">&quot;被&quot;</span> + <span class="hljs-built_in">this</span>.getClass().getSimpleName() + <span class="hljs-string">&quot;访问&quot;</span>);<br>  &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitConcreteElementB</span><span class="hljs-params">(ConcreteElementB concreteElementB)</span> &#123;<br>    System.out.println(concreteElementB.getClass().getSimpleName() + <span class="hljs-string">&quot;被&quot;</span> + <span class="hljs-built_in">this</span>.getClass().getSimpleName() + <span class="hljs-string">&quot;访问&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Element</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Element</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span>;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteElementA</code>类和<code>ConcreteElementB</code>类：具体元素，实现accept操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;<br>    visitor.visitConcreteElementA(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 利用双分派技术，实现处理与数据结构的分离</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationA</span><span class="hljs-params">()</span> &#123;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;<br>    visitor.visitConcreteElementB(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 利用双分派技术，实现处理与数据结构的分离</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationB</span><span class="hljs-params">()</span> &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ObjectStructure</code>类：能枚举<code>ConcreteElement</code>，可以提供一个高层的接口以允许访问者访问它的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectStructure</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> ArrayList&lt;Element&gt; elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Element element)</span> &#123;<br>    elements.add(element);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Element element)</span> &#123;<br>    elements.remove(element);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Element e : elements) &#123;<br>      e.accept(visitor);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectStructure</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectStructure</span>();<br>o.attach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteElementA</span>());<br>o.attach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteElementB</span>());<br><br><span class="hljs-type">ConcreteVisitor1</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteVisitor1</span>();<br><span class="hljs-type">ConcreteVisitor2</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteVisitor2</span>();<br><br>o.accept(v1);<br>o.accept(v2);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>访问者模式的目的是把<strong>处理操作</strong>从<strong>元素的数据结构</strong>分离出来。</p><blockquote><p>很多系统可以按照算法和数据结构分开，如果这样的系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较合适的，因为访问者模式使得算法操作的增加变得容易。</p></blockquote><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。</p><p>访问者模式将有关的行为集中到一个访问者对象中。</p><blockquote><p>通常ConcreteVisitor可以单独开发，不必跟ConcreteElementA或ConcreteElementB写在一起。正因为这样，ConcreteVisitor能提高ConcreteElement之间的独立性，如果把一个处理动作设计成ConcreteElementA和ConcreteElementB类的方法，每次想新增’处理’以扩充功能时就得去修改ConcreteElementA和ConcreteElementB了。</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>使增加新的数据结构（元素）变得困难。</p><blockquote><p>大多时候你并不需要访问者模式，但当一旦你需要访问者模式时，那就是真的需要它了。</p><p>事实上，我们很难找到数据结构不变化的情况，所以用访问者模式的机会也就不太多了。</p></blockquote><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="双分派技术"><a href="#双分派技术" class="headerlink" title="双分派技术"></a>双分派技术</h3><p>双分派意味着得到执行的操作决定于请求的种类和两个接收者的类型。</p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法时空复杂度分析</title>
    <link href="/posts/bf4710f3.html"/>
    <url>/posts/bf4710f3.html</url>
    
    <content type="html"><![CDATA[<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="由数据范围反推算法复杂度以及算法内容"><a href="#由数据范围反推算法复杂度以及算法内容" class="headerlink" title="由数据范围反推算法复杂度以及算法内容"></a>由数据范围反推算法复杂度以及算法内容</h2><p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 $10^7∼10^8$ 为最佳。</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><ol><li>$n≤30$ &#x3D;&gt; 指数级别：dfs+剪枝，状态压缩DP</li><li>$n≤100$ &#x3D;&gt; $O(n^3)$：Floyd，DP，高斯消元</li><li>$n≤1000$ &#x3D;&gt; $O(n^2), O(n^2logn)$ ：DP，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</li><li>$n≤10^4$ &#x3D;&gt; $O(n*\sqrt n)$：块状链表、分块、莫队</li><li>$n≤10^5$ &#x3D;&gt; $O(nlogn)$：各种sort，线段树、树状数组、set&#x2F;map、heap、拓扑排序、Dijkstra+heap、Prim+heap、Kruskal、SPFA、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</li><li>$n≤10^6$ &#x3D;&gt; $O(n)$： 单调队列、hash、双指针扫描、BFS、并查集，KMP、AC自动机；以及常数比较小的$O(nlogn)$算法：sort、树状数组、heap、Dijkstra、SPFA</li><li>$n≤10^7$ &#x3D;&gt; $O(n)$：双指针扫描、KMP、AC自动机、线性筛素数</li><li>$n≤10^9$ &#x3D;&gt; $O(\sqrt n)$：判断质数</li><li>$n≤10^{18}$ &#x3D;&gt; $O(logn)$：最大公约数，快速幂，数位DP</li><li>$n≤10^{1000}$ &#x3D;&gt; $O((logn)^2)$：高精度加减乘除</li><li>$n≤10^{100000}$ &#x3D;&gt; $O(logk * loglogk)$，k表示位数：高精度加减、FFT&#x2F;NTT</li></ol><blockquote><p>SPFA，匈牙利，最大流的理论复杂度高，但实际几乎为线性</p></blockquote><h2 id="分析时间复杂度的方法"><a href="#分析时间复杂度的方法" class="headerlink" title="分析时间复杂度的方法"></a>分析时间复杂度的方法</h2><ol><li>循环：看循环的层数</li><li>递归：<ol><li>主定理，看递推关系式$T(n) &#x3D; aT(\frac{n}{b}) + f(n)$，然后分情况，较复杂</li><li>看层数，如快排，每层递归是$O(n)$，一共$logn$层，所以时间复杂度为$O(nlogn)$</li></ol></li></ol><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>一般空间限制：$64MB$。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span>: <span class="hljs-number">4</span> <span class="hljs-keyword">Byte</span><br><span class="hljs-keyword">char</span>: <span class="hljs-number">1</span> <span class="hljs-keyword">Byte</span><br><span class="hljs-keyword">double</span>, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>: <span class="hljs-number">8</span> <span class="hljs-keyword">Byte</span><br><br><span class="hljs-number">64</span>MB = <span class="hljs-number">2</span>^<span class="hljs-number">26</span> <span class="hljs-keyword">Byte</span><br>能开多少<span class="hljs-keyword">int</span>变量？<br><span class="hljs-number">2</span>^<span class="hljs-number">26</span> / <span class="hljs-number">4</span> = <span class="hljs-number">2</span> ^ <span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><blockquote><p>注：操作系统有优化，数组是用的时候再临时分配内存。</p><p>如果只开了数组，没有用那么多的话，用sizeof算出来超内存也不会MLE。</p></blockquote><p>递归会使用系统栈，即使没有额外开数组，也会占用系统空间。如快排的额外空间复杂度是$O(logn)$的。</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式15-抽象工厂模式</title>
    <link href="/posts/87e8a40d.html"/>
    <url>/posts/87e8a40d.html</url>
    
    <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>抽象工厂模式（Abstract Factory），提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p><blockquote><p>与工厂方法模式的区别：</p><p>以操作不同数据库为例：只有一个User类和User操作类的时候，是只需要工厂方法模式的，但现在显然你数据库中有很多的表，而SQL Server与Access又是两大不同的分类，所以解决这种涉及<strong>多个产品系列</strong>的问题，有一个专门的工厂模式叫抽象工厂模式。</p></blockquote><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/11/RILujqhdlvWVsQF.png" alt="抽象工厂模式结构图.png"></p><p>AbstractProductA和AbstractProductB是两个抽象产品，之所以为抽象，是因为它们都有可能有两种不同的实现，比如对两种数据库中某一张表的操作。</p><p>ProductA1、ProductA2和ProductB1、ProductB2就是对两个抽象产品的具体分类的实现。</p><p>IFactory是一个抽象工厂接口，它里面应该包含所有的产品创建的抽象方法。</p><p>而ConcreteFactory1和ConcreteFactory2就是具体的工厂了，就像SqlserverFactory和AccessFactory一样。</p><blockquote><p>通常是在<strong>运行时刻</strong>再创建一个ConcreteFactory类的实例，这个具体的工厂再创建具有特定实现的产品对象，也就是说，为创建不同的产品对象，客户端应使用不同的具体工厂。</p></blockquote><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p><strong>易于交换产品系列</strong>。由于具体工厂类，例如 <code>IFactory factory = new AccessFactory()</code>，在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易（只在初始化的地方改一行就行），它只需要改变具体工厂即可使用不同的产品配置。</p><blockquote><p>我们的设计不能去防止需求的更改，那么我们的理想便是让改动变得最小，现在如果你要更改数据库访问，我们只需要更改具体工厂就可以做到。</p></blockquote></li><li><p><strong>让具体的创建实例过程与客户端分离</strong>。客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。</p><blockquote><p>比如换数据库的例子，客户端所认识的只有IUser和IDepartment，至于它是用SQL Server来实现还是Access来实现就不知道了。</p></blockquote></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>如果需求来自添加功能（比如添加数据库中的一张表），需要增加三个类： IProject、SqlserverProject、AccessProject ，还需要更改三个类：IFactory 、SqlserverFactory 和AccessFactory才可以完全实现。</li><li>客户端程序类很多的情况下，还是需要改很多行 <code>IFactory factory = new AccessFactory()</code>这样的代码。</li></ul><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="1-用简单工厂来改进抽象工厂"><a href="#1-用简单工厂来改进抽象工厂" class="headerlink" title="1. 用简单工厂来改进抽象工厂"></a>1. 用简单工厂来改进抽象工厂</h3><p>去除IFactory 、SqlserverFactory和AccessFactory三个工厂类，取而代之的是DataAccess类，用一个简单工厂模式来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataAccess</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Sqlserver&quot;</span>; <span class="hljs-comment">// 数据库预设名称，可换成其他</span><br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IUser <span class="hljs-title function_">createUser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">IUser</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-keyword">switch</span>(db) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Sqlserver&quot;</span>:<br>        result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlserverUser</span>();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Access&quot;</span>:<br>        result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccessUser</span>();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样当新增一个表时，只需要修改DataAccess一个类，而不是IFactory 、SqlserverFactory 和AccessFactory这三个类。</p><p>但当新增Oracle数据库时，抽象工厂只需要增加一个OracleFactory，而简单工厂需要在DataAccess类中的每个方法的switch语句中加对应的case。</p><h3 id="2-反射-抽象工厂"><a href="#2-反射-抽象工厂" class="headerlink" title="2. 反射+抽象工厂"></a>2. 反射+抽象工厂</h3><p>使用一种编程方式：依赖注入（Dependency Injection）。</p><p>方式：</p><ol><li><p>专门的IoC容器提供，比如Spring</p></li><li><p>Java反射技术</p><p>将程序由编译时转为运行时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 常规的写法</span><br><span class="hljs-type">IUser</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlserverUser</span>();<br><br><span class="hljs-comment">// 反射的写法</span><br><span class="hljs-type">IUser</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (IUser)Class.forName(<span class="hljs-string">&quot;pathxxx.xxx.abstractfactory.SqlserverUser&quot;</span>).getDeclaredConstructor().newInstance();<br></code></pre></td></tr></table></figure><p>由于forName传参是字符串，所以可以用变量来处理，根据需要来更换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DataAccess类，用反射技术，取代IFactory、SqlserverFactory和AccessFactory</span><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataAccess</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">assemblyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pathxxx.xxx.abstractfactory.&quot;</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Sqlserver&quot;</span>; <span class="hljs-comment">// 数据库预设名称，可换成其他</span><br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IUser <span class="hljs-title function_">createUser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (IUser)getInstance(assemblyName + db + <span class="hljs-string">&quot;User&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getInstance</span><span class="hljs-params">(String className)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      result = Class.forName(className).getDeclaredConstructor().newInstance();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IvocationTargetException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>现在如果我们增加了Oracle数据访问，相关类的增加（如OracleUser, OracleDepartment）是不可避免的，这点无论我们用任何办法都解决不了，不过这叫扩展，<strong>开放-封闭原则</strong>告诉我们，<strong>对于扩展，我们开放。但对于修改，我们应该要尽量关闭。</strong></p><p>现在如果需要增加Oracle数据库的访问，只需要更改 <code>private static String db =&quot;Sqlserver&quot;;</code> 为<code>private static String db = &quot;Oracle&quot;;</code></p><p>如果要增加Project表产品，只需要增加三个与Project相关的类 IProject、SqlserverProject、AccessProject，再修改DataAccesss，在其中增加一个public static IProject createProject()方法即可。</p><h3 id="3-反射-配置文件-抽象工厂"><a href="#3-反射-配置文件-抽象工厂" class="headerlink" title="3. 反射+配置文件+抽象工厂"></a>3. 反射+配置文件+抽象工厂</h3><p>反射+抽象工厂问题：</p><p>在更换数据库访问时，我还是需要去改程序（改db这个字符串的值）重编译，如果可以不改程序，那才是真正地符合开放-封闭原则。</p><p>解决：</p><p>利用配置文件来解决更改DataAccess的问题。读文件来给DB字符串赋值，在配置文件中写明是Sqlserver还是Access，这样就连DataAccess类也不用更改了。</p><ol><li><p>添加一个db.properties文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">db=Sqlserver<br></code></pre></td></tr></table></figure></li><li><p>再更改DataAccess类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加与读取文件内容相关的包</span><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataAccess</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">assemblyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pathxxx.xxx.abstractfactory.&quot;</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getDb</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>      <span class="hljs-comment">// 需要将db.properties文件放到要编译的class目录中，并确保下面path路径与实际db.properties文件路径一致。否则会报No such file or directory错误</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;/pathxxx/xxx/abstractfactory/db.properties&quot;</span>;<br>      System.out.println(<span class="hljs-string">&quot;path: &quot;</span> + path);<br>      <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(path));<br>      properties.load(bufferedReader);<br>      result = properties.getProperty(<span class="hljs-string">&quot;db&quot;</span>); <span class="hljs-comment">// 读取db.properties配置文件中db的内容</span><br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOExceprtion e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IUser <span class="hljs-title function_">createUser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> getDb();<br>    <span class="hljs-keyword">return</span> (IUser)getInstance(assemblyName + db + <span class="hljs-string">&quot;User&quot;</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><p>将来要更换数据库，根本无须重新编译任何代码，只需要更改配置文件就好了。应用了反射+配置文件+抽象工厂模式解决了数据库访问时的可维护、可扩展的问题。</p><blockquote><p>所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合，解决它们难以应对变化，难以维护和扩展的诟病。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式27-解释器模式</title>
    <link href="/posts/6ba28d2e.html"/>
    <url>/posts/6ba28d2e.html</url>
    
    <content type="html"><![CDATA[<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>解释器模式（interpreter），给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/11/04/aJBM9Oxve8oF2tH.jpg" alt="解释器模式结构图.jpg"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>AbstractExpression</code>类：声明一个抽象的解释操作，为抽象语法树中的所有节点所共享</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br>  <br>  <span class="hljs-comment">// 解释操作</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>TerminalExpression</code>（终结符表达式）：实现与文法中的终结符相关联的解释操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TerminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;终端解释器&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NonterminalExpression</code>（非终结符表达式）：为文法中的非终结符实现解释操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NonterminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context context)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;非终端解释器&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Context</code>类：包含解释器之外的一些全局信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> String input;<br>  <span class="hljs-keyword">private</span> String output;<br>  <br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getInput</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.input;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInput</span><span class="hljs-params">(String value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.input = value;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getOutput</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.output;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOutput</span><span class="hljs-params">(String value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.output = value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：构建表示该文法定义的语言中一个特定的句子的抽象语法树。调用解释操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>();<br>ArrayList&lt;AbstractExpression&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>());<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NonterminalExpression</span>());<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>());<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TerminalExpression</span>());<br><br><span class="hljs-keyword">for</span> (AbstractExpression exp : list) &#123;<br>  exp.interpret(context);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>通常当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>容易改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。</li><li>也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写。</li></ul><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p>解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。</p><blockquote><p>高级语言（如Java）的开发：当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理。</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>正则表达式</li><li>浏览器（解释HTML，渲染页面）</li><li>机器人指令</li></ul>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板5-5.贪心-推公式</title>
    <link href="/posts/aef7ba51.html"/>
    <url>/posts/aef7ba51.html</url>
    
    <content type="html"><![CDATA[<h1 id="推公式"><a href="#推公式" class="headerlink" title="推公式"></a>推公式</h1><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="耍杂技的牛"><a href="#耍杂技的牛" class="headerlink" title="耍杂技的牛"></a>耍杂技的牛</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>按照<code>wi+si</code>从小到大的顺序排，最大的危险系数一定是最小的</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>显然算法得出的答案 &gt;&#x3D; 最优解。</p><p>下面证明算法得出的答案 &lt;&#x3D; 最优解：</p><p>假设不是按照<code>wi+si</code>从小到大排序，那么从上到下，一定存在两头相邻的牛：<code>w[i] + s[i] &gt; w[i + 1] + s[i + 1]</code>。交换这两头牛，不影响其他牛的危险系数。</p><ul><li><p>对于第<code>i</code>头牛：危险系数从<code>w - s[i]</code>变成了<code>w + w[i + 1] - s[i]</code></p></li><li><p>对于第<code>i+1</code>头牛：危险系数从<code>w + w[i] - s[i + 1]</code>变成了<code>w - s[i + 1]</code></p></li></ul><p>给每个数都加上<code>s[i] + s[i + 1] - w</code>：</p><ul><li><p>对于第<code>i</code>头牛：危险系数从<code>s[i + 1]</code>变成了<code>w[i + 1] + s[i + 1]</code></p></li><li><p>对于第<code>i+1</code>头牛：危险系数从<code>w[i] + s[i]</code>变成了<code>s[i]</code></p></li></ul><p>由于<code>w[i] + s[i] &gt; w[i + 1] + s[i + 1]</code>，交换后的结果肯定会变小，所以可以调整为从小到大排序</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">50010</span>;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cow</span> &#123;<br>    <span class="hljs-type">int</span> w, s;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Cow &amp;C)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> w + s &lt; C.w + C.s;<br>    &#125;<br>&#125;cow[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;cow[i].w, &amp;cow[i].s);<br>    <br>    <span class="hljs-built_in">sort</span>(cow, cow + n);<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">-2e9</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        res = <span class="hljs-built_in">max</span>(res, sum - cow[i].s);<br>        sum += cow[i].w;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板5-4.贪心-绝对值不等式</title>
    <link href="/posts/9424a82c.html"/>
    <url>/posts/9424a82c.html</url>
    
    <content type="html"><![CDATA[<h1 id="绝对值不等式"><a href="#绝对值不等式" class="headerlink" title="绝对值不等式"></a>绝对值不等式</h1><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="货仓选址"><a href="#货仓选址" class="headerlink" title="货仓选址"></a>货仓选址</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>总距离：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">f(x) = |<span class="hljs-string">x1 - x</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">x2 - x</span>|<span class="hljs-string"> + ... + </span>|<span class="hljs-string">xn - x</span>|<span class="hljs-string"> 求最小值</span><br><span class="hljs-string">= (</span>|<span class="hljs-string">x1 - x</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">xn - x</span>|<span class="hljs-string">) + (</span>|<span class="hljs-string">x2 - x</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">xn-1 - x</span>|<span class="hljs-string">) + ... 两两分组</span><br><span class="hljs-string">&gt;= (xn - x1) + (xn-1 - x2) + ... 当x在每组的两个数之间时，等号成立</span><br><span class="hljs-string">商店数量为奇数时，x取中位数，商店数量为偶数时，取最中间的两个数之间的任意一个位置</span><br></code></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>绝对值公式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <br>    <span class="hljs-built_in">sort</span>(a, a + n);<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) res += <span class="hljs-built_in">abs</span>(a[i] - a[n / <span class="hljs-number">2</span>]);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>双指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    <br>    <span class="hljs-built_in">sort</span>(a, a + n);<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>; i &lt; j; i ++, j --) res += a[j] - a[i];<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板5-3.贪心-排序不等式</title>
    <link href="/posts/fb840512.html"/>
    <url>/posts/fb840512.html</url>
    
    <content type="html"><![CDATA[<h1 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h1><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="排队打水"><a href="#排队打水" class="headerlink" title="排队打水"></a>排队打水</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>总等待时间：<code>t1 * (n-1) + t2 * (n-2) + ... + tn * 0</code></p><p>时间长的人放在后面，时间短的人放在前面</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, t[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t[i]);<br>    <br>    <span class="hljs-built_in">sort</span>(t, t + n);<br>    <br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) res += t[i] * (n - i - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式26-享元模式</title>
    <link href="/posts/8e44fdda.html"/>
    <url>/posts/8e44fdda.html</url>
    
    <content type="html"><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>享元模式（Flyweight），运用共享技术有效地支持大量细粒度的对象。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/11/03/bMCrOhWLicHdA4y.jpg" alt="享元模式结构图.jpg"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Flyweight</code>类：所有具体享元类的超类&#x2F;接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyweight</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(<span class="hljs-type">int</span> extrinsicstate)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteFlyweight</code>：继承<code>Flyweight</code>超类或实现<code>Flyweight</code>接口，并为内部状态增加存储空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要共享的具体Flyweight子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFlyweight</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Flyweight</span> &#123;<br>  pubilc <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(<span class="hljs-type">int</span> extrinsicstate)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;具体Flyweight：&quot;</span> + extrinsicstate);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>UnsharedConcreteFlyweight</code>：不需要共享的<code>Flyweight</code>子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不需要共享的Flyweight子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsharedConcerteFlyweight</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Flyweight</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(<span class="hljs-type">int</span> extrinsicstate)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;不共享的具体Flyweight：&quot;</span> + extrinsicstate);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FlyweightFactory</code>：享元工厂，用来创建并管理<code>Flyweight</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> Hashtable&lt;String, Flyweight&gt; flyweights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>  <br>  <span class="hljs-comment">// 初始化工厂时，先生成三个实例</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">FlyweightFactory</span><span class="hljs-params">()</span> &#123;<br>    flyweights.put(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyweight</span>));<br>    flyweights.put(<span class="hljs-string">&quot;Y&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyweight</span>));<br>    flyweights.put(<span class="hljs-string">&quot;Z&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyweight</span>));<br>  &#125;<br>  <br>  <span class="hljs-comment">// 根据客户端请求，获得已生成的实例</span><br>  <span class="hljs-keyword">public</span> Flyweight <span class="hljs-title function_">getFlyweight</span><span class="hljs-params">(String key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!flyweights.contains(key)) &#123;<br>      flyweights.put(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteFlyweight</span>(key));<br>    &#125;<br>    <span class="hljs-keyword">return</span> (Flyweight)flyweights.get(key);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">extrinsicstate</span> <span class="hljs-operator">=</span> <span class="hljs-number">22</span>;<br><br><span class="hljs-type">FlyweightFactory</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlyweightFactory</span>();<br><br><span class="hljs-type">Flyweight</span> <span class="hljs-variable">fx</span> <span class="hljs-operator">=</span> f.getFlyweight(<span class="hljs-string">&quot;X&quot;</span>);<br>fx.operation(--extrinsicstate);<br><br><span class="hljs-type">Flyweight</span> <span class="hljs-variable">fy</span> <span class="hljs-operator">=</span> f.getFlyweight(<span class="hljs-string">&quot;Y&quot;</span>);<br>fy.operation(--extrinsicstate);<br><br><span class="hljs-type">Flyweight</span> <span class="hljs-variable">fz</span> <span class="hljs-operator">=</span> f.getFlyweight(<span class="hljs-string">&quot;Z&quot;</span>);<br>fz.operation(--extrinsicstate);<br><br><span class="hljs-type">Flyweight</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsharedConcreteFlyweight</span>();<br>uf.operation(--extrinsicstate);<br></code></pre></td></tr></table></figure><p>注：</p><ul><li><code>FlyweightFactory</code>初始化时不一定需要生成对象实例。也可以到需要时，再去根据对象是否为null来决定是否实例化。</li><li><code>UnsharedConcreteFlyweight</code>存在的原因：尽管我们大部分时间都需要共享对象来降低内存的损耗，但个<br>别时候也有可能不需要共享，那么此时的<code>UnsharedConcreteFlyweight</code>子类就有存在的必要了，它可以解决那些不需要共享对象的问题。</li></ul><h2 id="内部状态与外部状态"><a href="#内部状态与外部状态" class="headerlink" title="内部状态与外部状态"></a>内部状态与外部状态</h2><ul><li>内部状态：在享元对象内部并且不会随环境改变而改变的共享部分</li><li>外部状态：随环境改变而改变的、不可以共享的状态</li></ul><blockquote><p>享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了<strong>几个参数</strong>外基本上都是相同的，有时就能够大幅度地减少需要实例化的类的数量。如果能把那些参数<strong>移到类实例的外面</strong>，<strong>在方法调用时将它们传递进来</strong>，就可以通过共享大幅度地减少单个实例的数目。</p></blockquote><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>一个应用程序使用了<strong>大量的对象</strong>，而大量的这些对象造成了很大的存储开销</li><li>对象的<strong>大多数状态可以是外部状态</strong>，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象</li></ul><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>非常好地解决了<strong>对象的开销问题</strong>。</p><p>因为用了享元模式，所以有了共享对象，实例总数就大大减少了，如果共享的对象越多，存储节约也就越多，节约量随着共享状态的增多而增大。</p><blockquote><p>例：Java中的String就运用了Flyweight模式。</p><p>‘&#x3D;&#x3D;’可以用来确定titleA与titleB是否是相同的实例，返回值为boolean值。当用new String()方法时，两个对象titleA和titleB的引用地址是不相同的，但当titleC和titleD都使用赋值的方式时，两个字符串的引用地址竟然是相同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">titleA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;test1&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">titleB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;test1&quot;</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">titleC</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test2&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">titleD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test2&quot;</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">==: 比较内存引用地址</span><br><span class="hljs-comment">equals(): 比较字符串的值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">titleA == titleB: false</span><br><span class="hljs-comment">titleA.equals(titleB): true</span><br><span class="hljs-comment">titleC == titleD: true</span><br><span class="hljs-comment">titleC.equals(titleD): true</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ul><li><p>使用享元模式需要维护一个<strong>记录了系统已有的所有享元的列表</strong>，而这本身需要耗费资源，另外享元模式使得系统更加复杂。</p></li><li><p>为了使对象可以共享，需要将一些<strong>状态外部化</strong>，这使得程序的逻辑复杂化。</p></li></ul><p>因此，应当在有<strong>足够多的对象实例</strong>可供共享时才值得使用享元模式。</p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式2-策略模式</title>
    <link href="/posts/dec2734b.html"/>
    <url>/posts/dec2734b.html</url>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p><h3 id="策略模式结构图"><a href="#策略模式结构图" class="headerlink" title="策略模式结构图"></a>策略模式结构图</h3><p><img src="https://s2.loli.net/2023/09/25/3FbYVIzrKk2hLA5.jpg" alt="策略模式结构图.jpg"></p><h3 id="策略模式基本代码"><a href="#策略模式基本代码" class="headerlink" title="策略模式基本代码"></a>策略模式基本代码</h3><p>Strategy类，定义所有支持的算法的公共接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象算法类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-comment">// 算法方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ConcreteStrategy类，封装了具体的算法或行为，继承于Strategy：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体算法A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-comment">// 算法A实现方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;算法A实现&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体算法B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-comment">// 算法B实现方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;算法B实现&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体算法C</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-comment">// 算法C实现方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithmInterface</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;算法C实现&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Context类，用一个ConcreteStrategy来配置，维护一个对Strategy对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 上下文</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    Strategy strategy;<br>    <br>    <span class="hljs-comment">// 初始化时，传入具体的策略对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Context</span><span class="hljs-params">(Strategy strategy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.strategy = strategy;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 上下文接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextInterface</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 根据具体的策略对象，调用其算法的方法</span><br>        strategy.algorithmInterface();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Context context;<br><br><span class="hljs-comment">// 实例化不同的策略</span><br>context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyA</span>());<br>context.contextInterface();<br><br>context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyB</span>());<br>context.contextInterface();<br><br>context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStrategyC</span>());<br>context.contextInterface();<br></code></pre></td></tr></table></figure><h1 id="例：商场收银软件"><a href="#例：商场收银软件" class="headerlink" title="例：商场收银软件"></a>例：商场收银软件</h1><h2 id="原始版本"><a href="#原始版本" class="headerlink" title="原始版本"></a>原始版本</h2><p>所有内容都写在一个程序中，如要需要修改任意代码，都需要重新安装在商场所有机器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>; <span class="hljs-comment">// 商品单价</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 商品数量</span><br><span class="hljs-type">double</span> <span class="hljs-variable">totalPrices</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>; <span class="hljs-comment">// 当前商品合计费用</span><br><span class="hljs-type">double</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>; <span class="hljs-comment">// 总计所有商品费用</span><br><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br><span class="hljs-keyword">do</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;请输入商品单价：&quot;</span>);<br>    price = Double.parseDouble(sc.nextLine());<br>    System.out.println(<span class="hljs-string">&quot;请输入商品数量：&quot;</span>);<br>    num = Integer.parseInt(sc.nextLine());<br>    System.out.println();<br>    <br>    <span class="hljs-keyword">if</span> (price &gt; <span class="hljs-number">0</span> &amp;&amp; num &gt; <span class="hljs-number">0</span>) &#123;<br>        totalPrices = price * num;<br>        total += totalPrices;<br>        <br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;单价：&quot;</span> + price + <span class="hljs-string">&quot;元，数量：&quot;</span> + num + <span class="hljs-string">&quot;，合计：&quot;</span> + totalPrices + <span class="hljs-string">&quot;元&quot;</span>);<br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;总计：&quot;</span> + total + <span class="hljs-string">&quot;元&quot;</span>);<br>        System.out.println();<br>    &#125;<br>&#125; <span class="hljs-keyword">while</span> (price &gt; <span class="hljs-number">0</span> &amp;&amp; num &gt; <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="增加打折"><a href="#增加打折" class="headerlink" title="增加打折"></a>增加打折</h2><p>新增打折&#x2F;返利功能</p><h3 id="硬编码实现版本"><a href="#硬编码实现版本" class="headerlink" title="硬编码实现版本"></a>硬编码实现版本</h3><p>写在客户端程序中。每新增打x折都要重新安装。用下拉框选择销售模式实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">discount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 商品销售模式：1.原价 2.八折 3.七折</span><br>...<br><span class="hljs-keyword">switch</span> (discount) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        totalPrices = price * num;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        totalPrices = price * num * <span class="hljs-number">0.8</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        totalPrices = price * num * <span class="hljs-number">0.7</span>;<br>&#125;<br><br>total += totalPrices;<br></code></pre></td></tr></table></figure><h3 id="简单工厂实现版本"><a href="#简单工厂实现版本" class="headerlink" title="简单工厂实现版本"></a>简单工厂实现版本</h3><p>用收费抽象类，让打折&#x2F;返利继承抽象类，传入对应需要的参数灵活实现具体打几折、满多少返多少，需要新增时在工厂类中添加模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 收费抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashSuper</span> &#123;<br>    <br>    <span class="hljs-comment">// 收费抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span>;<br>&#125;<br><br><span class="hljs-comment">// 正常收费</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashNormal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CashSuper</span> &#123;<br>    <br>    <span class="hljs-comment">// 原价返回</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">return</span> price * num;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 打折收费</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashRebate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CashSuper</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyRebate</span> <span class="hljs-operator">=</span> <span class="hljs-number">1d</span>;<br>    <br>    <span class="hljs-comment">// 初始化时输入折扣率</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashRebate</span><span class="hljs-params">(<span class="hljs-type">double</span> moneyRebate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.moneyRebate = moneyRebate;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 返回乘上折扣率的总价</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">return</span> price * num * <span class="hljs-built_in">this</span>.moneyRebate;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 返利收费</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashReturn</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CashSuper</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyCondition</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>; <span class="hljs-comment">// 返利条件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-variable">moneyReturn</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>; <span class="hljs-comment">// 返利值</span><br>    <br>    <span class="hljs-comment">// 初始化时输入返利条件和返利值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashReturn</span><span class="hljs-params">(<span class="hljs-type">double</span> moneyCondition, <span class="hljs-type">double</span> moneyReturn)</span> &#123;<br>        <span class="hljs-built_in">this</span>.moneyCondition = moneyCondition;<br>        <span class="hljs-built_in">this</span>.moneyReturn = moneyReturn;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 返回返利后的总价</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">acceptCash</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> price * num;<br>        <span class="hljs-keyword">if</span> (moneyCondition &gt; <span class="hljs-number">0</span> &amp;&amp; result &gt;= moneyCondition) &#123;<br>            result -= Math.floor(result / moneyCondition) * moneyReturn;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>收费工厂代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashFactory</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CashSuper <span class="hljs-title function_">createCashAccept</span><span class="hljs-params">(<span class="hljs-type">int</span> cashType)</span> &#123;<br>        <span class="hljs-type">CashSuper</span> <span class="hljs-variable">cs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (cashType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.8d</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.7d</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashReturn</span>(<span class="hljs-number">300d</span>, <span class="hljs-number">100d</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cs;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端程序主要部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CashSuper</span> <span class="hljs-variable">cashSuper</span> <span class="hljs-operator">=</span> CashFactory.createCashAccept(cashType);<br>totalPrices = cashSuper.acceptCash(price, num);<br>total += totalPrices;<br></code></pre></td></tr></table></figure><h3 id="策略模式实现版本"><a href="#策略模式实现版本" class="headerlink" title="策略模式实现版本"></a>策略模式实现版本</h3><p>跟简单工厂很像，只要加一个CashContext类，改写一下客户端代码即可。</p><p>CashContext类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashContext</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> CashSuper cs;<br>    <br>    <span class="hljs-comment">// 构造方法传入具体的收费策略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashContext</span><span class="hljs-params">(CashSuper csuper)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cs = csuper;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 根据收费策略的不同，获得计算结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.cs.acceptCash(price, num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端主要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CashContext</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">switch</span> (cashType) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        cc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashContext</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>());<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        cc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashContext</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.8d</span>));<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        cc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashContext</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.7d</span>));<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>        cc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashContext</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CashReturn</span>(<span class="hljs-number">300d</span>, <span class="hljs-number">100d</span>));<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 通过Context的getResult方法调用，得到收费结果</span><br><span class="hljs-comment">// 让具体算法与客户完全隔离</span><br>totalPrices = cc.getResult(price, num);<br>total += totalPrices;<br></code></pre></td></tr></table></figure><p>但这样是在客户端判断使用哪种算法，客户能看到具体的收费策略，可以将策略模式与简单工厂模式结合，把判断转移到工厂中。</p><h3 id="策略与简单工厂结合版本"><a href="#策略与简单工厂结合版本" class="headerlink" title="策略与简单工厂结合版本"></a>策略与简单工厂结合版本</h3><p>改进CashContext类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashContext</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> CashSuper cs;<br>    <br>    <span class="hljs-comment">// 在构造函数中传入type，根据type来实例化具体的收费策略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CashContext</span><span class="hljs-params">(<span class="hljs-type">int</span> cashType)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (cashType) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-built_in">this</span>.cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashNormal</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-built_in">this</span>.cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.8d</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                <span class="hljs-built_in">this</span>.cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashRebate</span>(<span class="hljs-number">0.7d</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                <span class="hljs-built_in">this</span>.cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashReturn</span>(<span class="hljs-number">300d</span>, <span class="hljs-number">100d</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> price, <span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 根据收费策略的不同，获得计算结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.cs.acceptCash(price, num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CashContext</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashContext</span>(cashType);<br>totalPrices = cc.getResult(price, num);<br>total += totalPrices;<br></code></pre></td></tr></table></figure><h4 id="与纯简单工厂模式对比"><a href="#与纯简单工厂模式对比" class="headerlink" title="与纯简单工厂模式对比"></a>与纯简单工厂模式对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 简单工厂模式用法</span><br><span class="hljs-type">CashSuper</span> <span class="hljs-variable">cs</span> <span class="hljs-operator">=</span> CashFactory.createCashAccept(cashType);<br>totalPrices = cs.acceptCash(price, num);<br><br><span class="hljs-comment">// 策略模式与简单工厂模式结合的用法</span><br><span class="hljs-type">CashContext</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CashContext</span>(cashType);<br>totalPrices = cc.getResult(price, num);<br></code></pre></td></tr></table></figure><p>简单工厂模式我需要让客户端认识两个类，CashSuper和CashFactory，而策略模式与简单工厂结合的用法，客户端就只需要认识一个类CashContext就可以了。耦合更加降低。</p><p>在客户端实例化的是CashContext的对象，调用的是CashContext的方法GetResult，这使得具体的收费算法彻底地与客户端分离。连算法的父类CashSuper都不让客户端认识了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="策略模式优点"><a href="#策略模式优点" class="headerlink" title="策略模式优点"></a>策略模式优点</h2><ul><li>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种<strong>算法类</strong>与<strong>使用算法类</strong>之间的耦合。<strong>策略模式封装了变化。</strong></li><li>策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于<strong>析取</strong>出这些算法中的<strong>公共功能</strong>。如：收费算法公共的功能就是获得计算费用的结果GetResult，这使得算法间有了抽象的父类CashSuper.</li><li>简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口<strong>单独测试</strong>。</li></ul><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>收银系统中如果要新增折扣，还是需要修改CashContext中的switch语句，可以通过<code>反射技术</code>（抽象工厂模式章节）来解决这个问题。</p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板5-2.贪心-Huffman树</title>
    <link href="/posts/d4eb8437.html"/>
    <url>/posts/d4eb8437.html</url>
    
    <content type="html"><![CDATA[<h1 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h1><p>问题可以看作一颗完全二叉树。</p><p>Huffman树的总代价：对于每个叶子节点n，需要的代价是<code>n所处的层级*n的权重</code>，把它们求和</p><p>问题：如何排列所有叶子节点，使得总代价最小</p><p>解法：每次挑权重最小的两个节点合并。</p><p>可以证明：权重最小的两个点，在树中一定是最深的节点，且可以互为兄弟节点。</p><blockquote><p>证明：</p><ol><li>如果最小节点深度不是最深，将其与最深的节点交换位置，代价一定减小；</li><li>可以互为兄弟：在最深层可以任意交换位置。</li></ol></blockquote><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="1-合并果子"><a href="#1-合并果子" class="headerlink" title="1. 合并果子"></a>1. 合并果子</h3><blockquote><p>和DP中的石子合并的区别：石子合并必须两堆石子相邻，果子没有这个限制。</p></blockquote><p>Huffman树中所有叶子节点就是要合并的果子堆。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> t;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);<br>        heap.<span class="hljs-built_in">push</span>(t);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> a = heap.<span class="hljs-built_in">top</span>(); heap.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> b = heap.<span class="hljs-built_in">top</span>(); heap.<span class="hljs-built_in">pop</span>();<br>        res += a + b;<br>        heap.<span class="hljs-built_in">push</span>(a + b);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板5-1.贪心-区间问题</title>
    <link href="/posts/208cad05.html"/>
    <url>/posts/208cad05.html</url>
    
    <content type="html"><![CDATA[<h1 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑按照左端点&#x2F;右端点排序。</p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="1-区间选点"><a href="#1-区间选点" class="headerlink" title="1. 区间选点"></a>1. 区间选点</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol><li>将所有区间按右端点从小到大排序</li><li>枚举每个区间<ol><li>如果区间不包含当前点x，取区间右端点作为x</li><li>如果区间包含当前点x，跳过该区间</li></ol></li></ol><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><blockquote><p>证明技巧：要证A&#x3D;B, 可以证A&gt;&#x3D;B &amp;&amp; A&lt;&#x3D;B</p></blockquote><p>设点数最小值为<code>ans</code>，上述算法得出的值为<code>cnt</code>。</p><ul><li>证<code>ans &lt;= cnt</code>：<code>cnt</code>个点一定覆盖了所有区间，所以是一种合法方案，而<code>ans</code>是合法方案里的最小值。</li><li>证<code>ans &gt;= cnt</code>：上述算法等价于将取点范围从所有区间缩小为了没有交集的<code>cnt</code>个区间，覆盖这<code>cnt</code>个区间至少要<code>cnt</code>个点。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Range</span><br>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Range &amp;W)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> r &lt; W.r;<br>    &#125;<br>&#125;range[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>        range[i] = &#123;l, r&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(range, range + n);<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (range[i].l &lt;= ed &amp;&amp; range[i].r &gt;= ed) <span class="hljs-keyword">continue</span>;<br>        ed = range[i].r; res ++;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：也可以自定义比较函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Range a,Range b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.r&lt;b.r;<br>&#125;<br><span class="hljs-built_in">sort</span>(range,range+n,cmp);<br></code></pre></td></tr></table></figure><h3 id="2-最大不相交区间数量"><a href="#2-最大不相交区间数量" class="headerlink" title="2. 最大不相交区间数量"></a>2. 最大不相交区间数量</h3><p>选最多不相交的区间和上一题选最少的点等价。</p><h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>设区间数最大值为<code>ans</code>，算法得出的值为<code>cnt</code>。</p><ul><li>证<code>ans &gt;= cnt</code>：上述算法等价于将取点范围从所有区间缩小为了没有交集的<code>cnt</code>个区间，所以是一种合法方案。</li><li>证<code>ans &lt;= cnt</code>：反证，假设<code>ans &gt; cnt</code>，即有<code>ans</code>个不相交的区间，那么至少需要<code>ans</code>个点才可以覆盖所有区间，但事实上<code>cnt</code>个点一定覆盖了所有区间，所以矛盾。</li></ul><h3 id="3-区间分组"><a href="#3-区间分组" class="headerlink" title="3. 区间分组"></a>3. 区间分组</h3><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><ol><li><p>将所有区间按左端点从小到大排序</p></li><li><p>从前往后处理每个区间</p><p><code>L[i] &gt; max_r</code>: 判断能否将其放到某个现有的组中：组中最大的右端点是否在当前区间左端点的左侧</p><ol><li>是：将区间放入该组，更新当前组的max_r</li><li>否：创建一个新组，将其放进去</li></ol><blockquote><p>为什么可以直接放入max_r最小的组，而不是max_r离当前区间左端点最近但不相交的组？</p><p>因为所有区间按左端点排序过了，下一个区间必定与上一个区间相交，或完全在其右侧，不可能完全在其左侧</p></blockquote></li></ol><h4 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h4><p>设分组数最小值为<code>ans</code>，算法得出的分组数为<code>cnt</code>。</p><ul><li>证<code>ans &lt;= cnt</code>：上述算法能够将区间放到<code>cnt</code>个组中，且组中所有区间没有交集，所以是一种合法方案。</li><li>证<code>ans &gt;= cnt</code>：既然开了新组，就说明存在一个点，每个组都能找到一个区间使得这个点在区间内（感觉不一定，因为算法只根据组内区间右端点的最大值来判断，有可能这个点在两个区间中间的空隙里），所以至少要有<code>cnt</code>个组保证这<code>cnt</code>个区间不重合。</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Range</span><br>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Range &amp;W)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> l &lt; W.l;<br>    &#125;<br>&#125;range[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;range[i].l, &amp;range[i].r);<br>    <br>    <span class="hljs-built_in">sort</span>(range, range + n);<br>    <br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; heap;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (heap.<span class="hljs-built_in">empty</span>() || heap.<span class="hljs-built_in">top</span>() &gt;= range[i].l) heap.<span class="hljs-built_in">push</span>(range[i].r);<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 更新右端点最大值最小的组中右端点的最大值</span><br>        &#123;<br>            heap.<span class="hljs-built_in">pop</span>();<br>            heap.<span class="hljs-built_in">push</span>(range[i].r);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, heap.<span class="hljs-built_in">size</span>());<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-区间覆盖"><a href="#4-区间覆盖" class="headerlink" title="4. 区间覆盖"></a>4. 区间覆盖</h3><h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><p>假设区间从start到end</p><ol><li>将所有区间按左端点从小到大排序</li><li>从前往后依次枚举每个区间，在所有能覆盖start的区间中，选择右端点最大的区间，然后将start更新成右端点的最大值</li></ol><h4 id="证明-3"><a href="#证明-3" class="headerlink" title="证明"></a>证明</h4><p>设区间数最小值为<code>ans</code>，算法得出的区间数为<code>cnt</code>。</p><p>把最优解和算法的解的区间从小到大枚举，找到第一个不同的区间：因为算法选择的是右端点的最大值，所以可以把最优解的该区间替换成算法的区间（不亏，只会让右端点更长），以此类推，最终最优解可以转化成上述算法的解。</p><blockquote><p>感觉和没证一样…</p></blockquote><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> st, ed, n;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Range</span><br>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Range &amp;W)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> l &lt; W.l;<br>    &#125;<br>&#125;range[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;st, &amp;ed, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;range[i].l, &amp;range[i].r);<br>    <br>    <span class="hljs-built_in">sort</span>(range, range + n);<br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> j = i, r = <span class="hljs-number">-2e9</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; range[j].l &lt;= st)<br>        &#123;<br>            r = <span class="hljs-built_in">max</span>(r, range[j].r);<br>            j ++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (r &lt; st) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 失败</span><br>        <br>        res ++;<br>        <span class="hljs-keyword">if</span> (r &gt;= ed)<br>        &#123;<br>            success = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        st = r, i = j - <span class="hljs-number">1</span>; <span class="hljs-comment">// 因为i还要++的</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (success) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-8.DP-记忆化搜索</title>
    <link href="/posts/10b04145.html"/>
    <url>/posts/10b04145.html</url>
    
    <content type="html"><![CDATA[<h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h3><p>前提：图是拓扑图，不存在环（循环依赖）。</p><p>时间复杂度：<code>O(n^2)</code></p><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f[i, j]</code>表示所有从点(i, j)开始滑的路径长度的最大值。</p><h4 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h4><p>分成四个子集，分别为往四个方向滑的路径的最大值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">310</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N][N], f[N][N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> &amp;v = f[x][y];<br>    <br>    <span class="hljs-keyword">if</span> (v != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> v; <span class="hljs-comment">// 如果已经搜索过了，直接返回即可，否则时间复杂度是指数级别</span><br>    <br>    v = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>        <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; n &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; m &amp;&amp; h[a][b] &lt; h[x][y])<br>            v = <span class="hljs-built_in">max</span>(v, <span class="hljs-built_in">dp</span>(a, b) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;h[i][j]);<br>    <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f); <span class="hljs-comment">// 初始化，-1表示还没有搜索过</span><br>    <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">dp</span>(i, j)); <span class="hljs-comment">// 枚举起点</span><br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式25-中介者模式</title>
    <link href="/posts/5f671627.html"/>
    <url>/posts/5f671627.html</url>
    
    <content type="html"><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>迪米特法则的实现。</p><p>通过中介者对象，可以将系统的网状结构变成以中介者为中心的星状结构，每个具体对象不再通过直接的联系与另一个对象发生相互作用，而是通过”中介者”对象与另一个对象发生相互作用。</p><blockquote><p>如联合国可以作为各个国家的中介者，用来转发消息，而不是让各个国家直接通信。</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>中介者模式（Mediator），用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/11/01/sf3KV7nBPTLixMy.jpg" alt="中介者模式结构图.jpg"></p><p>Colleague叫作抽象同事类，而ConcreteColleague是具体同事类，每个具体同事只知道自己的行为，而不了解其他同事类的情况，但他们却都认识中介者对象。</p><p>Mediator是抽象中介者，定义了同事对象到中介者对象的接口，ConcreteMediator是具体中介者对象，实现抽象类的方法，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Colleague</code>类：抽象同事类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Colleague</span> &#123;<br>  <span class="hljs-keyword">protected</span> Mediator mediator;<br>  <span class="hljs-comment">// 构造方法，得到中介者对象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Colleague</span><span class="hljs-params">(Mediator mediator)</span> &#123;<br>    <span class="hljs-built_in">this</span>.mediator = mediator;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteColleague1</code>, <code>ConcreteColleague2</code>：具体同事类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteColleague1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Colleague</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteColleague1</span><span class="hljs-params">(Mediator mediator)</span> &#123;<br>    <span class="hljs-built_in">super</span>(mediator);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>    <span class="hljs-built_in">this</span>.mediator.send(message, <span class="hljs-built_in">this</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;同事1得到信息：&quot;</span> + message);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteColleague2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Colleague</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteColleague2</span><span class="hljs-params">(Mediator mediator)</span> &#123;<br>    <span class="hljs-built_in">super</span>(mediator);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>    <span class="hljs-built_in">this</span>.mediator.send(message, <span class="hljs-built_in">this</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;同事2得到信息：&quot;</span> + message);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Mediator</code>类：抽象中介者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;<br>  <span class="hljs-comment">// 定义一个抽象的发送消息方法，得到同事对象和发送消息</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message, Colleague colleague)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteMediator</code>类：具体中介者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteMediator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mediator</span> &#123;<br>  <span class="hljs-keyword">private</span> ConcreteColleague1 colleague1;<br>  <span class="hljs-keyword">private</span> ConcreteColleague2 colleague2;<br>  <br>  <span class="hljs-comment">// 需要了解所有的具体同事对象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColleague1</span><span class="hljs-params">(ConcreteColleague1 value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.colleague1 = value;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColleague2</span><span class="hljs-params">(ConcreteColleague2 value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.colleague2 = value;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 重写发送信息的方法，根据对象做出选择判断，通知对象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String message, Colleague colleague)</span> &#123;<br>    <span class="hljs-keyword">if</span> (colleague == colleague1) &#123;<br>      colleague2.notify(message);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      colleague1.notify(message);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ConcreteMediator</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteMediator</span>();<br><br><span class="hljs-comment">// 让两个具体同事类对象认识中介者对象</span><br><span class="hljs-type">ConcreteColleague1</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteColleague1</span>(m);<br><span class="hljs-type">ConcreteColleague1</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteColleague2</span>(m);<br><br><span class="hljs-comment">// 让中介者认识各个具体同事类对象</span><br>m.setColleague1(c1);<br>m.setColleague2(c2);<br><br>c1.send(<span class="hljs-string">&quot;notify c2&quot;</span>);<br>c2.send(<span class="hljs-string">&quot;notify c1&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>中介者模式很容易在系统中应用，也很容易在系统中误用。当系统出现了’多对多’交互复杂的对象群时，不要急于使用中介者模式，而要先反思你的系统在设计上是不是合理。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>Mediator的出现<strong>减少了各个Colleague的耦合</strong>，使得可以独立地改变和复用各个Colleague类和Mediator，比如任何国家的改变不会影响到其他国家，而只是与安理会发生变化。</p></li><li><p>由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个<strong>更宏观的角度</strong>去看待系统。</p><blockquote><p>比如巴以冲突，本来只能算是国与国之间的矛盾，因此各自的看法可能都比较狭隘，但站在联合国安理会的角度，就可以从全球化、也更客观的角度来看待这个问题，在调停和维和上做出贡献。</p></blockquote></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于ConcreteMediator控制了集中化，于是就把交互复杂性变为中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>中介者模式一般应用于：</p><ul><li>一组<strong>对象以定义良好但是复杂的方式进行通信</strong>的场合，比如窗体Form对象或Web页面aspx</li><li>想定制一个分布在多个类中的行为，而又<strong>不想生成太多的子类</strong>的场合</li></ul>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-7.DP-树形DP</title>
    <link href="/posts/2ce0a12a.html"/>
    <url>/posts/2ce0a12a.html</url>
    
    <content type="html"><![CDATA[<h1 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h1><p>一般是DFS的形式。</p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h3><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f(i, 0)</code>和<code>f(i, 1)</code>分别表示在以<code>i</code>为根的子树中不选<code>i</code>和选<code>i</code>的最大值是多少。</p><h4 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h4><p><code>f[i, 0] = sum(max(f[i的子节点, 0], f[i的子节点, 1]))</code></p><p><code>f[i, 1] = sum(f[i的子节点, 0])</code></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> w[N], f[N][<span class="hljs-number">2</span>];<br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 为了找到根节点，值为false的话则为根节点</span><br><span class="hljs-type">int</span> idx, e[N], ne[N], h[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    f[u][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, f[u][<span class="hljs-number">1</span>] = w[u]; <span class="hljs-comment">// 快乐指数有负数，但如果不选该点则应该初始化为0</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) <span class="hljs-comment">// 遍历u的子节点</span><br>    &#123;<br>        <span class="hljs-type">int</span> t = e[i];<br>        <span class="hljs-built_in">dfs</span>(t);<br>        f[u][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(f[t][<span class="hljs-number">0</span>], f[t][<span class="hljs-number">1</span>]);<br>        f[u][<span class="hljs-number">1</span>] += f[t][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) cin &gt;&gt; w[i];<br><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">add</span>(b, a);<br>        st[a] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> root = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (st[root]) root ++; <span class="hljs-comment">// 找到根节点</span><br>    <br>    <span class="hljs-built_in">dfs</span>(root);<br>    <br>    cout &lt;&lt; <span class="hljs-built_in">max</span>(f[root][<span class="hljs-number">0</span>], f[root][<span class="hljs-number">1</span>]) &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-6.DP-状态压缩DP</title>
    <link href="/posts/a0874cea.html"/>
    <url>/posts/a0874cea.html</url>
    
    <content type="html"><![CDATA[<h1 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h1><p>一般数据范围非常小。如蒙德里安的梦想：$1&lt;&#x3D;N, M&lt;&#x3D;11$</p><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="1-蒙德里安的梦想"><a href="#1-蒙德里安的梦想" class="headerlink" title="1. 蒙德里安的梦想"></a>1. 蒙德里安的梦想</h3><p>放1*2的小方块，把长m宽n的矩形放满。</p><p>核心：先放横着的，再放竖着的。</p><p>总方案数 &#x3D; 只放横着的小方块的合法方案数</p><p>如何判断当前方案是否合法？ 所有剩余位置，能否填充满竖着的小方块。可以按列来看，每一列内部所有连续的空着的小方块需要是偶数个。</p><p>时间复杂度：<code>M * 2^N * 2^N</code></p><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f[i, j]</code>表示已经将前<code>i - 1</code>列摆好，且从第<code>i - 1</code>列，伸出到第<code>i</code>列的状态是<code>j</code>的所有方案。</p><p>答案为<code>f[m, 0]</code>，即全部的列都已经摆好，且不再往外伸。</p><h4 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h4><p><code>f[i, j]</code>由<code>f[i - 1, k]</code>计算得出，其中<code>k</code>用二进制位来表示（e.g. 00100），有<code>2^n</code>种取值，每一行都可以选从<code>i - 2</code>列到第<code>i - 1</code>列伸或不伸。</p><p>所有的k需要满足两个条件才合法：</p><ol><li>(j &amp; k) &#x3D;&#x3D; 0。即方块不能有重叠，已经放了就不能再放</li><li>一列中所有连续空着的位置的长度必须是偶数。即要保证不重不漏地全摆上竖着的小方块。</li></ol><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>预处理</p><ol><li><code>state[k][]</code>：可以从<code>k</code>状态更新到哪些<code>j</code>状态。</li><li><code>st[]</code>：一列中所有连续的空白小方块是否是偶数个。</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">12</span>, M = <span class="hljs-number">1</span> &lt;&lt; N;<br><br><span class="hljs-type">int</span> n, m;<br>LL f[N][M];<br>vector&lt;<span class="hljs-type">int</span>&gt; state[M];<br><span class="hljs-type">bool</span> st[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m)<br>    &#123;<br>        <span class="hljs-comment">// 预处理st数组：列中所有连续的空白小方块数量是否为偶数个</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++) <span class="hljs-comment">// 遍历所有可能的列的状态</span><br>        &#123;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">bool</span> is_valid = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++) <span class="hljs-comment">// 遍历该列每个小方块</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> ((i &gt;&gt; j) &amp; <span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>)<br>                    &#123;<br>                        is_valid = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 合法，空白方块数重新计数</span><br>                &#125; <span class="hljs-keyword">else</span> cnt ++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) is_valid = <span class="hljs-literal">false</span>;<br>            st[i] = is_valid;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 预处理state数组：从哪些j状态可以到达i状态</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++)<br>        &#123;<br>            state[i].<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1</span> &lt;&lt; n; j ++)<br>                <span class="hljs-keyword">if</span> ((i &amp; j) == <span class="hljs-number">0</span> &amp;&amp; st[i | j])<br>                    state[i].<span class="hljs-built_in">push_back</span>(j);<br>        &#125;<br>        <br>        <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化，从第-1列到第0列，伸出到全空的列的方案数为1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1</span> &lt;&lt; n; j ++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> k : state[j])<br>                    f[i][j] += f[i - <span class="hljs-number">1</span>][k];<br>        <br>        cout &lt;&lt; f[m][<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-最短Hamilton路径"><a href="#2-最短Hamilton路径" class="headerlink" title="2. 最短Hamilton路径"></a>2. 最短Hamilton路径</h3><p>时间复杂度：<code>2^N * N</code>， <code>N</code>为点数</p><p>很重要的前提：图是完全图，并且两边之和大于第三边。</p><h4 id="状态表示-1"><a href="#状态表示-1" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f[i, j]</code>的含义：状态是<code>i</code>的情况下，最后停在点<code>j</code>，其中<code>i</code>表示哪些点被用过，可能的取值为<code>2^N</code>，<code>N</code>为点数</p><h4 id="状态计算-1"><a href="#状态计算-1" class="headerlink" title="状态计算"></a>状态计算</h4><p><code>f[state][j] = f[state_k][k] + weight[k][j]</code>，其中<code>state_k = state除掉j之后的集合，且state_k中要包含k</code></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>两层循环，要外层先枚举状态，再枚举所有点</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">因为在进行状态转移时，f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> 要由 f<span class="hljs-selector-attr">[i - (1 &lt;&lt; j)]</span><span class="hljs-selector-attr">[k]</span> 转移过来，所以一定要保证在计算 f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> 之前一定已经计算过 f<span class="hljs-selector-attr">[i - (1 &lt;&lt; j)]</span><span class="hljs-selector-attr">[k]</span> 了，这样才能保证答案递推的连续性。<br><br>在 <span class="hljs-selector-tag">i</span> 是外层循环中，是按照最外层为 状态依次从小到大 的顺序进行对答案的计算<br>因为状态 <span class="hljs-selector-tag">i</span> - (<span class="hljs-number">1</span> &lt;&lt; j) 一定是小于状态 <span class="hljs-selector-tag">i</span> 的，所以符合递推的连续性。<br><br>在 j 是外层循环中，在计算 f<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> 时一定用到 f<span class="hljs-selector-attr">[i - (1 &lt;&lt; j)]</span><span class="hljs-selector-attr">[k]</span><br>而当 k&gt;j 的情况时，此时的 f<span class="hljs-selector-attr">[i - (1 &lt;&lt; j)]</span><span class="hljs-selector-attr">[k]</span> 并没有被计算过，因为你最外层循环还没循环到k呢。<br><br>例如： f<span class="hljs-selector-attr">[101011]</span><span class="hljs-selector-attr">[3]</span> = f<span class="hljs-selector-attr">[100011]</span><span class="hljs-selector-attr">[5]</span> + w<span class="hljs-selector-attr">[5]</span><span class="hljs-selector-attr">[3]</span><br>按 <span class="hljs-selector-tag">i</span> 外层循环，一定可以保证 f<span class="hljs-selector-attr">[100011]</span><span class="hljs-selector-attr">[5]</span> 在f<span class="hljs-selector-attr">[101011]</span><span class="hljs-selector-attr">[3]</span> 之前被计算出来。<br>而按 j 外层循环，由于 <span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span> ，f<span class="hljs-selector-attr">[100011]</span><span class="hljs-selector-attr">[5]</span> 根本就没有被计算过，所以不可行。<br></code></pre></td></tr></table></figure><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>, M = <span class="hljs-number">1</span> &lt;&lt; N;<br><span class="hljs-type">int</span> w[N][N];<br><span class="hljs-type">int</span> f[M][N];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w[i][j]);<br>    <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 从起点出发，路径长度为0</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++) <span class="hljs-comment">// 枚举当前终点j</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>) <span class="hljs-comment">// 路径经过j才合法</span><br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k ++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (i - (<span class="hljs-number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="hljs-number">1</span>) <span class="hljs-comment">// 路径经过k</span><br>                    &#123;<br>                        f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - (<span class="hljs-number">1</span> &lt;&lt; j)][k] + w[k][j]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    <br>    cout &lt;&lt; f[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] &lt;&lt; endl; <span class="hljs-comment">// 经过了所有点，且最终停在终点</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式24-职责链模式</title>
    <link href="/posts/730f7444.html"/>
    <url>/posts/730f7444.html</url>
    
    <content type="html"><![CDATA[<h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>职责链模式（Chain of Responsibility）：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><blockquote><p>Netty中的ChannelHandler, ChannelPipeline用到了职责链模式。</p></blockquote><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/30/365cXGqiPFpfLoW.jpg" alt="职责链模式结构图.jpg"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Handler</code> 类：定义一个处理请求的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br>  <span class="hljs-keyword">protected</span> Handler successor;<br>  <br>  <span class="hljs-comment">// 设置后继者</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(Handler successor)</span> &#123;<br>    <span class="hljs-built_in">this</span>.successor = successor;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteHandler</code> 类：具体处理者类，处理它负责的请求，可访问它的后继者，如果可处理该请求，就处理之，否则就将该请求转发给它的后继者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConcreteHandler1: 当请求数为0~10时有权处理，否则转发给后继</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandler1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span> &#123;<br>    <span class="hljs-keyword">if</span> (request &gt;= <span class="hljs-number">0</span> &amp;&amp; request &lt; <span class="hljs-number">10</span>) &#123;<br>      System.out.println(<span class="hljs-built_in">this</span>.getClass().getSimpleName() + <span class="hljs-string">&quot;处理请求&quot;</span> + request);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) &#123;<br>      successor.handleRequest(request);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// ConcreteHandler2: 当请求数为10~20时有权处理，否则转发给后继</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandler2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span> &#123;<br>    <span class="hljs-keyword">if</span> (request &gt;= <span class="hljs-number">10</span> &amp;&amp; request &lt; <span class="hljs-number">20</span>) &#123;<br>      System.out.println(<span class="hljs-built_in">this</span>.getClass().getSimpleName() + <span class="hljs-string">&quot;处理请求&quot;</span> + request);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (successor != <span class="hljs-literal">null</span>) &#123;<br>      successor.handleRequest(request);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Handler</span> <span class="hljs-variable">h1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteHandler1</span>();<br><span class="hljs-type">Handler</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteHandler2</span>();<br><br>h1.setSuccessor(h2);<br><br><span class="hljs-type">int</span>[] requests = &#123; <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">14</span> &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> request : requests) &#123;<br>h1.handleRequest(request);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用，大大降低了耦合度。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理。需要事先考虑全面。</p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-5.DP-数位统计DP</title>
    <link href="/posts/97ab2a1f.html"/>
    <url>/posts/97ab2a1f.html</url>
    
    <content type="html"><![CDATA[<h1 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h1><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>分情况讨论。</p><h2 id="模板题：计数问题"><a href="#模板题：计数问题" class="headerlink" title="模板题：计数问题"></a>模板题：计数问题</h2><p>求数a～b中，0～9出现的次数。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>类似前缀和的思想。构造一个函数<code>count(n, x)</code>，表示1～n中x出现的次数</p><p><code>ans = count(b, x) - count(a - 1, x)</code></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>遍历位数，分别求出x在每一位上出现的次数。</p><p>设<code>n=abcdefg</code>，求<code>x</code>在第4位上出现的次数：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs llvm">将第<span class="hljs-number">3</span>位确定为<span class="hljs-keyword">x</span><br><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> yyxzzz &lt;<span class="hljs-operator">=</span> abcdef<br><br>分情况：<br>(<span class="hljs-number">1</span>) yy <span class="hljs-operator">=</span> <span class="hljs-number">00</span> ~ ab - <span class="hljs-number">1</span>: zzz可取<span class="hljs-number">000</span>~<span class="hljs-number">999</span>. 总次数为ab * <span class="hljs-number">1000</span><br>(<span class="hljs-number">2</span>) yy <span class="hljs-operator">=</span> ab:<br>(<span class="hljs-number">2.1</span>) <span class="hljs-keyword">c</span> &lt; <span class="hljs-keyword">x</span>: abxzzz &gt; abcdef，总次数为<span class="hljs-number">0</span><br>(<span class="hljs-number">2.2</span>) <span class="hljs-keyword">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>: zzz可取<span class="hljs-number">000</span>~def，总次数为def + <span class="hljs-number">1</span><br>(<span class="hljs-number">2.3</span>) <span class="hljs-keyword">c</span> &gt; <span class="hljs-keyword">x</span>: zzz可取<span class="hljs-number">000</span>~<span class="hljs-number">999</span>，总次数为<span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-4.DP-计数类DP</title>
    <link href="/posts/c539c0da.html"/>
    <url>/posts/c539c0da.html</url>
    
    <content type="html"><![CDATA[<h1 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h1><h2 id="模板题：整数划分"><a href="#模板题：整数划分" class="headerlink" title="模板题：整数划分"></a>模板题：整数划分</h2><h3 id="解法一：完全背包问题"><a href="#解法一：完全背包问题" class="headerlink" title="解法一：完全背包问题"></a>解法一：完全背包问题</h3><p>看作从权重为1～n的物品中选总权重不超过n的物品的完全背包问题，属性为总选法的个数cnt。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">f[i][j] = f[i - <span class="hljs-number">1</span>][j] + f[i - <span class="hljs-number">1</span>][j - i] + f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span>i] + ... + f[i - <span class="hljs-number">1</span>][j - si]<br>f[i][j - i] = f[i - <span class="hljs-number">1</span>][j - i] + f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span>i] + ... + f[i - <span class="hljs-number">1</span>][j - si]<br><br>=&gt;f[i][j] = f[i - <span class="hljs-number">1</span>][j] + f[i][j - i]<br></code></pre></td></tr></table></figure><h3 id="解法二：计数DP"><a href="#解法二：计数DP" class="headerlink" title="解法二：计数DP"></a>解法二：计数DP</h3><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p>集合：<code>f(i, j)</code>表示所有总和是<code>i</code>，并且恰好表示成<code>j</code>个数的和的方案。</p><p>属性：方案数量</p><h4 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h4><p>集合划分为：<code>方案中的最小值为1</code> 和 <code>方案中的最小值大于1</code> 两个集合。</p><p><code>f[i][j] = f[i - 1][j - 1] + f[i - j][j]</code>，等式右边的两项分别对应上述两个集合的方案数。</p><blockquote><p><code>f[i - 1][j - 1]</code>表示把集合中等于1的那个数去掉的选法数量，之后加上1选法数量不变</p><p><code>f[i - j][j]</code>表示把方案中所有数都减去1的选法数量，总共减了<code>j</code>，数的个数还是<code>j</code></p></blockquote><p><code>ans = f[n][1] + f[n][2] + ... + f[n][n]</code></p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式23-命令模式</title>
    <link href="/posts/936974fa.html"/>
    <url>/posts/936974fa.html</url>
    
    <content type="html"><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>命令模式（Command），将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/29/DhKeTdnJQt6GuxX.jpg" alt="命令模式结构图.jpg"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Command</code> 类：用来声明执行操作的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> &#123;<br>  <br>  <span class="hljs-keyword">protected</span> Receiver receiver;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Command</span><span class="hljs-params">(Receiver receiver)</span> &#123;<br>    <span class="hljs-built_in">this</span>.receiver = receiver;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 执行命令</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeCommand</span><span class="hljs-params">()</span>;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteCommand</code> 类：将一个 <code>Receiver</code> 对象绑定于一个动作，调用 <code>Receiver</code> 相应的操作，以实现 <code>executeCommand</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Command</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteCommand</span><span class="hljs-params">(Receiver receiver)</span> &#123;<br>    <span class="hljs-built_in">super</span>(receiver);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeCommand</span><span class="hljs-params">()</span> &#123;<br>    receiver.action();<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>Invoker</code> 类：要求 <code>Command</code> 执行请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> Command command;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command command)</span> &#123;<br>    <span class="hljs-built_in">this</span>.command = command;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeCommand</span><span class="hljs-params">()</span> &#123;<br>    command.executeCommand();<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>Receiver</code> 类：知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;执行请求&quot;</span>);<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Receiver</span> <span class="hljs-variable">receiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Receiver</span>();<br><span class="hljs-type">Command</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteCommand</span>(receiver);<br><span class="hljs-type">Invoker</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Invoker</span>();<br><br>invoker.setCommand(command);<br>invoker.executeCommand();<br></code></pre></td></tr></table></figure><h2 id="进一步改进代码"><a href="#进一步改进代码" class="headerlink" title="进一步改进代码"></a>进一步改进代码</h2><p><code>Invoker</code> 类中的 <code>Command</code> 属性可以修改成 <code>List</code>，以实现执行命令的批处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> ArrayList&lt;Command&gt; commands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Command&gt;();<br>  <br>  <span class="hljs-comment">// 设置命令</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command command)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> command.getClass().getSimpleName();<br>    <br>    <span class="hljs-keyword">if</span> (className.equals(<span class="hljs-string">&quot;xxx&quot;</span>))&#123; <span class="hljs-comment">// 对无法完成的请求给予回绝</span><br>      <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>.commands.add(command);<br>      System.out.println(<span class="hljs-string">&quot;增加请求：&quot;</span> + className + <span class="hljs-string">&quot;，时间：&quot;</span> + getNowTime());<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 取消命令</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelCommand</span><span class="hljs-params">(Command command)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> command.getClass().getSimpleName();<br>    commands.remove(command);<br>    System.out.println(<span class="hljs-string">&quot;取消请求：&quot;</span> + className + <span class="hljs-string">&quot;，时间：&quot;</span> + getNowTime());<br>  &#125;<br>  <br>  <span class="hljs-comment">// 通知执行</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyCommand</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (Command command : commands)<br>      command.executeCommand();<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getNowTime</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SimpleDataFormat</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>);<br>    <span class="hljs-keyword">return</span> formatter.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).toString();<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Receiver</span> <span class="hljs-variable">receiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Receiver</span>();<br><span class="hljs-type">Command</span> <span class="hljs-variable">command1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteCommand1</span>(receiver);<br><span class="hljs-type">Command</span> <span class="hljs-variable">command2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteCommand2</span>(receiver);<br><span class="hljs-type">Invoker</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Invoker</span>();<br><br>invoker.setCommand(command1);<br>invoker.setCommand(command2);<br>invoker.setCommand(command1);<br>invoker.setCommand(command1);<br><br>invoker.cancelCommand(command1);<br><br>invoker.setCommand(command2);<br><br>invoker.notifyCommand(); <span class="hljs-comment">// 执行所有命令</span><br></code></pre></td></tr></table></figure><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>它能较容易地设计一个命令队列</li><li>在需要的情况下，可以较容易地将命令记录进日志</li><li>允许接受请求的一方决定是否要否决请求</li><li>可以容易地实现对请求的撤销与重做</li><li>由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易</li><li>把<strong>请求一个操作</strong>的对象与<strong>知道怎么执行一个操作</strong>的对象分隔开</li></ul><blockquote><p>敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销／恢复操作等功能时，把原来的代码重构为命令模式才有意义。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-3.DP-区间DP</title>
    <link href="/posts/157417db.html"/>
    <url>/posts/157417db.html</url>
    
    <content type="html"><![CDATA[<h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><h2 id="状态分析"><a href="#状态分析" class="headerlink" title="状态分析"></a>状态分析</h2><h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p><code>f(i, j)</code>一般表示从i到j这个区间中的方案。</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>要保证每次枚举的时候等式右侧的状态已经被更新过了。</p><p>所以按照区间长度从小到大来枚举。</p><p>三重循环：</p><ol><li>区间长度从小到大</li><li>区间左端点（右端点可以通过左端点和长度算出来）</li><li>左右端点之间的分界点</li></ol><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><p>时间复杂度：<code>O(n^3)</code>，状态表示2维<code>O(n^2)</code> * 状态计算枚举分界线<code>O(n)</code></p><h4 id="状态分析-1"><a href="#状态分析-1" class="headerlink" title="状态分析"></a>状态分析</h4><h5 id="状态表示-1"><a href="#状态表示-1" class="headerlink" title="状态表示"></a>状态表示</h5><ul><li>集合：所有将第i堆石子到第j堆石子合并成一堆石子的合并方式</li><li>属性：代价的min</li></ul><h5 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h5><p>以最后一次合并的分界线的位置来分类：枚举i到j中的任何一个点x，把x左边和右边的石子合并</p><p>转移方程：<code>f[i][j] = min&#123;f[i][k] + f[k + 1][j] + s[j] - s[i - 1]&#125;, k = i ~ j-1</code></p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-2.DP-线性DP</title>
    <link href="/posts/40472d26.html"/>
    <url>/posts/40472d26.html</url>
    
    <content type="html"><![CDATA[<h1 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h1><p>DP的递推顺序是线性的。</p><blockquote><p>比如：<code>f(i, j)</code>中i和j是从小到大递增。</p><p>背包问题就是线性DP。</p></blockquote><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p><code>f(i, j)</code>表示走到第i行第j列时的最大路径</p><p>方程：<code>f(i, j) = max(f[i - 1][j], f[i - 1][j - 1]) + a[i][j]</code></p><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><p><code>f[i]</code>表示所有以第i个数结尾的上升子序列长度的最大值</p><p>从0到i-1枚举倒数第二位j，找到最长的<code>f[j]</code></p><p>方程：<code>f[i] = max(f[j] + 1), j = 0,1,2,...,i-1 &amp;&amp; a[j] &lt; a[i]</code></p><p>记录方案：用一个g数组记录第i个数对应的最长子序列中倒数第二位j：<code>g[i] = j</code>，最后就可以把路径倒序输出</p><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p><code>f(i, j)</code> 表示所有在第一个序列的前i个字母中出现，且在第二个序列的前j个字母中出现的子序列的长度的最大值</p><p>集合划分：</p><ul><li><p>以<code>a[i]</code>和<code>b[j]</code>是否出现在子序列中划分（4种情况）</p><ul><li>00：<code>f(i - 1, j - 1)</code>（不用写，已经包含在01和10情况内了）</li><li>01：<code>f(i - 1, j)</code></li><li>10：<code>f(i, j - 1)</code></li><li>11：<code>f(i - 1, j - 1) + 1</code>, 且需要满足<code>a[i] == b[j]</code></li></ul><blockquote><p>注意：</p><p>01情况：<code>f(i - 1, j)</code>和01又区别，前者表示在第二个的前j个字母中出现的子序列（第j个字母不一定包含在子序列内），而后者表示第j个字母一定在子序列内。前者包含后者。但由于<code>f(i, j)</code>包含<code>f(i - 1, j)</code>这种状态，属性又为Max（集合划分适当重叠不影响结果的正确性，只要不漏掉某些情况），所以可以这样表示。</p><p>10情况同理。</p><p>不懂再去复习一下题解。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-0.DP理解方式</title>
    <link href="/posts/98bf06c9.html"/>
    <url>/posts/98bf06c9.html</url>
    
    <content type="html"><![CDATA[<h1 id="DP理解"><a href="#DP理解" class="headerlink" title="DP理解"></a>DP理解</h1><h2 id="DP求解过程"><a href="#DP求解过程" class="headerlink" title="DP求解过程"></a>DP求解过程</h2><p>DP求解过程可以分为两步：状态表示</p><h3 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h3><p>思考：问题需要用几维的状态来表示？</p><blockquote><p>背包问题有两维。</p></blockquote><p><code>f(i, j)</code></p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p><code>f(i, j)</code>表示的是什么集合？</p><blockquote><p>如背包问题：<code>f(i, j)</code>表示所有选法的集合。</p></blockquote><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p><code>f(i, j)</code>这个数存的是这个集合的什么属性？min, max, cnt?</p><blockquote><p>如背包问题：<code>f(i, j)</code>表示集合选法对应的价值的最大值。</p></blockquote><h3 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h3><p>思考：如何一步一步地把每个状态算出来？</p><p>对应集合划分。如何将当前的集合<strong>不重不漏</strong>地划分成若干更小的子集，使得每一个子集都能够被前面的状态表示出来。</p><h2 id="DP优化"><a href="#DP优化" class="headerlink" title="DP优化"></a>DP优化</h2><p>DP优化一般是对代码&#x2F;状态方程做等价变形。</p><p>先把朴素算法写出来，再变形。</p><h1 id="DP时间复杂度分析"><a href="#DP时间复杂度分析" class="headerlink" title="DP时间复杂度分析"></a>DP时间复杂度分析</h1><p>状态数量 * 转移计算量</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式22-桥接模式</title>
    <link href="/posts/2047b357.html"/>
    <url>/posts/2047b357.html</url>
    
    <content type="html"><![CDATA[<h1 id="合成-聚合复用原则-CARP"><a href="#合成-聚合复用原则-CARP" class="headerlink" title="合成&#x2F;聚合复用原则 (CARP)"></a>合成&#x2F;聚合复用原则 (CARP)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>合成／聚合复用原则（CARP），尽量使用合成 (Composition)／聚合 (Aggregation)，尽量不要使用类继承。</p><h2 id="合成和聚合"><a href="#合成和聚合" class="headerlink" title="合成和聚合"></a>合成和聚合</h2><ul><li><p>聚合表示一种弱的’拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。</p><ul><li>如：大雁是群居动物，所以每只大雁都是属于一个雁群，一个雁群可以有多只大雁，所以大雁和雁群是聚合关系。</li></ul></li><li><p>合成则是一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</p><ul><li>如：大雁有两个翅膀，翅膀与大雁是部分和整体的关系，并且它们的生命周期是相同的，于是大雁和翅膀就是合成关系。</li></ul></li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>优先使用对象的合成／聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>桥接模式（Bridge），将抽象部分（如手机品牌）与它的实现部分（如手机软件）分离，使它们都可以独立地变化。</p><blockquote><p>什么叫抽象与它的实现分离？这并不是说，让抽象类与其派生类分离，因为这没有任何意义。实现指的是抽象类和它的派生类用来实现自己的对象。</p><p>实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。</p></blockquote><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/26/pstFy3v7dxHa481.png" alt="桥接模式结构图.png"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Implementor</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Implementor</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteImplementorA</code>和<code>ConcreteImplementorB</code>等派生类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteImplementorA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Implementor</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;具体实现A的方法执行&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteImplementorB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Implementor</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;具体实现B的方法执行&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Abstraction</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Abstraction</span> &#123;<br>  <br>  <span class="hljs-keyword">protected</span> Implementor implementor;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setImplementor</span><span class="hljs-params">(Implementor implementor)</span> &#123;<br>    <span class="hljs-built_in">this</span>.implementor = implementor;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RefinedAbstraction</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefinedAbstraction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Abstraction</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>    System.out.print(<span class="hljs-string">&quot;具体的Abstraction&quot;</span>);<br>    implementor.operation();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Abstraction ab;<br>ab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefinedAbstraction</span>();<br><br>ab.setImplementor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteImplementorA</span>());<br>ab.operation();<br><br>ab.setImplementor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteImplementorB</span>());<br>ab.operation();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板4-1.DP-背包问题</title>
    <link href="/posts/d549d88.html"/>
    <url>/posts/d549d88.html</url>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h1 id="通用问题描述"><a href="#通用问题描述" class="headerlink" title="通用问题描述"></a>通用问题描述</h1><p>给定 <code>N</code> 个物品和容量是为 <code>V</code> 的背包。每一个物品 <code>i</code> 有两个属性：体积 <code>vi</code> 和价值 <code>wi</code> 。</p><p>求：在 <code>总体积&lt;=V</code>的情况下，选出一些物品，它们的<code>最大价值之和</code>是多少。</p><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定 <code>N</code> 个物品和容量是为 <code>V</code> 的背包。每一个物品 <code>i</code> 有两个属性：体积 <code>vi</code> 和价值 <code>wi</code> 。</p><p>求：在 <code>总体积&lt;=V</code>的情况下，选出一些物品，它们的<code>最大价值之和</code>是多少。</p><p><strong>每件物品只能用一次或者不用。</strong></p><h3 id="状态分析"><a href="#状态分析" class="headerlink" title="状态分析"></a>状态分析</h3><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f(i, j)</code></p><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>所有选法的集合。</p><p>满足条件：</p><ol><li>只从前 <code>i</code> 个物品中选</li><li>选出来的物品的 <code>总体积 &lt;= j</code></li></ol><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p><code>f(i, j)</code> 表示所有选法集合里的价值的最大值。</p><h4 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h4><p>集合划分：<code>f(i, j)</code> 分成不含 <code>i</code> （一定存在）和含 <code>i</code>（不一定存在，只有j &gt;&#x3D; vi才存在） 两种情况的集合。</p><p>得出状态转移方程：</p><p><code>f(i, j) = max(f(i - 1, j), f(i - 1, j - vi) + wi)</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="朴素：二维"><a href="#朴素：二维" class="headerlink" title="朴素：二维"></a>朴素：二维</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m; <span class="hljs-comment">// n: N, m: V</span><br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++)<br>  &#123;<br>    f[i][j] = f[i - <span class="hljs-number">1</span>][j]; <span class="hljs-comment">// 不含i，一定存在</span><br>    <span class="hljs-keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - v[i]] + w[i]); <span class="hljs-comment">// 含i，需要判断条件</span><br>  &#125;<br><br>cout &lt;&lt; f[n][m] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h4 id="优化：一维"><a href="#优化：一维" class="headerlink" title="优化：一维"></a>优化：一维</h4><p>思路：</p><p>由于 <code>f[i]</code> 这一层只需要用到 <code>f[i - 1]</code> 层，所以可以优化成两层的滚动数组。</p><p>又两种情况：j和j-v[i]都是小于等于j的，说明不会同时用到当前列两边的数据，所以可以进一步优化成一层数组，即优化成一维数组。</p><p>需要注意：由于j-v[i]在j的左边，需要保证第i-1层循环中的<code>f[j - v[i]]</code>在被用到的时候没有被第i层更新过，所以内层循环j应从大到小枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j --)<br>  &#123;<br>    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定 <code>N</code> 个物品和容量是为 <code>V</code> 的背包。每一个物品 <code>i</code> 有两个属性：体积 <code>vi</code> 和价值 <code>wi</code> 。</p><p>求：在 <code>总体积&lt;=V</code>的情况下，选出一些物品，它们的<code>最大价值之和</code>是多少。</p><p><strong>每件物品有无限个。</strong></p><h3 id="状态分析-1"><a href="#状态分析-1" class="headerlink" title="状态分析"></a>状态分析</h3><h4 id="状态表示-1"><a href="#状态表示-1" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f(i, j)</code></p><h5 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h5><p>所有选法的集合。</p><p>满足条件：</p><ol><li>只从前 <code>i</code> 个物品中选</li><li>选出来的物品的 <code>总体积 &lt;= j</code></li></ol><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><p><code>f(i, j)</code> 表示所有选法集合里的价值的最大值。</p><h4 id="状态计算-1"><a href="#状态计算-1" class="headerlink" title="状态计算"></a>状态计算</h4><p>集合划分：<code>f(i, j)</code> 分成含<code>0~k</code> 个 <code>i</code> 的集合，其中<code>k</code>满足<code>j &gt;= k*v[i]</code>。</p><p>得出状态转移方程：</p><p><code>f(i, j) = max(f(i - 1, j), f(i - 1, j - k * vi) + k * wi), j &gt;= k*v[i]</code></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="朴素：二维，三重循环"><a href="#朴素：二维，三重循环" class="headerlink" title="朴素：二维，三重循环"></a>朴素：二维，三重循环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m; <span class="hljs-comment">// n: N, m: V</span><br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j; k ++)<br>      f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - k * v[i]] + k * w[i]);<br></code></pre></td></tr></table></figure><h4 id="优化：一维，两重循环"><a href="#优化：一维，两重循环" class="headerlink" title="优化：一维，两重循环"></a>优化：一维，两重循环</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">f<span class="hljs-selector-attr">[i, j]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span>, f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - v]</span> + w, f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - 2v]</span> + <span class="hljs-number">2</span>w, f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - 3v]</span> + <span class="hljs-number">3</span>w, ...)<br>=&gt;f<span class="hljs-selector-attr">[i, j - v]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - v]</span>, f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - 2v]</span> + w, f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - 3v]</span> + <span class="hljs-number">2</span>w, ...)<br>可以推出：<br>f<span class="hljs-selector-attr">[i, j]</span> = <span class="hljs-built_in">max</span>(f<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span>, f<span class="hljs-selector-attr">[i, j - v]</span> + w)<br></code></pre></td></tr></table></figure><p><code>f[i, j - v]</code>用的是第<code>i</code>层的<code>f[j - v[i]]</code> 所以内层循环j从小到大枚举，这样<code>f[j - v[i]]</code> 刚好是被第<code>i</code>层更新过的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = v[i]; j &lt;= m; j ++)<br>      f[i][j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br></code></pre></td></tr></table></figure><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定 <code>N</code> 个物品和容量是为 <code>V</code> 的背包。每一个物品 <code>i</code> 有两个属性：体积 <code>vi</code> 和价值 <code>wi</code> 。</p><p>求：在 <code>总体积&lt;=V</code>的情况下，选出一些物品，它们的<code>最大价值之和</code>是多少。</p><p><strong>每件物品有 <code>si</code> 个。</strong></p><h3 id="状态分析-2"><a href="#状态分析-2" class="headerlink" title="状态分析"></a>状态分析</h3><h4 id="状态表示-2"><a href="#状态表示-2" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f(i, j)</code></p><h5 id="集合-2"><a href="#集合-2" class="headerlink" title="集合"></a>集合</h5><p>所有选法的集合。</p><p>满足条件：</p><ol><li>只从前 <code>i</code> 个物品中选</li><li>选出来的物品的 <code>总体积 &lt;= j</code></li></ol><h5 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h5><p><code>f(i, j)</code> 表示所有选法集合里的价值的最大值。</p><h4 id="状态计算-2"><a href="#状态计算-2" class="headerlink" title="状态计算"></a>状态计算</h4><p>集合划分：<code>f(i, j)</code> 分成含<code>0~s[i]</code> 个 <code>i</code> 的集合。</p><p>得出状态转移方程（和完全背包类似，只是k变成了s[i]）：</p><p><code>f(i, j) = max(f(i - 1, j - k * vi) + k * wi), k=0, 1, ..., si</code></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="朴素"><a href="#朴素" class="headerlink" title="朴素"></a>朴素</h4><p>时间复杂度：<code>N * V * S</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++)<br>      f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - k * v[i]] + k * w[i]);<br></code></pre></td></tr></table></figure><h4 id="优化：二进制优化"><a href="#优化：二进制优化" class="headerlink" title="优化：二进制优化"></a>优化：二进制优化</h4><p>能不能像完全背包一样优化呢？</p><p>不能，它们是有区别的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 完全背包</span><br>f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j - v] + w, f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span>v] + <span class="hljs-number">2</span>w, f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">3</span>v] + <span class="hljs-number">3</span>w, ...)<br>=&gt;f[i][j - v] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j - v], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span>v] + w, f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">3</span>v] + <span class="hljs-number">2</span>w, ...)<br><span class="hljs-comment">// 两个省略号是完全可以对齐的，因为只要满足第二维下标j-kv&gt;=0即可</span><br>可以推出：<br>f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - v] + w)<br>  <br><span class="hljs-comment">// 多重背包</span><br>f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i - <span class="hljs-number">1</span>][j - v] + w, f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span>v] + <span class="hljs-number">2</span>w, f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">3</span>v] + <span class="hljs-number">3</span>w, ..., f[i - <span class="hljs-number">1</span>][j - sv] + sw)<br>=&gt;f[i][j - v] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j - v], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">2</span>v] + w, f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">3</span>v] + <span class="hljs-number">2</span>w, ..., f[i - <span class="hljs-number">1</span>][j - (s+<span class="hljs-number">1</span>)v] + sw)<br><span class="hljs-comment">// 两个省略号不一定是完全可以对齐的，因为有可能j-(s+1)v&gt;=0，那么j-sv&gt;=0也成立，但没有(s+1)那么多个物品，相当于提前结束了，此时第一个等式中没有一项与f[i - 1][j-(s+1)v]对齐</span><br><span class="hljs-comment">// 无法通过第二个等式来得出第一个等式中f[i][j]的最大值</span><br></code></pre></td></tr></table></figure><p>优化方式：<strong>二进制优化</strong>，看成若干个01背包问题</p><p>时间复杂度：<code>N * V * logS</code></p><p>对于一个一般的s（即物品个数），把它分成若干个组，其中前k+1组中第i组中有<code>2^i</code>个物品（<code>i=0~k</code>），最后一组中有<code>c</code>个物品（<code>c=(s-前k+1组中物品之和) &amp;&amp; c &lt; 2^(k+1)</code>），这样通过选或不选各个组，可以拼凑出取<code>0～s</code> 个物品的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = n * logs, M = v;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N];<br><br><span class="hljs-comment">// 预处理物品</span><br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>&#123;<br>  <span class="hljs-type">int</span> a, b, s; <span class="hljs-comment">// 分别为当前物品的体积，价值和个数</span><br>  cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>  <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (k &lt;= s)<br>  &#123;<br>    cnt ++;<br>    v[cnt] = a * k;<br>    w[cnt] = b * k;<br>    s -= k;<br>    k &lt;&lt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 还剩下c个物品</span><br>  &#123;<br>    cnt ++;<br>    v[cnt] = a * s;<br>    w[cnt] = b * s;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 转化成01背包求解</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; cnt; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j --)<br>    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br><br>cout &lt;&lt; f[m] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定 <code>N</code> 组物品和容量是为 <code>V</code> 的背包，每组物品里有若干件物品。每一个物品 <code>i</code> 有两个属性：体积 <code>vi</code> 和价值 <code>wi</code> 。</p><p>求：在 <code>总体积&lt;=V</code>的情况下，选出一些物品，它们的<code>最大价值之和</code>是多少。</p><p><strong>每组物品中只能选1件。</strong></p><h3 id="状态分析-3"><a href="#状态分析-3" class="headerlink" title="状态分析"></a>状态分析</h3><h4 id="状态表示-3"><a href="#状态表示-3" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f(i, j)</code></p><h5 id="集合-3"><a href="#集合-3" class="headerlink" title="集合"></a>集合</h5><p>所有选法的集合。</p><p>满足条件：</p><ol><li>只从前 <code>i</code> 组物品中选</li><li>选出来的物品的 <code>总体积 &lt;= j</code></li></ol><h5 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h5><p><code>f(i, j)</code> 表示所有选法集合里的价值的最大值。</p><h4 id="状态计算-3"><a href="#状态计算-3" class="headerlink" title="状态计算"></a>状态计算</h4><p>集合划分：<code>f(i, j)</code> 枚举：选第<code>i</code>组物品中的哪一个或者不选。</p><p>状态转移方程：<code>f(i, j) = max(f(i - 1, j), f(i - 1, j - v[i][k]) + w[i][k])</code></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j --) <span class="hljs-comment">// 这里 j &gt;= 0 而不是 j &gt;= v[i] 是因为一组有多种物品，无法确定一个v[i]，放到循环内部去判断了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; s[i]; k ++) <span class="hljs-comment">// s[i]为该组物品个数</span><br>      <span class="hljs-keyword">if</span> (j &gt;= v[i][k]) f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式21-单例模式</title>
    <link href="/posts/fb74e26e.html"/>
    <url>/posts/fb74e26e.html</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单例模式（Singleton），保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/23/7qNvY9VbhWHPit2.png" alt="单例模式结构图.png"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>Singleton类，定义一个GetInstance操作，允许客户访问它的唯一实例。GetInstance是一个静态方法，主要负责创建自己的唯一实例。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>调用getInstance的时候再来创建instance。</p><h4 id="V1-线程不安全"><a href="#V1-线程不安全" class="headerlink" title="V1 线程不安全"></a>V1 线程不安全</h4><p>在多线程的情况下有可能创建多个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>  <br>  <span class="hljs-comment">// 构造方法private化，堵死了外部代码利用new创建此类实例的可能</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>  <br>  <span class="hljs-comment">// 得到Singleton的实例（唯一途径）</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> instance; <span class="hljs-comment">// 当instance为null时创建一个返回，否则直接返回原有实例</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="V2-synchronized锁方法"><a href="#V2-synchronized锁方法" class="headerlink" title="V2 synchronized锁方法"></a>V2 synchronized锁方法</h4><p>每次调用 <code>getInstance</code> 时都需要锁。写起来简单，但比较影响性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>  <br>  <span class="hljs-comment">// 构造方法private化</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>  <br>  <span class="hljs-comment">// 得到Singleton的实例（唯一途径）</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>      instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="V3-Double-Check-Locking"><a href="#V3-Double-Check-Locking" class="headerlink" title="V3 Double-Check Locking"></a>V3 Double-Check Locking</h4><p>不用让线程每次都加锁，而只是在实例未被创建的时候再加锁处理。同时也能保证多线程的安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance; <span class="hljs-comment">// volatile作用是使得所有线程能够及时得知instance是否被实例化的状态</span><br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123; <span class="hljs-comment">// 保证所有线程用的是同一把锁</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>          instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要两次判断instance是否为null？</p><p>对于instance存在的情况，就直接返回，这没有问题。当instance为null并且同时有两个线程调用getInstance（）方法时，它们将都可以通过第一重instance&#x3D;&#x3D;null的判断。然后由于’锁’机制，这两个线程则只有一个进入，另一个在外排队等候，必须要其中的一个进入并出来后，另一个才能进入。而此时如果没有了第二重的instance是否为null的判断，则第一个线程创建了实例，而第二个线程还是可以继续再创建新的实例，这就没有达到单例的目的。</p><h3 id="饿汉式（静态初始化）"><a href="#饿汉式（静态初始化）" class="headerlink" title="饿汉式（静态初始化）"></a>饿汉式（静态初始化）</h3><p>不管有没有调用getInstance，先在自己被加载时就把instance创建出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="客户端代码："><a href="#客户端代码：" class="headerlink" title="客户端代码："></a>客户端代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Singleton s0 = new Singleton();</span><br><span class="hljs-type">Singleton</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br><span class="hljs-type">Singleton</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br><br><span class="hljs-keyword">if</span> (s1 == s2) &#123;<br>  System.out.println(<span class="hljs-string">&quot;两个对象是相同的实例&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单例模式好处"><a href="#单例模式好处" class="headerlink" title="单例模式好处"></a>单例模式好处</h2><ol><li>可以保证唯一的实例。</li><li>因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。</li></ol><h2 id="饿汉式和懒汉式对比"><a href="#饿汉式和懒汉式对比" class="headerlink" title="饿汉式和懒汉式对比"></a>饿汉式和懒汉式对比</h2><p>饿汉式，即静态初始化的方式，它是类一加载就实例化的对象，所以要提前占用系统资源。</p><p>然而懒汉式，又会面临着多线程访问的安全性问题，需要做双重锁定这样的处理才可以保证安全。</p><p>到底使用哪一种方式，取决于实际的需求。从Java语言角度来讲，饿汉式的单例类已经足够满足我们的需求了。</p><h2 id="单例模式-vs-实用类静态方法"><a href="#单例模式-vs-实用类静态方法" class="headerlink" title="单例模式 vs 实用类静态方法"></a>单例模式 vs 实用类静态方法</h2><p>和单例模式类似，实用类通常也会采用私有化的构造方法来避免其有实例。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>实用类不保存状态，只提供静态方法或静态属性使用；而单例类有状态。</li><li>实用类不能用于继承多态；而单例类虽然实例唯一，但可以有子类来继承。</li><li>实用类是一些方法属性的集合；单例类有唯一的对象实例。</li></ol>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板3-6.二分图</title>
    <link href="/posts/9f5052e9.html"/>
    <url>/posts/9f5052e9.html</url>
    
    <content type="html"><![CDATA[<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p>通俗定义：一个图可以分成两个集合，每个集合内部没有边。</p><h2 id="染色法-DFS"><a href="#染色法-DFS" class="headerlink" title="染色法 (DFS)"></a>染色法 (DFS)</h2><p>时间复杂度：<code>O(n + m)</code></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>判别一个图是否为二分图。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>一个图是二分图（等价于这个图可以被2染色），当且仅当图中不含奇数环。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><ul><li><p>必要性（二分图-&gt;不含奇数环）：反证法</p><p>假设有奇数环：把环中每个点依次标记为1, 2, 1, 2, … 标记到最后一个点的时候，应该为1。而它后一个点（也就是第一个点）也为1，矛盾。</p></li><li><p>充分性（不含奇数环-&gt;二分图）：</p><p>先任意标记一个点为1，之后与它连通的所有点的数字都被确定。在不与它连通的点中，又任选一个点标记为1。</p><p>由于图中不含奇数环，所以染色过程中一定没有矛盾。</p><blockquote><p>证明：反证法</p><p>如果染色过程中出现了矛盾，那么一定是1, 2, 1, 2, …, 1, 1这种形式，最后两个1和1一定头尾相接（否则最后一个1可以被标记为2），那么环中点的数量一定为奇数，即图中一定含有奇数环</p></blockquote></li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">if</span> (i未被染色)<br>    <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">1</span>) <span class="hljs-comment">// 1表示染的颜色</span><br>    <br><span class="hljs-comment">// dfs过程</span><br>递归将所有相邻的点染成相反的颜色，并且判断能不能成功并返回<br></code></pre></td></tr></table></figure><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> color[N]; <span class="hljs-comment">// 表示每个点的颜色，-1表示为染色，0表示白色，1表示黑色</span><br><br><span class="hljs-comment">// 参数：u表示当前节点，c表示当前点的颜色</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>  color[u] = c;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) <span class="hljs-comment">// 遍历所有相邻点</span><br>  &#123;<br>    <span class="hljs-type">int</span> j = e[i];<br>    <span class="hljs-keyword">if</span> (color[j] == <span class="hljs-number">-1</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(j, !c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果相邻点还没有染色，递归染色，传递的颜色是与当前点相反的颜色</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>  <span class="hljs-built_in">memset</span>(color, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> color);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    <span class="hljs-keyword">if</span> (color[i] == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>时间复杂度：理论最坏<code>O(mn)</code>，实际远小于 <code>O(mn)</code>（可能接近线性）</p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>求二分图的成功匹配的情况下，最大的匹配数量。</p><p>匹配：指的是边的数量。</p><p>匹配成功：不存在两条边共用一个点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">设左边集合为S1，右边集合为S2.<br>依次遍历S1中的每个点i，看能否匹配S2中的点：<br>  <span class="hljs-number">1.</span> 如果有S2中的点没有被匹配，或者它匹配的S1中的点可以换一个点匹配，返回<span class="hljs-literal">true</span><br>  <span class="hljs-number">2.</span> 如果i指向的所有点都不能被匹配，返回<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n1, n2; <span class="hljs-comment">// n1表示S1中的点数，n2表示S2中的点数</span><br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx; <span class="hljs-comment">// 邻接表存储所有边，匈牙利算法中只会用到从S1指向S2的边</span><br><span class="hljs-type">int</span> match[N]; <span class="hljs-comment">// 存储S2中的每一个点当前匹配的S1中的点是哪个</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 表示S2中的每个点是否已经被遍历过</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[x]; ~i; i = ne[i]) <span class="hljs-comment">// 遍历x结点指向S2集合的所有边</span><br>  &#123;<br>    <span class="hljs-type">int</span> j = e[i];<br>    <span class="hljs-keyword">if</span> (!st[j])<br>    &#123;<br>      st[j] = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j])) <span class="hljs-comment">// S2中的j结点还没有被匹配，或者能够让j结点当前匹配的S1中的点换一个点匹配</span><br>      &#123;<br>        match[j] = x;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 求最大匹配数量，依次枚举S1中的每一个点能否匹配S2中的点</span><br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>&#123;<br>  <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st); <span class="hljs-comment">// 在枚举S1中每个点的时候都要把S2中所有点的状态置0，每个点都只需要考虑一次</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i)) res ++;<br>&#125;<br></code></pre></td></tr></table></figure><p>练习：372</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式20-迭代器模式</title>
    <link href="/posts/ebaa2fa0.html"/>
    <url>/posts/ebaa2fa0.html</url>
    
    <content type="html"><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>迭代器模式（Iterator），提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/19/mKfRk7ElDi4Os1p.jpg" alt="迭代器模式结构图.jpg"></p><p>需要有 <code>Iterator</code> 抽象类的原因：遍历方式可能有很多种，需要对不同方式做不同具体实现。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Aggregate</code> 聚集抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>  <br>  <span class="hljs-comment">// 创建迭代器</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteAggregate</code> 具体聚集类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteAggregate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>  <br>  <span class="hljs-comment">// 声明一个ArrayList泛型变量，用于存放聚合对象</span><br>  <span class="hljs-keyword">private</span> ArrayList&lt;Object&gt; items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>  <br>  <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteIterator</span>(<span class="hljs-built_in">this</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 返回聚集总个数</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> items.size();<br>  &#125;<br>  <br>  <span class="hljs-comment">// 增加新对象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object object)</span> &#123;<br>    items.add(object);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 得到指定索引对象</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getCurrentItem</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> items.get(index);<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>Iterator</code> 迭代器抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">first</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 第一个</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 下一个</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 是否到结尾</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 当前对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteIterator</code> 具体迭代器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterator</span> &#123;<br>  <span class="hljs-keyword">private</span> ConcreteAggregate aggregate;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">// 初始化时将具体的聚集对象传入</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteIterator</span><span class="hljs-params">(ConcreteAggregate aggregate)</span> &#123;<br>    <span class="hljs-built_in">this</span>.aggregate = aggregate;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 得到第一个对象</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">first</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> aggregate.getCurrentItem(<span class="hljs-number">0</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 得到下一个对象</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    current ++;<br>    <span class="hljs-keyword">if</span> (current &lt; aggregate.getCount()) &#123;<br>      ret = aggregate.getCurrentItem(current);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 判断当前是否遍历到结尾，到结尾返回true</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> current &gt;= aggregate.getCount() ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 返回当前的聚集对象</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> aggregate.getCurrentItem(current);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ConcreteAggregate</span> <span class="hljs-variable">ca</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteAggregate</span>();<br>ca.add(<span class="hljs-number">1</span>);<br>ca.add(<span class="hljs-number">2</span>);<br>ca.add(<span class="hljs-number">3</span>);<br><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteIterator</span>(ca);<br><br>i.first();<br><span class="hljs-keyword">while</span> (!i.isDone()) &#123;<br>  System.out.println(i.currentItem());<br>  i.next();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Java的迭代器实现"><a href="#Java的迭代器实现" class="headerlink" title="Java的迭代器实现"></a>Java的迭代器实现</h2><p>java.util.Iterator支持对集合的简单迭代接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 如果还有下一个元素，返回true</span><br>  <br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 返回迭代中的下一个元素</span><br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>java.util.ListIterator支持对集合的任意方向上迭代接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ListIterator</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPrevious</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">previous</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>迭代器（Iterator）模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责。</p><p>这样既可以做到<strong>不暴露集合的内部结构</strong>，又可以让外部代码<strong>透明地访问集合内部的数据</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式19-组合模式</title>
    <link href="/posts/f7b71d8d.html"/>
    <url>/posts/f7b71d8d.html</url>
    
    <content type="html"><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>组合模式（Composite），将对象组合成树形结构以表示’部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/18/qbGU8Fy4LRCzDvO.jpg" alt="组合模式结构图.jpg"></p><p><code>Component</code> 接口&#x2F;抽象类：为组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理 <code>Component</code> 的子部件。</p><p><code>Leaf</code> 类：在组合中表示叶节点，无子节点。</p><p><code>Composite</code> 类：定义非叶节点的行为。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Component</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>  <br>  <span class="hljs-keyword">protected</span> String name;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Component</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span>;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">int</span> depth)</span>;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>Leaf</code> 类：add和remove方法没有意义，但好处是可以消除叶节点和非叶节点在抽象层次的区别，它们具备完全一致的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Leaf</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Cannot add to a leaf.&quot;</span>); <span class="hljs-comment">// 叶子无法增加子节点</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Cannot remove from a leaf.&quot;</span>); <span class="hljs-comment">// 叶子无法移除子节点</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">int</span> depth)</span> &#123;<br>    <span class="hljs-comment">// 叶节点的具体显示方法</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; depth; i ++)<br>      System.out.println(<span class="hljs-string">&quot;-&quot;</span>);<br>    System.out.println(name);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Composite</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> ArrayList&lt;Component&gt; children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 存储其下属的非叶节点和叶节点</span><br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Composite</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component component)</span> &#123;<br>    children.add(component);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component component)</span> &#123;<br>    children.remove(component);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">int</span> depth)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; depth; i ++)<br>      System.out.println(<span class="hljs-string">&quot;-&quot;</span>);<br>    System.out.println(name);<br>    <span class="hljs-comment">// 对下一层进行遍历</span><br>    <span class="hljs-keyword">for</span> (Component item : children) &#123;<br>      item.display(depth + <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Composite</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>(<span class="hljs-string">&quot;root&quot;</span>);<br>root.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf A&quot;</span>));<br>root.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf B&quot;</span>));<br><br><span class="hljs-type">Composite</span> <span class="hljs-variable">comp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>(<span class="hljs-string">&quot;Composite X&quot;</span>);<br>comp.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf XA&quot;</span>));<br>comp.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf XB&quot;</span>));<br>root.add(comp);<br><br><span class="hljs-type">Composite</span> <span class="hljs-variable">comp2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Composite</span>(<span class="hljs-string">&quot;Composite XY&quot;</span>);<br>comp2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf XYA&quot;</span>));<br>comp2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf XYB&quot;</span>));<br>comp.add(comp2);<br><br><span class="hljs-type">Leaf</span> <span class="hljs-variable">leaf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf C&quot;</span>);<br>root.add(leaf);<br><br><span class="hljs-type">Leaf</span> <span class="hljs-variable">leaf2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>(<span class="hljs-string">&quot;Leaf D&quot;</span>);<br>root.add(leaf2);<br>root.remove(leaf2);<br><br>root.display(<span class="hljs-number">1</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">展示结果：</span><br><span class="hljs-comment">-root</span><br><span class="hljs-comment">--Leaf A</span><br><span class="hljs-comment">--Leaf B</span><br><span class="hljs-comment">--Composite X</span><br><span class="hljs-comment">---Leaf XA</span><br><span class="hljs-comment">---Leaf XB</span><br><span class="hljs-comment">---Composite XY</span><br><span class="hljs-comment">----LeafXYA</span><br><span class="hljs-comment">----LeafXYB</span><br><span class="hljs-comment">--Leaf C</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="透明方式与安全方式"><a href="#透明方式与安全方式" class="headerlink" title="透明方式与安全方式"></a>透明方式与安全方式</h2><h3 id="透明方式"><a href="#透明方式" class="headerlink" title="透明方式"></a>透明方式</h3><p>在Component中声明所有用来管理子对象的方法，其中包括add、remove等。这样实现Component接口的所有子类都具备了add和remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。但问题也很明显，因为Leaf类本身不具备add()、remove()方法的功能，所以实现它是没有意义的。</p><h3 id="安全方式"><a href="#安全方式" class="headerlink" title="安全方式"></a>安全方式</h3><p>安全方式，也就是在Component接口中不去声明add和remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite中声明所有用来管理子类对象的方法，这样做就不会出现Leaf类也需要实现add()、remove()方法的问题，不过由于不够透明，所以树叶和树枝类将不具有相同的接口，客户端的调用需要做相应的判断，带来了不便。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>发现需求中是体现<strong>部分与整体层次的结构</strong>时，以及希望用户可以忽略组合对象与单个对象的不同，<strong>统一地使用组合结构中的所有对象</strong>时，就应该考虑用组合模式了。</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>组合模式定义了包含基本对象和组合对象的类层次结构。基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象了。</p><p>并且，用户不用关心到底是处理一个叶节点还是处理一个组合组件，也就不用为定义组合而写一些选择判断语句了。组合模式让客户可以一致地使用组合结构和单个对象。</p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式18-备忘录模式</title>
    <link href="/posts/b47e0b1e.html"/>
    <url>/posts/b47e0b1e.html</url>
    
    <content type="html"><![CDATA[<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>备忘录（Memento）：在<strong>不破坏封装性</strong>的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p><blockquote><p>如：游戏中的存档。不破坏封装性即不把过多的细节暴露给客户端</p></blockquote><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/17/Af2uqHx4KsjVtWz.jpg" alt="备忘录模式结构图.jpg"></p><p><code>Originator</code>（发起人）：负责创建一个备忘录 <code>Memento</code>，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。<code>Originator</code> 可根据需要决定 <code>Memento</code> 存储 <code>Originator</code> 的哪些内部状态。</p><p> <code>Memento</code> （备忘录）：负责存储 <code>Originator</code> 对象的内部状态，并可防止 <code>Originator</code> 以外的其他对象访问备忘录 <code>Memento</code> 。备忘录有两个接口：<code>Caretaker</code> 只能看到备忘录的窄接口，它只能将备忘录传递给其他对象；<code>Originator</code> 能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。</p><p><code>CareTaker</code> （管理者）：负责保存好备忘录<code>Memento</code>，不能对备忘录的内容进行操作或检查。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>发起人 <code>Originator</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span> &#123;<br>  <br>  <span class="hljs-comment">// 需要保存的状态，可能有多个</span><br>  <span class="hljs-keyword">private</span> String state;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.state;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(String value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.state = value;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 显示数据</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;State: &quot;</span> + <span class="hljs-built_in">this</span>.state);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 创建备忘录，将当前需要保存的信息（也许不是全部状态）导入，并实例化出一个Memento对象</span><br>  <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">createMemento</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(<span class="hljs-built_in">this</span>.state);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 恢复备忘录，将Memento导入并将相关数据恢复</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoveryMemento</span><span class="hljs-params">(Memento memento)</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(memento.getState());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>备忘录 <code>Memento</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> String state;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Memento</span><span class="hljs-params">(String state)</span> &#123;<br>    <span class="hljs-built_in">this</span>.state = state;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.state;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(String value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.state = value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>管理者 <code>Caretaker</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Caretaker</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> Memento memento;<br>  <br>  <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">getMemento</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.memento;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemento</span><span class="hljs-params">(Memento value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.memento = value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Originator初始状态：例如状态属性为&quot;On&quot;</span><br><span class="hljs-type">Originator</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Originator</span>();<br>o.setState(<span class="hljs-string">&quot;On&quot;</span>);<br>o.show();<br><br><span class="hljs-type">Caretaker</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Caretaker</span>();<br><span class="hljs-comment">// 保存状态时，由于有了很好的封装，可以隐藏Originator的实现细节</span><br>c.setMemento(o.createMMento());<br><br><span class="hljs-comment">// Originator改变了状态属性，变为&quot;Off&quot;</span><br>o.setState(<span class="hljs-string">&quot;Off&quot;</span>);<br>o.show();<br><br><span class="hljs-comment">// 恢复原来的初始状态</span><br>o.recoveryMemento(c.getMemento());<br>o.show();<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>要保存的细节给封装在了Memento中了，要更改保存的细节也不用影响客户端了。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>状态需要完整存储到备忘录对象中，如果状态数据很大很多，那么在资源消耗上，备忘录对象会非常耗内存。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>Memento模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，Originator可以根据保存的Memento信息还原到前一状态。</p><p>有时一些对象的内部信息必须保存在对象以外的地方，但是必须要由对象自己读取，这时，使用备忘录可以把复杂的对象内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。</p><blockquote><p>管理类是有必要的。其实管理类主要得做两件事，一个是保存快照信息，这个快照信息可以保存多份的（用啥容器都行，栈、列表啥的），游戏状态这个例子里只保存了一份，所以会觉得没有必要；第二个是undo操作（即取出某个快照并恢复原发器状态的操作），该操作最好也要由管理者来提供，这样原发器的职责会更单一。</p><p>还有一个很致命的缺陷，快照Memento的getState是public的，不够安全。应该由Memento持有原发器的引用，且由Memento对象提供方法进行原发器对象的状态恢复，这样就不会有Memento.state的信息泄漏的危险了；当然，还有另一种做法，将Memento设计为原发器的私有内部类。</p></blockquote><blockquote><p>拓展：命令模式也有实现类似撤销的作用，如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式17-适配器模式</title>
    <link href="/posts/442e6974.html"/>
    <url>/posts/442e6974.html</url>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>适配器模式（Adapter），将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><blockquote><p>类似于国标转英标的转接头。</p></blockquote><h2 id="适用场景和时机"><a href="#适用场景和时机" class="headerlink" title="适用场景和时机"></a>适用场景和时机</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>系统的数据和行为都相同或类似，但接口不统一时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。客户代码可以统一调用同一接口就行了，更简单、更直接、更紧凑。</p><p>适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况，比如在需要对早期代码复用一些功能等应用上很有实际价值。</p><h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><p>在设计阶段，应该把类似的功能类的接口按照规范设计得相同。</p><blockquote><p>设计之初就需要考虑用适配器模式的场景：公司设计一系统时考虑使用第三方开发组件，而这个组件的接口与我们自己的系统接口是不相同的，而我们也没有必要为了迎合它而改动自己的接口</p></blockquote><p>在软件开发后期或维护期，通常应优先考虑通过重构统一接口，其次在双方都不太容易修改的时候再使用适配器模式适配。</p><blockquote><p>用适配器模式是无奈之举，有点’亡羊补牢’的感觉</p></blockquote><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>GoF的设计模式介绍了适配器模式的两种类型：</p><h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>类适配器模式通过多重继承对一个接口与另一个接口进行匹配，而Java不支持多重继承，故略。</p><h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p>对象适配器模式结构图：</p><p><img src="https://s2.loli.net/2023/10/15/Zv51cel4BIWzA2q.jpg" alt="适配器模式结构图.jpg"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Target</code> 接口：客户所期待的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;普通请求&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Adaptee</code> 类：需要适配的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">specificRequest</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;特殊请求&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Adapter</code> 接口：通过在内部包装一个 <code>Adaptee</code> 对象，把源接口转换成目标接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Target</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-type">Adaptee</span> <span class="hljs-variable">adaptee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adaptee</span>(); <span class="hljs-comment">// 建立一个私有的Adaptee对象</span><br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>    adaptee.specificRequest(); <span class="hljs-comment">// 把表面上调用request()方法转换成实际调用specificRequest()方法</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Target</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Adapter</span>();<br><br>target.request();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板3-5.最小生成树</title>
    <link href="/posts/23133f7d.html"/>
    <url>/posts/23133f7d.html</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>定义：一个<strong>连通加权无向图</strong>中，一棵没有环的、权值最小的生成树。</p><p>注：权重的正负对最小生成树问题没有影响。</p><blockquote><p>应用举例：已知若干个城市的坐标，要在城市间铺设公路，使得各个城市能够连通，且公路长度最小。</p></blockquote><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><blockquote><p>和Dijkstra算法的形式非常类似。</p></blockquote><h3 id="朴素版Prim算法"><a href="#朴素版Prim算法" class="headerlink" title="朴素版Prim算法"></a>朴素版Prim算法</h3><p>时间复杂度：<code>O(n^2 + m)</code> ，适合稠密图</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">集合S: 存储当前已经在连通块中的所有点<br>    <br>dist[i] &lt;- +<span class="hljs-function">INF</span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-title">for</span> <span class="hljs-params">(i: <span class="hljs-number">0</span>~n)</span></span><br><span class="hljs-function">  t &lt;- 不在S中的距离S最近的点</span><br><span class="hljs-function">  用t更新其他点到**集合S**的距离，即所有连向集合S的边中权重最小的边 <span class="hljs-comment">// 注意：Dijkstra中是到起点的距离</span></span><br><span class="hljs-function">  st[t] </span>= <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">// 稠密图，用邻接矩阵存边权</span><br><span class="hljs-type">int</span> dist[N]; <span class="hljs-comment">// 存储其他点到集合S中的距离</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 记录每个点是否在S中</span><br><br><span class="hljs-comment">// 如果图不连通，则返回INF；否则返回最小生成树的边权之和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <br>  <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>  &#123;<br>    <span class="hljs-comment">// 找到不在S中的距离S最近的点</span><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>      <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t])) t = j;<br><br>    <span class="hljs-keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF; <span class="hljs-comment">// 表示图不连通</span><br><br>    <span class="hljs-keyword">if</span> (i) res += dist[t]; <span class="hljs-comment">// 从第二个点开始累加边权。注意这一步要写在更新距离前，以防负自环把自己的dist更新了</span><br><br>    st[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 把该点加入S</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++) dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]); <span class="hljs-comment">// 更新其他点到S的距离</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化版Prim算法（略）"><a href="#堆优化版Prim算法（略）" class="headerlink" title="堆优化版Prim算法（略）"></a>堆优化版Prim算法（略）</h3><p>时间复杂度：<code>O(mlogn)</code> ，适合稀疏图</p><p>稀疏图一般用Kruskal算法，堆优化Prim算法不常用，因为Kruskal代码短很多，思路也更清晰。</p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>时间复杂度：<code>O(mlogm)</code>（瓶颈是对边做排序的步骤），适合稀疏图</p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">集合S：存储最小生成树中的边<br><br><span class="hljs-comment">// O(mlogm)</span><br><span class="hljs-number">1.</span> 将所有边按权重从小到大排序<br><br><span class="hljs-comment">// O(m), 因为并查集是O(1)的，一共m条边</span><br><span class="hljs-number">2.</span> 枚举每条边a-b，权重c<br>  <span class="hljs-keyword">if</span> a,b不连通<br>    将这条边加入集合S中 <span class="hljs-comment">// 并查集的应用</span><br></code></pre></td></tr></table></figure><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> p[N]; <span class="hljs-comment">// 并查集中父节点数组</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> <span class="hljs-comment">// 由于只需要枚举所有边，可以用结构体来存储所有边</span><br>&#123;<br>  <span class="hljs-type">int</span> a, b, w;<br>  <br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;W)<span class="hljs-type">const</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> w &lt; W.w;<br>  &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 并查集</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>  <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">sort</span>(edges, edges + m);<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) p[i] = i;<br>  <br>  <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// res是最小生成树中的边权之和，cnt是最小生成树中的边的数量</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>  &#123;<br>    <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br>    <br>    a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b); <span class="hljs-comment">// 查找a和b所在的连通块</span><br>    <span class="hljs-keyword">if</span> (a != b) <span class="hljs-comment">// 如果两个连通块不连通，则合并两个连通块</span><br>    &#123;<br>      p[a] = b;<br>      res += w;<br>      cnt ++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板3-4.最短路</title>
    <link href="/posts/a211d8a2.html"/>
    <url>/posts/a211d8a2.html</url>
    
    <content type="html"><![CDATA[<h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><p>源点：起点，汇点：终点</p><p>n: 点数，m: 边数</p><p>稠密图：m ~ n^2^，稀疏图：m ~ n</p><blockquote><p>难点：建图，如何把原问题抽象成最短路问题，如何把原模型抽象成图，如何定义点和边</p></blockquote><blockquote><p>最短路问题只需要考虑有向图。无向图只需要连两条对称的边就可以。</p></blockquote><h2 id="边权为1的最短路"><a href="#边权为1的最短路" class="headerlink" title="边权为1的最短路"></a>边权为1的最短路</h2><p>比较特殊，可以用BFS来求。单源和多源都可以。</p><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><p>求从一个点到其他所有点的最短路。</p><h3 id="所有边权都是正数"><a href="#所有边权都是正数" class="headerlink" title="所有边权都是正数"></a>所有边权都是正数</h3><h4 id="朴素Dijkstra算法"><a href="#朴素Dijkstra算法" class="headerlink" title="朴素Dijkstra算法"></a>朴素Dijkstra算法</h4><p>时间复杂度：<code>O(n^2 + m)</code> ，适合稠密图</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>贪心</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">S集合：存储当前已确定最短距离的点<br><br><span class="hljs-number">1</span>. dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, dist[i] = +inf<br><span class="hljs-number">2</span>. for i <span class="hljs-symbol">:</span> <span class="hljs-number">0</span>~<span class="hljs-built_in">n</span> // 每次循环都能确定<span class="hljs-number">1</span>个点的最短距离，循环<span class="hljs-built_in">n</span>次结束<br><span class="hljs-built_in">t</span> &lt;- 不在S中的，距离最近的点<br>S &lt;- <span class="hljs-built_in">t</span> (<span class="hljs-built_in">t</span>放入S中)<br>dist[x] = <span class="hljs-built_in">min</span>(dist[x], dist[<span class="hljs-built_in">t</span>] + w(<span class="hljs-built_in">t</span>, x)) (用<span class="hljs-built_in">t</span>更新其他点x的距离)<br></code></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol><li><p>处理重边和自环。</p><ul><li>由于边权都是正数，自环直接忽略即可。</li><li>重边保留最小值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) g[i][i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 也可以不写，因为边权都为正，最短路不会走自环</span><br><br>对每条边：g[a][b] = <span class="hljs-built_in">min</span>(g[a][b], c);<br></code></pre></td></tr></table></figure></li></ol><h5 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 稠密图用邻接矩阵存</span><br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">// 存储每条边</span><br><span class="hljs-type">int</span> dist[N]; <span class="hljs-comment">// 存储1号点到每个点到最短距离</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 存储每个点到最短路是否已经确定，即步骤里的S集合</span><br><br><span class="hljs-comment">// 求1号点到n号点到最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>  dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++)<br>  &#123;<br>    <span class="hljs-comment">// 在还未确定的最短路的点中，寻找距离最小的点</span><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>      <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t])) t = j;<br><br>    <span class="hljs-comment">// 点t放入S集合</span><br>    st[t] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-comment">// 用t更新其他点的距离</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>      dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>    <br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="堆优化版Dijkstra算法"><a href="#堆优化版Dijkstra算法" class="headerlink" title="堆优化版Dijkstra算法"></a>堆优化版Dijkstra算法</h4><p>时间复杂度：<code>O(mlogn)</code> ，适合稀疏图（当图为稠密图，也就是 <code>m和n^2一个级别</code> 时，时间复杂度比朴素版高些）</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>先看看在稀疏图中，朴素Dijkstra算法循环内部每一步<strong>总共</strong>（循环n次之后）的执行次数</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">S集合：存储当前已确定最短距离的点<br><br><span class="hljs-number">1</span>. dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, dist[i] = +inf<br><span class="hljs-number">2</span>. for i <span class="hljs-symbol">:</span> <span class="hljs-number">0</span>~<span class="hljs-built_in">n</span><br>(<span class="hljs-number">1</span>) <span class="hljs-built_in">t</span> &lt;- 不在S中的，距离最近的点 总共执行<span class="hljs-built_in">n</span>^<span class="hljs-number">2</span>次（瓶颈）<br>(<span class="hljs-number">2</span>) S &lt;- <span class="hljs-built_in">t</span> 总共执行<span class="hljs-built_in">n</span>次<br>(<span class="hljs-number">3</span>) dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[<span class="hljs-built_in">t</span>] + w(<span class="hljs-built_in">t</span>, j)) 总共执行m次，因为图是用邻接表存，只有<span class="hljs-built_in">t</span>和j之间有边才有可能更新<br></code></pre></td></tr></table></figure><p>每次找离1号点最近的点这一步是算法瓶颈。由于是找最小值，可以<code>用堆来存储dist</code>，来优化到每次循环为O(1)，总复杂度为O(n)。但(3)在每次循环中的复杂度会从O(1)变到O(logn)，因为是对堆做更新操作。(3)总共执行m次，所以总的时间复杂度是O(mlogn)。</p><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">S集合：存储当前已确定最短距离的点<br><br><span class="hljs-number">1</span>. dist<span class="hljs-selector-attr">[1]</span> = <span class="hljs-number">0</span>, dist<span class="hljs-selector-attr">[i]</span> = +inf, heap<span class="hljs-selector-class">.push</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;) <span class="hljs-comment">// first: i号点到1号点到距离, second: 点编号i</span><br><span class="hljs-number">2</span>. <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> : <span class="hljs-number">1</span>~n<br>(<span class="hljs-number">1</span>) t &lt;- dist<span class="hljs-selector-class">.top</span>() 记得要判断t.second是不是已经S里<br>(<span class="hljs-number">2</span>) S &lt;- t<span class="hljs-selector-class">.second</span><br>(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> (t的所有边对应点j和权重w)<br><span class="hljs-keyword">if</span> (dist<span class="hljs-selector-attr">[j]</span> &gt; t<span class="hljs-selector-class">.first</span> + w) dist<span class="hljs-selector-class">.push</span>(&#123;t<span class="hljs-selector-class">.first</span> + w, j&#125;) 这里由于STL堆不支持修改任意位置的值，所以只能冗余，插入新的dist，反正小的dist先出来<br></code></pre></td></tr></table></figure><h5 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">int</span> n; <span class="hljs-comment">// 点的数量</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="hljs-comment">// 稀疏图用邻接表存</span><br><span class="hljs-type">int</span> dist[N]; <span class="hljs-comment">// 所有点到1号点的距离</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 即S集合</span><br><br><span class="hljs-comment">// 求1号点到n号点到最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>  dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; <span class="hljs-comment">// 小根堆</span><br>  heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// first存储距离，second存储点的编号</span><br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++)<br>  &#123;<br>    <span class="hljs-comment">// 在还未确定的最短路的点中，寻找距离最小的点</span><br>    <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>    heap.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br>    <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 因为堆存储有冗余，该节点的距离可能已经被确定了，此时跳过</span><br><br>    <span class="hljs-comment">// 点t放入S集合</span><br>    st[t] = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-comment">// 用t更新与其有边连接的其他点的距离</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; ~i; i)<br>    &#123;<br>      <span class="hljs-type">int</span> j = e[i];<br>      <span class="hljs-keyword">if</span> (dist[j] &gt; distance + w[i]) <span class="hljs-comment">// 需要更新dist[j]</span><br>      &#123;<br>        dist[j] = distance + w[i];<br>        heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="存在负权边"><a href="#存在负权边" class="headerlink" title="存在负权边"></a>存在负权边</h3><p>SPFA是BF算法的优化。但如果限制经过的边数（如&lt;&#x3D;k）的话，只能用Bellman-Ford。</p><h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h4><p>时间复杂度：<code>O(nm)</code></p><blockquote><p>注意：如果有负权回路存在，最短路就<strong>不一定</strong>存在。不一定的原因：只有这个负环1号点到某个点x的路径上，1-&gt;x到最短路才不存在。没在路径上就没有影响。</p></blockquote><h5 id="存边方式"><a href="#存边方式" class="headerlink" title="存边方式"></a>存边方式</h5><p>由于是遍历所有边，所以BF算法存边方式不一定要用邻接表。可以定义struct存边</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>  <span class="hljs-type">int</span> a, b, w;<br>&#125; edge[M];<br></code></pre></td></tr></table></figure><h5 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> n次循环<br><span class="hljs-keyword">for</span> 所有边a, b, w<br>dist[b] = <span class="hljs-built_in">min</span>(dist[b], dist[a] + w); <span class="hljs-comment">// 松弛操作</span><br></code></pre></td></tr></table></figure><h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><p><strong>三角不等式：</strong>在循环n*m次之后，对每条边，都有 <code>dist[b] &lt;= dist[a] + w</code>。</p><p><strong>n重循环中迭代k次的含义：</strong>从1号点经过不超过k条边，走到每一个点的最短距离。</p><h5 id="如何判断是否有负环？"><a href="#如何判断是否有负环？" class="headerlink" title="如何判断是否有负环？"></a>如何判断是否有负环？</h5><p>BF算法可以判断是否有负环。但时间复杂度较高，一般用SPFA来做。</p><p>如果第n次迭代时，dist[x]有更新：说明从1号点到x号点，存在一条有n条边的路。但一条路有n条边，说明有n+1个点，即路径上有环。又由于dist[x]更新了，所以这个环一定是负环（因为不包含环的那条路之前已经走过了）。</p><h5 id="代码模板-2"><a href="#代码模板-2" class="headerlink" title="代码模板"></a>代码模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> dist[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>  <span class="hljs-type">int</span> a, b, w;<br>&#125; edges[M];<br><br><span class="hljs-comment">// 求1到n到最短路距离，如果无法从1走到n，则返回-1。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>  dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>    &#123;<br>      <span class="hljs-type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>      <span class="hljs-keyword">if</span> (dist[b] &gt; dist[a] + w)<br>      dist[b] = dist[a] + w;<br>    &#125; <br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 不直接写 == 0x3f3f3f3f 的原因是，可能有负权边更新距离，使得dist小于0x3f3f3f3f</span><br>  <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="例题：有边数k限制的最短路"><a href="#例题：有边数k限制的最短路" class="headerlink" title="例题：有边数k限制的最短路"></a>例题：有边数k限制的最短路</h5><p>需要加上backup数组，保存上一次循环中所有边更新的结果，保证这一次循环只用上一次循环的结果，以免用到本次循环更新过的距离，这样经过的边实际可能&gt;k，不符合要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 每重循环复制dist数组到backup数组</span><br><span class="hljs-built_in">memcpy</span>(backup, dist, <span class="hljs-keyword">sizeof</span> dist);<br></code></pre></td></tr></table></figure><h4 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h4><p>一般时间复杂度：<code>O(m)</code>, 最坏时间复杂度：<code>O(nm)</code></p><h5 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h5><p>图中不含负环。</p><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>类似BFS的思想。</p><p>对于 <code>dist[b] = min(dist[b], dist[a] + w);</code> ，只有 <code>dist[a]</code> 变小了，<code>dist[b]</code> 才有可能被更新。所以用一个队列来存 更新过的点<code>a</code>。</p><blockquote><p>SPFA长得很Dijkstra算法很像。不过前者外循环是通过判断queue不空，后者是循环n次（n个点）。</p></blockquote><h5 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">st[]数组：记录队列里有没有某个节点<br>  <br>queue &lt;- 1<br><br><span class="hljs-keyword">while</span> queue不空<br>  1. t &lt;- q.front, q.pop(), st[t] = <span class="hljs-literal">false</span>;<br>2. 更新t的所有出边 t-w-&gt;<span class="hljs-function">b</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(dist[b] 被更新 &amp;&amp; !st[b])</span> queue &lt;- b, st[b] </span>= <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h5 id="代码模板-3"><a href="#代码模板-3" class="headerlink" title="代码模板"></a>代码模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n; <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 记录某个点是否在队列中</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>  dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <br>  queue&lt;<span class="hljs-type">int</span>&gt; q;<br>  q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>  st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>  <br>  <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>  &#123;<br>    <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    st[t] = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])<br>    &#123;<br>      <span class="hljs-type">int</span> j = e[i];<br>      <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>      &#123;<br>        dist[j] = dist[t] + w[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>          q.<span class="hljs-built_in">push</span>(j);<br>          st[j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 这里不用/2的原因是，只有它的前置节点被更新（变成非无穷的数）时，它才会被更新，它也一定是非无穷的数+w[i]；而BF算法是暴力更新所有边，可能是INF+w[i]</span><br>  <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="SPFA如何判负环？"><a href="#SPFA如何判负环？" class="headerlink" title="SPFA如何判负环？"></a>SPFA如何判负环？</h5><p>增加一个cnt[]数组，cnt[x]表示当前这个最短路边的数量。</p><p>在更新dist[x]的同时，也更新cnt[x]。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dist<span class="hljs-comment">[x]</span> = dist<span class="hljs-comment">[t]</span> + w<span class="hljs-comment">[i]</span>;<br>cnt<span class="hljs-comment">[x]</span> = cnt<span class="hljs-comment">[t]</span> + 1;<br></code></pre></td></tr></table></figure><p>当 <code>cnt[x] &gt;= n</code> 时，即最短路上的边数 &gt;&#x3D; n，即路上存在环，这个环一定是负环。</p><h6 id="代码模板-4"><a href="#代码模板-4" class="headerlink" title="代码模板"></a>代码模板</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n; <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">int</span> cnt[N]; <span class="hljs-comment">// cnt[x]存储</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// 记录某个点是否在队列中</span><br><br><span class="hljs-comment">// 求整个图中是否有负环</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 不需要初始化dist数组，不需要距离的绝对值，有相对值的大小作为比较就行</span><br>  <span class="hljs-comment">// memset(dist, 0x3f, sizeof dist);</span><br>  <span class="hljs-comment">// dist[1] = 0;</span><br>  <br>  queue&lt;<span class="hljs-type">int</span>&gt; q;<br>  <span class="hljs-comment">// 要求整个图上是否有负环，而不是从1开始的负环，所以把所有的点都加进队列</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  &#123;<br>    q.<span class="hljs-built_in">push</span>(i);<br>    st[i] = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>  &#123;<br>    <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br>    st[t] = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])<br>    &#123;<br>      <span class="hljs-type">int</span> j = e[i];<br>      <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>      &#123;<br>        dist[j] = dist[t] + w[i];<br>        cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>          q.<span class="hljs-built_in">push</span>(j);<br>          st[j] = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>      <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以这样理解：</p><ol><li>构造一个虚拟节点 O，单向指向所有的节点，且到所有节点距离为0；</li><li>新图是否有负环等价于原始的图。</li><li>dist[]一开始为0,没有违背算法过程，可以理解为根据算法已经从 O 更新到了各个节点，接下来的代码就是顺理成章。所以dist数组从所有为0的状态开始是有对应意义的。就是先走一步。</li><li>cnt[x]可以认为是从节点O到节点x的最短路中边的数量，由于O和所有其他节点都连通，所以能够判断<strong>整个</strong>图中是否有负环。</li></ol><h2 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h2><p>会有多个query，求不同的源点到不同的汇点的最短路。</p><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>时间复杂度： <code>O(n^3)</code></p><h4 id="原理：DP"><a href="#原理：DP" class="headerlink" title="原理：DP"></a>原理：DP</h4><h5 id="状态表示："><a href="#状态表示：" class="headerlink" title="状态表示："></a>状态表示：</h5><p><code>d[k, i, j]</code> 的含义：从节点i，只经过1~k这些节点，到达节点j，所有路径中最短路的距离。</p><h5 id="状态转移："><a href="#状态转移：" class="headerlink" title="状态转移："></a>状态转移：</h5><p><code>d[k, i, j] = d[k - 1, i, k] + d[k - 1, k, j]</code></p><p>表示只经过1~k-1这些节点，从i到k再从k到j的最短距离。</p><p>发现第一维无需记录，在循环中自然就是这么算的，所以可以改写为：</p><p><code>d[i, j] = d[i, k] + d[k, j]</code></p><h4 id="代码模板-5"><a href="#代码模板-5" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> d[N][N]; <span class="hljs-comment">// 邻接矩阵</span><br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>    <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> d[i][j] = INF;<br><br><span class="hljs-comment">// 然后加入所有边。。。</span><br><br><span class="hljs-comment">// 算法结束后，d[a][b]表示a到b的最短距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>        d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br><br><span class="hljs-comment">// 判断是否有最短路</span><br><span class="hljs-keyword">if</span> (d[a][b] &gt; INF / <span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>); <span class="hljs-comment">// /2的原因与BF相同</span><br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, d[a][b]);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp算法相关写法总结</title>
    <link href="/posts/3e8b9fd.html"/>
    <url>/posts/3e8b9fd.html</url>
    
    <content type="html"><![CDATA[<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="输入一行字符串到一个字符数组"><a href="#输入一行字符串到一个字符数组" class="headerlink" title="输入一行字符串到一个字符数组"></a>输入一行字符串到一个字符数组</h3><p>例：</p><p><code>abc def ghi</code> 到 <code>char str[1000]</code></p><p>写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> str[<span class="hljs-number">1000</span>];<br><span class="hljs-built_in">gets</span>(str);<br></code></pre></td></tr></table></figure><p><a href="https://www.programiz.com/cpp-programming/library-function/cstdio/gets">https://www.programiz.com/cpp-programming/library-function/cstdio/gets</a></p><h3 id="用scanf读入一个字母-推荐读成字符串的形式"><a href="#用scanf读入一个字母-推荐读成字符串的形式" class="headerlink" title="用scanf读入一个字母 - 推荐读成字符串的形式"></a>用scanf读入一个字母 - 推荐读成字符串的形式</h3><p>例：</p><p><code>Q 2 3</code></p><p>写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> op[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> a, b;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);<br><span class="hljs-comment">// op[0]即为所需字母</span><br></code></pre></td></tr></table></figure><p>原因：</p><p>如果用 <code>%c</code> 读op，容易读到空格回车等其他字符，很麻烦</p><p>但用 <code>%s</code> 会自动过滤空格回车（读到空格回车就停了）</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="比较字符串是否相等"><a href="#比较字符串是否相等" class="headerlink" title="比较字符串是否相等"></a>比较字符串是否相等</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><br>相等：!<span class="hljs-built_in">strcmp</span>(op, <span class="hljs-string">&quot;PM&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><p>头文件：cstring</p><h4 id="0"><a href="#0" class="headerlink" title="0"></a>0</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">memset</span><span class="hljs-params">(array, <span class="hljs-number">0</span>, sizeof(array)</span></span>)<br></code></pre></td></tr></table></figure><h4 id="1"><a href="#1" class="headerlink" title="-1"></a>-1</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">memset</span><span class="hljs-params">(array, -<span class="hljs-number">1</span>, sizeof(array)</span></span>)<br></code></pre></td></tr></table></figure><h4 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span>类型：常采用<span class="hljs-number">0x3f3f3f3f</span>来作为无穷大<br><br>memset(array, <span class="hljs-number">0x3f</span>, sizeof(array))<br>为数组设初值为<span class="hljs-number">0x3f3f3f3f</span>，因为这个数的每个字节都是<span class="hljs-number">0x3f</span><br></code></pre></td></tr></table></figure><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><ol><li>cout</li><li>Segment Fault的时候一段一段删代码</li></ol>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板3-2.树与图的存储</title>
    <link href="/posts/35683d73.html"/>
    <url>/posts/35683d73.html</url>
    
    <content type="html"><![CDATA[<h1 id="树和图的存储"><a href="#树和图的存储" class="headerlink" title="树和图的存储"></a>树和图的存储</h1><p>树是一种特殊的图：无环连通图。与图的存储方式相同。</p><p>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。</p><p>因此我们可以只考虑有向图的存储。</p><h2 id="存储方法一：邻接矩阵"><a href="#存储方法一：邻接矩阵" class="headerlink" title="存储方法一：邻接矩阵"></a>存储方法一：邻接矩阵</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">g<span class="hljs-selector-attr">[a]</span><span class="hljs-selector-attr">[b]</span> 存储边<span class="hljs-selector-tag">a</span>-&gt;<span class="hljs-selector-tag">b</span>的权重(int)/有无(bool)<br></code></pre></td></tr></table></figure><p>邻接矩阵不能存重边，不过一般存最短的就行。</p><h2 id="存储方法二：邻接表"><a href="#存储方法二：邻接表" class="headerlink" title="存储方法二：邻接表"></a>存储方法二：邻接表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = N * <span class="hljs-number">2</span>; <span class="hljs-comment">// N：点的数量，M：边的数量</span><br><br><span class="hljs-comment">// h[]对应点：对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头节点</span><br><span class="hljs-comment">// w[], e[], ne[]对应边：它们的下标都是边的编号，w[]值是边的权重，e[]值是指向的节点；ne[]存储某个节点的出边链表中，某条边的下一条边的编号</span><br><span class="hljs-type">int</span> h[N], w[M], e[M], ne[M], idx;<br><br><span class="hljs-comment">// 添加一条边a-&gt;b</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>  e[idx] = b, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br><span class="hljs-comment">// 初始化</span><br>idx = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h); <span class="hljs-comment">// 让n个头节点都指向-1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式16-状态模式</title>
    <link href="/posts/f46f279f.html"/>
    <url>/posts/f46f279f.html</url>
    
    <content type="html"><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>状态模式（State），当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p><blockquote><p>状态模式主要解决的是当控制一个对象<strong>状态转换的条件表达式过于复杂</strong>时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。</p></blockquote><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/12/MP5HFstNdQUkrT1.png" alt="状态模式结构图.png"></p><p><code>State</code> 类：抽象状态类，定义一个接口以封装与 <code>Context</code> 的一个特定状态相关的行为。</p><p><code>ConcreteState</code> 类：具体状态，每一个子类实现一个与 <code>Context</code> 的一个状态相关的行为。</p><p><code>Context</code> 类：维护一个 <code>ConcreteState</code> 类的实例，这个实例定义当前的状态（可以修改 <code>State</code> 的类型）。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>State</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Context context)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteState</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体状态类A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Context context)</span> &#123;<br>    <span class="hljs-comment">//可以在方法里做一些事情</span><br>    <br>    context.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStateB</span>()); <span class="hljs-comment">// 设置 ConcreteStateA 的下一状态是 ConcreteStateB</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体状态类B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(Context context)</span> &#123;<br>    <span class="hljs-comment">//可以在方法里做一些事情</span><br>    <br>    context.setState(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStateA</span>()); <span class="hljs-comment">// 设置 ConcreteStateB 的下一状态是 ConcreteStateA</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Context</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> State state;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Context</span><span class="hljs-params">(State state)</span> &#123;<br>    <span class="hljs-built_in">this</span>.state = state; <span class="hljs-comment">// 设置 Context 的初始状态</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// 可读写的状态属性，用于读取当前状态和设置新状态</span><br>  <span class="hljs-keyword">public</span> State <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.state;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(State value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.state = value;<br>    System.out.println(<span class="hljs-string">&quot;当前状态：&quot;</span> + <span class="hljs-built_in">this</span>.state.getClass().getName());<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.state.handle(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Context</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteStateA</span>()); <span class="hljs-comment">// 设置c的初始状态为 ConcreteStateA</span><br><br><span class="hljs-comment">// 不断请求，不断更改状态</span><br>c.request();<br>c.request();<br>c.request();<br>c.request();<br></code></pre></td></tr></table></figure><h2 id="好处与使用场景"><a href="#好处与使用场景" class="headerlink" title="好处与使用场景"></a>好处与使用场景</h2><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p><blockquote><p>将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换。</p></blockquote><p>这样做可以消除 <code>Long Method</code> 中庞大的条件分支语句。大的分支判断会使得它们难以修改和扩展。</p><p>状态模式通过把各种状态转移逻辑分布到 <code>State</code> 的子类之间，来减少相互间的依赖，这样就容易维护和扩展了。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式。</p><blockquote><p>如果业务需求某项业务有多个状态，通常都是一些枚举常量。</p><p>状态的变化都是依靠大量的多分支判断语句来实现，此时应该考虑<strong>将每一种业务状态定义为一个State的子类</strong>，于是这些对象就可以不依赖于其他对象而独立变化了。</p><p>某一天客户需要更改需求，增加或减少业务状态或改变状态流程，就变得不困难了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板3-3.树与图的遍历</title>
    <link href="/posts/3458e125.html"/>
    <url>/posts/3458e125.html</url>
    
    <content type="html"><![CDATA[<h1 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h1><p>时间复杂度：<code>O(n + m)</code>，其中 <code>n</code> 表示点数， <code>m</code> 表示边数。</p><p>树是特殊的图，同样只需要考虑图的遍历即可。</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>一般树和图的遍历，每个点只需要遍历一次。</p><p>需要一个状态数组 <code>st[]</code>，表示该点是否被遍历过。</p><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>  <br>  st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// st[u] 表示点u已经遍历过</span><br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = ne[i]) &#123;<br>    <span class="hljs-type">int</span> j = e[i]; <span class="hljs-comment">// 取到该边对应的点</span><br>    <span class="hljs-keyword">if</span> (!st[j]) <span class="hljs-built_in">dfs</span>(j);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h4><p>重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>在dfs的过程中从下往上算出以各个节点为根节点的子树节点的数量。</p><p>对每个节点n：求出<code>以其子节点为根节点的所有子树节点数量</code>和 <code>总节点数量减去以n为根节点的子树节点数量</code> （即剩余连通块点数）的最大值。再求所有最大值的最小值。</p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; q;<br>st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示1号点已经被遍历过</span><br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>  <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>  q.<span class="hljs-built_in">pop</span>();<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i]) &#123;<br>    <span class="hljs-type">int</span> j = e[i];<br>    <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>      st[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 把j号点标记为已经被遍历过</span><br>      q.<span class="hljs-built_in">push</span>(j);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="图中点的层次"><a href="#图中点的层次" class="headerlink" title="图中点的层次"></a>图中点的层次</h4><p>即从1号点开始一层层搜，计算每个点到1号点的最短距离。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h5 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h5><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。</p><p>其实也就是把点排成拓扑序列之后，满足所有的边都是从前面的点指向后面的点的。</p><blockquote><p>只有<strong>有向图</strong>有拓扑序列。</p></blockquote><h6 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h6><p>可以证明，一个有向无环图一定存在拓扑序列。</p><blockquote><p>有向无环图也被称为拓扑图。</p><p>一个有向无环图，一定至少存在一个入度为0的点。</p></blockquote><h5 id="拓扑排序-1"><a href="#拓扑排序-1" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><p>所有入度为0的点都可以作为起点。（所以对于有环的图，这个环上的点永远不会入队，因为入度都不为0）</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell">用bfs框架：<br><span class="hljs-title">queue</span> &lt;- 所有入度为<span class="hljs-number">0</span>的点<br><br><span class="hljs-title">while</span> queue 不空<br>&#123;<br>t &lt;- 队头<br>枚举t的所有出边t-&gt;j<br>删掉t-&gt;j 即j号点的入度--：d[j] <span class="hljs-comment">--;</span><br><span class="hljs-keyword">if</span> (!d[j]) queue &lt;- j<br>&#125;<br></code></pre></td></tr></table></figure><p>queue里的次序即为拓扑序。</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板3-1.DFS和BFS</title>
    <link href="/posts/d477b61a.html"/>
    <url>/posts/d477b61a.html</url>
    
    <content type="html"><![CDATA[<h1 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历 (DFS)"></a>深度优先遍历 (DFS)</h1><p>一条路走到底，无路可走了之后往回退<strong>一步</strong>，继续找一条其他的路一直往下走。</p><p>形势一般为递归。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>走到底了，返回的过程叫做回溯。</p><p>回来的时候要<strong>恢复现场</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 恢复现场的代码与修改状态的代码一般是对称的，例：</span><br>path[u] = i;<br>st[i] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>); <span class="hljs-comment">// 下一层递归返回之后恢复</span><br>st[i] = <span class="hljs-literal">false</span>;<br>path[u] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>剪枝可以提高效率。</p><h4 id="可行性剪枝"><a href="#可行性剪枝" class="headerlink" title="可行性剪枝"></a>可行性剪枝</h4><p>在搜索的过程中判断，如果这个节点不合法，那么它的子树上的所有节点也都不合法，直接停止搜索。</p><h4 id="最优性剪枝"><a href="#最优性剪枝" class="headerlink" title="最优性剪枝"></a>最优性剪枝</h4><p>当前路径一定不如最优解，停止搜索。</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>递归结束条件的选择+状态标记+递归后的恢复</p><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="字典序输出"><a href="#字典序输出" class="headerlink" title="字典序输出"></a>字典序输出</h3><p>每一种输出都是一个叶子节点，第x位的遍历对应第x层的节点。整个搜索过程就是一棵搜索树（当然不需要自己存这棵树，系统栈会帮我们做这件事）。</p><p>path数组下标为当前遍历到的位数，存储的值为这一位填的数字。</p><h3 id="n-皇后"><a href="#n-皇后" class="headerlink" title="n-皇后"></a>n-皇后</h3><h4 id="进阶解法-以行作为一层来搜索"><a href="#进阶解法-以行作为一层来搜索" class="headerlink" title="进阶解法 - 以行作为一层来搜索"></a>进阶解法 - 以<strong>行</strong>作为一层来搜索</h4><p>col数组记录该列是否有皇后。</p><p>额外开两个数组存储对角线和反对角线上是否有皇后，如果有代表不合法，剪枝。</p><p>对角线数组的长度是 <code>2n - 1</code>。</p><p>判断一个点在哪一条对角线&#x2F;反对角线上：用截距。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">x, y分别是行号和列号，b为对角线号。<br><br><span class="hljs-attribute">y</span>=x+b/ -&gt; <span class="hljs-attribute">b</span>=y-x+n (+n是因为数组下标要为正数)<br><br><span class="hljs-attribute">y</span>=-x+b -&gt; <span class="hljs-attribute">b</span>=y+x<br></code></pre></td></tr></table></figure><p>时间复杂度：<code>O(n*n!)</code></p><h4 id="原始解法-以格子作为一层来搜索"><a href="#原始解法-以格子作为一层来搜索" class="headerlink" title="原始解法 - 以格子作为一层来搜索"></a>原始解法 - 以<strong>格子</strong>作为一层来搜索</h4><p>每一层dfs都往下拓展两种可能：一种是该格子放皇后；一种是该格子不放皇后。</p><blockquote><p>row数组记录该行是否有皇后。</p><p>col数组记录该列是否有皇后。</p><p>额外开两个数组存储对角线和反对角线上是否有皇后，如果有代表不合法，剪枝。</p></blockquote><p>时间复杂度：<code>O(2^(n^2))</code></p><h1 id="宽度优先遍历-BFS"><a href="#宽度优先遍历-BFS" class="headerlink" title="宽度优先遍历 (BFS)"></a>宽度优先遍历 (BFS)</h1><p>一层一层遍历，某一层全部遍历完，再遍历该层第一个节点的第一个子节点，以此类推。</p><p>形势一般为迭代。</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl">模拟队列 <span class="hljs-string">q[N]</span>, d[N] 使用d数组标记状态<br><br>queue &lt;- 初始状态<br><span class="hljs-keyword">while</span> queue不空<br>&#123;<br>t &lt;- 队头<br>拓展t<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="往上下左右四个方向拓展的小技巧"><a href="#往上下左右四个方向拓展的小技巧" class="headerlink" title="往上下左右四个方向拓展的小技巧"></a>往上下左右四个方向拓展的小技巧</h2><p>用向量数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++)<br>  <span class="hljs-type">int</span> x = a + dx[i], y = b + dy[i];<br></code></pre></td></tr></table></figure><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h3><p>以离起点距离为x的点为第x层</p><h3 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h3><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><table><thead><tr><th>算法</th><th>数据结构</th><th>空间复杂度</th><th>性质</th></tr></thead><tbody><tr><td>DFS</td><td>stack</td><td>O(h)</td><td></td></tr><tr><td>BFS</td><td>queue</td><td>O(2^h^)</td><td>最短路（第一次搜到时）</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>DFS在空间上占优势；</p><p>但BFS具有“最短路”的性质（前提：边的权重为1）。</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>STL总结</title>
    <link href="/posts/86037912.html"/>
    <url>/posts/86037912.html</url>
    
    <content type="html"><![CDATA[<h3 id="vector-变长数组，倍增的思想"><a href="#vector-变长数组，倍增的思想" class="headerlink" title="vector, 变长数组，倍增的思想"></a>vector, 变长数组，倍增的思想</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>  返回元素个数<br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span>  返回是否为空<br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span>  清空<br><span class="hljs-function"><span class="hljs-title">front</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">back</span>()<br><span class="hljs-function"><span class="hljs-title">push_back</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">pop_back</span>()<br><span class="hljs-function"><span class="hljs-title">begin</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">end</span>()<br><span class="hljs-selector-attr">[]</span><br>支持比较运算，按字典序<br></code></pre></td></tr></table></figure><h3 id="pair"><a href="#pair" class="headerlink" title="pair&lt;int, int&gt;"></a>pair&lt;int, int&gt;</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">first</span>, 第一个元素<br><span class="hljs-keyword">second</span>, 第二个元素<br>支持比较运算，以<span class="hljs-keyword">first</span>为第一关键字，以<span class="hljs-keyword">second</span>为第二关键字（字典序）<br></code></pre></td></tr></table></figure><h3 id="string，字符串"><a href="#string，字符串" class="headerlink" title="string，字符串"></a>string，字符串</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">length</span>()  返回字符串长度<br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">substr</span><span class="hljs-params">(起始下标，(子串长度)</span></span>)  返回子串<br><span class="hljs-function"><span class="hljs-title">c_str</span><span class="hljs-params">()</span></span>  返回字符串所在字符数组的起始地址<br></code></pre></td></tr></table></figure><h3 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue, 队列"></a>queue, 队列</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">()</span></span>  向队尾插入一个元素<br><span class="hljs-function"><span class="hljs-title">front</span><span class="hljs-params">()</span></span>  返回队头元素<br><span class="hljs-function"><span class="hljs-title">back</span><span class="hljs-params">()</span></span>  返回队尾元素<br><span class="hljs-function"><span class="hljs-title">pop</span><span class="hljs-params">()</span></span>  弹出队头元素<br></code></pre></td></tr></table></figure><h3 id="priority-queue-优先队列，默认是大根堆"><a href="#priority-queue-优先队列，默认是大根堆" class="headerlink" title="priority_queue, 优先队列，默认是大根堆"></a>priority_queue, 优先队列，默认是大根堆</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">size</span>()<br><span class="hljs-built_in">empty</span>()<br><span class="hljs-built_in">push</span>()  插入一个元素<br><span class="hljs-attribute">top</span>()  返回堆顶元素<br><span class="hljs-built_in">pop</span>()  弹出堆顶元素<br>定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; <span class="hljs-selector-tag">q</span>;<br></code></pre></td></tr></table></figure><h3 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack, 栈"></a>stack, 栈</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">()</span></span>  向栈顶插入一个元素<br><span class="hljs-function"><span class="hljs-title">top</span><span class="hljs-params">()</span></span>  返回栈顶元素<br><span class="hljs-function"><span class="hljs-title">pop</span><span class="hljs-params">()</span></span>  弹出栈顶元素<br></code></pre></td></tr></table></figure><h3 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque, 双端队列"></a>deque, 双端队列</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">front</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">back</span>()<br><span class="hljs-function"><span class="hljs-title">push_back</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">pop_back</span>()<br><span class="hljs-function"><span class="hljs-title">push_front</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">pop_front</span>()<br><span class="hljs-function"><span class="hljs-title">begin</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">end</span>()<br><span class="hljs-selector-attr">[]</span><br></code></pre></td></tr></table></figure><h3 id="set-map-multiset-multimap-基于平衡二叉树（红黑树），动态维护有序序列"><a href="#set-map-multiset-multimap-基于平衡二叉树（红黑树），动态维护有序序列" class="headerlink" title="set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列"></a>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</h3><pre><code class="hljs">size()empty()clear()begin()/end()++, -- 返回前驱和后继，时间复杂度 O(logn)</code></pre><h4 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">insert</span><span class="hljs-params">()</span></span>  插入一个数<br><span class="hljs-function"><span class="hljs-title">find</span><span class="hljs-params">()</span></span>  查找一个数<br><span class="hljs-function"><span class="hljs-title">count</span><span class="hljs-params">()</span></span>  返回某一个数的个数<br><span class="hljs-function"><span class="hljs-title">erase</span><span class="hljs-params">()</span></span><br>    (<span class="hljs-number">1</span>) 输入是一个数x，删除所有x   <span class="hljs-built_in">O</span>(k + logn)<br>    (<span class="hljs-number">2</span>) 输入一个迭代器，删除这个迭代器<br><span class="hljs-function"><span class="hljs-title">lower_bound</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">upper_bound</span>()<br>    <span class="hljs-built_in">lower_bound</span>(x)  返回大于等于x的最小的数的迭代器<br>    <span class="hljs-built_in">upper_bound</span>(x)  返回大于x的最小的数的迭代器<br></code></pre></td></tr></table></figure><h4 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">insert</span><span class="hljs-params">()</span></span>  插入的数是一个pair<br><span class="hljs-function"><span class="hljs-title">erase</span><span class="hljs-params">()</span></span>  输入的参数是pair或者迭代器<br><span class="hljs-function"><span class="hljs-title">find</span><span class="hljs-params">()</span></span><br><span class="hljs-selector-attr">[]</span>  注意multimap不支持此操作。 时间复杂度是 <span class="hljs-built_in">O</span>(logn)<br><span class="hljs-function"><span class="hljs-title">lower_bound</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">upper_bound</span>()<br></code></pre></td></tr></table></figure><h3 id="unordered-set-unordered-map-unordered-multiset-unordered-multimap-哈希表"><a href="#unordered-set-unordered-map-unordered-multiset-unordered-multimap-哈希表" class="headerlink" title="unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表"></a>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</h3><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl">和上面类似，增删改查的时间复杂度是 <span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-number">1</span>)</span><br>不支持 <span class="hljs-function"><span class="hljs-title">lower_bound</span>()/<span class="hljs-title">upper_bound</span>()， 迭代器的++，--</span><br></code></pre></td></tr></table></figure><h3 id="bitset-圧位"><a href="#bitset-圧位" class="headerlink" title="bitset, 圧位"></a>bitset, 圧位</h3><pre><code class="hljs">bitset&lt;10000&gt; s;~, &amp;, |, ^&gt;&gt;, &lt;&lt;==, !=[]count()  返回有多少个1any()  判断是否至少有一个1none()  判断是否全为0set()  把所有位置成1set(k, v)  将第k位变成vreset()  把所有位变成0flip()  等价于~flip(k) 把第k位取反</code></pre>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-8.字符串哈希</title>
    <link href="/posts/2d6c6193.html"/>
    <url>/posts/2d6c6193.html</url>
    
    <content type="html"><![CDATA[<h1 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>快速判断一个字符串中两个区间对应的子串是否完全相同。</p><blockquote><p>除了求一个字符串的循环节只能用KMP之外，大部分时候字符串哈希都能代替KMP。</p></blockquote><h2 id="字符串前缀哈希法"><a href="#字符串前缀哈希法" class="headerlink" title="字符串前缀哈希法"></a>字符串前缀哈希法</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ABCABCDE&quot;</span><br><br>把每一个前缀的哈希值算出来：<br>h[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>h[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A&quot;</span>的哈希值<br>h[<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AB&quot;</span>的哈希值<br>h[<span class="hljs-number">3</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ABC&quot;</span>的哈希值<br>...<br></code></pre></td></tr></table></figure><p><strong>结果：</strong>可以通过这些前缀的哈希值，算出 <strong><code>str</code> 任何一个子串</strong>的哈希值。</p><h2 id="如何定义某一前缀的哈希值？"><a href="#如何定义某一前缀的哈希值？" class="headerlink" title="如何定义某一前缀的哈希值？"></a>如何定义某一前缀的哈希值？</h2><p>把字符串str看成一个p进制的数。str中<strong>每一个字符（的ASCII码）</strong>对应这个<strong>p进制数的每一位数字</strong>。最后一个字符对应最低位。</p><blockquote><p>例：hash(“ABC”) &#x3D; (A * p^2 + B * p^1 + C * p^0)</p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><strong>目标：</strong>将str映射到0～Q-1的范围内。</p><p><strong>经验值：</strong> <code> p=131或13331</code>, <code>Q = 2^64</code>。用 <code>unsigned long long</code> 来存储哈希值，当它溢出时，刚好等价于取模。</p><h4 id="1-算出这个p进制数x"><a href="#1-算出这个p进制数x" class="headerlink" title="1. 算出这个p进制数x"></a>1. 算出这个p进制数x</h4><h5 id="2-x-mod-Q"><a href="#2-x-mod-Q" class="headerlink" title="2. x mod Q"></a>2. x mod Q</h5><p>由于str的长度可能比较长，x可能为一个很大的数字，不好存。所以算出x之后，需要mod一个比较小的数Q。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>不能把某一个字母映射成0。例：”A”-&gt;0, “AA”-&gt;0，将不同的字符串映射成了同一个数。</li><li>假定无冲突。这个算法没有考虑冲突情况。p和Q取经验值的情况下，起冲突的可能性很小。</li></ol><h2 id="如何算出任意子串的哈希值？"><a href="#如何算出任意子串的哈希值？" class="headerlink" title="如何算出任意子串的哈希值？"></a>如何算出任意子串的哈希值？</h2><p>假设我们要算 <code>str</code> 第 <code>L</code> 位和第<code>R</code> 位之间这个子串的哈希值。</p><p>已知 <code>h[R]</code> 和 <code>h[L-1]</code> ：</p><p><code>h[R] - h[L - 1] * p^(R - L + 1)</code> 即为子串的哈希值。</p><blockquote><p><code>h[R]</code> 中第R个字符对应x的第0位，第1个字符对应x的第R-1位</p><p><code>h[L-1]</code>  中第L-1个字符对应x的第0位，第1个字符对应x的第L-2位</p><p>h[L-1] * p^(R - L + 1)是为了将 <code>h[L-1]</code> 往左移，与 <code>h[R]</code> 对齐。</p></blockquote><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, <span class="hljs-type">int</span> P = <span class="hljs-number">13331</span>;<br><span class="hljs-type">char</span> str[N];<br>ULL h[N], p[N]; <span class="hljs-comment">// h[k]存储字符串前k个字母的哈希值，p[k]存储 P^k mod 2^64（提前预处理减少重复计算）</span><br><br><span class="hljs-comment">// 初始化：注意str字符串是从1开始的，scanf(&quot;%s&quot;, str + 1)</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>  h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>  p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>&#125;<br><br><span class="hljs-comment">// 计算子串 str[l ~ r] 的哈希值</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-7.哈希</title>
    <link href="/posts/927b654c.html"/>
    <url>/posts/927b654c.html</url>
    
    <content type="html"><![CDATA[<h1 id="一般哈希"><a href="#一般哈希" class="headerlink" title="一般哈希"></a>一般哈希</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>把庞大的值域映射到一个比较小的空间。</p><p>如 <code>0~10^9 -&gt; 0~10^5</code>。</p><blockquote><p>与离散化的关系：离散化是需要保序的，可以看作一种特殊的哈希方式</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-x-mod-n"><a href="#1-x-mod-n" class="headerlink" title="1. x mod n"></a>1. x mod n</h3><p><code>n</code> 即数组长度，它是一个质数，并且这个质数要离2的整数次幂尽可能远。</p><blockquote><p>这样取可以使冲突的概率最小。数学证明待补充</p></blockquote><h3 id="2-解决冲突"><a href="#2-解决冲突" class="headerlink" title="2. 解决冲突"></a>2. 解决冲突</h3><p>有两种方法</p><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>数组的长度即为<code>n</code>，其中每个元素都是一个链表，取模之后结果相同的数存在链表里</p><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>只开一个一维数组，但长度应取为题给数据范围的2～3倍（经验值）。</p><p>取模之后存在数组对应的位置，如已有元素存在，则依次向后面的位置找，直到找到空位存下来。</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><h3 id="拉链法-1"><a href="#拉链法-1" class="headerlink" title="拉链法"></a>拉链法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-comment">// h[]是数组（槽），数组中的每个元素是一个链表，其中有e[]（存值）和ne[]（存下一个节点的下标），idx为当前新插入节点编号</span><br><br><span class="hljs-comment">// 需要先初始化h数组元素为-1，代表空链表</span><br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h)); <span class="hljs-comment">// -1二进制为11111111，刚好可以按字节设置</span><br><br><span class="hljs-comment">// 向哈希表中插入一个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-comment">// k即为哈希值</span><br>  <span class="hljs-type">int</span> k = (x % N + N) % N; <span class="hljs-comment">// 目的：让k在0～N范围内。cpp取模：原数是负数的话取模之后还是负数，所以要+N；但正数+N之后又大于N了，所以需要再取一次模</span><br>  <br>  <span class="hljs-comment">// 以下代码实现了将新节点插入h[k]，作为新的头节点</span><br>  e[idx] = x;<br>  ne[idx] = h[k];<br>  h[k] = idx ++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-type">int</span> k = (x % N + N) % N;<br>  <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[k]; ~i; i = ne[i]) <span class="hljs-comment">// 从头节点往后找</span><br>    <span class="hljs-keyword">if</span> (e[i] == x) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="开放寻址法-1"><a href="#开放寻址法-1" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200003</span>, null = <span class="hljs-number">0x3f3f3f3f</span>; <span class="hljs-comment">// null的值近似无穷大，代表数组该位置为空</span><br><br><span class="hljs-type">int</span> h[N];<br><br><span class="hljs-comment">// 需要先初始化h数组元素为0x3f3f3f3f，代表所有位置都空</span><br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(h)); <span class="hljs-comment">// memset按字节来设置</span><br><br><span class="hljs-comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-type">int</span> t = (x % N + N) % N;<br>  <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x) &#123;<br>    t ++;<br>    <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-comment">// 插入操作：</span><br><span class="hljs-type">int</span> k = <span class="hljs-built_in">find</span>(x);<br>h[k] = x;<br><br><span class="hljs-comment">// 查找操作：</span><br><span class="hljs-type">int</span> k = <span class="hljs-built_in">find</span>(x);<br><span class="hljs-keyword">if</span> (h[k] == null) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>一般不需要删除元素。如果需要考虑删除，一般是另开一个布尔数组，来标记对应元素是否已删除。</li></ol>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式13-建造者模式</title>
    <link href="/posts/3c62176d.html"/>
    <url>/posts/3c62176d.html</url>
    
    <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>建造者模式（Builder），将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者模式可以将一个产品的<strong>内部表象</strong>与产品的<strong>生成过程</strong>分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。</p><p>用户只需指定需要建造的类型即可，不需要知道具体建造的过程和细节。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/10/9L64AUgXlocTGOB.jpg" alt="建造者模式结构图.jpg"></p><h3 id="Director"><a href="#Director" class="headerlink" title="Director"></a>Director</h3><p>构建一个使用 <code>Builder</code> 接口的对象。</p><p>用于控制建造过程，隔离用户与建造过程的关联。</p><h3 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h3><p>为创建一个 <code>Product</code> 对象的各个部件指定的抽象接口。</p><h3 id="ConcreteBuilder"><a href="#ConcreteBuilder" class="headerlink" title="ConcreteBuilder"></a>ConcreteBuilder</h3><p>具体建造者，实现 <code>Builder</code> 接口，构造和装配各个部件。</p><h3 id="Product"><a href="#Product" class="headerlink" title="Product"></a>Product</h3><p><code>Builder</code> 建造出来的具体产品。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p><code>Product</code> 类：产品类，由多个部件组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>  <br>  ArrayList&lt;String&gt; parts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>  <br>  <span class="hljs-comment">// 添加新的产品部件</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String part)</span> &#123;<br>    parts.add(part);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 列举所有产品部件</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (String part : parts) &#123;<br>      System.out.println(part);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Builder</code> 类：抽象建造者类，确定产品由两个部件 <code>PartA</code> 和 <code>PartB</code> 组成，并声明一个得到产品建造后结果的方法 <code>GetResult</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartA</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartB</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Product <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcreteBuilder</code> 类：具体建造者类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体建造者类1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteBuilder1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Builder</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartA</span><span class="hljs-params">()</span> &#123;<br>    product.add(<span class="hljs-string">&quot;部件A-1&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartB</span><span class="hljs-params">()</span> &#123;<br>    product.add(<span class="hljs-string">&quot;部件B-1&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> product;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体建造者类2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteBuilder2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Builder</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartA</span><span class="hljs-params">()</span> &#123;<br>    product.add(<span class="hljs-string">&quot;部件A-2&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartB</span><span class="hljs-params">()</span> &#123;<br>    product.add(<span class="hljs-string">&quot;部件B-2&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> product;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Director</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span> &#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">construct</span><span class="hljs-params">(Builder builder)</span> &#123;<br>    builder.buildPartA();<br>    builder.buildPartB();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：客户不需要知道具体的建造过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Director</span> <span class="hljs-variable">director</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Director</span>();<br><span class="hljs-type">Builder</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteBuilder1</span>();<br><span class="hljs-type">Builder</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteBuilder2</span>();<br><br><span class="hljs-comment">// 指挥者用ConcreteBuilder1的方法来建造产品</span><br>director.construct(b1);<br><span class="hljs-type">Product</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> b1.getResult();<br>p1.show();<br><br><span class="hljs-comment">// 指挥者用ConcreteBuilder2的方法来建造产品</span><br>director.construct(b2);<br><span class="hljs-type">Product</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> b2.getResult();<br>p2.show();<br><br><span class="hljs-comment">// p1, p2结果不同</span><br></code></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>建造者模式主要用于创建一些复杂的对象，这些对象内部子对象的建造顺序通常是稳定的，但每个子对象的构建通常面临复杂的变化。</p><p>建造者模式是在当<strong>创建复杂对象的算法</strong>应该独立于<strong>该对象的组成部分</strong>以及<strong>它们的装配方式</strong>时适用的模式。</p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-6.堆</title>
    <link href="/posts/63c4c968.html"/>
    <url>/posts/63c4c968.html</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>以小根堆为例：</p><p>堆中的每一个点都是小于等于左右儿子的。</p><p>所以根节点就是整个堆的最小值。</p><h2 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h2><ol><li><p>插入一个数</p><p><code>heap[++ size] = x; up(size);</code></p></li><li><p>求集合当中的最小值</p><p><code>heap[1]</code></p></li><li><p>删除最小值</p><p>用整个堆的最后一个元素覆盖堆顶元素：</p><p><code>heap[1] = heap[size --]; down(1);</code></p></li><li><p>删除任意一个元素</p><p>与删除最小值类似，用最后一个元素覆盖下标为k的元素：</p><p><code>heap[k] = heap[size --]; up(k); down(k);</code></p><p>理论上是需要判断heap[k]的值变大还是变小再决定是up还是down。为了方便，可以直接up和down一遍</p></li><li><p>修改任意一个元素</p><p><code>heap[k] = x; up(k); down(k);</code></p></li></ol><p>其中，插入和删除元素都是 <code>O(logn)</code> 的，求最小值是 <code>O(1)</code> 的。</p><blockquote><p>后两种是手写堆特有的操作，STL无法直接实现。</p></blockquote><p>以上所有操作都可以由两个操作组合实现：</p><h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><p><code>down(x)</code>: 把下标为x的节点的值变大了</p><p>递归：与左右儿子相比，和最小的那个交换位置</p><h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><p><code>up(x)</code>: 把下标为x的节点的值变小了</p><p>递归：与父节点相比，如果比父节点小，则交换位置</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>堆是一个完全二叉树。</p><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p>用一个一位数组来存。下标为x的元素的左儿子下标是2x，右儿子的下标是2x + 1。</p><p>注：下标从1开始 </p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><p>带映射数组版本的模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// h[N]存储堆中的值，h[1]是堆顶，x的左儿子是2x，右儿子是2x + 1</span><br><span class="hljs-comment">// ph[k]存储第k个插入的点在堆中的位置，p是下标，h是堆，ph的意思是插入顺序的下标映射到堆</span><br><span class="hljs-comment">// hp[k]存储堆中下标是k的点是第几个插入的</span><br><span class="hljs-type">int</span> h[N], ph[N], hp[N], size;<br><br><span class="hljs-comment">// 交换两个点，及其映射关系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>  <span class="hljs-built_in">swap</span>(ph[hp[a]], ph[hp[b]]);<br>  <span class="hljs-built_in">swap</span>(hp[a], hp[b]);<br>  <span class="hljs-built_in">swap</span>(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>  <span class="hljs-type">int</span> t = u;<br>  <span class="hljs-comment">// t设为u及其左右儿子里值最小的那一个</span><br>  <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (u != t) &#123;<br>    <span class="hljs-built_in">heap_swap</span>(u, t);<br>    <span class="hljs-built_in">down</span>(t);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>]) &#123;<br>    <span class="hljs-built_in">heap_swap</span>(u, u / <span class="hljs-number">2</span>);<br>    u &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// O(n)建堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i --) <span class="hljs-built_in">down</span>(i);<br></code></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>先把数组建成堆，再依次输出堆顶元素</p><p>时间复杂度： <code>O(nlogn)</code>。</p><h4 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h4><p>如果一个一个元素插入，时间复杂度是 <code>O(nlogn)</code> 的。</p><p><code>O(n)</code> 的建堆方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i --) <span class="hljs-built_in">down</span>(i);<br></code></pre></td></tr></table></figure><p>从 n&#x2F;2 开始往上的所有元素 down，其实就是从树的倒数第二层开始down。</p><p>时间复杂度证明：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span>/<span class="hljs-number">4</span> * <span class="hljs-number">1</span> + <span class="hljs-built_in">n</span>/<span class="hljs-number">8</span> * <span class="hljs-number">2</span> + <span class="hljs-built_in">n</span>/<span class="hljs-number">16</span> * <span class="hljs-number">3</span> + ...<br>= <span class="hljs-built_in">n</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>^<span class="hljs-number">2</span> + <span class="hljs-number">2</span>/<span class="hljs-number">2</span>^<span class="hljs-number">3</span> + <span class="hljs-number">3</span>/<span class="hljs-number">2</span>^<span class="hljs-number">4</span> + ...)<br><br>S = <span class="hljs-number">1</span>/<span class="hljs-number">2</span>^<span class="hljs-number">2</span> + <span class="hljs-number">2</span>/<span class="hljs-number">2</span>^<span class="hljs-number">3</span> + <span class="hljs-number">3</span>/<span class="hljs-number">2</span>^<span class="hljs-number">4</span> + ...<br><span class="hljs-number">2</span>S = <span class="hljs-number">1</span>/<span class="hljs-number">2</span> + <span class="hljs-number">2</span>/<span class="hljs-number">2</span>^<span class="hljs-number">2</span> + <span class="hljs-number">3</span>/<span class="hljs-number">2</span>^<span class="hljs-number">3</span> + ...<br><span class="hljs-number">2</span>S - S = S = <span class="hljs-number">1</span>/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>/<span class="hljs-number">2</span>^<span class="hljs-number">2</span> + <span class="hljs-number">1</span>/<span class="hljs-number">2</span>^<span class="hljs-number">3</span> + ... &lt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="Dijkstra堆优化"><a href="#Dijkstra堆优化" class="headerlink" title="Dijkstra堆优化"></a>Dijkstra堆优化</h3><p>需要用到hp, ph映射数组</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-5.并查集</title>
    <link href="/posts/89087cc7.html"/>
    <url>/posts/89087cc7.html</url>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h2><p>在近乎 <code>O(1)</code> 的时间复杂度内支持以下两种操作：</p><ol><li>将两个集合合并</li><li>询问两个元素是否在一个集合当中</li></ol><p>注：有时也用于处理图论相关的问题。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>每个集合用一棵树来表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，<code>p[x]</code> 表示 <code>x</code> 的父节点。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="问题1-如何判断树根？"><a href="#问题1-如何判断树根？" class="headerlink" title="问题1: 如何判断树根？"></a>问题1: 如何判断树根？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (p[x] == x) 则为树根<br></code></pre></td></tr></table></figure><h3 id="问题2-如何求x的集合编号？"><a href="#问题2-如何求x的集合编号？" class="headerlink" title="问题2: 如何求x的集合编号？"></a>问题2: 如何求x的集合编号？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (p[x] != x) x = p[x];<br></code></pre></td></tr></table></figure><h3 id="问题3-如何合并两个集合？"><a href="#问题3-如何合并两个集合？" class="headerlink" title="问题3: 如何合并两个集合？"></a>问题3: 如何合并两个集合？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">px是x的集合编号，py是y的集合编号<br>令p[px] = py即可<br></code></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="1-路径压缩"><a href="#1-路径压缩" class="headerlink" title="1. 路径压缩"></a>1. 路径压缩</h3><p>在 <code>find</code> 函数中通过 <code> if (p[x] != x) p[x] = find(p[x]);</code> 实现把路径上所有点都直接指向祖宗节点</p><h3 id="2-按秩合并（待补充）"><a href="#2-按秩合并（待补充）" class="headerlink" title="2. 按秩合并（待补充）"></a>2. 按秩合并（待补充）</h3><p>大致意思就是倾向于把短的树接到长的树上面</p><p>用得较少，一般不在代码中实现</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><h3 id="朴素并查集"><a href="#朴素并查集" class="headerlink" title="朴素并查集"></a>朴素并查集</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> p[N]; <span class="hljs-comment">// 存储每个点的祖宗节点</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]); <span class="hljs-comment">// 顺手做了路径压缩</span><br>  <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1～n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) p[i] = i;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b); <span class="hljs-comment">// 让a的祖宗节点的父亲指向b的祖宗节点</span><br></code></pre></td></tr></table></figure><h3 id="维护size的并查集"><a href="#维护size的并查集" class="headerlink" title="维护size的并查集"></a>维护size的并查集</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> p[N], size[N];<br><span class="hljs-comment">// p[]存储每个点的祖宗节点，size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>  <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1～n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>  p[i] = i;<br>  size[i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合</span><br>size[<span class="hljs-built_in">find</span>(b)] += size[<span class="hljs-built_in">find</span>(a)];<br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><h3 id="维护到祖宗节点距离的并查集"><a href="#维护到祖宗节点距离的并查集" class="headerlink" title="维护到祖宗节点距离的并查集"></a>维护到祖宗节点距离的并查集</h3><p>例题：食物链</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> p[N], d[N];<br><span class="hljs-comment">// p[]存储每个点的祖宗节点，d[x]存储x到p[x]的距离</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (p[x] != x) &#123;<br>    <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>    d[x] += d[p[x]];<br>    p[x] = u;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1～n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) &#123;<br>  p[i] = i;<br>  d[i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b); <span class="hljs-comment">// 让a的祖宗节点的父亲指向b的祖宗节点</span><br>d[<span class="hljs-built_in">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-4.Trie树</title>
    <link href="/posts/ef9bba37.html"/>
    <url>/posts/ef9bba37.html</url>
    
    <content type="html"><![CDATA[<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>是用于高效<strong>存储</strong>和<strong>查找</strong>字符串集合中各字符串出现次数的数据结构。</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-comment">// 0号点既是根节点，又是空节点（一个点如果没有子节点，它的son就指向0）</span><br><span class="hljs-comment">// son[][]存储树中每个节点的子节点</span><br><span class="hljs-comment">// cnt[]存储以每个节点结尾的单词数量</span><br><br><span class="hljs-comment">// 插入一个字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span> </span>&#123;<br>  <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++) &#123;<br>    <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx; <span class="hljs-comment">// 如果没有子节点，创建一个新节点继续走</span><br>    p = son[p][u];<br>  &#125;<br>  cnt[p] ++;<br>&#125;<br><br><span class="hljs-comment">// 查询字符串出现的次数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span> </span>&#123;<br>  <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++) &#123;<br>    <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    p = son[p][u];<br>  &#125;<br>  <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-3.KMP</title>
    <link href="/posts/fca2cc32.html"/>
    <url>/posts/fca2cc32.html</url>
    
    <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>有两个字符串 <code>S</code> 和 <code>p</code>，其中 <code>S</code> 是原串（长），<code>p</code>是模板串（短）。</p><p>KMP用于字符串匹配：找到 <code>S</code> 中所有与 <code>p</code> 相同的子串，并返回每个子串开头字符的下标。</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span><br><br><span class="hljs-comment">// 求模式串的next数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++) &#123; <span class="hljs-comment">// i从2开始的原因：ne[1]不用算，ne[1]=0，第一个字母失败了只能从头开始</span><br>  <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>  <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++;<br>  ne[i] = j; <span class="hljs-comment">// 记录当前i对应的ne[i]</span><br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++) &#123;<br>  <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j]; <span class="hljs-comment">// j没有回到第一个字符且s[i]和p[j + 1]不能匹配：一直往后移动p串使得p[j + 1]之前的子串是匹配的</span><br>  <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++; <span class="hljs-comment">// 如果匹配了，j往后移动</span><br>  <span class="hljs-keyword">if</span> (j == m) &#123; <span class="hljs-comment">// 整个p串都匹配成功</span><br>    j = ne[j]; <span class="hljs-comment">// j还得退一步（试了下如果不加也能ac，因为在下一次循环的while中如果不匹配的话，反正也会执行j=ne[j]的？）</span><br>    <span class="hljs-comment">// 匹配成功之后的逻辑</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想不清楚的话拿个例子模拟一下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">s</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;abababc&quot;</span><br><span class="hljs-attribute">p</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;abababab&quot;</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h3><h4 id="时间复杂度-O-n-2"><a href="#时间复杂度-O-n-2" class="headerlink" title="时间复杂度 O(n^2)"></a>时间复杂度 <code>O(n^2)</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S[N], p[M]<br><br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>  <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>  <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>    <span class="hljs-keyword">if</span> (S[i + j - <span class="hljs-number">1</span>] != p[j]) &#123;<br>      flag = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  <span class="hljs-keyword">if</span> (flag) res.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="时间复杂度-O-n"><a href="#时间复杂度-O-n" class="headerlink" title="时间复杂度 O(n)"></a>时间复杂度 <code>O(n)</code></h4><p>分析：在 <code>i</code> 循环 <code>n</code> 次的过程中，每次循环 <code>j</code> 最多会+1，<code>j</code> 总共最多会+n，因此 <code>j=ne[j]</code> 再怎么减都最多减n</p><p>故总的时间复杂度是 <code>2n</code>，是 <code>O(n)</code> 的。</p><h4 id="next-数组"><a href="#next-数组" class="headerlink" title="next 数组"></a><code>next</code> 数组</h4><p>对于模板串 <code>p</code> 中的每一个字符 <code>p[i]</code>，都进行一个预处理：求出一个最大长度 <code>x</code>，使得以 <code>p[i]</code> 为结尾的长度为 <code>x</code> 的子串和 <code>p</code> 开头的长度为 <code>x</code> 的子串相等。</p><p><code>next[i] = j</code> 含义：<code>p[1, ..., j] = p[i - j + 1, ..., i]</code></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>模板中两个字符串的下标都是从1开始。</p><p><code>p</code> 中每次和<code>S[i]</code> 匹配的是 <code>p[j + 1]</code>，可以理解为 <code>j</code> 比 <code>i</code> 往前错一位，每次都只是试探一下 <code>p[j+1]</code> 能不能和 <code>S[i]</code> 匹配。</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-2.栈和队列</title>
    <link href="/posts/f726e612.html"/>
    <url>/posts/f726e612.html</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>LIFO</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// tt表示栈顶</span><br><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[++ tt] = x;<br><br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt --;<br><br><span class="hljs-comment">// 获得栈顶的值</span><br>stk[tt];<br><br><span class="hljs-comment">// 判断栈是否为空，如果 tt &gt; 0，则表示不为空</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>FIFO</p><h2 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h2><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// hh 表示队头， tt 表示队尾</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[++ tt] = x;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><h3 id="代码模板-2"><a href="#代码模板-2" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// hh 表示队头，tt 表示队尾的后一个位置</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[tt ++] = x;<br><span class="hljs-keyword">if</span> (tt == N) tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++;<br><span class="hljs-keyword">if</span> (hh == N) hh = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span><br><span class="hljs-keyword">if</span> (hh != tt) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="代码模板-3"><a href="#代码模板-3" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>    <span class="hljs-keyword">while</span> (tt &amp;&amp; <span class="hljs-built_in">check</span>(stk[tt], a[i])) tt --; <span class="hljs-comment">// 栈不空且栈顶元素满足某种性质时，一直弹出栈顶元素</span><br>    stk[++ tt] = a[i]; <span class="hljs-comment">// 当前元素压入栈中</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h2><p>找出每个数左边离它最近的比它大&#x2F;小的数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先想出暴力思路，再观察有没有单调性</p><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>两重循环 <code>O(n^2)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j --)<br>        <span class="hljs-keyword">if</span> (a[j] &lt; a[i]) &#123;<br>            cout &lt;&lt; a[j] &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h4><p><strong>性质</strong>：如果 <code>a[x] &gt;= a[y] &amp;&amp; x &lt; y</code>，那么 <code>a[x]</code> 一定不会被 <code>y</code> 及 <code>y</code> 后面的元素用到，它可以被删掉</p><p>一重循环 <code>O(n)</code>，每个元素最多入栈一次、出栈一次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>    <span class="hljs-comment">// 弹出不符合条件的元素</span><br>    <span class="hljs-keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= a[i]) tt --;<br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (tt) cout &lt;&lt; stk[tt] &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 新元素入栈</span><br>    stk[++ tt] = a[i];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><h2 id="代码模板-4"><a href="#代码模板-4" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check_out</span>(q[hh])) hh ++; <span class="hljs-comment">// 判断队头是否滑出窗口</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check</span>(q[tt], i)) tt --;<br>    q[++ tt] = i; <span class="hljs-comment">// 注意：此处队列里存的是下标，不是值</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常见模型-1"><a href="#常见模型-1" class="headerlink" title="常见模型"></a>常见模型</h2><p>找出滑动窗口中的最大值&#x2F;最小值</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力-1"><a href="#暴力-1" class="headerlink" title="暴力"></a>暴力</h4><p>从头到尾遍历元素，维护滑动窗口，每次遍历窗口内的所有元素找出最小值</p><p>时间复杂度 <code>O(nk)</code>，<code>k</code> 为窗口大小</p><h4 id="单调队列（双端队列）"><a href="#单调队列（双端队列）" class="headerlink" title="单调队列（双端队列）"></a>单调队列（双端队列）</h4><p>时间复杂度 <code>O(n)</code></p><p><strong>性质</strong>：如果 <code>a[x] &gt;= a[y] &amp;&amp; x &lt; y</code>，那么 <code>a[x]</code> 一定不会被用到，可以从队尾移除</p><p>额外维护一个严格单调递增的单调队列，取最小值时从队头取即可（记得判断队头元素是否已经在当前维护的滑动窗口之前了）</p><p>注意：队列里存的是下标，不是值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="hljs-number">1</span>) hh ++; <span class="hljs-comment">// 把滑动窗口之外的元素出队</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt --; <span class="hljs-comment">// 把队尾比a[i]大或相等的元素出队</span><br><br>    q[++ tt] = i; <span class="hljs-comment">// 当前元素入队</span><br><br>    <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[hh]]); <span class="hljs-comment">// 窗口完全进来了，输出队头元素（此时元素一定在滑动窗口范围内）</span><br>&#125;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板2-1.链表</title>
    <link href="/posts/594dd557.html"/>
    <url>/posts/594dd557.html</url>
    
    <content type="html"><![CDATA[<h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><h2 id="结构体-指针"><a href="#结构体-指针" class="headerlink" title="结构体+指针"></a>结构体+指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    Node *next;<br>&#125;;<br><br><span class="hljs-keyword">auto</span> n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(); <span class="hljs-comment">// 非常慢</span><br></code></pre></td></tr></table></figure><p>即动态链表。</p><p>一般面试中用得较多，笔试不常用，因为<code>new</code>操作效率低。</p><h2 id="数组模拟（常用）"><a href="#数组模拟（常用）" class="headerlink" title="数组模拟（常用）"></a>数组模拟（常用）</h2><p>即静态链表。</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>主要用途：邻接表。</p><p>邻接表应用：存储树和图。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><code>e[N]</code>: 存储每个点的 <code>val</code>。<code>ne[N]</code>：存储每个点的 <code>next</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// head存储链表头，e[]存储结点的值，ne[]存储结点的next指针，idx表示当前用到了哪个结点</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表头插入一个数a (80%的情况都是插到头结点的位置)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_to_head</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx ++;<br>&#125;<br><br><span class="hljs-comment">// 一般的插入操作：将a插入下标是k的结点后面</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> a)</span> </span>&#123;<br>    e[idx] = a, ne[idx] = ne[k], ne[k] = idx ++;<br>&#125;<br><br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_head</span><span class="hljs-params">()</span> </span>&#123;<br>    head = ne[head];<br>&#125;<br><br><span class="hljs-comment">// 一般的删除操作：将下标是k的点后面的点删掉</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    ne[k] = ne[ne[k]];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>主要用途：优化某些问题。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>让下标为0的点为<code>head</code>，下标为1的点为<code>tail</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// e[]表示结点的值，l[]表示结点的左指针，r[]表示结点的右指针，idx表示当前用到了哪个结点</span><br><span class="hljs-type">int</span> e[N], l[N], r[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 0是左端点，1是右端点</span><br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    idx = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 在结点k的右边插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> a)</span> </span>&#123;<br>    e[idx] = a;<br>    l[idx] = k, r[idx] = r[k];<br>    l[r[k]] = idx, r[k] = idx;<br>    idx ++;<br>&#125;<br><span class="hljs-comment">// 注：如果想在结点k的左边插入a，调用insert(l[k], a)即可</span><br><br><span class="hljs-comment">// 删除结点k</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    l[r[k]] = l[k];<br>    r[l[k]] = r[k];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式12-外观模式</title>
    <link href="/posts/90d63b5a.html"/>
    <url>/posts/90d63b5a.html</url>
    
    <content type="html"><![CDATA[<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个<strong>高层接口</strong>，这个接口使得这一子系统更加容易使用。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/07/LyeOAYqbGIl1nKp.jpg" alt="外观模式结构图.jpg"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>四个子系统的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 子系统1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemOne</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodOne</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子系统方法一&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 子系统2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemTwo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodTwo</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子系统方法二&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 子系统3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemThree</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodThree</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子系统方法三&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 子系统4</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemFour</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodFour</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子系统方法四&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>外观类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 外观类，需要了解所有子系统的方法或属性，进行组合以备外界调用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;<br>    SubSystemOne one;<br>    SubSystemTwo two;<br>    SubSystemThree three;<br>    SubSystemFour four;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Facade</span><span class="hljs-params">()</span> &#123;<br>        one = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemOne</span>();<br>        two = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemTwo</span>();<br>        three = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemThree</span>();<br>        four = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemFour</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        one.methodOne();<br>        two.methodTwo();<br>        three.methodThree();<br>        four.methodFour();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        two.methodTwo();<br>        three.methodThree();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 由于Facade的作用，客户端可以根本不知道四个子系统类的存在</span><br><span class="hljs-type">Facade</span> <span class="hljs-variable">facade</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Facade</span>();<br><br>facade.methodA();<br>facade.methodB();<br></code></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>对于面向对象有一定基础的朋友，即使没有听说过外观模式，也完全有可能在很多时候使用它，因为它完美地体现了依赖倒转原则和迪米特法则的思想，所以是非常常用的模式之一。</p><h3 id="何时使用？"><a href="#何时使用？" class="headerlink" title="何时使用？"></a>何时使用？</h3><ol><li>在设计初期阶段，应该要有意识地<strong>将不同的两个层分离</strong>，比如经典的三层架构，就需要考虑在数据访问层和业务逻辑层、业务逻辑层和表示层的<strong>层与层之间建立外观Facade</strong>，这样可以<strong>为复杂的子系统提供一个简单的接口，使得耦合大大降低。</strong></li><li>在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，大多数的模式使用时也都会产生很多很小的类，这本是好事，但也给外部调用它们的用户程序带来了使用上的困难，增加外观Facade可以<strong>提供一个简单的接口，减少它们之间的依赖。</strong></li><li>在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，但因为它包含非常重要的功能，新的需求开发必须要依赖于它。此时用外观模式Facade也是非常合适的。你可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让<strong>新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。</strong></li></ol><p><img src="https://s2.loli.net/2023/10/07/jCbN9tF6UzOJE1R.jpg" alt="外观模式使用场景.jpg"></p><h2 id="例：投资"><a href="#例：投资" class="headerlink" title="例：投资"></a>例：投资</h2><h3 id="v1股民直接炒股"><a href="#v1股民直接炒股" class="headerlink" title="v1股民直接炒股"></a>v1股民直接炒股</h3><p><img src="https://s2.loli.net/2023/10/07/y6CFScxOXlfApq5.jpg" alt="外观模式v1.jpg"></p><h3 id="v2股民投资基金"><a href="#v2股民投资基金" class="headerlink" title="v2股民投资基金"></a>v2股民投资基金</h3><p><img src="https://s2.loli.net/2023/10/07/X42AszLPjbJZhHd.jpg" alt="外观模式v2.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板1-7.区间合并模板</title>
    <link href="/posts/d9143548.html"/>
    <url>/posts/d9143548.html</url>
    
    <content type="html"><![CDATA[<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><p><strong>快速地</strong>将有交集的区间合并。</p><p>跟区间有关的问题，大概率会用到贪心。按照端点排序。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>有若干个区间，若其中某些区间有交集，则将它们合并。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>类似贪心。</p><ol><li>按区间左端点从小到大排序</li><li>当前维护的区间，左端点 <code>st</code>，右端点 <code>ed</code>。第<code>i</code>个区间（左端点 <code>l</code>，右端点 <code>r</code>）与当前维护区间的关系：<ol><li><code>st</code> &lt;&#x3D; <code>l</code> &lt;&#x3D; <code>r</code> &lt;&#x3D; <code>ed</code> &#x3D;&gt; 当前维护区间不变</li><li><code>st</code> &lt;&#x3D; <code>l</code> &lt;&#x3D; <code>ed</code> &lt; <code>r</code> &#x3D;&gt; <code>ed</code> 延长到 <code>r</code></li><li><code>st</code> &lt;&#x3D; <code>ed</code> &lt; <code>l</code> &lt;&#x3D; <code>r</code>  &#x3D;&gt; 当前维护区间放入答案，不会再更改；第 <code>i</code> 个区间作为新的当前维护区间</li></ol></li></ol><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回合并后的区间数组</span><br><span class="hljs-function">vector&lt;PII&gt; <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span> </span>&#123;<br>    vector&lt;PII&gt; res;<br>    <br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>; <span class="hljs-comment">// 初始区间设为负无穷</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs) &#123;<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first) &#123; <span class="hljs-comment">// 新区间左端点大于当前维护区间右端点，开始维护新区间</span><br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ed = <span class="hljs-built_in">max</span>(ed, seg.second); <span class="hljs-comment">// 合并情况1, 2</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;); <span class="hljs-comment">// 最后的区间也要加入答案，并且它不能为初始区间（segs为空的情况下答案也应为空）</span><br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板1-1.排序模板</title>
    <link href="/posts/1d57d4c3.html"/>
    <url>/posts/1d57d4c3.html</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均，最好：<code>O(nlogn)</code></p><p>最坏：<code>O(n^2)</code></p><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><p>从小到大：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">do</span> i ++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j --; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均，最好，最坏：<code>O(nlogn)</code></p><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><p>从小到大：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> tmp[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q, tmp, l, mid), <span class="hljs-built_in">merge_sort</span>(q, tmp, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++] = q[i ++];<br>        <span class="hljs-keyword">else</span> tmp[k ++] = q[j ++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++] = q[i ++];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++] = q[j ++];<br>    <br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://s2.loli.net/2023/09/19/aIySX8EKsdhnu4B.png" alt="排序复杂度总结.png"></p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板1-2.二分模板</title>
    <link href="/posts/7ea9f791.html"/>
    <url>/posts/7ea9f791.html</url>
    
    <content type="html"><![CDATA[<h1 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h1><p><code>check</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">// 检查arr[x]是否满足某种性质</span><br>&#125;<br></code></pre></td></tr></table></figure><p>区间<code>[l, r]</code>被划分成<code>[l, mid]</code>和<code>[mid + 1, r]</code>时使用（要找的是右半段的最左边那个点）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p>区间<code>[l, r]</code>被划分成<code>[l, mid - 1]</code>和<code>[mid, r]</code>时使用（要找的是左半段的最右边那个点）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br>    <span class="hljs-keyword">while</span> (r - l &gt; eps) &#123;  <span class="hljs-comment">// eps表示精度，取决于题目对精度的要求</span><br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板1-3.前缀和与差分模板</title>
    <link href="/posts/1384a50.html"/>
    <url>/posts/1384a50.html</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>给定a数组，需要构造S数组，使得：<code>S[i] = a[1] + a[2] + ... a[i] (i = 1, 2, ...), S[0] = 0</code></p><blockquote><p>注：a数组下标从1开始，S[i]也从1算起，且S[0]必须赋值0（当l&#x3D;1时会用到，S[l - 1] &#x3D; S[0]）</p></blockquote><h3 id="如何构造-S-i"><a href="#如何构造-S-i" class="headerlink" title="如何构造 S[i] ?"></a>如何构造 <code>S[i]</code> ?</h3><p>从前往后推：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    S[i] = S[i - <span class="hljs-number">1</span>] + a[i];<br></code></pre></td></tr></table></figure><h3 id="作用？"><a href="#作用？" class="headerlink" title="作用？"></a>作用？</h3><p>求a数组[l, r]的和 <code>a[l] + ... + a[r]</code></p><ul><li><p>如果没有S数组：时间复杂度<code>O(n)</code>，需要累加 <code>a[l] + a[l + 1] + ... + a[r]</code>；</p></li><li><p>有了S数组：时间复杂度 <code>O(1)</code>，直接 <code>S[r] - S[l - 1]</code>。</p></li></ul><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(<span class="hljs-built_in">x1</span>, y1)为左上角，(<span class="hljs-built_in">x2</span>, y2)为右下角的子矩阵的和为：<br>S[<span class="hljs-built_in">x2</span>, y2] - S[<span class="hljs-built_in">x1</span> - <span class="hljs-number">1</span>, y2] - S[<span class="hljs-built_in">x2</span>, y1 - <span class="hljs-number">1</span>] + S[<span class="hljs-built_in">x1</span> - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="如何构造-S-i-j"><a href="#如何构造-S-i-j" class="headerlink" title="如何构造 S[i, j] ?"></a>如何构造 <code>S[i, j]</code> ?</h3><p>二重循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>    S[i, j] = S[i - <span class="hljs-number">1</span>, j] + S[i, j - <span class="hljs-number">1</span>] - S[i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>] + a[i, j];<br></code></pre></td></tr></table></figure><h3 id="作用？-1"><a href="#作用？-1" class="headerlink" title="作用？"></a>作用？</h3><p>求a矩阵中：以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和</p><ul><li><p>如果没有S矩阵：时间复杂度<code>O(n^2)</code>，需要二重循环累加；</p></li><li><p>有了S矩阵：时间复杂度 <code>O(1)</code>，直接 <code>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</code>。</p></li></ul><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>前缀和的逆运算</p><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><h3 id="问题？"><a href="#问题？" class="headerlink" title="问题？"></a>问题？</h3><p>给定a数组，需要构造b数组，使得：<code>a[i] = b[1] + b[2] + ... + b[i]</code></p><blockquote><p>满足上述条件的b数组称为a的差分</p></blockquote><h3 id="作用？-2"><a href="#作用？-2" class="headerlink" title="作用？"></a>作用？</h3><p>给a数组区间[l, r]中的每个数加上c</p><ul><li>如果没有b数组：时间复杂度<code>O(n)</code>，需要遍历a数组</li><li>有了b数组：时间复杂度<code>O(1)</code>，<code>b[l] += c, b[r + 1] -= c</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何构造-b-i"><a href="#如何构造-b-i" class="headerlink" title="如何构造 b[i] ?"></a>如何构造 <code>b[i]</code> ?</h3><p>首先假定a, b数组所有元素都是0，此时满足前缀和与差分关系。</p><p>然后其实a数组是有初始值的，这里等价于做n次操作：<code>给a数组区间[i, i]中的每个数都加上a[i]</code>，构造b数组：<code>b[i] += a[i], b[i + 1] -= a[i]</code> 即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    <span class="hljs-built_in">insert</span>(i, i, a[i]);<br></code></pre></td></tr></table></figure><h3 id="最后用前缀和算法求操作后的a数组"><a href="#最后用前缀和算法求操作后的a数组" class="headerlink" title="最后用前缀和算法求操作后的a数组"></a>最后用前缀和算法求操作后的a数组</h3><p>做完若干+c操作后，用前缀和算法求最终答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>    b[i] += b[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, b[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">给以(<span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">1</span>)为左上角，(<span class="hljs-keyword">x</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">2</span>)为右下角的子矩阵中的所有元素加上<span class="hljs-keyword">c</span>：<br>b[<span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">1</span>] +<span class="hljs-operator">=</span> <span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> b[<span class="hljs-keyword">x</span><span class="hljs-number">2</span> + <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">1</span>] -<span class="hljs-operator">=</span> <span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> b[<span class="hljs-keyword">x</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">2</span> + <span class="hljs-number">1</span>] -<span class="hljs-operator">=</span> <span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> b[<span class="hljs-keyword">x</span><span class="hljs-number">2</span> + <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y<span class="hljs-number">2</span> + <span class="hljs-number">1</span>] +<span class="hljs-operator">=</span> <span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><h3 id="问题？-1"><a href="#问题？-1" class="headerlink" title="问题？"></a>问题？</h3><p>给定a矩阵，需要构造b矩阵，使得：<code>a[i, j] = b矩阵第i行j列格子左上部分所有元素的和</code></p><blockquote><p>也就是构造b矩阵，使得a矩阵是b矩阵的前缀和</p></blockquote><h3 id="作用？-3"><a href="#作用？-3" class="headerlink" title="作用？"></a>作用？</h3><p>给a矩阵以(x1, y1)为左上角，(x2, y2)为右下角的的子矩阵中的每个数加上c</p><ul><li>如果没有b矩阵：时间复杂度<code>O(n^2)</code>，需要遍历a矩阵</li><li>有了b矩阵：时间复杂度<code>O(1)</code>，<code>b[x1, y1] += c, b[x2 + 1, y1] -= c, b[x1, y2 + 1] -= c, b[x2 + 1, y2 + 1] += c</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    b[x1][y1] += c;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何构造-b-i-j"><a href="#如何构造-b-i-j" class="headerlink" title="如何构造 b[i][j] ?"></a>如何构造 <code>b[i][j]</code> ?</h3><p>与一维差分同理</p><p>其实具体构造不用管，就当作进行了n*m次修改操作即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++)<br>    <span class="hljs-built_in">insert</span>(i, j, i, j, a[i][j]);<br></code></pre></td></tr></table></figure><h3 id="最后用前缀和算法求操作后的a矩阵"><a href="#最后用前缀和算法求操作后的a矩阵" class="headerlink" title="最后用前缀和算法求操作后的a矩阵"></a>最后用前缀和算法求操作后的a矩阵</h3><p>做完若干+c操作后，用前缀和算法求最终答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>        b[i][j] += b[i][j - <span class="hljs-number">1</span>] + b[i - <span class="hljs-number">1</span>][j] - b[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, b[i][j]);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板1-4.双指针模板</title>
    <link href="/posts/9490f6c1.html"/>
    <url>/posts/9490f6c1.html</url>
    
    <content type="html"><![CDATA[<h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>    <span class="hljs-keyword">while</span> (j &lt;=  i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++; <span class="hljs-comment">// j在合法范围内且满足特定条件，继续往后走</span><br>    <br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常见问题分类"><a href="#常见问题分类" class="headerlink" title="常见问题分类"></a>常见问题分类</h2><ol><li>对于一个序列，用两个指针维护一段区间</li><li>对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</li></ol><h2 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a>核心作用</h2><p>运用某些单调性质（如i, j都只能往后移动），把 <code>O(n^2)</code> 复杂度的暴力枚举优化为 <code>O(n)</code>。</p>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板1-5.位运算模板</title>
    <link href="/posts/2b1eaae3.html"/>
    <url>/posts/2b1eaae3.html</url>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">求n的第k位数字: n &gt;&gt; k &amp; <span class="hljs-number">1</span><br>返回n的最后一位<span class="hljs-number">1</span>：<span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法模板1-6.离散化模板</title>
    <link href="/posts/dafbd502.html"/>
    <url>/posts/dafbd502.html</url>
    
    <content type="html"><![CDATA[<h1 id="整数保序离散化"><a href="#整数保序离散化" class="headerlink" title="整数保序离散化"></a>整数保序离散化</h1><h2 id="适用情景"><a href="#适用情景" class="headerlink" title="适用情景"></a>适用情景</h2><p>值域跨度大，但数非常稀疏。即数的范围比较大，但个数比较少。</p><blockquote><p>如：值域0~10^9^，个数10^5^。</p></blockquote><p>需要以数的值作为数组下标。这时需要用一个数组a[]对它们做映射。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>数组a[]中可能有重复元素 -&gt; <strong>需要去重</strong>，用cpp库函数erase()</li><li>如何算出某个数x离散化后的值（在a[]中的下标）是多少？ -&gt; <strong>二分</strong></li></ol><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><br><span class="hljs-comment">// 两行代码实现排序+去重</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//去掉重复元素（unique把所有不重复元素放到数组最前面，并返回这一段元素的尾端点的后一个端点，然后就可以用erase把这个端点到整个数组的尾端点这一段，即多余的重复元素删掉）</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>  </span>&#123; <span class="hljs-comment">// 找到第一个大于等于x的值对应的下标</span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 为了方便建立前缀和数组，映射到1, 2, ..., n （如果需要映射到0, 1, ..., n - 1，return r即可）</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例子：区间和"><a href="#例子：区间和" class="headerlink" title="例子：区间和"></a>例子：区间和</h2><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。</p><p>现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。</p><p>接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p><p>接下来 n 行，每行包含两个整数 x 和 c。</p><p>再接下来 m 行，每行包含两个整数 l 和 r。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 m 行，每行输出一个询问中所求的区间内数字和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>−10^9^≤ x ≤10^9^<br>1≤ n,m ≤10^5^<br>−10^9^≤ l ≤ r ≤10^9^<br>−10000≤ c ≤10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">8<br>0<br>5<br></code></pre></td></tr></table></figure><p>x, l和r都需要离散化存到a[]中，共3×10^5^的空间复杂度</p><p>最后query的区间和用离散化之后的数组求前缀和得出。</p><blockquote><p>注：如果值域跨度小，也可以直接用前缀和来做。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>template</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式11-迪米特法则</title>
    <link href="/posts/fd053551.html"/>
    <url>/posts/fd053551.html</url>
    
    <content type="html"><![CDATA[<h1 id="迪米特法则-LoD"><a href="#迪米特法则-LoD" class="headerlink" title="迪米特法则 (LoD)"></a>迪米特法则 (LoD)</h1><p>迪米特法则，也叫最少知识原则。</p><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><h2 id="根本思想"><a href="#根本思想" class="headerlink" title="根本思想"></a>根本思想</h2><p>强调类之间的松耦合。</p><p>在程序设计时，类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>在类的结构设计上，每一个类都应当尽量<strong>降低成员的访问权限</strong>。也就是说，一个类包装好自己的private状态，不需要让别的类知道的字段或行为就不要公开。</p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式10-模板方法模式</title>
    <link href="/posts/dbd95b3b.html"/>
    <url>/posts/dbd95b3b.html</url>
    
    <content type="html"><![CDATA[<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>模板方法（Template Method）模式，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。</p><p>模板方法使得子类可以在不改变一个算法的结构的情况下，重定义该算法的某些特定步骤。</p><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://s2.loli.net/2023/10/06/cXdaetYSGvgoiw8.jpg" alt="模板方法模式结构图.jpg"></p><h3 id="AbstractClass"><a href="#AbstractClass" class="headerlink" title="AbstractClass"></a>AbstractClass</h3><p>AbstractClass是抽象类，其实也就是一个抽象模板，定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</p><h3 id="ConcreteClass"><a href="#ConcreteClass" class="headerlink" title="ConcreteClass"></a>ConcreteClass</h3><p>ConcreteClass ， 实现父类所定义的一个或多个抽象方法。每一个AbstractClass 都可以有任意多个ConcreteClass 与之对应， 而每一个ConcreteClass都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>模板方法抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <br>    <span class="hljs-comment">// 模板方法，给出逻辑骨架，而逻辑组成是一些相应的抽象操作，都推迟到子类实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">templateMethod</span><span class="hljs-params">()</span> &#123;<br>        <br>        <span class="hljs-comment">// 写一些可以被子类共享的代码</span><br>        <br>        <span class="hljs-built_in">this</span>.primitiveOperation1();<br>        <span class="hljs-built_in">this</span>.primitiveOperation2();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 子类个性的行为，放到子类去实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation2</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板方法具体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 具体类A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClassA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;具体类A方法1实现&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;具体类A方法2实现&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体类B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClassB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;具体类B方法1实现&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">primitiveOperation2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;具体类B方法2实现&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势。</p><p>当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。</p><p>模板方法模式是很常用的模式，对继承和多态玩得好的人几乎都会在继承体系中多多少少用到它。比如在Java类库的设计中，通常都会利用模板方法模式提取类库中的公共行为到抽象类中。</p><h2 id="例：试卷抄题与作答"><a href="#例：试卷抄题与作答" class="headerlink" title="例：试卷抄题与作答"></a>例：试卷抄题与作答</h2><h3 id="v1学生抄题"><a href="#v1学生抄题" class="headerlink" title="v1学生抄题"></a>v1学生抄题</h3><p>试卷内容和答案都放到具体某个学生类中实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPaperA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TestPaper</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQuestion1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;问题xxxx。a. xxx b. xxx c. xxx&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;答案：b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="v2打印试卷"><a href="#v2打印试卷" class="headerlink" title="v2打印试卷"></a>v2打印试卷</h3><p>考题试卷类作为父类，试卷内容在试卷类中实现。</p><p>学生答卷类继承试卷类，答案在学生答卷类中实现。</p><h4 id="v2-1-试题方法在子类调用"><a href="#v2-1-试题方法在子类调用" class="headerlink" title="v2.1 试题方法在子类调用"></a>v2.1 试题方法在子类调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPaperA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TestPaper</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQuestion1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.testQuestion1();<br>        System.out.println(<span class="hljs-string">&quot;答案：b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="v2-2-只有具体答案在子类实现"><a href="#v2-2-只有具体答案在子类实现" class="headerlink" title="v2.2 只有具体答案在子类实现"></a>v2.2 只有具体答案在子类实现</h4><p>所有重复的代码都应该要上升到父类去，而不是让每个子类都去重复。</p><p>增加answer1()抽象方法，在子类重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 考题试卷</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPaper</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQuestion1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;问题xxxx。a. xxx b. xxx c. xxx&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;答案：&quot;</span> + <span class="hljs-built_in">this</span>.answer1()); <span class="hljs-comment">// 改成调用抽象方法answer1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">answer1</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 让继承的子类重写，因为每个人的答案不同</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 学生答卷</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPaperA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TestPaper</span> &#123;<br>    <br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">answer1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;b&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式9-原型模式</title>
    <link href="/posts/72b46234.html"/>
    <url>/posts/72b46234.html</url>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>原型模式（Prototype），用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</p><h2 id="原型模式结构图"><a href="#原型模式结构图" class="headerlink" title="原型模式结构图"></a>原型模式结构图</h2><p><img src="https://s2.loli.net/2023/10/05/MWng9htBKl2oAVD.jpg" alt="原型模式结构图.jpg"></p><h2 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h2><p>原型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Prototype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Prototype</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getID</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.id;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 原型模式关键：clone方法</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            object = <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Clone异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体原型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcretePrototype</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Prototype</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcretePrototype</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-built_in">super</span>(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ConcretePrototype</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcretePrototype</span>(<span class="hljs-string">&quot;123456&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;原ID: &quot;</span> + p1.getID());<br><br><span class="hljs-type">ConcretePrototype</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> (ConcretePrototype)p1.clone();<br>System.out.println(<span class="hljs-string">&quot;克隆ID: &quot;</span> + c1.getID());<br></code></pre></td></tr></table></figure><blockquote><p>对于Java而言，那个原型抽象类Prototype是用不着的，因为克隆实在是太常用了，所以Java提供了Cloneable接口，其中就是唯一的一个方法clone()，这样就只需要实现这个接口就可以完成原型模式了。</p></blockquote><h2 id="clone的好处"><a href="#clone的好处" class="headerlink" title="clone的好处"></a>clone的好处</h2><p>一般在初始化的信息不发生变化的情况下，克隆是最好的办法</p><ul><li>隐藏对象创建的细节，且修改时可以对特定对象修改，相同的部分也无需重复</li><li>提高性能：不用重新初始化对象，而是动态地获得对象运行时的状态</li></ul><h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><p>super.clone()方法是这样：</p><ul><li>如果字段是值类型的，则对该字段执行逐位复制</li><li>如果字段是引用类型，则复制引用但不复制引用的对象</li></ul><p>因此，原始对象及其副本引用同一对象。</p><h2 id="例：简历"><a href="#例：简历" class="headerlink" title="例：简历"></a>例：简历</h2><p>招聘时投递的简历，可以手抄也可以复印</p><h3 id="v1初步实现"><a href="#v1初步实现" class="headerlink" title="v1初步实现"></a>v1初步实现</h3><p>每生成一份简历，就要实例化一个Resume类的对象。类似于手写，信息需要填写多次，容易出错。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>简历类 <code>Resume</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resume</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> String age;<br>    <span class="hljs-keyword">private</span> String timeArea;<br>    <span class="hljs-keyword">private</span> String company;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Resume</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置个人信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPersonalInfo</span><span class="hljs-params">(String sex, String age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置工作经历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWorkExperience</span><span class="hljs-params">(String timeArea, String company)</span> &#123;<br>        <span class="hljs-built_in">this</span>.timeArea = timeArea;<br>        <span class="hljs-built_in">this</span>.company = company;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 展示简历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.sex + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.age);<br>        System.out.println(<span class="hljs-string">&quot;工作经历 &quot;</span> + <span class="hljs-built_in">this</span>.timeArea + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.company);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Resume</span> <span class="hljs-variable">resume1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>resume1.setPersonalInfo(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>resume1.setWorkExperience(<span class="hljs-string">&quot;2022-2023&quot;</span>, <span class="hljs-string">&quot;xx company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>resume2.setPersonalInfo(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>resume2.setWorkExperience(<span class="hljs-string">&quot;2022-2023&quot;</span>, <span class="hljs-string">&quot;xx company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>resume3.setPersonalInfo(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>resume3.setWorkExperience(<span class="hljs-string">&quot;2022-2023&quot;</span>, <span class="hljs-string">&quot;xx company&quot;</span>);<br><br>resume1.display();<br>resume2.display();<br>resume3.display();<br><br><span class="hljs-comment">// 错误的代码：引用传递 - 实际上指向的是同一个对象</span><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>resume1.setPersonalInfo(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>resume1.setWorkExperience(<span class="hljs-string">&quot;2022-2023&quot;</span>, <span class="hljs-string">&quot;xx company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume2</span> <span class="hljs-operator">=</span> resume1;<br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume3</span> <span class="hljs-operator">=</span> resume1;<br></code></pre></td></tr></table></figure><h3 id="v2原型实现"><a href="#v2原型实现" class="headerlink" title="v2原型实现"></a>v2原型实现</h3><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>简历类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resume</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> String age;<br>    <span class="hljs-keyword">private</span> String timeArea;<br>    <span class="hljs-keyword">private</span> String company;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Resume</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>    ... <span class="hljs-comment">// set方法</span><br>        <br>    <span class="hljs-comment">// 重写clone()方法</span><br>    <span class="hljs-keyword">public</span> Resume <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Resume</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            object = (Resume)<span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Clone异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Resume</span> <span class="hljs-variable">resume1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>resume1.setPersonalInfo(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>resume1.setWorkExperience(<span class="hljs-string">&quot;2022-2023&quot;</span>, <span class="hljs-string">&quot;xx company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume2</span> <span class="hljs-operator">=</span> resume1.clone();<br>resume2.setWorkExperience(<span class="hljs-string">&quot;2021-2022&quot;</span>, <span class="hljs-string">&quot;yy company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume3</span> <span class="hljs-operator">=</span> resume1.clone();<br>resume3.setPersonalInfo(<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;23&quot;</span>);<br><br>resume1.display();<br>resume2.display();<br>resume3.display();<br></code></pre></td></tr></table></figure><h3 id="v3浅拷贝与深拷贝实现"><a href="#v3浅拷贝与深拷贝实现" class="headerlink" title="v3浅拷贝与深拷贝实现"></a>v3浅拷贝与深拷贝实现</h3><p>将 <code>workExperience</code> 单独作为一个类，其中有时间区间和公司名称属性</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>不同resume对象指向的workExperience实际上是同一个</p><h5 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h5><p><img src="https://s2.loli.net/2023/10/05/p7GNTdRsmej3yWL.jpg" alt="原型模式v3浅拷贝.jpg"></p><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><p>工作经历类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkExperience</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String timeArea;<br>    <span class="hljs-keyword">private</span> String company;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTimeArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.timeArea;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTimeArea</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.timeArea = value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCompany</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.company;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCompany</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.company = vaule;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简历类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resume</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> String age;<br>    <span class="hljs-keyword">private</span> WorkExperience work; <span class="hljs-comment">// 声明一个工作经历的对象</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Resume</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.work = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkExperience</span>(); <span class="hljs-comment">// 对这个工作经历对象实例化</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置个人信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPersonalInfo</span><span class="hljs-params">(String sex, String age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置工作经历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWorkExperience</span><span class="hljs-params">(String timeArea, String company)</span> &#123;<br>        <span class="hljs-built_in">this</span>.work.setTimeArea(timeArea); <span class="hljs-comment">// 给工作经历实例的时间赋值</span><br>        <span class="hljs-built_in">this</span>.work.setCompany(company); <span class="hljs-comment">// 给工作经历实例的公司赋值</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 展示简历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.sex + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.age);<br>        System.out.println(<span class="hljs-string">&quot;工作经历 &quot;</span> + <span class="hljs-built_in">this</span>.work.getTimeArea() + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.work.getCompany());<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Resume <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Resume</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            object = (Resume)<span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span>(CloneNotSupportedException e) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Clone异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Resume</span> <span class="hljs-variable">resume1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>resume1.setPersonalInfo(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>resume1.setWorkExperience(<span class="hljs-string">&quot;2022-2023&quot;</span>, <span class="hljs-string">&quot;xx company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume2</span> <span class="hljs-operator">=</span> resume1.clone();<br>resume2.setWorkExperience(<span class="hljs-string">&quot;2021-2022&quot;</span>, <span class="hljs-string">&quot;yy company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume3</span> <span class="hljs-operator">=</span> resume1.clone();<br>resume3.setPersonalInfo(<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;23&quot;</span>);<br>resume2.setWorkExperience(<span class="hljs-string">&quot;2020-2021&quot;</span>, <span class="hljs-string">&quot;zz company&quot;</span>);<br><br>resume1.display();<br>resume2.display();<br>resume3.display();<br></code></pre></td></tr></table></figure><h6 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h6><p>实际结果与期望结果并不符合，前两次的工作经历数据被最后一次数据给覆盖了。</p><h6 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h6><p>这种拷贝方式是<strong>浅拷贝</strong>。对于值类型，没什么问题；对引用类型，就只是复制了引用，对引用的对象还是指向了原来的对象。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>我们希望是resume1、resume2、resume3三个引用的对象是不同的，复制时就一变二，二变三，此时，我们就叫这种方式为 <code>深拷贝</code>，深拷贝把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。</p><p>深复制要深入到多少层，需要事先就考虑好，而且要当心出现循环引用的问题，需要小心处理，这里比较复杂，可以慢慢研究。</p><h5 id="结构图-1"><a href="#结构图-1" class="headerlink" title="结构图"></a>结构图</h5><p><img src="https://s2.loli.net/2023/10/05/yRPYeD53NJKVduL.jpg" alt="原型模式v3深拷贝.jpg"></p><h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><p>工作经历类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkExperience</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String timeArea;<br>    <span class="hljs-keyword">private</span> String company;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTimeArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.timeArea;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTimeArea</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.timeArea = value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCompany</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.company;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCompany</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.company = vaule;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 重写clone方法</span><br>    <span class="hljs-keyword">public</span> WorkExperience <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">WorkExperience</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            object = (WorkExperience)<span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Clone异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简历类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resume</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> String age;<br>    <span class="hljs-keyword">private</span> WorkExperience work; <span class="hljs-comment">// 声明一个工作经历的对象</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Resume</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.work = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkExperience</span>(); <span class="hljs-comment">// 对这个工作经历对象实例化</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置个人信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPersonalInfo</span><span class="hljs-params">(String sex, String age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置工作经历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWorkExperience</span><span class="hljs-params">(String timeArea, String company)</span> &#123;<br>        <span class="hljs-built_in">this</span>.work.setTimeArea(timeArea); <span class="hljs-comment">// 给工作经历实例的时间赋值</span><br>        <span class="hljs-built_in">this</span>.work.setCompany(company); <span class="hljs-comment">// 给工作经历实例的公司赋值</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 展示简历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.sex + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.age);<br>        System.out.println(<span class="hljs-string">&quot;工作经历 &quot;</span> + <span class="hljs-built_in">this</span>.work.getTimeArea() + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.work.getCompany());<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Resume <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Resume</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            object = (Resume)<span class="hljs-built_in">super</span>.clone();<br>            object.work = <span class="hljs-built_in">this</span>.work.clone(); <span class="hljs-comment">// 新增该条语句，对work进行深拷贝</span><br>        &#125; <span class="hljs-keyword">catch</span>(CloneNotSupportedException e) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Clone异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Resume</span> <span class="hljs-variable">resume1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resume</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>resume1.setPersonalInfo(<span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);<br>resume1.setWorkExperience(<span class="hljs-string">&quot;2022-2023&quot;</span>, <span class="hljs-string">&quot;xx company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume2</span> <span class="hljs-operator">=</span> resume1.clone();<br>resume2.setWorkExperience(<span class="hljs-string">&quot;2021-2022&quot;</span>, <span class="hljs-string">&quot;yy company&quot;</span>);<br><br><span class="hljs-type">Resume</span> <span class="hljs-variable">resume3</span> <span class="hljs-operator">=</span> resume1.clone();<br>resume3.setPersonalInfo(<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;23&quot;</span>);<br>resume2.setWorkExperience(<span class="hljs-string">&quot;2020-2021&quot;</span>, <span class="hljs-string">&quot;zz company&quot;</span>);<br><br>resume1.display();<br>resume2.display();<br>resume3.display();<br></code></pre></td></tr></table></figure><h6 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h6><p>这时客户端输出结果达到预期效果。</p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式7-代理模式</title>
    <link href="/posts/53d3a547.html"/>
    <url>/posts/53d3a547.html</url>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。</p><h2 id="代理模式结构图"><a href="#代理模式结构图" class="headerlink" title="代理模式结构图"></a>代理模式结构图</h2><p><img src="https://s2.loli.net/2023/09/21/PAE9T4Ht7ku6MFY.jpg" alt="代理模式结构图.jpg"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><code>ISubject</code> 接口：定义了 <code>RealSubject</code> 和 <code>Proxy</code> 的共用接口，这样就可以在任何使用 <code>RealSubject</code> 的地方都可以使用 <code>Proxy</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISubject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RealSubject</code> 类：定义 <code>Proxy</code> 所代表的真实实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISubject</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;真实的请求。&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Proxy</code> 类：保存一个 <code>RealSubject</code> 的引用使得 <code>Proxy</code> 可以访问实体，并提供一个与 <code>RealSubject</code> 相同的方法，以替代实体执行方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISubject</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> RealSubject rs;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>(); <span class="hljs-comment">// 为什么不是传入参数rs?</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.rs.request();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="应用场合"><a href="#应用场合" class="headerlink" title="应用场合"></a>应用场合</h2><h3 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h3><p>为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。</p><p>例：WebService在Java中的应用。在项目中加入一个WebService，此时会在项目中生成一个wsdl文件和一些相关文件，其实它们就是代理，这就使得客户端程序调用代理就可以解决远程访问的问题。</p><h3 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h3><p>是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。</p><p>例：比如说你打开一个很大的HTML网页时，里面可能有很多的文字和图片，但你还是可以很快打开它，此时你所看到的是所有的文字，但图片却是一张一张地下载后才能看到。那些未打开的图片框，就是通过虚拟代理来替代了真实的图片，此时代理存储了真实图片的路径和尺寸。</p><h3 id="安全代理"><a href="#安全代理" class="headerlink" title="安全代理"></a>安全代理</h3><p>用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候。</p><h3 id="智能指引"><a href="#智能指引" class="headerlink" title="智能指引"></a>智能指引</h3><p>当调用真实的对象时，代理处理另外一些事。</p><p>例：计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它；或当第一次引用一个持久对象时，将它装入内存；或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。</p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合使用注意事项</title>
    <link href="/posts/725575c.html"/>
    <url>/posts/725575c.html</url>
    
    <content type="html"><![CDATA[<h1 id="集合判空"><a href="#集合判空" class="headerlink" title="集合判空"></a>集合判空</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</strong></p></blockquote><p>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 O(1)。</p><p>绝大部分我们使用的集合的 <code>size()</code> 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 <code>java.util.concurrent</code> 包下的某些集合（<code>ConcurrentLinkedQueue</code>、<code>ConcurrentHashMap</code>…）。</p><p>下面是 <code>ConcurrentHashMap</code> 的 <code>size()</code> 方法和 <code>isEmpty()</code> 方法的源码。（时间复杂度都是O(1)啊）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sumCount();<br>    <span class="hljs-keyword">return</span> ((n &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0</span> :<br>            (n &gt; (<span class="hljs-type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :<br>            (<span class="hljs-type">int</span>)n);<br>&#125;<br><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sumCount</span><span class="hljs-params">()</span> &#123;<br>    CounterCell[] as = counterCells; CounterCell a;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> baseCount;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> sumCount() &lt;= <span class="hljs-number">0L</span>; <span class="hljs-comment">// ignore transient negative values</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="集合转-Map"><a href="#集合转-Map" class="headerlink" title="集合转 Map"></a>集合转 Map</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String phoneNumber;<br>     <span class="hljs-comment">// getters and setters</span><br>&#125;<br><br>List&lt;Person&gt; bookList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-string">&quot;18163138123&quot;</span>));<br>bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;martin&quot;</span>,<span class="hljs-literal">null</span>));<br><span class="hljs-comment">// 空指针异常</span><br>bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));<br></code></pre></td></tr></table></figure><h1 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</strong></p></blockquote><p>通过反编译你会发现 foreach 语法底层其实还是依赖 <code>Iterator</code> 。不过， <code>remove/add</code> 操作直接调用的是集合自己的方法，而不是 <code>Iterator</code> 的 <code>remove/add</code>方法。</p><p>这就导致 <code>Iterator</code> 莫名其妙地发现自己有元素被 <code>remove/add</code> ，然后，它就会抛出一个 <code>ConcurrentModificationException</code> 来提示用户发生了并发修改异常。这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p><blockquote><p><strong>fail-fast 机制</strong>：多个线程对 fail-fast 集合进行修改的时候，可能会抛出<code>ConcurrentModificationException</code>。 即使是单线程下也有可能会出现这种情况，上面已经提到过。</p></blockquote><p>Java8 开始，可以使用 <code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br>    list.add(i);<br>&#125;<br>list.removeIf(filter -&gt; filter % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">/* 删除list中的所有偶数 */</span><br>System.out.println(list); <span class="hljs-comment">/* [1, 3, 5, 7, 9] */</span><br></code></pre></td></tr></table></figure><p>除了上面介绍的直接使用 <code>Iterator</code> 进行遍历操作之外，还可以：</p><ul><li>使用<strong>普通的 for 循环</strong></li><li>使用 <strong>fail-safe 的集合类</strong>。<code>java.util</code>包下面的所有的集合类都是 fail-fast 的，而<code>java.util.concurrent</code>包下面的所有的类都是 fail-safe 的。</li></ul><h1 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>可以利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</strong></p></blockquote><p>以 <code>HashSet</code> 和 <code>ArrayList</code> 为例说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Set 去重代码示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="hljs-title function_">removeDuplicateBySet</span><span class="hljs-params">(List&lt;T&gt; data)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(data)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(data);<br>&#125;<br><br><span class="hljs-comment">// List 去重代码示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">removeDuplicateByList</span><span class="hljs-params">(List&lt;T&gt; data)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(data)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    &#125;<br>    List&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(data.size());<br>    <span class="hljs-keyword">for</span> (T current : data) &#123;<br>        <span class="hljs-keyword">if</span> (!result.contains(current)) &#123;<br>            result.add(current);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>两者的核心差别在于 <code>contains()</code> 方法的实现。</p><p><code>HashSet</code> 的 <code>contains()</code> 方法底部依赖的 <code>HashMap</code> 的 <code>containsKey()</code> 方法，时间复杂度接近<code>O(1)</code>（没有出现哈希冲突的时候为 <code>O(1)</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">return</span> map.containsKey(o);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们有 N 个元素插入进 Set 中，时间复杂度为 <code>O(n)</code>。</p><p><code>ArrayList</code> 的 <code>contains()</code> 方法是通过遍历所有元素的方法来做的，时间复杂度为 <code>O(n)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>List</code> 中有 N 个元素，时间复杂度为 <code>O (n^2)</code>。</p><h1 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。</strong></p></blockquote><p><code>toArray(T[] array)</code> 方法的参数是一个泛型数组，如果 <code>toArray</code> 方法中没有传递任何参数的话返回的是 <code>Object</code>类 型数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String [] s= <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<br>    <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;lazy&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;over&quot;</span>, <span class="hljs-string">&quot;jumps&quot;</span>, <span class="hljs-string">&quot;fox&quot;</span>, <span class="hljs-string">&quot;brown&quot;</span>, <span class="hljs-string">&quot;quick&quot;</span>, <span class="hljs-string">&quot;A&quot;</span><br>&#125;;<br>List&lt;String&gt; list = Arrays.asList(s);<br>Collections.reverse(list);<br><span class="hljs-comment">//没有指定类型的话会报错</span><br>s=list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p>由于 JVM 优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。</p><h1 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h1><p>《阿里巴巴 Java 开发手册》的描述如下：</p><blockquote><p><strong>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</strong></p></blockquote><p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个 <code>List</code> 集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] myArray = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>&#125;;<br>List&lt;String&gt; myList = Arrays.asList(myArray);<br><span class="hljs-comment">//上面两个语句等价于下面一条语句</span><br>List&lt;String&gt; myList = Arrays.asList(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>);<br></code></pre></td></tr></table></figure><p>JDK 源码对于这个方法的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，</span><br><span class="hljs-comment">  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">asList</span><span class="hljs-params">(T... a)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(a);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Array-asList-使用注意事项"><a href="#Array-asList-使用注意事项" class="headerlink" title="Array.asList()使用注意事项"></a><code>Array.asList()</code>使用注意事项</h2><p><strong>1、<code>Arrays.asList()</code>是泛型方法，传递的数组的类型必须是对象（如Integer），而不是基本类型（如int）。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] myArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> Arrays.asList(myArray);<br>System.out.println(myList.size());<span class="hljs-comment">//1</span><br>System.out.println(myList.get(<span class="hljs-number">0</span>));<span class="hljs-comment">//数组地址值</span><br>System.out.println(myList.get(<span class="hljs-number">1</span>));<span class="hljs-comment">//报错：ArrayIndexOutOfBoundsException</span><br><span class="hljs-type">int</span>[] array = (<span class="hljs-type">int</span>[]) myList.get(<span class="hljs-number">0</span>);<br>System.out.println(array[<span class="hljs-number">0</span>]);<span class="hljs-comment">//1</span><br><br><span class="hljs-comment">// 要使用包装类型数组</span><br>Integer[] myArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身。此时 <code>List</code> 的唯一元素就是这个数组。</p><p><strong>2、使用集合的修改方法: <code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>myList.add(<span class="hljs-number">4</span>);<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br>myList.remove(<span class="hljs-number">1</span>);<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br>myList.clear();<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br></code></pre></td></tr></table></figure><p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类 <code>java.util.Arrays$ArrayList</code> ,这个内部类并没有实现集合的修改方法（并没有重写这些方法）。</p><h2 id="如何正确的将数组转换为-ArrayList"><a href="#如何正确的将数组转换为-ArrayList" class="headerlink" title="如何正确的将数组转换为 ArrayList ?"></a><strong>如何正确的将数组转换为 <code>ArrayList</code> ?</strong></h2><p>使用 Java8 的 <code>Stream</code> (推荐)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer [] myArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());<br><span class="hljs-comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span><br><span class="hljs-type">int</span> [] myArray2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode15. 三数之和</title>
    <link href="/posts/4539a383.html"/>
    <url>/posts/4539a383.html</url>
    
    <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>CodeTop字节高频题。</p><p><a href="https://leetcode.cn/problems/3sum/description/">https://leetcode.cn/problems/3sum/description/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><h1 id="考察知识点"><a href="#考察知识点" class="headerlink" title="考察知识点"></a>考察知识点</h1><ul><li>双指针</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>时间复杂度：<code>O(n^2)</code>，i从头到尾：<code>O(n)</code>，对每个i：j和k加起来<code>O(n)</code>。<ul><li>暴力：<code>O(n^3)</code></li></ul></li></ul><p>首先将数组排序（<code>O(nlogn)</code>）。使用双指针算法需要数组有序。</p><p>三个指针i, j, k，首先固定i，然后让j从i+1往后遍历。对于每个i, j：k从最后一个数往左移，直到找到最小的k，使得<code>nums[i] + nums[j] + nums[k] &gt;= 0</code>。此时若三数之和为0，加入res。</p><p>去重方法：判断<code>i</code>和<code>i-1</code>、<code>j</code>和<code>j-1</code>(还得j不为第一个数即<code>j != i + 1</code>)下标对应的值是否相同，相同则代表这种情况已经考虑过了，直接continue。</p><h3 id="自己写的非常不优雅的版本"><a href="#自己写的非常不优雅的版本" class="headerlink" title="自己写的非常不优雅的版本"></a>自己写的非常不优雅的版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 去除重复情况</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &lt; k; j ++) &#123;<br>                <span class="hljs-keyword">while</span> (nums[j - <span class="hljs-number">1</span>] == nums[j] &amp;&amp; i != j - <span class="hljs-number">1</span> &amp;&amp; j != k) j ++;<br>                <span class="hljs-keyword">while</span> (j &lt; k - <span class="hljs-number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>) k --; <span class="hljs-comment">// 获得当前i, j满足条件的k的最小坐标</span><br>                <span class="hljs-keyword">if</span> (j != k &amp;&amp; nums[i] + nums[j] + nums[k] == <span class="hljs-number">0</span>) res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="优雅版本"><a href="#优雅版本" class="headerlink" title="优雅版本"></a>优雅版本</h3><p><code>while (nums[j - 1] == nums[j] &amp;&amp; i != j - 1 &amp;&amp; j != k) j ++;</code> 这一步可以用<code>continue</code>语句代替，之后的<code>j != k</code>也不需要判断了（只要在循环里没跳出，就一定满足<code>j &lt; k</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 去除重复情况</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &lt; k; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j - <span class="hljs-number">1</span>] == nums[j]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 去除重复情况</span><br>                <span class="hljs-keyword">while</span> (j &lt; k - <span class="hljs-number">1</span> &amp;&amp; nums[i] + nums[j] + nums[k - <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>) k --; <span class="hljs-comment">// 获得当前i, j满足条件的k的最小坐标</span><br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="hljs-number">0</span>) res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式1-简单工厂模式</title>
    <link href="/posts/886a88d5.html"/>
    <url>/posts/886a88d5.html</url>
    
    <content type="html"><![CDATA[<h1 id="业务的封装"><a href="#业务的封装" class="headerlink" title="业务的封装"></a>业务的封装</h1><p>让业务逻辑与界面逻辑分开，让它们之间的耦合度下降。只有分离开，才可以达到容易维护或扩展，且可复用。</p><p>封装业务逻辑，开放特定外部接口，让界面逻辑使用。</p><p>封装业务逻辑前，与界面逻辑糅合在一起，不易维护：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    System.out.println(<span class="hljs-string">&quot;请输入数字A:&quot;</span>);<br>    <span class="hljs-type">double</span> <span class="hljs-variable">numberA</span> <span class="hljs-operator">=</span> Double.parseDouble(sc.nextLine());<br>    System.out.println(<span class="hljs-string">&quot;请选择运算符号:&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">strOperate</span> <span class="hljs-operator">=</span> sc.nextLine();<br>    System.out.println(<span class="hljs-string">&quot;请输入数字B:&quot;</span>);<br>    <span class="hljs-type">double</span> <span class="hljs-variable">numberB</span> <span class="hljs-operator">=</span> Double.parseDouble(sc.nextLine());<br>    <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>;<br>    <br>    <span class="hljs-keyword">switch</span> (strOperate) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>            result = numberA + numberB;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>            result = numberA - numberB;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>            result = numberA * numberB;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>            result = numberA / numberB;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <br>    System.out.println(<span class="hljs-string">&quot;result: &quot;</span> + result);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;wrong input: &quot;</span> + e.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>将业务逻辑（计算）封装在Operation类中，与界面逻辑（输出）分离：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Operation类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> numberA, <span class="hljs-type">double</span> numberB, String operate)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0d</span>;<br>        <span class="hljs-keyword">switch</span> (operate) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                result = numberA + numberB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                result = numberA - numberB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                result = numberA * numberB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                result = numberA / numberB;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    System.out.println(<span class="hljs-string">&quot;请输入数字A:&quot;</span>);<br>    <span class="hljs-type">double</span> <span class="hljs-variable">numberA</span> <span class="hljs-operator">=</span> Double.parseDouble(sc.nextLine());<br>    System.out.println(<span class="hljs-string">&quot;请选择运算符号:&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">strOperate</span> <span class="hljs-operator">=</span> sc.nextLine();<br>    System.out.println(<span class="hljs-string">&quot;请输入数字B:&quot;</span>);<br>    <span class="hljs-type">double</span> <span class="hljs-variable">numberB</span> <span class="hljs-operator">=</span> Double.parseDouble(sc.nextLine());<br>    <br>    <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Operation.getResult(numberA, numberB, strOperate);<br>    <br>    System.out.println(<span class="hljs-string">&quot;result: &quot;</span> + result);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;wrong input: &quot;</span> + e.toString());<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="紧耦合vs松耦合"><a href="#紧耦合vs松耦合" class="headerlink" title="紧耦合vs松耦合"></a>紧耦合vs松耦合</h1><p>按照上一节的写法，如果需要增加一个新的运算方式，加减乘除运算都会暴露。</p><p>可以将Operation类变为抽象类，各个运算方式继承这个类。这样新增运算方式只需要创建新类继承Operation不影响其他几个运算。</p><p>Operation类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> numberA, <span class="hljs-type">double</span> numberB)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0d</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>加减乘除类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Add</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> numberA, <span class="hljs-type">double</span> numberB)</span> &#123;<br>        <span class="hljs-keyword">return</span> numberA + numberB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> numberA, <span class="hljs-type">double</span> numberB)</span> &#123;<br>        <span class="hljs-keyword">return</span> numberA - numberB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mul</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> numberA, <span class="hljs-type">double</span> numberB)</span> &#123;<br>        <span class="hljs-keyword">return</span> numberA * numberB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Div</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(<span class="hljs-type">double</span> numberA, <span class="hljs-type">double</span> numberB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (numberB == <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;除数不能为0&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticException</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> numberA / numberB;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>解决<code>实例化哪个类的对象</code>的问题。</p><p>简单运算工厂类：根据用户输入的运算符号，决定返回哪一个运算子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperate</span><span class="hljs-params">(String operate)</span> &#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (operate) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Add</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mul</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>                oper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Div</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> oper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Operation</span> <span class="hljs-variable">oper</span> <span class="hljs-operator">=</span> OperationFactory.createOperate(strOperate);<br><span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> oper.getResult(numberA, numberB);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/09/14/uDzxwSonvHCfRrj.jpg" alt="简单工厂类图.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合-Map</title>
    <link href="/posts/168f6a95.html"/>
    <url>/posts/168f6a95.html</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h2><h3 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h3><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过<strong>拉链法</strong>解决冲突。</p><h4 id="扰动函数"><a href="#扰动函数" class="headerlink" title="扰动函数"></a><strong>扰动函数</strong></h4><p>指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法。换句话说使用扰动函数之后可以减少碰撞。</p><h5 id="JDK-1-8-HashMap-的-hash-方法源码"><a href="#JDK-1-8-HashMap-的-hash-方法源码" class="headerlink" title="JDK 1.8 HashMap 的 hash 方法源码:"></a><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></h5><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="对比一下-JDK1-7-的-HashMap-的-hash-方法源码"><a href="#对比一下-JDK1-7-的-HashMap-的-hash-方法源码" class="headerlink" title="对比一下 JDK1.7 的 HashMap 的 hash 方法源码:"></a>对比一下 JDK1.7 的 HashMap 的 hash 方法源码:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> &#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a><strong>拉链法</strong></h4><p>将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><h3 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h3><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><blockquote><p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="1、-putVal-方法中执行链表转红黑树的判断逻辑。"><a href="#1、-putVal-方法中执行链表转红黑树的判断逻辑。" class="headerlink" title="1、 putVal 方法中执行链表转红黑树的判断逻辑。"></a><strong>1、 <code>putVal</code> 方法中执行链表转红黑树的判断逻辑。</strong></h5><p>链表的长度大于 8 的时候，就执行 <code>treeifyBin</code> （转换红黑树）的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历链表</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>    <span class="hljs-comment">// 遍历到链表最后一个节点</span><br>    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）</span><br>        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>            <span class="hljs-comment">// 红黑树转换（并不会直接转换成红黑树）</span><br>            treeifyBin(tab, hash);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>        <span class="hljs-keyword">break</span>;<br>    p = e;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2、treeifyBin-方法中判断是否真的转换为红黑树。"><a href="#2、treeifyBin-方法中判断是否真的转换为红黑树。" class="headerlink" title="2、treeifyBin 方法中判断是否真的转换为红黑树。"></a><strong>2、<code>treeifyBin</code> 方法中判断是否真的转换为红黑树。</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">// 判断当前数组的长度是否小于 64</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        <span class="hljs-comment">// 如果当前数组的长度小于 64，那么会选择先进行数组扩容</span><br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 否则才将列表转换为红黑树</span><br><br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>                hd = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)<br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树。</p><h2 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h2><ul><li><p><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p></li><li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p></li><li><p><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p></li><li><p><strong>初始容量大小和每次扩充容量大小的不同：</strong> </p><ul><li>创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li><li>创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 <strong>2 的幂次方</strong>大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li></ul></li><li><p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</p></li></ul><p><strong><code>HashMap</code> 中带有初始容量的构造函数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tableSizeFor</code>，保证了 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Returns a power of two size for the given target capacity.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span>;<br>       n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>       n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>       n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>       n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>       n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>       <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h2><p><code>HashSet</code> 底层是基于 <code>HashMap</code> 实现的。</p><table><thead><tr><th align="center"><code>HashMap</code></th><th align="center"><code>HashSet</code></th></tr></thead><tbody><tr><td align="center">实现了 <code>Map</code> 接口</td><td align="center">实现 <code>Set</code> 接口</td></tr><tr><td align="center">存储键值对</td><td align="center">仅存储对象</td></tr><tr><td align="center">调用 <code>put()</code>向 map 中添加元素</td><td align="center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr><tr><td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td><td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><h2 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h2><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p><img src="https://s2.loli.net/2023/09/19/BhjL4qe3pPAUDyu.png" alt="TreeMap继承关系图.png"></p><ul><li><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p></li><li><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p></li></ul><h2 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h2><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用<code>%</code>取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p><h2 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h2><p>JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在<strong>死循环</strong>问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p><p>为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在<strong>数据覆盖</strong>的问题。并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h2><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong><ul><li><strong><code>ConcurrentHashMap</code></strong>:<ul><li>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li><li>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li></ul></li><li><strong><code>Hashtable</code>(同一把锁)</strong> :<ul><li>s使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul></li></ul></li></ul><h2 id="不同版本ConcurrentHashMap底层实现"><a href="#不同版本ConcurrentHashMap底层实现" class="headerlink" title="不同版本ConcurrentHashMap底层实现"></a>不同版本ConcurrentHashMap底层实现</h2><h3 id="JDK1-7-的-ConcurrentHashMap"><a href="#JDK1-7-的-ConcurrentHashMap" class="headerlink" title="JDK1.7 的 ConcurrentHashMap"></a><strong>JDK1.7 的 ConcurrentHashMap</strong></h3><p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</p><p><code>Segment</code> 数组中的每个元素包含一个 <code>HashEntry</code> 数组， <code>HashEntry</code> 数组中的元素是链表结构。</p><p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p><p><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p><h3 id="JDK1-8-的-ConcurrentHashMap"><a href="#JDK1-8-的-ConcurrentHashMap" class="headerlink" title="JDK1.8 的 ConcurrentHashMap"></a><strong>JDK1.8 的 ConcurrentHashMap</strong></h3><p>JDK1.8 的 <code>ConcurrentHashMap</code> 不再是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 **<code>TreeNode</code>**。当冲突链表达到一定长度时，链表会转换成红黑树。</p><p><code>TreeNode</code>是存储红黑树节点，被<code>TreeBin</code>包装。<code>TreeBin</code>通过<code>root</code>属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 <code>ConcurrentHashMap</code> 中<code>TreeBin</code>通过<code>waiter</code>属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>        TreeNode&lt;K,V&gt; root;<br>        <span class="hljs-keyword">volatile</span> TreeNode&lt;K,V&gt; first;<br>        <span class="hljs-keyword">volatile</span> Thread waiter;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> lockState;<br>        <span class="hljs-comment">// values for lockState</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WRITER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// set while holding write lock</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WAITER</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// set when waiting for write lock</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">READER</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// increment value for setting read lock</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p><p>Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p><h3 id="总结：JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？"><a href="#总结：JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？" class="headerlink" title="总结：JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"></a>总结：JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h3><ul><li><p><strong>线程安全实现方式</strong>：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p></li><li><p><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p></li><li><p><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p></li></ul><h2 id="ConcurrentHashMap-为什么-key-和-value-不能为-null？"><a href="#ConcurrentHashMap-为什么-key-和-value-不能为-null？" class="headerlink" title="ConcurrentHashMap 为什么 key 和 value 不能为 null？"></a>ConcurrentHashMap 为什么 key 和 value 不能为 null？</h2><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 <code>ConcurrentHashMap</code> 中，还是根本没有这个键。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 <code>ConcurrentHashMap</code> 中的，还是因为找不到对应的键而返回的。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>这也就是二义性的由来。</p><p>多线程环境下，存在一个线程操作该 <code>ConcurrentHashMap</code> 时，其他的线程将该 <code>ConcurrentHashMap</code> 修改的情况，所以无法通过 <code>containsKey(key)</code> 来判断否存在这个键值对，也就没办法解决二义性问题了。</p><p>与此形成对比的是，<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 <code>HashMap</code> 修改的情况，所以可以通过 <code>contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p><p>也就是说，多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。</p><p>如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">NULL</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><h2 id="ConcurrentHashMap-能保证复合操作的原子性吗？"><a href="#ConcurrentHashMap-能保证复合操作的原子性吗？" class="headerlink" title="ConcurrentHashMap 能保证复合操作的原子性吗？"></a>ConcurrentHashMap 能保证复合操作的原子性吗？</h2><p>不能。</p><p><code>ConcurrentHashMap</code> 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况，也不会导致 JDK1.7 及之前版本的 <code>HashMap</code> 多线程操作导致死循环问题。但是，这并不意味着它可以保证所有的复合操作都是原子性的。</p><p>复合操作是指由多个基本操作(如<code>put</code>、<code>get</code>、<code>remove</code>、<code>containsKey</code>等)组成的操作，例如先判断某个键是否存在<code>containsKey(key)</code>，然后根据结果进行插入或更新<code>put(key, value)</code>。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。</p><p>例如，有两个线程 A 和 B 同时对 <code>ConcurrentHashMap</code> 进行复合操作，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A</span><br><span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>map.put(key, value);<br>&#125;<br><span class="hljs-comment">// 线程 B</span><br><span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>map.put(key, anotherValue);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果线程 A 和 B 的执行顺序是这样：</p><ol><li>线程 A 判断 map 中不存在 key</li><li>线程 B 判断 map 中不存在 key</li><li>线程 B 将 (key, anotherValue) 插入 map</li><li>线程 A 将 (key, value) 插入 map</li></ol><p>那么最终的结果是 (key, value)，而不是预期的 (key, anotherValue)。这就是复合操作的非原子性导致的问题。</p><h3 id="那如何保证-ConcurrentHashMap-复合操作的原子性呢？"><a href="#那如何保证-ConcurrentHashMap-复合操作的原子性呢？" class="headerlink" title="那如何保证 ConcurrentHashMap 复合操作的原子性呢？"></a><strong>那如何保证 <code>ConcurrentHashMap</code> 复合操作的原子性呢？</strong></h3><p><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。</p><p>上面的代码可以改写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A</span><br>map.putIfAbsent(key, value);<br><span class="hljs-comment">// 线程 B</span><br>map.putIfAbsent(key, anotherValue);<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A</span><br>map.computeIfAbsent(key, k -&gt; value);<br><span class="hljs-comment">// 线程 B</span><br>map.computeIfAbsent(key, k -&gt; anotherValue);<br></code></pre></td></tr></table></figure><p>很多同学可能会说了，这种情况也能加锁同步呀！确实可以，但不建议使用加锁的同步机制，违背了使用 <code>ConcurrentHashMap</code> 的初衷。在使用 <code>ConcurrentHashMap</code> 的时候，尽量使用这些原子性的复合操作方法来保证原子性。</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合-Set</title>
    <link href="/posts/6336e5f2.html"/>
    <url>/posts/6336e5f2.html</url>
    
    <content type="html"><![CDATA[<h2 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul><li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都<strong>不是线程安全的</strong>。</p></li><li><p><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。</p><ul><li><code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。</li><li><code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li><li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li></ul></li><li><p>底层数据结构不同又导致这三者的应用场景不同。</p><ul><li><code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景。</li><li><code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景。</li><li><code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul></li></ul><h2 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h2><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p><ul><li><code>Comparable</code> 接口出自<code>java.lang</code>包，它有一个 <code>compareTo(Object obj)</code>方法用来排序（拿自己和其他对象比较）</li><li><code>Comparator</code>接口出自 <code>java.util</code> 包，它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序（传入两个对象比较）</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要<strong>重写<code>compareTo()</code>方法或<code>compare()</code>方法</strong>。</p><ul><li>当我们需要对某一个集合实现两种排序方式，比如一个 <code>song</code> 对象中的歌名和歌手名分别采用一种排序方法的话：<ul><li>我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法来实现歌名排序和歌星名排序</li><li>或者以两个 <code>Comparator</code> 来实现歌名排序和歌星名排序，我们只能使用两个参数版的 <code>Collections.sort(collection, comparator)</code>.</li></ul></li></ul><h2 id="无序性和不可重复性的含义"><a href="#无序性和不可重复性的含义" class="headerlink" title="无序性和不可重复性的含义"></a>无序性和不可重复性的含义</h2><ul><li><p>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p></li><li><p>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</p></li></ul><h2 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复?"></a>HashSet 如何检查重复?</h2><p>先检查<code>hashcode</code>，如果有重复的再调用<code>equals()</code>。</p><blockquote><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p></blockquote><p>在 JDK1.8 中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。直接看一下<code>HashSet</code>中的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Returns: true if this set did not already contain the specified element</span><br><span class="hljs-comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而在<code>HashMap</code>的<code>putVal()</code>方法中也能看到如下说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Returns : previous value, or null if none</span><br><span class="hljs-comment">// 返回值：如果插入位置没有元素返回null，否则返回上一个元素</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，在 JDK1.8 中，实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式5-依赖倒转原则</title>
    <link href="/posts/749848fc.html"/>
    <url>/posts/749848fc.html</url>
    
    <content type="html"><![CDATA[<h1 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h1><p>SOLID原则中的D: <strong>D</strong>ependency Inversion Principle</p><h2 id="准确解释"><a href="#准确解释" class="headerlink" title="准确解释"></a>准确解释</h2><ul><li>高层模块不应该依赖低层模块。两个都应该依赖抽象。<ul><li>解释：<ul><li>面向过程的开发时，为了使得常用代码可以复用，一般都会把这些常用代码写成许许多多函数的程序库，这样我们在做新项目时，去调用这些低层的函数就可以了。比如我们做的项目大多要访问数据库，所以我们就把访问数据库的代码写成了函数，每次做新项目时就去调用这些函数。这也就叫作高层模块依赖低层模块。</li><li>而如果不管高层模块还是低层模块，它们都依赖于抽象，具体一点就是接口或抽象类，只要接口是稳定的，那么任何一个更改都不用担心其他受到影响，这就使得无论高层模块还是低层模块都可以很容易地被复用。</li></ul></li></ul></li><li>抽象不应该依赖细节，细节应该依赖于抽象，即：要针对接口编程，不要对实现编程。<ul><li>例：主板、CPU、内存、硬盘都是针对接口设计的，如果针对实现来设计，内存就要对应到具体的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即<strong>程序中所有的依赖关系都是终止于抽象类或者接口</strong>，那就是面向对象的设计，反之那就是过程化的设计了。</p><h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h1><p>SOLID原则中的L: <strong>L</strong>iskov Substitution Principle</p><h2 id="准确解释-1"><a href="#准确解释-1" class="headerlink" title="准确解释"></a>准确解释</h2><p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。</p><p>正因为有了这个原则，使得继承复用成为可能，只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。</p><h2 id="与其他原则的关系"><a href="#与其他原则的关系" class="headerlink" title="与其他原则的关系"></a>与其他原则的关系</h2><p><strong>有里氏代换原则，才使得开放-封闭成为可能。</strong></p><p>正是由于<strong>子类型的可替换性</strong>才使得使用父类类型的模块在无须修改的情况下就可以扩展。</p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode215. 数组中的第K个最大元素</title>
    <link href="/posts/1cf34af1.html"/>
    <url>/posts/1cf34af1.html</url>
    
    <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>CodeTop字节高频题。</p><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">https://leetcode.cn/problems/kth-largest-element-in-an-array/description/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,5,6,4], k = 2</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">3,2,3,1</span>,<span class="hljs-number">2,4,5,5</span>,<span class="hljs-number">6</span>], k = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h1 id="考察知识点"><a href="#考察知识点" class="headerlink" title="考察知识点"></a>考察知识点</h1><ul><li>快速选择算法</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>套快排模板，区别是只需要递归左区间&#x2F;右区间，时间复杂度为<code>O(n)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_select</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> nums[l];<br>        <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = nums[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i ++; <span class="hljs-keyword">while</span> (nums[i] &gt; x);<br>            <span class="hljs-keyword">do</span> j --; <span class="hljs-keyword">while</span> (nums[j] &lt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-type">int</span> cnt_l = j - l + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k &lt;= cnt_l) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_select</span>(nums, l, j, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_select</span>(nums, j + <span class="hljs-number">1</span>, r, k - cnt_l);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_select</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合-Queue</title>
    <link href="/posts/ef9e31dd.html"/>
    <url>/posts/ef9e31dd.html</url>
    
    <content type="html"><![CDATA[<h1 id="Queue-和-Deque-的区别"><a href="#Queue-和-Deque-的区别" class="headerlink" title="Queue 和 Deque 的区别"></a>Queue 和 Deque 的区别</h1><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: </p><ul><li>一种在操作失败后会抛出异常（如add）</li><li>另一种则会返回特殊值（如offer）</li></ul><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p><h1 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h1><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能。</p><p>区别：</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li>关于插入性能<ul><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。</li><li>虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul></li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。</p><p>此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是<strong>优先级最高的元素先出队</strong>。（二叉堆是优先队列的一种实现方式。最小堆即元素越小，优先级最高）</p><p>这里列举其相关的一些要点：</p><ul><li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</p><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h1><p><code>BlockingQueue</code> （阻塞队列）是一个接口，继承自 <code>Queue</code>。</p><p><code>BlockingQueue</code>支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p><h2 id="BlockingQueue-的实现类有哪些？"><a href="#BlockingQueue-的实现类有哪些？" class="headerlink" title="BlockingQueue 的实现类有哪些？"></a>BlockingQueue 的实现类有哪些？</h2><p><img src="https://s2.loli.net/2023/09/18/WRSBpaoAXiZzkq4.png" alt="BlockingQueue 的实现类.png"></p><p>Java 中常用的阻塞队列实现类有以下几种：</p><ol><li><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</li><li><code>LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为<code>Integer.MAX_VALUE</code>。和<code>ArrayBlockingQueue</code>类似， 它也支持公平和非公平的锁访问机制。</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</li><li><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</li><li><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li><li>……</li></ol><p>日常开发中，这些队列使用的其实都不多，了解即可。</p><h2 id="ArrayBlockingQueue-和-LinkedBlockingQueue-有什么区别？"><a href="#ArrayBlockingQueue-和-LinkedBlockingQueue-有什么区别？" class="headerlink" title="ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？"></a>ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？</h2><p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 是 Java 并发包中常用的两种阻塞队列实现，它们都是线程安全的。不过，不过它们之间也存在下面这些区别：</p><ul><li>底层实现：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>LinkedBlockingQueue</code> 基于链表实现。</li><li>是否有界：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code>Integer.MAX_VALUE</code>，也就是无界的。但也可以指定队列大小，从而成为有界的。</li><li>锁是否分离： <code>ArrayBlockingQueue</code>中的锁是没有分离的，即生产和消费用的是同一个锁；<code>LinkedBlockingQueue</code>中的锁是分离的，即生产用的是<code>putLock</code>，消费是<code>takeLock</code>，这样可以防止生产者和消费者线程之间的锁争夺。</li><li>内存占用：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。这意味着，<code>ArrayBlockingQueue</code> 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而<code>LinkedBlockingQueue</code> 则是根据元素的增加而逐渐占用内存空间。</li></ul>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合概览</title>
    <link href="/posts/f14ccc72.html"/>
    <url>/posts/f14ccc72.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/09/18/NSXU8CnfhvgZopd.png" alt="Java集合框架.png"></p><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：</p><ul><li><code>Collection</code>接口，主要用于存放单一元素</li><li><code>List</code>接口(对付顺序的好帮手): 存储的元素是有序的、可重复的。<ul><li><code>ArrayList</code>：<code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul></li><li><code>Set</code>接口(注重独一无二的性质): 存储的元素不可重复的。<ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul></li><li><code>Queue</code>接口(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。<ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li><li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul></li><li><code>Map</code> 接口(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li><li><code>HashMap</code>：JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）</li></ul><h2 id="如何选用集合？"><a href="#如何选用集合？" class="headerlink" title="如何选用集合？"></a>如何选用集合？</h2><p>根据集合的特点来选择合适的集合。比如：</p><ul><li>我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</li><li>我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</li></ul><h2 id="为什么要选用集合？"><a href="#为什么要选用集合？" class="headerlink" title="为什么要选用集合？"></a>为什么要选用集合？</h2><p>相较于数组，Java 集合的优势在于它们的<strong>大小可变、支持泛型、具有内建算法</strong>等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合-List</title>
    <link href="/posts/989bd717.html"/>
    <url>/posts/989bd717.html</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="ArrayList-和-Array（数组）的区别？"><a href="#ArrayList-和-Array（数组）的区别？" class="headerlink" title="ArrayList 和 Array（数组）的区别？"></a>ArrayList 和 Array（数组）的区别？</h2><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><h3 id="使用对比"><a href="#使用对比" class="headerlink" title="使用对比"></a>使用对比</h3><p><code>Array</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化一个 String 类型的数组</span><br>String[] stringArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>&#125;;<br><span class="hljs-comment">// 修改数组元素的值</span><br>stringArr[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;goodbye&quot;</span>;<br>System.out.println(Arrays.toString(stringArr));<span class="hljs-comment">// [goodbye, world, !]</span><br><span class="hljs-comment">// 删除数组中的元素，需要手动移动后面的元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stringArr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    stringArr[i] = stringArr[i + <span class="hljs-number">1</span>];<br>&#125;<br>stringArr[stringArr.length - <span class="hljs-number">1</span>] = <span class="hljs-literal">null</span>;<br>System.out.println(Arrays.toString(stringArr));<span class="hljs-comment">// [world, !, null]</span><br></code></pre></td></tr></table></figure><p><code>ArrayList</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化一个 String 类型的 ArrayList</span><br> ArrayList&lt;String&gt; stringList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// 添加元素到 ArrayList 中</span><br> stringList.add(<span class="hljs-string">&quot;goodbye&quot;</span>);<br> System.out.println(stringList);<span class="hljs-comment">// [hello, world, !, goodbye]</span><br> <span class="hljs-comment">// 修改 ArrayList 中的元素</span><br> stringList.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hi&quot;</span>);<br> System.out.println(stringList);<span class="hljs-comment">// [hi, world, !, goodbye]</span><br> <span class="hljs-comment">// 删除 ArrayList 中的元素</span><br> stringList.remove(<span class="hljs-number">0</span>);<br> System.out.println(stringList); <span class="hljs-comment">// [world, !, goodbye]</span><br></code></pre></td></tr></table></figure><h2 id="ArrayList-插入和删除元素的时间复杂度？"><a href="#ArrayList-插入和删除元素的时间复杂度？" class="headerlink" title="ArrayList 插入和删除元素的时间复杂度？"></a>ArrayList 插入和删除元素的时间复杂度？</h2><p>对于插入：</p><ul><li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部插入：当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li></ul><p>对于删除：</p><ul><li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li><li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li><li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li></ul><h1 id="Vector-Stack"><a href="#Vector-Stack" class="headerlink" title="Vector &amp; Stack"></a>Vector &amp; Stack</h1><h2 id="ArrayList-和-Vector-的区别-（了解即可）"><a href="#ArrayList-和-Vector-的区别-（了解即可）" class="headerlink" title="ArrayList 和 Vector 的区别?（了解即可）"></a>ArrayList 和 Vector 的区别?（了解即可）</h2><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 。</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全。</li></ul><h2 id="Vector-和-Stack-的区别-（了解即可）"><a href="#Vector-和-Stack-的区别-（了解即可）" class="headerlink" title="Vector 和 Stack 的区别?（了解即可）"></a>Vector 和 Stack 的区别?（了解即可）</h2><ul><li><code>Vector</code> 和 <code>Stack</code> 两者都是线程安全的，都是使用 <code>synchronized</code> 关键字进行同步处理。</li><li><code>Stack</code> 继承自 <code>Vector</code>，是一个后进先出的栈，而 <code>Vector</code> 是一个列表。</li></ul><p>随着 Java 并发编程的发展，<code>Vector</code> 和 <code>Stack</code> 已经被淘汰，推荐使用并发集合类（例如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。</p><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><h2 id="LinkedList-插入和删除元素的时间复杂度？"><a href="#LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="LinkedList 插入和删除元素的时间复杂度？"></a>LinkedList 插入和删除元素的时间复杂度？</h2><ul><li><p>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</p></li><li><p>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</p></li><li><p>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</p></li></ul><h2 id="LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="LinkedList 为什么不能实现 RandomAccess 接口？"></a>LinkedList 为什么不能实现 RandomAccess 接口？</h2><p><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口。</p><p><code>ArrayList</code>可以。</p><h3 id="补充：RandomAccess接口"><a href="#补充：RandomAccess接口" class="headerlink" title="补充：RandomAccess接口"></a>补充：RandomAccess接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RandomAccess</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RandomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt;<br><span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(List&lt;? extends Comparable&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; list, T key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (list <span class="hljs-keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)<br>        <span class="hljs-keyword">return</span> Collections.indexedBinarySearch(list, key);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> Collections.iteratorBinarySearch(list, key);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。</p><p> <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的。</p><h2 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h2><ul><li><p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p></li><li><p><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p></li><li><p><strong>插入和删除是否受元素位置的影响：</strong></p><ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、 <code>removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>,<code>remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。</li></ul></li><li><p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p></li><li><p><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ul><p>我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！就连 <code>LinkedList</code> 的作者约书亚 · 布洛克（Joshua Bloch）自己都说从来不会使用 <code>LinkedList</code> 。</p><p>不要下意识地认为 <code>LinkedList</code> 作为链表就最适合元素增删的场景。<code>LinkedList</code> 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 。</p>]]></content>
    
    
    <categories>
      
      <category>programming language</category>
      
      <category>Java</category>
      
      <category>collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式4-开放封闭原则</title>
    <link href="/posts/acd02086.html"/>
    <url>/posts/acd02086.html</url>
    
    <content type="html"><![CDATA[<p>SOLID原则中的O: <strong>O</strong>pen-Close Principle</p><h1 id="准确解释"><a href="#准确解释" class="headerlink" title="准确解释"></a>准确解释</h1><p>开放-封闭原则，是说软件实体（类、模块、函数等）应该可以扩展，但是不可修改。</p><h2 id="两个特征"><a href="#两个特征" class="headerlink" title="两个特征"></a>两个特征</h2><ul><li>Open for extension 对扩展开放</li><li>Close for modification 对修改封闭</li></ul><h2 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h2><p>面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本，而不会把整个程序推倒重来。</p><p>设计的时候，时刻要考虑，尽量让这个类足够好，写好了就不要去修改了，如果新需求来，我们增加一些类就完事了，原来的代码能不动则不动。</p><p>绝对的对修改关闭是不可能的。无论模块是多么的’封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块<strong>应该对哪种变化封闭</strong>做出选择。他必须先猜测出最有可能发生的变化种类，然后<strong>构造抽象</strong>来隔离那些变化。</p><p>我们是很难预先猜测，但我们却可以在发生小变化时，就及早去想办法应对发生更大变化的可能。也就是说，<strong>等到变化发生时立即采取行动</strong>。在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>简单工厂模式中的计算器。</p><ol><li>首先加法程序写在client类中。</li><li>然后增加减法功能，发现需要修改原来类，违背OCP -&gt; 考虑重构程序，增加抽象的运算类 -&gt; 能够满足需求，并能应对变化</li><li>增加乘除法功能，无需修改client类，只需增加乘法和除法的子类。</li></ol><p>面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。</p><p>我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。（如：加减运算在很多地方应用了，再考虑抽象、考虑分离，就很困难）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是<strong>可维护、可扩展、可复用、灵活性好</strong>。</p><p>开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。<strong>拒绝不成熟的抽象和抽象本身一样重要</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode206. 反转链表</title>
    <link href="/posts/7d23fe8b.html"/>
    <url>/posts/7d23fe8b.html</url>
    
    <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>CodeTop字节高频题。</p><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>双指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> a = head, b = a-&gt;next;<br>        <span class="hljs-keyword">while</span> (b) &#123;<br>            <span class="hljs-keyword">auto</span> c = b-&gt;next;<br>            b-&gt;next = a;<br>            a = b, b = c;<br>        &#125;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>直接用给的函数<code>reverseList</code>本身递归。</p><p><code>reverseList</code>的参数是某节点<code>n</code>，返回值是<code>n指向的子链表</code>的尾结点<code>tail</code>。<code>n指向的子链表</code>是已经翻转完毕的链表，只需要将<code>n的下一个节点</code>的next指向n，n的next设置成nullptr即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> tail = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> tail;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式3-单一职责原则</title>
    <link href="/posts/6f3ea88b.html"/>
    <url>/posts/6f3ea88b.html</url>
    
    <content type="html"><![CDATA[<p>SOLID原则中的S: <strong>S</strong>ingle Responsibility Principle</p><h1 id="准确解释"><a href="#准确解释" class="headerlink" title="准确解释"></a>准确解释</h1><p>就一个类而言，应该仅有一个引起它变化的原因。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。</p><p>如果你能够想到<strong>多于一个的动机去改变一个类</strong>，那么这个类就具有<strong>多于一个的职责</strong>，就应该考虑类的职责分离。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="俄罗斯方块开发"><a href="#俄罗斯方块开发" class="headerlink" title="俄罗斯方块开发"></a>俄罗斯方块开发</h2><p>将游戏界面和游戏逻辑分离开。界面的变化是和游戏本身没有关系的，界面是容易变化的，而游戏逻辑是不太容易变化的，将它们分离开有利于界面的改动。</p><h3 id="游戏界面"><a href="#游戏界面" class="headerlink" title="游戏界面"></a>游戏界面</h3><ul><li>Android</li><li>Web</li><li>Windows</li></ul><h3 id="游戏逻辑"><a href="#游戏逻辑" class="headerlink" title="游戏逻辑"></a>游戏逻辑</h3><ul><li>移动</li><li>旋转</li><li>消层</li><li>堆积</li></ul>]]></content>
    
    
    <categories>
      
      <category>design-pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode146. LRU 缓存</title>
    <link href="/posts/8b45e5c8.html"/>
    <url>/posts/8b45e5c8.html</url>
    
    <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>CodeTop字节高频题。</p><p><a href="https://leetcode.cn/problems/lru-cache/description/">https://leetcode.cn/problems/lru-cache/description/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 105</code></li><li>最多调用 <code>2 * 10^5</code> 次 <code>get</code> 和 <code>put</code></li></ul><h1 id="考察知识点"><a href="#考察知识点" class="headerlink" title="考察知识点"></a>考察知识点</h1><ul><li>哈希表</li><li>双向链表</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用哈希表和双向链表两个数据结构实现。</p><p>哈希表用来存储key对应的Node，双向链表用来记录每个Node最近使用时间的新旧顺序。</p><p>实现<code>insert</code>和<code>remove</code>两个函数可以在<code>get</code>和<code>put</code>方法中复用。</p><p>注意判断当前哈希表的size是否已经到达capacity，从而决定是否要移除最旧的Node。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> key, val;<br>        Node *left, *right;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _val): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>    &#125;*L, *R;<br><br>    <span class="hljs-type">int</span> capacity;<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; hash;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> _capacity) &#123;<br>        capacity = _capacity;<br>        L = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>), R = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);<br>        L-&gt;right = R, R-&gt;left = L;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node *n)</span> </span>&#123;<br>        n-&gt;left-&gt;right = n-&gt;right;<br>        n-&gt;right-&gt;left = n-&gt;left;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Node *n)</span> </span>&#123;<br>        L-&gt;right-&gt;left = n;<br>        n-&gt;right = L-&gt;right;<br>        L-&gt;right = n;<br>        n-&gt;left = L;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> n = hash[key];<br>            <span class="hljs-built_in">remove</span>(n);<br>            <span class="hljs-built_in">insert</span>(n);<br>            <span class="hljs-keyword">return</span> n-&gt;val;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> n = hash[key];<br>            n-&gt;val = value;<br>            <span class="hljs-built_in">remove</span>(n);<br>            <span class="hljs-built_in">insert</span>(n);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">auto</span> n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            <span class="hljs-built_in">insert</span>(n);<br>            hash[key] = n;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">size</span>() &gt; capacity) &#123;<br>                <span class="hljs-keyword">auto</span> n = R-&gt;left;<br>                <span class="hljs-built_in">remove</span>(n);<br>                hash.<span class="hljs-built_in">erase</span>(n-&gt;key);<br>                <span class="hljs-keyword">delete</span> n;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>学习结构体构造函数的简写方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> key, val;<br>    Node *left, *right;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _val): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;*L, *R;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode3. 无重复字符的最长子串</title>
    <link href="/posts/8872e46c.html"/>
    <url>/posts/8872e46c.html</url>
    
    <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p>CodeTop字节高频题。</p><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h1 id="考察知识点"><a href="#考察知识点" class="headerlink" title="考察知识点"></a>考察知识点</h1><ul><li>哈希表</li><li>滑动窗口（双指针）</li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="原始思路"><a href="#原始思路" class="headerlink" title="原始思路"></a>原始思路</h2><p>从头到尾遍历字符串s，hash存储每个字符最后出现的下标，p作为子串起始点，i为子串当前结束点。</p><p>i每次移动，更新对应字符下标。如果出现重复字符，将子串起点p更新到重复字符上一次出现位置的后一个位置（如果已经在它后面了就不动）。</p><p>i每次移动，都更新全局最大长度res。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">0</span>;<br>        s = <span class="hljs-string">&quot; &quot;</span> + s;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (!hash[s[i]]) &#123;<br>                hash[s[i]] = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 将子串起点p更新到重复字符上一次出现位置的后一个位置（如果已经在它后面了就不动）</span><br>                p = <span class="hljs-built_in">max</span>(p, hash[s[i]] + <span class="hljs-number">1</span>);<br>                hash[s[i]] = i;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, i - p + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以简写为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">0</span>;<br>        s = <span class="hljs-string">&quot; &quot;</span> + s;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (hash[s[i]]) p = <span class="hljs-built_in">max</span>(p, hash[s[i]] + <span class="hljs-number">1</span>);<br>            hash[s[i]] = i;<br>            res = <span class="hljs-built_in">max</span>(res, i - p + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="另一种思路"><a href="#另一种思路" class="headerlink" title="另一种思路"></a>另一种思路</h2><p>i和j为子串右端点和左端点，hash存储每个字符在i和j之间出现的次数，如果出现次数大于1了，把左端点j往右移，直到该字符出现次数为1为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            hash[s[i]] ++;<br>            <span class="hljs-keyword">while</span> (hash[s[i]] &gt; <span class="hljs-number">1</span>) hash[s[j ++]] --;<br>            res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Doc</title>
    <link href="/posts/5bb8c7eb.html"/>
    <url>/posts/5bb8c7eb.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post Title&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h4 id="Create-and-put-the-new-post-into-subfolder"><a href="#Create-and-put-the-new-post-into-subfolder" class="headerlink" title="Create and put the new post into subfolder"></a>Create and put the new post into subfolder</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post Title&quot;</span> -p path/test_file_name.md<br></code></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>tips</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
